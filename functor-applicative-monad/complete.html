<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>完整定义 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构体和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的契约</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html" class="active"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/functor-applicative-monad/complete.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# The Complete Definitions
-->
<h1 id="完整定义"><a class="header" href="#完整定义">完整定义</a></h1>
<!--
Now that all the relevant language features have been presented, this section describes the complete, honest definitions of `Functor`, `Applicative`, and `Monad` as they occur in the Lean standard library.
For the sake of understanding, no details are omitted.
-->
<p>现在所有相关的语言特性都已介绍完毕，本节将讲述 Lean 的标准库中 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 的完整、准确的定义。
为了便于理解，没有任何细节会被省略。</p>
<!--
## Functor
-->
<h2 id="函子"><a class="header" href="#函子">函子</a></h2>
<!--
The complete definition of the `Functor` class makes use of universe polymorphism and a default method implementation:
```lean
class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
  mapConst : {α β : Type u} → α → f β → f α :=
    Function.comp map (Function.const _)
```
In this definition, `Function.comp` is function composition, which is typically written with the `∘` operator.
`Function.const` is the _constant function_, which is a two-argument function that ignores its second argument.
Applying this function to only one argument produces a function that always returns the same value, which is useful when an API demands a function but a program doesn't need to compute different results for different arguments.
A simple version of `Function.const` can be written as follows:
```lean
def simpleConst  (x : α) (_ : β) : α := x
```
Using it with one argument as the function argument to `List.map` demonstrates its utility:
```lean
#eval [1, 2, 3].map (simpleConst "same")
```
```output info
["same", "same", "same"]
```
The actual function has the following signature:
```output info
Function.const.{u, v} {α : Sort u} (β : Sort v) (a : α) (a✝ : β) : α
```
Here, the type argument `β` is an explicit argument, so the default definition of `Functor.mapConst` provides an `_` argument that instructs Lean to find a unique type to pass to `Function.const` that would cause the program to type check.
`(Function.comp map (Function.const _) : α → f β → f α)` is equivalent to `fun (x : α) (y : f β) => map (fun _ => x) y`.
-->
<p><code>Functor</code> 类的完整定义使用了宇宙多态性和默认方法实现：</p>
<pre><code class="language-lean">class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
  mapConst : {α β : Type u} → α → f β → f α :=
    Function.comp map (Function.const _)
</code></pre>
<p>在这个定义中，<code>Function.comp</code> 是函数复合，通常用 <code>∘</code> 运算符表示。
<code>Function.const</code> 是 <strong>常量函数</strong>，它是一个忽略第二个参数的二元函数。
将该函数应用于仅一个参数上时，会生成一个总是返回相同值的函数，这在 API 需要一个函数但程序不需要根据不同参数去计算不同结果时非常有用。
一个简单版本的 <code>Function.const</code> 可以编写如下：</p>
<pre><code class="language-lean">def simpleConst  (x : α) (_ : β) : α := x
</code></pre>
<p>将其与一个参数一起使用作为 <code>List.map</code> 的函数参数可以演示它的实用性：</p>
<pre><code class="language-lean">#eval [1, 2, 3].map (simpleConst &quot;same&quot;)
</code></pre>
<pre><code class="language-output info">[&quot;same&quot;, &quot;same&quot;, &quot;same&quot;]
</code></pre>
<p>实际的函数具有以下签名：</p>
<pre><code class="language-output info">Function.const.{u, v} {α : Sort u} (β : Sort v) (a : α) (a✝ : β) : α
</code></pre>
<p>这里，类型参数 <code>β</code> 是一个显式参数，因此 <code>Functor.mapConst</code> 的默认定义提供了一个 <code>_</code> 参数，这个参数指示着 Lean 去找到一个唯一的类型来传递给 <code>Function.const</code>，以使程序通过类型检查。
<code>(Function.comp map (Function.const _) : α → f β → f α)</code> 等价于 <code>fun (x : α) (y : f β) =&gt; map (fun _ =&gt; x) y</code>。</p>
<!--
The `Functor` type class inhabits a universe that is the greater of `u+1` and `v`.
Here, `u` is the level of universes accepted as arguments to `f`, while `v` is the universe returned by `f`.
To see why the structure that implements the `Functor` type class must be in a universe that's larger than `u`, begin with a simplified definition of the class:
```lean
class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
```
This type class's structure type is equivalent to the following inductive type:
```lean
inductive Functor (f : Type u → Type v) : Type (max (u+1) v) where
  | mk : ({α β : Type u} → (α → β) → f α → f β) → Functor f
```
The implementation of the `map` method that is passed as an argument to `Functor.mk` contains a function that takes two types in `Type u` as arguments.
This means that the type of the function itself is in `Type (u+1)`, so `Functor` must also be at a level that is at least `u+1`.
Similarly, other arguments to the function have a type built by applying `f`, so it must also have a level that is at least `v`.
All the type classes in this section share this property.
-->
<p><code>Functor</code> 类型类所处的宇宙是 <code>u+1</code> 和 <code>v</code> 中较大的一个。
这里，<code>u</code> 是作为 <code>f</code> 所接受的参数的宇宙层级，而 <code>v</code> 是 <code>f</code> 返回的宇宙。
要理解实现了 <code>Functor</code> 类型类的结构为何必须处于比 <code>u</code> 更大的宇宙中，请从该类的简化定义开始：</p>
<pre><code class="language-lean">class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
</code></pre>
<p>该类型类的结构类型等同于以下的归纳类型：</p>
<pre><code class="language-lean">inductive Functor (f : Type u → Type v) : Type (max (u+1) v) where
  | mk : ({α β : Type u} → (α → β) → f α → f β) → Functor f
</code></pre>
<p>作为参数传递给 <code>Functor.mk</code> 的 <code>map</code> 方法的实现包含着一个函数，该函数将 <code>Type u</code> 中的两个类型作为参数。
这意味着函数本身的类型在 <code>Type (u+1)</code> 中，因此 <code>Functor</code> 也必须至少处于 <code>u+1</code> 层级。
类似地，函数的其他参数的类型是通过应用 <code>f</code> 构建的，所以它们也必须至少在 <code>v</code> 级别。
本节中的所有类型类都具有这一属性。</p>
<!--
## Applicative
-->
<h2 id="应用类型类"><a class="header" href="#应用类型类">应用类型类</a></h2>
<!--
The `Applicative` type class is actually built from a number of smaller classes that each contain some of the relevant methods.
The first are `Pure` and `Seq`, which contain `pure` and `seq` respectively:
```lean
class Pure (f : Type u → Type v) : Type (max (u+1) v) where
  pure {α : Type u} : α → f α

class Seq (f : Type u → Type v) : Type (max (u+1) v) where
  seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β
```
-->
<p><code>Applicative</code> 类型类实际上是由多个较小的类构成的，其中每个较小的类都包含着一些相关的方法。
首先是 <code>Pure</code> 和 <code>Seq</code>，它们分别包含着 <code>pure</code> 和 <code>seq</code> 方法：</p>
<pre><code class="language-lean">class Pure (f : Type u → Type v) : Type (max (u+1) v) where
  pure {α : Type u} : α → f α

class Seq (f : Type u → Type v) : Type (max (u+1) v) where
  seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β
</code></pre>
<!--
In addition to these, `Applicative` also depends on `SeqRight` and an analogous `SeqLeft` class:
```lean
class SeqRight (f : Type u → Type v) : Type (max (u+1) v) where
  seqRight : {α β : Type u} → f α → (Unit → f β) → f β

class SeqLeft (f : Type u → Type v) : Type (max (u+1) v) where
  seqLeft : {α β : Type u} → f α → (Unit → f β) → f α
```
-->
<p>除了这些之外，<code>Applicative</code> 还依赖于 <code>SeqRight</code> 以及一个类似的 <code>SeqLeft</code> 类：</p>
<pre><code class="language-lean">class SeqRight (f : Type u → Type v) : Type (max (u+1) v) where
  seqRight : {α β : Type u} → f α → (Unit → f β) → f β

class SeqLeft (f : Type u → Type v) : Type (max (u+1) v) where
  seqLeft : {α β : Type u} → f α → (Unit → f β) → f α
</code></pre>
<!--
The `seqRight` function, which was introduced in the [section about alternatives and validation](alternative.md), is easiest to understand from the perspective of effects.
`E1 *> E2`, which desugars to `SeqRight.seqRight E1 (fun () => E2)`, can be understood as first executing `E1`, and then `E2`, resulting only in `E2`'s result.
Effects from `E1` may result in `E2` not being run, or being run multiple times.
Indeed, if `f` has a `Monad` instance, then `E1 *> E2` is equivalent to `do let _ ← E1; E2`, but `seqRight` can be used with types like `Validate` that are not monads.
-->
<p><code>seqRight</code> 函数在<a href="alternative.html">关于选择子和验证的小节</a>中介绍过，从作用的角度来看，它是最容易理解的。
<code>E1 *&gt; E2</code>，其去除语法糖后的形式为 <code>SeqRight.seqRight E1 (fun () =&gt; E2)</code>，可以理解为先执行 <code>E1</code>，然后执行 <code>E2</code>，最终仅保留 <code>E2</code> 的结果。
<code>E1</code> 的作用可能导致 <code>E2</code> 未被执行，或被多次运行。
实际上，如果 <code>f</code> 有一个 <code>Monad</code> 实例，那么 <code>E1 *&gt; E2</code> 等价于 <code>do let _ ← E1; E2</code>，但 <code>seqRight</code> 可以与像 <code>Validate</code> 这样不是单子的类型一起使用。</p>
<!--
Its cousin `seqLeft` is very similar, except the leftmost expression's value is returned.
`E1 <* E2` desugars to `SeqLeft.seqLeft E1 (fun () => E2)`.
`SeqLeft.seqLeft` has type `f α → (Unit → f β) → f α`, which is identical to that of `seqRight` except for the fact that it returns `f α`.
`E1 <* E2` can be understood as a program that first executes `E1`, and then `E2`, returning the original result for `E1`.
If `f` has a `Monad` instance, then `E1 <* E2` is equivalent to `do let x ← E1; _ ← E2; pure x`.
Generally speaking, `seqLeft` is useful for specifying extra conditions on a value in a validation or parser-like workflow without changing the value itself.
-->
<p>它的近亲 <code>seqLeft</code> 非常相似，只不过其返回的是最左边的表达式的值。
<code>E1 &lt;* E2</code> 被去除语法糖后的形式为 <code>SeqLeft.seqLeft E1 (fun () =&gt; E2)</code>。
<code>SeqLeft.seqLeft</code> 的类型是 <code>f α → (Unit → f β) → f α</code>，与 <code>seqRight</code> 的类型相同，只是它返回 <code>f α</code>。
<code>E1 &lt;* E2</code> 可以理解为一个先执行 <code>E1</code>，然后执行 <code>E2</code>，最后返回 <code>E1</code> 的原始结果的程序。
如果 <code>f</code> 有一个 <code>Monad</code> 实例，那么 <code>E1 &lt;* E2</code> 等价于 <code>do let x ← E1; _ ← E2; pure x</code>。
通常来说，<code>seqLeft</code> 在验证或类似解析器的工作流程中，可用于为一个值指定的额外条件而不改变该值本身。</p>
<!--
The definition of `Applicative` extends all these classes, along with `Functor`:
```lean
class Applicative (f : Type u → Type v) extends Functor f, Pure f, Seq f, SeqLeft f, SeqRight f where
  map      := fun x y => Seq.seq (pure x) fun _ => y
  seqLeft  := fun a b => Seq.seq (Functor.map (Function.const _) a) b
  seqRight := fun a b => Seq.seq (Functor.map (Function.const _ id) a) b
```
A complete definition of `Applicative` requires only definitions for `pure` and `seq`.
This is because there are default definitions for all of the methods from `Functor`, `SeqLeft`, and `SeqRight`.
The `mapConst` method of `Functor` has its own default implementation in terms of `Functor.map`.
These default implementations should only be overridden with new functions that are behaviorally equivalent, but more efficient.
The default implementations should be seen as specifications for correctness as well as automatically-created code.
-->
<p><code>Applicative</code> 的定义扩展自所有这些类，以及 <code>Functor</code>：</p>
<pre><code class="language-lean">class Applicative (f : Type u → Type v) extends Functor f, Pure f, Seq f, SeqLeft f, SeqRight f where
  map      := fun x y =&gt; Seq.seq (pure x) fun _ =&gt; y
  seqLeft  := fun a b =&gt; Seq.seq (Functor.map (Function.const _) a) b
  seqRight := fun a b =&gt; Seq.seq (Functor.map (Function.const _ id) a) b
</code></pre>
<p>完整定义 <code>Applicative</code> 只需要 <code>pure</code> 和 <code>seq</code> 的定义。
这是因为 <code>Functor</code>、<code>SeqLeft</code> 和 <code>SeqRight</code> 的所有方法都有默认定义。
<code>Functor</code> 的 <code>mapConst</code> 方法有一个基于 <code>Functor.map</code> 的自己的默认实现。
这些默认实现只应被行为上等价但更高效的新函数覆盖。
默认实现应被视为正确性的规范以及自动创建的代码。</p>
<!--
The default implementation for `seqLeft` is very compact.
Replacing some of the names with their syntactic sugar or their definitions can provide another view on it, so:
```lean
fun a b => Seq.seq (Functor.map (Function.const _) a) b
```
becomes
```lean
fun a b => Seq.seq ((fun x _ => x) <$> a) b
```
How should `(fun x _ => x) <$> a` be understood?
Here, `a` has type `f α`, and `f` is a functor.
If `f` is `List`, then `(fun x _ => x) <$> [1, 2, 3]` evaluates to `[fun _ => 1, fun _ => 2, fun _ => 3]`.
If `f` is `Option`, then `(fun x _ => x) <$> some "hello"` evaluates to `some (fun _ => "hello")`.
In each case, the values in the functor are replaced by functions that return the original value, ignoring their argument.
When combined with `seq`, this function discards the values from `seq`'s second argument.
-->
<p><code>seqLeft</code> 的默认实现非常简洁。
将其中一些名称替换为它们的语法糖或它们的定义可以提供另一种视角，因此：</p>
<pre><code class="language-lean">fun a b =&gt; Seq.seq (Functor.map (Function.const _) a) b
</code></pre>
<p>变成了</p>
<pre><code class="language-lean">fun a b =&gt; Seq.seq ((fun x _ =&gt; x) &lt;$&gt; a) b
</code></pre>
<p><code>(fun x _ =&gt; x) &lt;$&gt; a</code> 应该如何理解？
这里，<code>a</code> 的类型是 <code>f α</code>，且 <code>f</code> 是一个函子。
如果 <code>f</code> 是 <code>List</code>，那么 <code>(fun x _ =&gt; x) &lt;$&gt; [1, 2, 3]</code> 的求值结果为 <code>[fun _ =&gt; 1, fun _ =&gt; 2, fun _ =&gt; 3]</code>。
如果 <code>f</code> 是 <code>Option</code>，那么 <code>(fun x _ =&gt; x) &lt;$&gt; some &quot;hello&quot;</code> 的求值结果为 <code>some (fun _ =&gt; &quot;hello&quot;)</code>。
在每种情况下，函子中的值都被替换为忽略其参数并返回原始值的函数。
当与 <code>seq</code> 组合时，该函数会舍弃 <code>seq</code> 的第二个参数的值。</p>
<!--
The default implementation for `seqRight` is very similar, except `const` has an additional argument `id`.
This definition can be understood similarly, by first introducing some standard syntactic sugar and then replacing some names with their definitions:
```lean
fun a b => Seq.seq (Functor.map (Function.const _ id) a) b
===>
fun a b => Seq.seq ((fun _ => id) <$> a) b
===>
fun a b => Seq.seq ((fun _ => fun x => x) <$> a) b
===>
fun a b => Seq.seq ((fun _ x => x) <$> a) b
```
How should `(fun _ x => x) <$> a` be understood?
Once again, examples are useful.
`(fun _ x => x) <$> [1, 2, 3]` is equivalent to `[fun x => x, fun x => x, fun x => x]`, and `(fun _ x => x) <$> some "hello"` is equivalent to `some (fun x => x)`.
In other words, `(fun _ x => x) <$> a` preserves the overall shape of `a`, but each value is replaced by the identity function.
From the perspective of effects, the side effects of `a` occur, but the values are thrown out when it is used with `seq`.
-->
<p><code>seqRight</code> 的默认实现非常相似，只不过 <code>const</code> 有一个额外的参数 <code>id</code>。
这个定义可以类似地理解，首先引入一些标准的语法糖，然后用它们的定义替换一些名称：</p>
<pre><code class="language-lean">fun a b =&gt; Seq.seq (Functor.map (Function.const _ id) a) b
===&gt;
fun a b =&gt; Seq.seq ((fun _ =&gt; id) &lt;$&gt; a) b
===&gt;
fun a b =&gt; Seq.seq ((fun _ =&gt; fun x =&gt; x) &lt;$&gt; a) b
===&gt;
fun a b =&gt; Seq.seq ((fun _ x =&gt; x) &lt;$&gt; a) b
</code></pre>
<p><code>(fun _ x =&gt; x) &lt;$&gt; a</code> 应该如何理解？
同样地，例子很有用。
<code>(fun _ x =&gt; x) &lt;$&gt; [1, 2, 3]</code> 等价于 <code>[fun x =&gt; x, fun x =&gt; x, fun x =&gt; x]</code>，而 <code>(fun _ x =&gt; x) &lt;$&gt; some &quot;hello&quot;</code> 等价于 <code>some (fun x =&gt; x)</code>。
换句话说，<code>(fun _ x =&gt; x) &lt;$&gt; a</code> 保留了 <code>a</code> 的整体形状，但每个值都被恒等函数替换。
从作用的角度来看，<code>a</code> 的副作用发生了，但是当它与 <code>seq</code> 一起使用时，其值会被丢弃。</p>
<!--
## Monad
-->
<h2 id="单子"><a class="header" href="#单子">单子</a></h2>
<!--
Just as the constituent operations of `Applicative` are split into their own type classes, `Bind` has its own class as well:
```lean
class Bind (m : Type u → Type v) where
  bind : {α β : Type u} → m α → (α → m β) → m β
```
`Monad` extends `Applicative` with `Bind`:
```lean
class Monad (m : Type u → Type v) extends Applicative m, Bind m : Type (max (u+1) v) where
  map      f x := bind x (Function.comp pure f)
  seq      f x := bind f fun y => Functor.map y (x ())
  seqLeft  x y := bind x fun a => bind (y ()) (fun _ => pure a)
  seqRight x y := bind x fun _ => y ()
```
Tracing the collection of inherited methods and default methods from the entire hierarchy shows that a `Monad` instance requires only implementations of `bind` and `pure`.
In other words, `Monad` instances automatically yield implementations of `seq`, `seqLeft`, `seqRight`, `map`, and `mapConst`.
From the perspective of API boundaries, any type with a `Monad` instance gets instances for `Bind`, `Pure`, `Seq`, `Functor`, `SeqLeft`, and `SeqRight`.
-->
<p>正如 <code>Applicative</code> 的组成操作被分成各自的类型类一样，<code>Bind</code> 也有它自己的类型类：</p>
<pre><code class="language-lean">class Bind (m : Type u → Type v) where
  bind : {α β : Type u} → m α → (α → m β) → m β
</code></pre>
<p><code>Monad</code> 扩展自 <code>Applicative</code>，以及 <code>Bind</code>：</p>
<pre><code class="language-lean">class Monad (m : Type u → Type v) extends Applicative m, Bind m : Type (max (u+1) v) where
  map      f x := bind x (Function.comp pure f)
  seq      f x := bind f fun y =&gt; Functor.map y (x ())
  seqLeft  x y := bind x fun a =&gt; bind (y ()) (fun _ =&gt; pure a)
  seqRight x y := bind x fun _ =&gt; y ()
</code></pre>
<p>从整个层级结构中追踪继承的方法和默认方法的集合可以看出，一个 <code>Monad</code> 实例只需要实现 <code>bind</code> 和 <code>pure</code>。
换句话说，<code>Monad</code> 实例会自动生成 <code>seq</code>、<code>seqLeft</code>、<code>seqRight</code>、<code>map</code> 和 <code>mapConst</code> 的实现。
从 API 边界的角度来看，任何具有 <code>Monad</code> 实例的类型都会获得 <code>Bind</code>、<code>Pure</code>、<code>Seq</code>、<code>Functor</code>、<code>SeqLeft</code> 和 <code>SeqRight</code> 的实例。</p>
<!--
## Exercises
-->
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<!--
 1. Understand the default implementations of `map`, `seq`, `seqLeft`, and `seqRight` in `Monad` by working through examples such as `Option` and `Except`. In other words, substitute their definitions for `bind` and `pure` into the default definitions, and simplify them to recover the versions `map`, `seq`, `seqLeft`, and `seqRight` that would be written by hand.
 2. On paper or in a text file, prove to yourself that the default implementations of `map` and `seq` satisfy the contracts for `Functor` and `Applicative`. In this argument, you're allowed to use the rules from the `Monad` contract as well as ordinary expression evaluation.
-->
<ol>
<li>通过研究诸如 <code>Option</code> 和 <code>Except</code> 等例子来理解 <code>Monad</code> 中 <code>map</code>、<code>seq</code>、<code>seqLeft</code> 和 <code>seqRight</code> 的默认实现。换句话说，将它们对 <code>bind</code> 和 <code>pure</code> 的定义去替换默认定义，并简化它们以恢复手写版本的 <code>map</code>、<code>seq</code>、<code>seqLeft</code> 和 <code>seqRight</code>。</li>
<li>在纸上或文本文件中，向自己证明 <code>map</code> 和 <code>seq</code> 的默认实现满足 <code>Functor</code> 和 <code>Applicative</code> 的契约。在这个论证中，你允许使用 <code>Monad</code> 契约中的规则以及普通的表达式求值。</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../functor-applicative-monad/universes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../functor-applicative-monad/summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../functor-applicative-monad/universes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../functor-applicative-monad/summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
