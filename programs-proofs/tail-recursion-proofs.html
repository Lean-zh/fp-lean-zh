<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>证明等价 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html" class="active"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/programs-proofs/tail-recursion-proofs.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Proving Equivalence
-->
<h1 id="证明等价"><a class="header" href="#证明等价">证明等价</a></h1>
<!--
Programs that have been rewritten to use tail recursion and an accumulator can look quite different from the original program.
The original recursive function is often much easier to understand, but it runs the risk of exhausting the stack at run time.
After testing both versions of the program on examples to rule out simple bugs, proofs can be used to show once and for all that the programs are equivalent.
-->
<p>重写为使用尾递归和累加器的程序可能看起来与原始程序非常不同。
原始递归函数通常更容易理解，但它有在运行时耗尽栈的风险。
在用示例测试程序的两个版本以排除简单错误后，可以使用证明来一劳永逸地证明二者是等价的。</p>
<!--
## Proving `sum` Equal
-->
<h2 id="证明-sum-相等"><a class="header" href="#证明-sum-相等">证明 <code>sum</code> 相等</a></h2>
<!--
To prove that both versions of `sum` are equal, begin by writing the theorem statement with a stub proof:
-->
<p>要证明 <code>sum</code> 的两个版本相等，首先用桩（stub）证明编写定理的陈述：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  skip
</code></pre>
<!--
As expected, Lean describes an unsolved goal:
-->
<p>正如预期，Lean 描述了一个未解决的目标：</p>
<pre><code class="language-output error">unsolved goals
⊢ NonTail.sum = Tail.sum
</code></pre>
<!--
The `rfl` tactic cannot be applied here, because `NonTail.sum` and `Tail.sum` are not definitionally equal.
Functions can be equal in more ways than just definitional equality, however.
It is also possible to prove that two functions are equal by proving that they produce equal outputs for the same input.
In other words, \\( f = g \\) can be proved by proving that \\( f(x) = g(x) \\) for all possible inputs \\( x \\).
This principle is called _function extensionality_.
Function extensionality is exactly the reason why `NonTail.sum` equals `Tail.sum`: they both sum lists of numbers.
-->
<p><code>rfl</code> 策略无法在此处应用，因为 <code>NonTail.sum</code> 和 <code>Tail.sum</code> 在定义上不相等。
然而，函数除了定义相等外还存在更多相等的方式。还可以通过证明两个函数对相同输入产生相等输出，
来证明它们相等。换句话说，可以通过证明「对于所有可能的输入 \( x \)，
都有 \( f(x) = g(x) \)」来证明 \( f = g \)。此原理称为 <strong>函数外延性（Function Extensionality）</strong>。
函数外延性正是 <code>NonTail.sum</code> 等于 <code>Tail.sum</code> 的原因：它们都对数字列表求和。</p>
<!--
In Lean's tactic language, function extensionality is invoked using `funext`, followed by a name to be used for the arbitrary argument.
The arbitrary argument is added as an assumption to the context, and the goal changes to require a proof that the functions applied to this argument are equal:
-->
<p>在 Lean 的策略语言中，可使用 <code>funext</code> 调用函数外延性，后跟一个用于任意参数的名称。
任意参数会作为假设添加到语境中，目标变为证明应用于此参数的函数相等：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
</code></pre>
<pre><code class="language-output error">unsolved goals
case h
xs : List Nat
⊢ NonTail.sum xs = Tail.sum xs
</code></pre>
<!--
This goal can be proved by induction on the argument `xs`.
Both `sum` functions return `0` when applied to the empty list, which serves as a base case.
Adding a number to the beginning of the input list causes both functions to add that number to the result, which serves as an induction step.
Invoking the `induction` tactic results in two goals:
-->
<p>此目标可通过对参数 <code>xs</code> 进行归纳来证明。当应用于空列表时，<code>sum</code> 函数都返回 <code>0</code>，这是基本情况。
在输入列表的开头添加一个数字会让两个函数都将该数字添加到结果中，这是归纳步骤。
调用 <code>induction</code> 策略会产生两个目标：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; skip
  | cons y ys ih =&gt; skip
</code></pre>
<pre><code class="language-output error">unsolved goals
case h.nil
⊢ NonTail.sum [] = Tail.sum []
</code></pre>
<pre><code class="language-output error">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
⊢ NonTail.sum (y :: ys) = Tail.sum (y :: ys)
</code></pre>
<!--
The base case for `nil` can be solved using `rfl`, because both functions return `0` when passed the empty list:
-->
<p><code>nil</code> 的基本情况可以使用 <code>rfl</code> 解决，因为当传递空列表时，两个函数都返回 <code>0</code>：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt; skip
</code></pre>
<!--
The first step in solving the induction step is to simplify the goal, asking `simp` to unfold `NonTail.sum` and `Tail.sum`:
-->
<p>解决归纳步骤的第一步是简化目标，要求 <code>simp</code> 展开 <code>NonTail.sum</code> 和 <code>Tail.sum</code>：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt;
    simp [NonTail.sum, Tail.sum]
</code></pre>
<pre><code class="language-output error">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
⊢ y + NonTail.sum ys = Tail.sumHelper 0 (y :: ys)
</code></pre>
<!--
Unfolding `Tail.sum` revealed that it immediately delegates to `Tail.sumHelper`, which should also be simplified:
-->
<p>展开 <code>Tail.sum</code> 会发现它直接委托给了 <code>Tail.sumHelper</code>，它也应该被简化：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt;
    simp [NonTail.sum, Tail.sum, Tail.sumHelper]
</code></pre>
<!--
In the resulting goal, `sumHelper` has taken a step of computation and added `y` to the accumulator:
-->
<p>在结果目标中，<code>sumHelper</code> 执行了一步计算并将 <code>y</code> 加到累加器上：</p>
<pre><code class="language-output error">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
⊢ y + NonTail.sum ys = Tail.sumHelper y ys
</code></pre>
<!--
Rewriting with the induction hypothesis removes all mentions of `NonTail.sum` from the goal:
-->
<p>使用归纳假设重写会从目标中删除所有 <code>NonTail.sum</code> 的引用：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt;
    simp [NonTail.sum, Tail.sum, Tail.sumHelper]
    rw [ih]
</code></pre>
<pre><code class="language-output error">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
⊢ y + Tail.sum ys = Tail.sumHelper y ys
</code></pre>
<!--
This new goal states that adding some number to the sum of a list is the same as using that number as the initial accumulator in `sumHelper`.
For the sake of clarity, this new goal can be proved as a separate theorem:
-->
<p>这个新目标表明，将某个数字加到列表的和中与在 <code>sumHelper</code> 中使用该数字作为初始累加器相同。
为了清晰起见，这个新目标可以作为独立的定理来证明：</p>
<pre><code class="language-leantac">theorem helper_add_sum_accum (xs : List Nat) (n : Nat) :
    n + Tail.sum xs = Tail.sumHelper n xs := by
  skip
</code></pre>
<pre><code class="language-output error">unsolved goals
xs : List Nat
n : Nat
⊢ n + Tail.sum xs = Tail.sumHelper n xs
</code></pre>
<!--
Once again, this is a proof by induction where the base case uses `rfl`:
-->
<p>这又是一次归纳证明，其中基本情况使用 <code>rfl</code> 证明：</p>
<pre><code class="language-leantac">theorem helper_add_sum_accum (xs : List Nat) (n : Nat) :
    n + Tail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt; skip
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
n y : Nat
ys : List Nat
ih : n + Tail.sum ys = Tail.sumHelper n ys
⊢ n + Tail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<!--
Because this is an inductive step, the goal should be simplified until it matches the induction hypothesis `ih`.
Simplifying, using the definitions of `Tail.sum` and `Tail.sumHelper`, results in the following:
-->
<p>由于这是一个归纳步骤，因此目标应该被简化，直到它与归纳假设 <code>ih</code> 匹配。
简化，然后使用 <code>Tail.sum</code> 和 <code>Tail.sumHelper</code> 的定义，得到以下结果：</p>
<pre><code class="language-leantac">theorem helper_add_sum_accum (xs : List Nat) (n : Nat) :
    n + Tail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt;
    simp [Tail.sum, Tail.sumHelper]
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
n y : Nat
ys : List Nat
ih : n + Tail.sum ys = Tail.sumHelper n ys
⊢ n + Tail.sumHelper y ys = Tail.sumHelper (y + n) ys
</code></pre>
<!--
Ideally, the induction hypothesis could be used to replace `Tail.sumHelper (y + n) ys`, but they don't match.
The induction hypothesis can be used for `Tail.sumHelper n ys`, not `Tail.sumHelper (y + n) ys`.
In other words, this proof is stuck.
-->
<p>理想情况下，归纳假设可以用来替换 <code>Tail.sumHelper (y + n) ys</code>，但它们不匹配。
归纳假设可用于 <code>Tail.sumHelper n ys</code>，而非 <code>Tail.sumHelper (y + n) ys</code>。
换句话说，这个证明到这里被卡住了。</p>
<!--
## A Second Attempt
-->
<h2 id="第二次尝试"><a class="header" href="#第二次尝试">第二次尝试</a></h2>
<!--
Rather than attempting to muddle through the proof, it's time to take a step back and think.
Why is it that the tail-recursive version of the function is equal to the non-tail-recursive version?
Fundamentally speaking, at each entry in the list, the accumulator grows by the same amount as would be added to the result of the recursion.
This insight can be used to write an elegant proof.
Crucially, the proof by induction must be set up such that the induction hypothesis can be applied to _any_ accumulator value.
-->
<p>与其试图弄清楚证明，不如退一步思考。为什么函数的尾递归版本等于非尾递归版本？
从根本上讲，在列表中的每个条目中，累加器都会增加与递归结果中添加的量相同的值。
这个见解可以用来写一个优雅的证明。
重点在于，归纳证明必须设置成归纳假设可以应用于 <strong>任何</strong> 累加器值。</p>
<!--
Discarding the prior attempt, the insight can be encoded as the following statement:
-->
<p>放弃之前的尝试，这个见解可以编码为以下陈述：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  skip
</code></pre>
<!--
In this statement, it's very important that `n` is part of the type that's after the colon.
The resulting goal begins with `∀ (n : Nat)`, which is short for "For all `n`":
-->
<p>在这个陈述中，非常重要的是 <code>n</code> 是冒号后面类型的组成部分。
产生的目标以 <code>∀ (n : Nat)</code> 开头，这是「对于所有 <code>n</code>」的缩写：</p>
<pre><code class="language-output error">unsolved goals
xs : List Nat
⊢ ∀ (n : Nat), n + NonTail.sum xs = Tail.sumHelper n xs
</code></pre>
<!--
Using the induction tactic results in goals that include this "for all" statement:
-->
<p>使用归纳策略会产生包含这个「对于所有（for all）」语句的目标：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt; skip
  | cons y ys ih =&gt; skip
</code></pre>
<!--
In the `nil` case, the goal is:
-->
<p>在 <code>nil</code> 情况下，目标是：</p>
<pre><code class="language-output error">unsolved goals
case nil
⊢ ∀ (n : Nat), n + NonTail.sum [] = Tail.sumHelper n []
</code></pre>
<!--
For the induction step for `cons`, both the induction hypothesis and the specific goal contain the "for all `n`":
-->
<p>对于 <code>cons</code> 的归纳步骤，归纳假设和具体目标都包含「对于所有 <code>n</code>」：</p>
<pre><code class="language-output error">unsolved goals
case cons
y : Nat
ys : List Nat
ih : ∀ (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
⊢ ∀ (n : Nat), n + NonTail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<!--
In other words, the goal has become more challenging to prove, but the induction hypothesis is correspondingly more useful.
-->
<p>换句话说，目标变得更难证明，但归纳假设相应地更加有用。</p>
<!--
A mathematical proof for a statement that beings with "for all \\( x \\)" should assume some arbitrary \\( x \\), and prove the statement.
"Arbitrary" means that no additional properties of \\( x \\) are assumed, so the resulting statement will work for _any_ \\( x \\).
In Lean, a "for all" statement is a dependent function: no matter which specific value it is applied to, it will return evidence of the proposition.
Similarly, the process of picking an arbitrary \\( x \\) is the same as using ``fun x => ...``.
In the tactic language, this process of selecting an arbitrary \\( x \\) is performed using the `intro` tactic, which produces the function behind the scenes when the tactic script has completed.
The `intro` tactic should be provided with the name to be used for this arbitrary value.
-->
<p>对于以「对于所有 \( x \)」开头的陈述的数学证明应该假设存在任意的 \( x \)，
并证明该阐述。「任意」意味着不假设 \( x \) 的任何额外性质，因此结果语句将适用于 <strong>任何</strong> \( x \)。
在 Lean 中，「对于所有」语句是一个依值函数：无论将其应用于哪个特定值，它都将返回命题的证据。
类似地，选择任意 \( x \) 的过程与使用 <code>fun x =&gt; ...</code> 相同。在策略语言中，
选择任意 \( x \) 的过程是使用 <code>intro</code> 策略执行的，当策略脚本完成后，它会在幕后生成函数。
<code>intro</code> 策略应当被提供用于此任意值的名称。</p>
<!--
Using the `intro` tactic in the `nil` case removes the `∀ (n : Nat),` from the goal, and adds an assumption `n : Nat`:
-->
<p>在 <code>nil</code> 情况下使用 <code>intro</code> 策略会从目标中移除 <code>∀ (n : Nat),</code>，并添加假设 <code>n : Nat</code>：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt; intro n
  | cons y ys ih =&gt; skip
</code></pre>
<pre><code class="language-output error">unsolved goals
case nil
n : Nat
⊢ n + NonTail.sum [] = Tail.sumHelper n []
</code></pre>
<!--
Both sides of this propositional equality are definitionally equal to `n`, so `rfl` suffices:
-->
<p>此命题等式的两边在定义上等于 <code>n</code>，因此 <code>rfl</code> 就足够了：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt;
    intro n
    rfl
  | cons y ys ih =&gt; skip
</code></pre>
<p><code>cons</code> 目标也包含一个「对于所有」：</p>
<pre><code class="language-output error">unsolved goals
case cons
y : Nat
ys : List Nat
ih : ∀ (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
⊢ ∀ (n : Nat), n + NonTail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<!--
This suggests the use of `intro`.
-->
<p>这这里建议使用 <code>intro</code>。</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt;
    intro n
    rfl
  | cons y ys ih =&gt;
    intro n
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
y : Nat
ys : List Nat
ih : ∀ (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
⊢ n + NonTail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<!--
The proof goal now contains both `NonTail.sum` and `Tail.sumHelper` applied to `y :: ys`.
The simplifier can make the next step more clear:
-->
<p>现在，证明目标包含应用于 <code>y :: ys</code> 的 <code>NonTail.sum</code> 和 <code>Tail.sumHelper</code>。
简化器可以使下一步更清晰：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt;
    intro n
    rfl
  | cons y ys ih =&gt;
    intro n
    simp [NonTail.sum, Tail.sumHelper]
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
y : Nat
ys : List Nat
ih : ∀ (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
⊢ n + (y + NonTail.sum ys) = Tail.sumHelper (y + n) ys
</code></pre>
<!--
This goal is very close to matching the induction hypothesis.
There are two ways in which it does not match:

 * The left-hand side of the equation is `n + (y + NonTail.sum ys)`, but the induction hypothesis needs the left-hand side to be a number added to `NonTail.sum ys`.
   In other words, this goal should be rewritten to `(n + y) + NonTail.sum ys`, which is valid because addition of natural numbers is associative.
 * When the left side has been rewritten to `(y + n) + NonTail.sum ys`, the accumulator argument on the right side should be `n + y` rather than `y + n` in order to match.
   This rewrite is valid because addition is also commutative.
-->
<p>此目标非常接近于匹配归纳假设。它不匹配的方面有两个：</p>
<ul>
<li>等式的左侧是 <code>n + (y + NonTail.sum ys)</code>，但归纳假设需要左侧是一个添加到 <code>NonTail.sum ys</code> 的数字。
换句话说，此目标应重写为 <code>(n + y) + NonTail.sum ys</code>，这是有效的，因为自然数加法满足结合律。</li>
<li>当左侧重写为 <code>(y + n) + NonTail.sum ys</code> 时，右侧的累加器参数应为 <code>n + y</code> 而非 <code>y + n</code> 以进行匹配。
此重写是有效的，因为加法也满足交换律。</li>
</ul>
<!--
The associativity and commutativity of addition have already been proved in Lean's standard library.
The proof of associativity is named `Nat.add_assoc`, and its type is `(n m k : Nat) → (n + m) + k = n + (m + k)`, while the proof of commutativity is called `Nat.add_comm` and has type `(n m : Nat) → n + m = m + n`.
Normally, the `rw` tactic is provided with an expression whose type is an equality.
However, if the argument is instead a dependent function whose return type is an equality, it attempts to find arguments to the function that would allow the equality to match something in the goal.
There is only one opportunity to apply associativity, though the direction of the rewrite must be reversed because the right side of the equality in `Nat.add_assoc` is the one that matches the proof goal:
-->
<p>The associativity and commutativity of addition have already been proved in Lean's standard library.
The proof of associativity is named <code>Nat.add_assoc</code>, and its type is <code>(n m k : Nat) → (n + m) + k = n + (m + k)</code>, while the proof of commutativity is called <code>Nat.add_comm</code> and has type <code>(n m : Nat) → n + m = m + n</code>.
Normally, the <code>rw</code> tactic is provided with an expression whose type is an equality.
However, if the argument is instead a dependent function whose return type is an equality, it attempts to find arguments to the function that would allow the equality to match something in the goal.
There is only one opportunity to apply associativity, though the direction of the rewrite must be reversed because the right side of the equality in <code>Nat.add_assoc</code> is the one that matches the proof goal:</p>
<p>加法的结合律和交换律已在 Lean 的标准库中得到证明。结合律的证明名为
<code>Nat.add_assoc</code>，
其类型为 <code>(n m k : Nat) → (n + m) + k = n + (m + k)</code>，
而交换律的证明称为 <code>Nat.add_comm</code>，
其类型为 <code>(n m : Nat) → n + m = m + n</code>。
通常，<code>rw</code> 策略会提供一个类型为等式的表达式。但是，如果参数是一个返回类型为等式的相关函数，
它会尝试查找函数的参数，以便等式可以匹配目标中的某个内容。
虽然必须反转重写方向，但只有一种机会应用结合律，
因为 <code>Nat.add_assoc</code>
中等式的右侧是与证明目标匹配的：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt;
    intro n
    rfl
  | cons y ys ih =&gt;
    intro n
    simp [NonTail.sum, Tail.sumHelper]
    rw [←Nat.add_assoc]
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
y : Nat
ys : List Nat
ih : ∀ (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
⊢ n + y + NonTail.sum ys = Tail.sumHelper (y + n) ys
</code></pre>
<!--
Rewriting directly with `Nat.add_comm`, however, leads to the wrong result.
The `rw` tactic guesses the wrong location for the rewrite, leading to an unintended goal:
-->
<p>然而，直接使用 <code>Nat.add_comm</code>
重写会导致错误的结果。<code>rw</code> 策略猜测了错误的重写位置，导致了意料之外的目标：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt;
    intro n
    rfl
  | cons y ys ih =&gt;
    intro n
    simp [NonTail.sum, Tail.sumHelper]
    rw [←Nat.add_assoc]
    rw [Nat.add_comm]
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
y : Nat
ys : List Nat
ih : ∀ (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
⊢ NonTail.sum ys + (n + y) = Tail.sumHelper (y + n) ys
</code></pre>
<!--
This can be fixed by explicitly providing `y` and `n` as arguments to `Nat.add_comm`:
-->
<p>可以通过显式地将 <code>y</code> 和 <code>n</code> 作为参数提供给 <code>Nat.add_comm</code> 来解决此问题：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt;
    intro n
    rfl
  | cons y ys ih =&gt;
    intro n
    simp [NonTail.sum, Tail.sumHelper]
    rw [←Nat.add_assoc]
    rw [Nat.add_comm y n]
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
y : Nat
ys : List Nat
ih : ∀ (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
⊢ n + y + NonTail.sum ys = Tail.sumHelper (n + y) ys
</code></pre>
<!--
The goal now matches the induction hypothesis.
In particular, the induction hypothesis's type is a dependent function type.
Applying `ih` to `n + y` results in exactly the desired type.
The `exact` tactic completes a proof goal if its argument has exactly the desired type:
-->
<p>现在目标与归纳假设相匹配了。特别是，归纳假设的类型是一个依值函数类型。
将 <code>ih</code> 应用于 <code>n + y</code> 会产生刚好期望的类型。如果其参数具有期望的类型，
<code>exact</code> 策略会完成证明目标：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_helper_accum (xs : List Nat) :
    (n : Nat) → n + NonTail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt; intro n; rfl
  | cons y ys ih =&gt;
    intro n
    simp [NonTail.sum, Tail.sumHelper]
    rw [←Nat.add_assoc]
    rw [Nat.add_comm y n]
    exact ih (n + y)
</code></pre>
<!--
The actual proof requires only a little additional work to get the goal to match the helper's type.
The first step is still to invoke function extensionality:
-->
<p>实际的证明只需要一些额外的工作即可使目标与辅助函数的类型相匹配。
第一步仍然是调用函数外延性：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
</code></pre>
<pre><code class="language-output error">unsolved goals
case h
xs : List Nat
⊢ NonTail.sum xs = Tail.sum xs
</code></pre>
<!--
The next step is unfold `Tail.sum`, exposing `Tail.sumHelper`:
-->
<p>下一步是展开 <code>Tail.sum</code>，暴露出 <code>Tail.sumHelper</code>：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  simp [Tail.sum]
</code></pre>
<pre><code class="language-output error">unsolved goals
case h
xs : List Nat
⊢ NonTail.sum xs = Tail.sumHelper 0 xs
</code></pre>
<!--
Having done this, the types almost match.
However, the helper has an additional addend on the left side.
In other words, the proof goal is `NonTail.sum xs = Tail.sumHelper 0 xs`, but applying `non_tail_sum_eq_helper_accum` to `xs` and `0` yields the type `0 + NonTail.sum xs = Tail.sumHelper 0 xs`.
Another standard library proof, `Nat.zero_add`, has type `(n : Nat) → 0 + n = n`.
Applying this function to `NonTail.sum xs` results in an expression with type `0 + NonTail.sum xs = NonTail.sum xs`, so rewriting from right to left results in the desired goal:
-->
<p>完成这一步后，类型已经近乎匹配了。但是，辅助类型在左侧有一个额外的加数。
换句话说，证明目标是 <code>NonTail.sum xs = Tail.sumHelper 0 xs</code>，
但将 <code>non_tail_sum_eq_helper_accum</code> 应用于 <code>xs</code> 和 <code>0</code> 会产生类型
<code>0 + NonTail.sum xs = Tail.sumHelper 0 xs</code>。
另一个标准库证明 <code>Nat.zero_add</code> 的类型为
<code>(n : Nat) → 0 + n = n</code>。
将此函数应用于 <code>NonTail.sum xs</code> 会产生类型为
<code>0 + NonTail.sum xs = NonTail.sum xs</code> 的表达式，
因此从右往左重写会产生期望的目标：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  simp [Tail.sum]
  rw [←Nat.zero_add (NonTail.sum xs)]
</code></pre>
<pre><code class="language-output error">unsolved goals
case h
xs : List Nat
⊢ 0 + NonTail.sum xs = Tail.sumHelper 0 xs
</code></pre>
<!--
Finally, the helper can be used to complete the proof:
-->
<p>最后，可以使用辅助定理来完成证明：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  simp [Tail.sum]
  rw [←Nat.zero_add (NonTail.sum xs)]
  exact non_tail_sum_eq_helper_accum xs 0
</code></pre>
<!--
This proof demonstrates a general pattern that can be used when proving that an accumulator-passing tail-recursive function is equal to the non-tail-recursive version.
The first step is to discover the relationship between the starting accumulator argument and the final result.
For instance, beginning `Tail.sumHelper` with an accumulator of `n` results in the final sum being added to `n`, and beginning `Tail.reverseHelper` with an accumulator of `ys` results in the final reversed list being prepended to `ys`.
The second step is to write down this relationship as a theorem statement and prove it by induction.
While the accumulator is always initialized with some neutral value in practice, such as `0` or `[]`, this more general statement that allows the starting accumulator to be any value is what's needed to get a strong enough induction hypothesis.
Finally, using this helper theorem with the actual initial accumulator value results in the desired proof.
For example, in `non_tail_sum_eq_tail_sum`, the accumulator is specified to be `0`.
This may require rewriting the goal to make the neutral initial accumulator values occur in the right place.
-->
<p>此证明演示了在证明「累加器传递尾递归函数等于非尾递归版本」时可以使用的通用模式。
第一步是发现起始累加器参数和最终结果之间的关系。
例如，以 <code>n</code> 的累加器开始 <code>Tail.sumHelper</code> 会导致最终的和被添加到 <code>n</code> 中，
而以 <code>ys</code> 的累加器开始 <code>Tail.reverseHelper</code> 会导致最终反转的列表被前置到 <code>ys</code> 中。
第二步是将此关系写成定理陈述，并通过归纳法证明它。虽然在实践中，
累加器总是用一些中性值（Neutral，即幺元，例如 <code>0</code> 或 <code>[]</code>）初始化，
但允许起始累加器为任何值的更通用的陈述是获得足够强的归纳假设所需要的。
最后，将此辅助定理与实际的初始累加器值一起使用会产生期望的证明。
例如，在 <code>non_tail_sum_eq_tail_sum</code> 中，累加器指定为 <code>0</code>。
这可能需要重写目标以使中性初始累加器值出现在正确的位置。</p>
<!--
## Exercise
-->
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<!--
### Warming Up
-->
<h3 id="热身"><a class="header" href="#热身">热身</a></h3>
<!--
Write your own proofs for `Nat.zero_add`, `Nat.add_assoc`, and `Nat.add_comm` using the `induction` tactic.
-->
<p>使用 <code>induction</code> 策略编写你自己的 <code>Nat.zero_add</code>、<code>Nat.add_assoc</code> 和 <code>Nat.add_comm</code> 的证明。</p>
<!--
### More Accumulator Proofs
-->
<h3 id="更多累加器证明"><a class="header" href="#更多累加器证明">更多累加器证明</a></h3>
<!--
#### Reversing Lists
-->
<h4 id="反转列表"><a class="header" href="#反转列表">反转列表</a></h4>
<!--
Adapt the proof for `sum` into a proof for `NonTail.reverse` and `Tail.reverse`.
The first step is to think about the relationship between the accumulator value being passed to `Tail.reverseHelper` and the non-tail-recursive reverse.
Just as adding a number to the accumulator in `Tail.sumHelper` is the same as adding it to the overall sum, using `List.cons` to add a new entry to the accumulator in `Tail.reverseHelper` is equivalent to some change to the overall result.
Try three or four different accumulator values with pencil and paper until the relationship becomes clear.
Use this relationship to prove a suitable helper theorem.
Then, write down the overall theorem.
Because `NonTail.reverse` and `Tail.reverse` are polymorphic, stating their equality requires the use of `@` to stop Lean from trying to figure out which type to use for `α`.
Once `α` is treated as an ordinary argument, `funext` should be invoked with both `α` and `xs`:
-->
<p>将 <code>sum</code> 的证明调整为 <code>NonTail.reverse</code> 和 <code>Tail.reverse</code> 的证明。
第一步是思考传递给 <code>Tail.reverseHelper</code> 的累加器值与非尾递归反转之间的关系。
正如在 <code>Tail.sumHelper</code> 中将数字添加到累加器中与将其添加到整体的和中相同，
在 <code>Tail.reverseHelper</code> 中使用 <code>List.cons</code> 将新条目添加到累加器中相当于对整体结果进行了一些更改。
用纸和笔尝试三个或四个不同的累加器值，直到关系变得清晰。
使用此关系来证明一个合适的辅助定理。然后，写下整体定理。
因为 <code>NonTail.reverse</code> 和 <code>Tail.reverse</code> 是多态的，所以声明它们的相等性需要使用
<code>@</code> 来阻止 Lean 尝试找出为 <code>α</code> 使用哪种类型。一旦 <code>α</code> 被视为一个普通参数，
<code>funext</code> 应该与 <code>α</code> 和 <code>xs</code> 一起调用：</p>
<pre><code class="language-leantac">theorem non_tail_reverse_eq_tail_reverse : @NonTail.reverse = @Tail.reverse := by
  funext α xs
</code></pre>
<!--
This results in a suitable goal:
-->
<p>这会产生一个合适的目标：</p>
<pre><code class="language-output error">unsolved goals
case h.h
α : Type u_1
xs : List α
⊢ NonTail.reverse xs = Tail.reverse xs
</code></pre>
<!--
#### Factorial
-->
<h4 id="阶乘"><a class="header" href="#阶乘">阶乘</a></h4>
<!--
Prove that `NonTail.factorial` from the exercises in the previous section is equal to your tail-recursive solution by finding the relationship between the accumulator and the result and proving a suitable helper theorem.
-->
<p>通过找到累加器和结果之间的关系并证明一个合适的辅助定理，
证明上一节练习中的 <code>NonTail.factorial</code> 等于你的尾递归版本的解决方案。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../programs-proofs/tail-recursion.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../programs-proofs/arrays-termination.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../programs-proofs/tail-recursion.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../programs-proofs/arrays-termination.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
