
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1 src/title.md:1
msgid "Functional Programming in Lean"
msgstr ""

#: src/SUMMARY.md:3
msgid "Functional Programming in Lean Introduction Acknowledgments"
msgstr ""

#: src/SUMMARY.md:7
msgid "Getting to Know Lean"
msgstr ""

#: src/SUMMARY.md:8 src/getting-to-know/evaluating.md:1
#: src/getting-to-know/summary.md:3 src/monads/arithmetic.md:41
msgid "Evaluating Expressions"
msgstr ""

#: src/SUMMARY.md:9 src/getting-to-know/types.md:1
#: src/getting-to-know/summary.md:28
msgid "Types"
msgstr ""

#: src/SUMMARY.md:10 src/getting-to-know/functions-and-definitions.md:1
msgid "Functions and Definitions"
msgstr ""

#: src/SUMMARY.md:11 src/getting-to-know/structures.md:1
msgid "Structures"
msgstr ""

#: src/SUMMARY.md:12
msgid "Datatypes, Patterns and Recursion"
msgstr ""

#: src/SUMMARY.md:13 src/getting-to-know/polymorphism.md:1
msgid "Polymorphism"
msgstr ""

#: src/SUMMARY.md:14 src/SUMMARY.md:21 src/SUMMARY.md:31 src/SUMMARY.md:38
#: src/SUMMARY.md:53 src/getting-to-know/conveniences.md:1
#: src/hello-world/conveniences.md:1 src/type-classes/conveniences.md:1
#: src/monads/conveniences.md:1 src/monad-transformers/conveniences.md:1
msgid "Additional Conveniences"
msgstr ""

#: src/SUMMARY.md:15 src/SUMMARY.md:22 src/SUMMARY.md:32 src/SUMMARY.md:39
#: src/SUMMARY.md:47 src/SUMMARY.md:54 src/SUMMARY.md:61 src/SUMMARY.md:71
#: src/getting-to-know/summary.md:1 src/hello-world/summary.md:1
#: src/type-classes/summary.md:1 src/monads/summary.md:1
#: src/functor-applicative-monad/summary.md:1
#: src/monad-transformers/summary.md:1 src/dependent-types/summary.md:1
#: src/programs-proofs/summary.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:16 src/hello-world.md:1
msgid "Hello, World!"
msgstr ""

#: src/SUMMARY.md:17 src/hello-world/running-a-program.md:1
msgid "Running a Program"
msgstr ""

#: src/SUMMARY.md:18 src/hello-world/step-by-step.md:1
msgid "Step By Step"
msgstr ""

#: src/SUMMARY.md:19 src/hello-world/starting-a-project.md:1
msgid "Starting a Project"
msgstr ""

#: src/SUMMARY.md:20 src/hello-world/cat.md:1
msgid "Worked Example: `cat`"
msgstr ""

#: src/SUMMARY.md:23 src/props-proofs-indexing.md:1
msgid "Interlude: Propositions, Proofs, and Indexing"
msgstr ""

#: src/SUMMARY.md:24 src/type-classes.md:1
msgid "Overloading and Type Classes"
msgstr ""

#: src/SUMMARY.md:25 src/type-classes/pos.md:1 src/type-classes/coercion.md:12
msgid "Positive Numbers"
msgstr ""

#: src/SUMMARY.md:26 src/type-classes/polymorphism.md:1
msgid "Type Classes and Polymorphism"
msgstr ""

#: src/SUMMARY.md:27 src/type-classes/out-params.md:1
msgid "Controlling Instance Search"
msgstr ""

#: src/SUMMARY.md:28 src/type-classes/indexing.md:1
msgid "Arrays and Indexing"
msgstr ""

#: src/SUMMARY.md:29 src/type-classes/standard-classes.md:1
msgid "Standard Classes"
msgstr ""

#: src/SUMMARY.md:30 src/type-classes/coercion.md:1
#: src/type-classes/summary.md:59
msgid "Coercions"
msgstr ""

#: src/SUMMARY.md:33 src/monads.md:1
msgid "Monads"
msgstr ""

#: src/SUMMARY.md:34 src/monads/class.md:1 src/monads/summary.md:15
msgid "The Monad Type Class"
msgstr ""

#: src/SUMMARY.md:35 src/monads/arithmetic.md:1
msgid "Example: Arithmetic in Monads"
msgstr ""

#: src/SUMMARY.md:36 src/monads/do.md:1 src/monads/summary.md:26
msgid "`do`\\-Notation for Monads"
msgstr ""

#: src/SUMMARY.md:37 src/monads/summary.md:41
msgid "The `IO` Monad"
msgstr ""

#: src/SUMMARY.md:40 src/functor-applicative-monad.md:1
msgid "Functors, Applicative Functors, and Monads"
msgstr ""

#: src/SUMMARY.md:41 src/functor-applicative-monad/inheritance.md:1
#: src/functor-applicative-monad/summary.md:11
msgid "Structures and Inheritance"
msgstr ""

#: src/SUMMARY.md:42 src/functor-applicative-monad/applicative.md:1
#: src/functor-applicative-monad/summary.md:22
msgid "Applicative Functors"
msgstr ""

#: src/SUMMARY.md:43 src/functor-applicative-monad/applicative-contract.md:1
msgid "The Applicative Contract"
msgstr ""

#: src/SUMMARY.md:44 src/functor-applicative-monad/alternative.md:1
msgid "Alternatives"
msgstr ""

#: src/SUMMARY.md:45 src/functor-applicative-monad/universes.md:1
#: src/functor-applicative-monad/summary.md:42
msgid "Universes"
msgstr ""

#: src/SUMMARY.md:46 src/functor-applicative-monad/complete.md:1
msgid "The Complete Definitions"
msgstr ""

#: src/SUMMARY.md:48 src/monad-transformers.md:1
msgid "Monad Transformers"
msgstr ""

#: src/SUMMARY.md:49 src/monad-transformers/reader-io.md:1
msgid "Combining IO and Reader"
msgstr ""

#: src/SUMMARY.md:50 src/monad-transformers/transformers.md:1
msgid "A Monad Construction Kit"
msgstr ""

#: src/SUMMARY.md:51 src/monad-transformers/order.md:1
msgid "Ordering Monad Transformers"
msgstr ""

#: src/SUMMARY.md:52
msgid "More `do` Features"
msgstr ""

#: src/SUMMARY.md:55 src/dependent-types.md:1 src/next-steps.md:48
msgid "Programming with Dependent Types"
msgstr ""

#: src/SUMMARY.md:56 src/dependent-types/indexed-families.md:1
#: src/dependent-types/summary.md:34
msgid "Indexed Families"
msgstr ""

#: src/SUMMARY.md:57 src/dependent-types/universe-pattern.md:1
msgid "The Universe Design Pattern"
msgstr ""

#: src/SUMMARY.md:58 src/dependent-types/typed-queries.md:1
msgid "Worked Example: Typed Queries"
msgstr ""

#: src/SUMMARY.md:59 src/dependent-types/indices-parameters-universes.md:1
msgid "Indices, Parameters, and Universe Levels"
msgstr ""

#: src/SUMMARY.md:60 src/dependent-types/pitfalls.md:1
msgid "Pitfalls of Programming with Dependent Types"
msgstr ""

#: src/SUMMARY.md:62 src/tactics-induction-proofs.md:1
msgid "Interlude: Tactics, Induction, and Proofs"
msgstr ""

#: src/SUMMARY.md:63 src/programs-proofs.md:1
msgid "Programming, Proving, and Performance"
msgstr ""

#: src/SUMMARY.md:64 src/programs-proofs/tail-recursion.md:1
#: src/programs-proofs/summary.md:3
msgid "Tail Recursion"
msgstr ""

#: src/SUMMARY.md:65 src/programs-proofs/tail-recursion-proofs.md:1
msgid "Proving Equivalence"
msgstr ""

#: src/SUMMARY.md:66 src/programs-proofs/arrays-termination.md:1
msgid "Arrays and Termination"
msgstr ""

#: src/SUMMARY.md:67 src/programs-proofs/inequalities.md:1
msgid "More Inequalities"
msgstr ""

#: src/SUMMARY.md:68 src/programs-proofs/fin.md:1
#: src/programs-proofs/summary.md:44
msgid "Safe Array Indices"
msgstr ""

#: src/SUMMARY.md:69 src/programs-proofs/insertion-sort.md:1
msgid "Insertion Sort and Array Mutation"
msgstr ""

#: src/SUMMARY.md:70 src/programs-proofs/special-types.md:1
msgid "Special Types"
msgstr ""

#: src/SUMMARY.md:73 src/next-steps.md:1
msgid "Next Steps"
msgstr ""

#: src/title.md:3
msgid "_by David Thrane Christiansen_"
msgstr ""

#: src/title.md:5
msgid "_Copyright Microsoft Corporation 2023_"
msgstr ""

#: src/title.md:9
msgid ""
"This is a free book on using Lean 4 as a programming language. All code "
"samples are tested with Lean 4 release `4.1.0`."
msgstr ""

#: src/title.md:11
msgid "Release history"
msgstr ""

#: src/title.md:13
msgid "January, 2024"
msgstr ""

#: src/title.md:15
msgid ""
"This is a minor bugfix release that fixes a regression in an example program."
msgstr ""

#: src/title.md:17
msgid "October, 2023"
msgstr ""

#: src/title.md:19
msgid ""
"In this first maintenance release, a number of smaller issues were fixed and "
"the text was brought up to date with the latest release of Lean."
msgstr ""

#: src/title.md:21
msgid "May, 2023"
msgstr ""

#: src/title.md:23
msgid ""
"The book is now complete! Compared to the April pre-release, many small "
"details have been improved and minor mistakes have been fixed."
msgstr ""

#: src/title.md:25
msgid "April, 2023"
msgstr ""

#: src/title.md:27
msgid ""
"This release adds an interlude on writing proofs with tactics as well as a "
"final chapter that combines discussion of performance and cost models with "
"proofs of termination and program equivalence. This is the last release "
"prior to the final release."
msgstr ""

#: src/title.md:30
msgid "March, 2023"
msgstr ""

#: src/title.md:32
msgid ""
"This release adds a chapter on programming with dependent types and indexed "
"families."
msgstr ""

#: src/title.md:34
msgid "January, 2023"
msgstr ""

#: src/title.md:36
msgid ""
"This release adds a chapter on monad transformers that includes a "
"description of the imperative features that are available in `do`\\-notation."
msgstr ""

#: src/title.md:38
msgid "December, 2022"
msgstr ""

#: src/title.md:40
msgid ""
"This release adds a chapter on applicative functors that additionally "
"describes structures and type classes in more detail. This is accompanied "
"with improvements to the description of monads. The December 2022 release "
"was delayed until January 2023 due to winter holidays."
msgstr ""

#: src/title.md:44
msgid "November, 2022"
msgstr ""

#: src/title.md:45
msgid ""
"This release adds a chapter on programming with monads. Additionally, the "
"example of using JSON in the coercions section has been updated to include "
"the complete code."
msgstr ""

#: src/title.md:47
msgid "October, 2022"
msgstr ""

#: src/title.md:49
msgid ""
"This release completes the chapter on type classes. In addition, a short "
"interlude introducing propositions, proofs, and tactics has been added just "
"before the chapter on type classes, because a small amount of familiarity "
"with the concepts helps to understand some of the standard library type "
"classes."
msgstr ""

#: src/title.md:51
msgid "September, 2022"
msgstr ""

#: src/title.md:53
msgid ""
"This release adds the first half of a chapter on type classes, which are "
"Lean's mechanism for overloading operators and an important means of "
"organizing code and structuring libraries. Additionally, the second chapter "
"has been updated to account for changes in Lean's stream API."
msgstr ""

#: src/title.md:55
msgid "August, 2022"
msgstr ""

#: src/title.md:57
msgid ""
"This third public release adds a second chapter, which describes compiling "
"and running programs along with Lean's model for side effects."
msgstr ""

#: src/title.md:59
msgid "July, 2022"
msgstr ""

#: src/title.md:61
msgid "The second public release completes the first chapter."
msgstr ""

#: src/title.md:63
msgid "June, 2022"
msgstr ""

#: src/title.md:65
msgid ""
"This was the first public release, consisting of an introduction and part of "
"the first chapter."
msgstr ""

#: src/title.md:67
msgid "About the Author"
msgstr ""

#: src/title.md:69
msgid ""
"David Thrane Christiansen has been using functional languages for twenty "
"years, and dependent types for ten. Together with Daniel P. Friedman, he "
"wrote [_The Little Typer_](https://thelittletyper.com/), an introduction to "
"the key ideas of dependent type theory. He has a Ph.D. from the IT "
"University of Copenhagen. During his studies, he was a major contributor to "
"the first version of the Idris language. Since leaving academia, he has "
"worked as a software developer at Galois in Portland, Oregon and Deon "
"Digital in Copenhagen, Denmark, and he was the Executive Director of the "
"Haskell Foundation. At the time of writing, he is employed at the [Lean "
"Focused Research Organization](https://lean-fro.org) working full-time on "
"Lean."
msgstr ""

#: src/title.md:76
msgid "License"
msgstr ""

#: src/title.md:78
msgid "This work is licensed under a "
msgstr ""

#: src/title.md:78
msgid "Creative Commons Attribution 4.0 International License"
msgstr ""

#: src/title.md:78
msgid "."
msgstr ""

#: src/introduction.md:3
msgid ""
"Lean is an interactive theorem prover developed at Microsoft Research, based "
"on dependent type theory. Dependent type theory unites the worlds of "
"programs and proofs; thus, Lean is also a programming language. Lean takes "
"its dual nature seriously, and it is designed to be suitable for use as a "
"general-purpose programming language—Lean is even implemented in itself. "
"This book is about writing programs in Lean."
msgstr ""

#: src/introduction.md:8
msgid ""
"When viewed as a programming language, Lean is a strict pure functional "
"language with dependent types. A large part of learning to program with Lean "
"consists of learning how each of these attributes affects the way programs "
"are written, and how to think like a functional programmer. _Strictness_ "
"means that function calls in Lean work similarly to the way they do in most "
"languages: the arguments are fully computed before the function's body "
"begins running. _Purity_ means that Lean programs cannot have side effects "
"such as modifying locations in memory, sending emails, or deleting files "
"without the program's type saying so. Lean is a _functional_ language in the "
"sense that functions are first-class values like any other and that the "
"execution model is inspired by the evaluation of mathematical expressions. "
"_Dependent types_, which are the most unusual feature of Lean, make types "
"into a first-class part of the language, allowing types to contain programs "
"and programs to compute types."
msgstr ""

#: src/introduction.md:15
msgid ""
"This book is intended for programmers who want to learn Lean, but who have "
"not necessarily used a functional programming language before. Familiarity "
"with functional languages such as Haskell, OCaml, or F# is not required. On "
"the other hand, this book does assume knowledge of concepts like loops, "
"functions, and data structures that are common to most programming "
"languages. While this book is intended to be a good first book on functional "
"programming, it is not a good first book on programming in general."
msgstr ""

#: src/introduction.md:20
msgid ""
"Mathematicians who are using Lean as a proof assistant will likely need to "
"write custom proof automation tools at some point. This book is also for "
"them. As these tools become more sophisticated, they begin to resemble "
"programs in functional languages, but most working mathematicians are "
"trained in languages like Python and Mathematica. This book can help bridge "
"the gap, empowering more mathematicians to write maintainable and "
"understandable proof automation tools."
msgstr ""

#: src/introduction.md:25
msgid ""
"This book is intended to be read linearly, from the beginning to the end. "
"Concepts are introduced one at a time, and later sections assume familiarity "
"with earlier sections. Sometimes, later chapters will go into depth on a "
"topic that was only briefly addressed earlier on. Some sections of the book "
"contain exercises. These are worth doing, in order to cement your "
"understanding of the section. It is also useful to explore Lean as you read "
"the book, finding creative new ways to use what you have learned."
msgstr ""

#: src/introduction.md:32
msgid "Getting Lean"
msgstr ""

#: src/introduction.md:34
msgid ""
"Before writing and running programs written in Lean, you'll need to set up "
"Lean on your own computer. The Lean tooling consists of the following:"
msgstr ""

#: src/introduction.md:37
msgid ""
"`elan` manages the Lean compiler toolchains, similarly to `rustup` or "
"`ghcup`."
msgstr ""

#: src/introduction.md:38
msgid ""
"`lake` builds Lean packages and their dependencies, similarly to `cargo`, "
"`make`, or Gradle."
msgstr ""

#: src/introduction.md:39
msgid ""
"`lean` type checks and compiles individual Lean files as well as providing "
"information to programmer tools about files that are currently being "
"written. Normally, `lean` is invoked by other tools rather than directly by "
"users."
msgstr ""

#: src/introduction.md:41
msgid ""
"Plugins for editors, such as Visual Studio Code or Emacs, that communicate "
"with `lean` and present its information conveniently."
msgstr ""

#: src/introduction.md:43
msgid ""
"Please refer to the [Lean "
"manual](https://lean-lang.org/lean4/doc/quickstart.html) for up-to-date "
"instructions for installing Lean."
msgstr ""

#: src/introduction.md:45
msgid "Typographical Conventions"
msgstr ""

#: src/introduction.md:47
msgid ""
"Code examples that are provided to Lean as _input_ are formatted like this:"
msgstr ""

#: src/introduction.md:53
msgid ""
"The last line above (beginning with `#eval`) is a command that instructs "
"Lean to calculate an answer. Lean's replies are formatted like this:"
msgstr ""

#: src/introduction.md:58
msgid "Error messages returned by Lean are formatted like this:"
msgstr ""

#: src/introduction.md:59
msgid ""
"```output error\n"
"application type mismatch\n"
"  add1 \"seven\"\n"
"argument\n"
"  \"seven\"\n"
"has type\n"
"  String : Type\n"
"but is expected to have type\n"
"  Nat : Type\n"
"```"
msgstr ""

#: src/introduction.md:69
msgid "Warnings are formatted like this:"
msgstr ""

#: src/introduction.md:74
msgid "Unicode"
msgstr ""

#: src/introduction.md:76
msgid ""
"Idiomatic Lean code makes use of a variety of Unicode characters that are "
"not part of ASCII. For instance, Greek letters like `α` and `β` and the "
"arrow `→` both occur in the first chapter of this book. This allows Lean "
"code to more closely resemble ordinary mathematical notation."
msgstr ""

#: src/introduction.md:80
msgid ""
"With the default Lean settings, both Visual Studio Code and Emacs allow "
"these characters to be typed with a backslash (`\\`) followed by a name. For "
"example, to enter `α`, type `\\alpha`. To find out how to type a character "
"in Visual Studio Code, point the mouse at it and look at the tooltip. In "
"Emacs, use `C-c C-k` with point on the character in question."
msgstr ""

#: src/acknowledgments.md:1
msgid "Acknowledgments"
msgstr ""

#: src/acknowledgments.md:4
msgid ""
"This free online book was made possible by the generous support of Microsoft "
"Research, who paid for it to be written and given away. During the process "
"of writing, they made the expertise of the Lean development team available "
"to both answer my questions and make Lean easier to use. In particular, "
"Leonardo de Moura initiated the project and helped me get started, Chris "
"Lovett set up the CI and deployment automation and provided great feedback "
"as a test reader, Gabriel Ebner provided technical reviews, Sarah Smith kept "
"the administrative side working well, and Vanessa Rodriguez helped me "
"diagnose a tricky interaction between the source-code highlighting library "
"and certain versions of Safari on iOS."
msgstr ""

#: src/acknowledgments.md:8
msgid ""
"Writing this book has taken up many hours outside of normal working hours. "
"My wife Ellie Thrane Christiansen has taken on a larger than usual share of "
"running the family, and this book could not exist if she had not done so. An "
"extra day of work each week has not been easy for my family—thank you for "
"your patience and support while I was writing."
msgstr ""

#: src/acknowledgments.md:12
msgid ""
"The online community surrounding Lean provided enthusiastic support for the "
"project, both technical and emotional. In particular, Sebastian Ullrich "
"provided key help when I was learning Lean's metaprogramming system in order "
"to write the supporting code that allowed the text of error messages to be "
"both checked in CI and easily included in the book itself. Within hours of "
"posting a new revision, excited readers would be finding mistakes, providing "
"suggestions, and showering me with kindness. In particular, I'd like to "
"thank Arien Malec, Asta Halkjær From, Bulhwi Cha, Craig Stuntz, Daniel "
"Fabian, Evgenia Karunus, eyelash, Floris van Doorn, František Silváši, "
"Henrik Böving, Ian Young, Jeremy Salwen, Jireh Loreaux, Kevin Buzzard, Lars "
"Ericson, Liu Yuxi, Mac Malone, Malcolm Langfield, Mario Carneiro, Newell "
"Jensen, Patrick Massot, Paul Chisholm, Pietro Monticone, Tomas Puverle, Yaël "
"Dillies, Zhiyuan Bao, and Zyad Hassan for their many suggestions, both "
"stylistic and technical."
msgstr ""

#: src/getting-to-know.md:1
msgid ""
"According to tradition, a programming language should be introduced by "
"compiling and running a program that displays `\"Hello, world!\"` on the "
"console. This simple program ensures that the language tooling is installed "
"correctly and that the programmer is able to run the compiled code."
msgstr ""

#: src/getting-to-know.md:7
msgid ""
"Since the 1970s, however, programming has changed. Today, compilers are "
"typically integrated into text editors, and the programming environment "
"offers feedback as the program is written. Lean is no exception: it "
"implements an extended version of the Language Server Protocol that allows "
"it to communicate with a text editor and provide feedback as the user types."
msgstr ""

#: src/getting-to-know.md:14
msgid ""
"Languages as varied as Python, Haskell, and JavaScript offer a "
"read-eval-print-loop (REPL), also known as an interactive toplevel or a "
"browser console, in which expressions or statements can be entered. The "
"language then computes and displays the result of the user's input. Lean, on "
"the other hand, integrates these features into the interaction with the "
"editor, providing commands that cause the text editor to display feedback "
"integrated into the program text itself. This chapter provides a short "
"introduction to interacting with Lean in an editor, while [Hello, World!]() "
"describes how to use Lean traditionally from the command line in batch mode."
msgstr ""

#: src/getting-to-know.md:19
msgid ""
"It is best if you read this book with Lean open in your editor, following "
"along and typing in each example. Please play with the examples, and see "
"what happens!"
msgstr ""

#: src/getting-to-know/evaluating.md:3
msgid ""
"The most important thing to understand as a programmer learning Lean is how "
"evaluation works. Evaluation is the process of finding the value of an "
"expression, just as one does in arithmetic. For instance, the value of 15 - "
"6 is 9 and the value of 2 × (3 + 1) is 8. To find the value of the latter "
"expression, 3 + 1 is first replaced by 4, yielding 2 × 4, which itself can "
"be reduced to 8. Sometimes, mathematical expressions contain variables: the "
"value of _x_ + 1 cannot be computed until we know what the value of _x_ is. "
"In Lean, programs are first and foremost expressions, and the primary way to "
"think about computation is as evaluating expressions to find their values."
msgstr ""

#: src/getting-to-know/evaluating.md:11
msgid ""
"Most programming languages are _imperative_, where a program consists of a "
"series of statements that should be carried out in order to find the "
"program's result. Programs have access to mutable memory, so the value "
"referred to by a variable can change over time. In addition to mutable "
"state, programs may have other side effects, such as deleting files, making "
"outgoing network connections, throwing or catching exceptions, and reading "
"data from a database. \"Side effects\" is essentially a catch-all term for "
"describing things that may happen in a program that don't follow the model "
"of evaluating mathematical expressions."
msgstr ""

#: src/getting-to-know/evaluating.md:21
msgid ""
"In Lean, however, programs work the same way as mathematical expressions. "
"Once given a value, variables cannot be reassigned. Evaluating an expression "
"cannot have side effects. If two expressions have the same value, then "
"replacing one with the other will not cause the program to compute a "
"different result. This does not mean that Lean cannot be used to write "
"`Hello, world!` to the console, but performing I/O is not a core part of the "
"experience of using Lean in the same way. Thus, this chapter focuses on how "
"to evaluate expressions interactively with Lean, while the next chapter "
"describes how to write, compile, and run the `Hello, world!` program."
msgstr ""

#: src/getting-to-know/evaluating.md:31
msgid ""
"To ask Lean to evaluate an expression, write `#eval` before it in your "
"editor, which will then report the result back. Typically, the result is "
"found by putting the cursor or mouse pointer over `#eval`. For instance,"
msgstr ""

#: src/getting-to-know/evaluating.md:39
msgid "yields the value `3`."
msgstr ""

#: src/getting-to-know/evaluating.md:41
msgid ""
"Lean obeys the ordinary rules of precedence and associativity for arithmetic "
"operators. That is,"
msgstr ""

#: src/getting-to-know/evaluating.md:47
msgid "yields the value `11` rather than `15`."
msgstr ""

#: src/getting-to-know/evaluating.md:51
msgid ""
"While both ordinary mathematical notation and the majority of programming "
"languages use parentheses (e.g. `f(x)`) to apply a function to its "
"arguments, Lean simply writes the function next to its arguments (e.g. `f "
"x`). Function application is one of the most common operations, so it pays "
"to keep it concise. Rather than writing"
msgstr ""

#: src/getting-to-know/evaluating.md:56
msgid ""
"```lean\n"
"#eval String.append(\"Hello, \", \"Lean!\")\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:59
msgid "to compute `\"Hello, Lean!\"`, one would instead write"
msgstr ""

#: src/getting-to-know/evaluating.md:61
msgid ""
"```Lean\n"
"#eval String.append \"Hello, \" \"Lean!\"\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:64
msgid ""
"where the function's two arguments are simply written next to it with spaces."
msgstr ""

#: src/getting-to-know/evaluating.md:67
msgid ""
"Just as the order-of-operations rules for arithmetic demand parentheses in "
"the expression `(1 + 2) * 5`, parentheses are also necessary when a "
"function's argument is to be computed via another function call. For "
"instance, parentheses are required in"
msgstr ""

#: src/getting-to-know/evaluating.md:71
msgid ""
"```Lean\n"
"#eval String.append \"great \" (String.append \"oak \" \"tree\")\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:74
msgid ""
"because otherwise the second `String.append` would be interpreted as an "
"argument to the first, rather than as a function being passed `\"oak \"` and "
"`\"tree\"` as arguments. The value of the inner `String.append` call must be "
"found first, after which it can be appended to `\"great \"`, yielding the "
"final value `\"great oak tree\"`."
msgstr ""

#: src/getting-to-know/evaluating.md:80
msgid ""
"Imperative languages often have two kinds of conditional: a conditional "
"_statement_ that determines which instructions to carry out based on a "
"Boolean value, and a conditional _expression_ that determines which of two "
"expressions to evaluate based on a Boolean value. For instance, in C and "
"C++, the conditional statement is written using `if` and `else`, while the "
"conditional expression is written with a ternary operator `?` and `:`. In "
"Python, the conditional statement begins with `if`, while the conditional "
"expression puts `if` in the middle. Because Lean is an expression-oriented "
"functional language, there are no conditional statements, only conditional "
"expressions. They are written using `if`, `then`, and `else`. For instance,"
msgstr ""

#: src/getting-to-know/evaluating.md:92
msgid ""
"```Lean\n"
"String.append \"it is \" (if 1 > 2 then \"yes\" else \"no\")\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:95
#: src/dependent-types/indexed-families.md:197
#: src/dependent-types/typed-queries.md:582
msgid "evaluates to"
msgstr ""

#: src/getting-to-know/evaluating.md:96
msgid ""
"```Lean\n"
"String.append \"it is \" (if false then \"yes\" else \"no\")\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:99
msgid "which evaluates to"
msgstr ""

#: src/getting-to-know/evaluating.md:100
msgid ""
"```lean\n"
"String.append \"it is \" \"no\"\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:103
msgid "which finally evaluates to `\"it is no\"`."
msgstr ""

#: src/getting-to-know/evaluating.md:105
msgid ""
"For the sake of brevity, a series of evaluation steps like this will "
"sometimes be written with arrows between them:"
msgstr ""

#: src/getting-to-know/evaluating.md:106
msgid ""
"```lean\n"
"String.append \"it is \" (if 1 > 2 then \"yes\" else \"no\")\n"
"===>\n"
"String.append \"it is \" (if false then \"yes\" else \"no\")\n"
"===>\n"
"String.append \"it is \" \"no\"\n"
"===>\n"
"\"it is no\"\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:116
#: src/getting-to-know/functions-and-definitions.md:112
#: src/getting-to-know/polymorphism.md:466 src/props-proofs-indexing.md:254
#: src/type-classes/standard-classes.md:350 src/type-classes/coercion.md:402
msgid "Messages You May Meet"
msgstr ""

#: src/getting-to-know/evaluating.md:118
msgid ""
"Asking Lean to evaluate a function application that is missing an argument "
"will lead to an error message. In particular, the example"
msgstr ""

#: src/getting-to-know/evaluating.md:120
msgid ""
"```lean\n"
"#eval String.append \"it is \"\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:123
msgid "yields a quite long error message:"
msgstr ""

#: src/getting-to-know/evaluating.md:124
msgid ""
"```output error\n"
"expression\n"
"  String.append \"it is \"\n"
"has type\n"
"  String → String\n"
"but instance\n"
"  Lean.MetaEval (String → String)\n"
"failed to be synthesized, this instance instructs Lean on how to display the "
"resulting value, recall that any type implementing the `Repr` class also "
"implements the `Lean.MetaEval` class\n"
"```"
msgstr ""

#: src/getting-to-know/evaluating.md:134
msgid ""
"This message occurs because Lean functions that are applied to only some of "
"their arguments return new functions that are waiting for the rest of the "
"arguments. Lean cannot display functions to users, and thus returns an error "
"when asked to do so."
msgstr ""

#: src/getting-to-know/evaluating.md:138
#: src/getting-to-know/functions-and-definitions.md:87
#: src/getting-to-know/structures.md:318
#: src/getting-to-know/polymorphism.md:522 src/props-proofs-indexing.md:287
#: src/type-classes/pos.md:303 src/type-classes/polymorphism.md:127
#: src/type-classes/out-params.md:180 src/type-classes/standard-classes.md:365
#: src/monads/class.md:222 src/monads/arithmetic.md:646 src/monads/do.md:157
#: src/functor-applicative-monad/alternative.md:241
#: src/functor-applicative-monad/complete.md:152
#: src/monad-transformers/reader-io.md:381
#: src/monad-transformers/transformers.md:496
#: src/monad-transformers/order.md:135 src/monad-transformers/do.md:649
#: src/dependent-types/indexed-families.md:262
#: src/dependent-types/universe-pattern.md:325
#: src/dependent-types/typed-queries.md:738 src/dependent-types/pitfalls.md:470
#: src/tactics-induction-proofs.md:418
#: src/programs-proofs/tail-recursion.md:202
#: src/programs-proofs/arrays-termination.md:330
#: src/programs-proofs/inequalities.md:784
#: src/programs-proofs/insertion-sort.md:916
msgid "Exercises"
msgstr ""

#: src/getting-to-know/evaluating.md:140
msgid ""
"What are the values of the following expressions? Work them out by hand, "
"then enter them into Lean to check your work."
msgstr ""

#: src/getting-to-know/evaluating.md:143
msgid "`42 + 19`"
msgstr ""

#: src/getting-to-know/evaluating.md:144
msgid "`String.append \"A\" (String.append \"B\" \"C\")`"
msgstr ""

#: src/getting-to-know/evaluating.md:145
msgid "`String.append (String.append \"A\" \"B\") \"C\"`"
msgstr ""

#: src/getting-to-know/evaluating.md:146
msgid "`if 3 == 3 then 5 else 7`"
msgstr ""

#: src/getting-to-know/evaluating.md:147
msgid "`if 3 == 4 then \"equal\" else \"not equal\"`"
msgstr ""

#: src/getting-to-know/types.md:3
msgid ""
"Types classify programs based on the values that they can compute. Types "
"serve a number of roles in a program:"
msgstr ""

#: src/getting-to-know/types.md:6
msgid ""
"They allow the compiler to make decisions about the in-memory representation "
"of a value."
msgstr ""

#: src/getting-to-know/types.md:9
msgid ""
"They help programmers to communicate their intent to others, serving as a "
"lightweight specification for the inputs and outputs of a function that the "
"compiler can ensure the program adheres to."
msgstr ""

#: src/getting-to-know/types.md:13
msgid ""
"They prevent various potential mistakes, such as adding a number to a "
"string, and thus reduce the number of tests that are necessary for a program."
msgstr ""

#: src/getting-to-know/types.md:17
msgid ""
"They help the Lean compiler automate the production of auxiliary code that "
"can save boilerplate."
msgstr ""

#: src/getting-to-know/types.md:19
msgid ""
"Lean's type system is unusually expressive. Types can encode strong "
"specifications like \"this sorting function returns a permutation of its "
"input\" and flexible specifications like \"this function has different "
"return types, depending on the value of its argument\". The type system can "
"even be used as a full-blown logic for proving mathematical theorems. This "
"cutting-edge expressive power doesn't obviate the need for simpler types, "
"however, and understanding these simpler types is a prerequisite for using "
"the more advanced features."
msgstr ""

#: src/getting-to-know/types.md:24
msgid ""
"Every program in Lean must have a type. In particular, every expression must "
"have a type before it can be evaluated. In the examples so far, Lean has "
"been able to discover a type on its own, but it is sometimes necessary to "
"provide one. This is done using the colon operator:"
msgstr ""

#: src/getting-to-know/types.md:34
msgid ""
"Here, `Nat` is the type of _natural numbers_, which are arbitrary-precision "
"unsigned integers. In Lean, `Nat` is the default type for non-negative "
"integer literals. This default type is not always the best choice. In C, "
"unsigned integers underflow to the largest representable numbers when "
"subtraction would otherwise yield a result less than zero. `Nat`, however, "
"can represent arbitrarily-large unsigned numbers, so there is no largest "
"number to underflow to. Thus, subtraction on `Nat` returns `0` when the "
"answer would have otherwise been negative. For instance,"
msgstr ""

#: src/getting-to-know/types.md:46
msgid ""
"evaluates to `0` rather than `-1`. To use a type that can represent the "
"negative integers, provide it directly:"
msgstr ""

#: src/getting-to-know/types.md:54
msgid "With this type, the result is `-1`, as expected."
msgstr ""

#: src/getting-to-know/types.md:56
msgid ""
"To check the type of an expression without evaluating it, use `#check` "
"instead of `#eval`. For instance:"
msgstr ""

#: src/getting-to-know/types.md:63
msgid "reports `1 - 2 : Int` without actually performing the subtraction."
msgstr ""

#: src/getting-to-know/types.md:65
msgid ""
"When a program can't be given a type, an error is returned from both "
"`#check` and `#eval`. For instance:"
msgstr ""

#: src/getting-to-know/types.md:68
msgid ""
"```lean\n"
"#check String.append \"hello\" [\" \", \"world\"]\n"
"```"
msgstr ""

#: src/getting-to-know/types.md:72
#: src/getting-to-know/functions-and-definitions.md:26
#: src/programs-proofs/fin.md:48 src/programs-proofs/fin.md:56
msgid "outputs"
msgstr ""

#: src/getting-to-know/types.md:74
msgid ""
"```output error\n"
"application type mismatch\n"
"  String.append \"hello\" [\" \", \"world\"]\n"
"argument\n"
"  [\" \", \"world\"]\n"
"has type\n"
"  List String : Type\n"
"but is expected to have type\n"
"  String : Type\n"
"```"
msgstr ""

#: src/getting-to-know/types.md:85
msgid ""
"because the second argument to `String.append` is expected to be a string, "
"but a list of strings was provided instead."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:3
msgid ""
"In Lean, definitions are introduced using the `def` keyword. For instance, "
"to define the name `hello` to refer to the string `\"Hello\"`, write:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:5
msgid ""
"```lean\n"
"def hello := \"Hello\"\n"
"```"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:9
msgid ""
"In Lean, new names are defined using the colon-equal operator`:=` rather "
"than `=`. This is because `=` is used to describe equalities between "
"existing expressions, and using two different operators helps prevent "
"confusion."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:14
msgid ""
"In the definition of `hello`, the expression `\"Hello\"` is simple enough "
"that Lean is able to determine the definition's type automatically. However, "
"most definitions are not so simple, so it will usually be necessary to add a "
"type. This is done using a colon after the name being defined."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:18
msgid ""
"```lean\n"
"def lean : String := \"Lean\"\n"
"```"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:22
msgid "Now that the names have been defined, they can be used, so"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:23
msgid ""
"```Lean\n"
"#eval String.append hello (String.append \" \" lean)\n"
"```"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:27
msgid ""
"```Lean info\n"
"\"Hello Lean\"\n"
"```"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:30
msgid "In Lean, defined names may only be used after their definitions."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:32
msgid ""
"In many languages, definitions of functions use a different syntax than "
"definitions of other values. For instance, Python function definitions begin "
"with the `def` keyword, while other definitions are defined with an equals "
"sign. In Lean, functions are defined using the same `def` keyword as other "
"values. Nonetheless, definitions such as `hello` introduce names that refer "
"_directly_ to their values, rather than to zero-argument functions that "
"return equivalent results each time they are called."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:37
msgid "Defining Functions"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:39
msgid ""
"There are a variety of ways to define functions in Lean. The simplest is to "
"place the function's arguments before the definition's type, separated by "
"spaces. For instance, a function that adds one to its argument can be "
"written:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:45
msgid "Testing this function with `#eval` gives `8`, as expected:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:51
msgid ""
"Just as functions are applied to multiple arguments by writing spaces "
"between each argument, functions that accept multiple arguments are defined "
"with spaces between the arguments' names and types. The function `maximum`, "
"whose result is equal to the greatest of its two arguments, takes two `Nat` "
"arguments `n` and `k` and returns a `Nat`."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:60
msgid ""
"When a defined function like `maximum` has been provided with its arguments, "
"the result is determined by first replacing the argument names with the "
"provided values in the body, and then evaluating the resulting body. For "
"example:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:71
msgid ""
"Expressions that evaluate to natural numbers, integers, and strings have "
"types that say this (`Nat`, `Int`, and `String`, respectively). This is also "
"true of functions. A function that accepts a `Nat` and returns a `Bool` has "
"type `Nat → Bool`, and a function that accepts two `Nat`s and returns a "
"`Nat` has type `Nat → Nat → Nat`."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:75
msgid ""
"As a special case, Lean returns a function's signature when its name is used "
"directly with `#check`. Entering `#check add1` yields `add1 (n : Nat) : "
"Nat`. However, Lean can be \"tricked\" into showing the function's type by "
"writing the function's name in parentheses, which causes the function to be "
"treated as an ordinary expression, so `#check (add1)` yields `add1 : Nat → "
"Nat` and `#check (maximum)` yields `maximum : Nat → Nat → Nat`. This arrow "
"can also be written with an ASCII alternative arrow `->`, so the preceding "
"function types can be written `Nat -> Nat` and `Nat -> Nat -> Nat`, "
"respectively."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:80
msgid ""
"Behind the scenes, all functions actually expect precisely one argument. "
"Functions like `maximum` that seem to take more than one argument are in "
"fact functions that take one argument and then return a new function. This "
"new function takes the next argument, and the process continues until no "
"more arguments are expected. This can be seen by providing one argument to a "
"multiple-argument function: `#check maximum 3` yields `maximum 3 : Nat → "
"Nat` and `#check String.append \"Hello \"` yields `String.append \"Hello \" "
": String → String`. Using a function that returns a function to implement "
"multiple-argument functions is called _currying_ after the mathematician "
"Haskell Curry. Function arrows associate to the right, which means that `Nat "
"→ Nat → Nat` should be parenthesized `Nat → (Nat → Nat)`."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:89
msgid ""
"Define the function `joinStringsWith` with type `String -> String -> String "
"-> String` that creates a new string by placing its first argument between "
"its second and third arguments. `joinStringsWith \", \" \"one\" \"and "
"another\"` should evaluate to `\"one, and another\"`."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:90
msgid ""
"What is the type of `joinStringsWith \": \"`? Check your answer with Lean."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:91
msgid ""
"Define a function `volume` with type `Nat → Nat → Nat → Nat` that computes "
"the volume of a rectangular prism with the given height, width, and depth."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:93
msgid "Defining Types"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:95
msgid ""
"Most typed programming languages have some means of defining aliases for "
"types, such as C's `typedef`. In Lean, however, types are a first-class part "
"of the language - they are expressions like any other. This means that "
"definitions can refer to types just as well as they can refer to other "
"values."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:99
msgid ""
"For instance, if `String` is too much to type, a shorter abbreviation `Str` "
"can be defined:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:103
msgid ""
"It is then possible to use `Str` as a definition's type instead of `String`:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:104
msgid ""
"```lean\n"
"def aStr : Str := \"This is a string.\"\n"
"```"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:108
msgid ""
"The reason this works is that types follow the same rules as the rest of "
"Lean. Types are expressions, and in an expression, a defined name can be "
"replaced with its definition. Because `Str` has been defined to mean "
"`String`, the definition of `aStr` makes sense."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:114
msgid ""
"Experimenting with using definitions for types is made more complicated by "
"the way that Lean supports overloaded integer literals. If `Nat` is too "
"short, a longer name `NaturalNumber` can be defined:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:119
msgid ""
"However, using `NaturalNumber` as a definition's type instead of `Nat` does "
"not have the expected effect. In particular, the definition:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:124
#: src/type-classes/standard-classes.md:357
msgid "results in the following error:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:130
msgid ""
"This error occurs because Lean allows number literals to be _overloaded_. "
"When it makes sense to do so, natural number literals can be used for new "
"types, just as if those types were built in to the system. This is part of "
"Lean's mission of making it convenient to represent mathematics, and "
"different branches of mathematics use number notation for very different "
"purposes. The specific feature that allows this overloading does not replace "
"all defined names with their definitions before looking for overloading, "
"which is what leads to the error message above."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:135
msgid ""
"One way to work around this limitation is by providing the type `Nat` on the "
"right-hand side of the definition, causing `Nat`'s overloading rules to be "
"used for `38`:"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:139
msgid ""
"The definition is still type-correct because `NaturalNumber` is the same "
"type as `Nat`—by definition!"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:141
msgid ""
"Another solution is to define an overloading for `NaturalNumber` that works "
"equivalently to the one for `Nat`. This requires more advanced features of "
"Lean, however."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:144
msgid ""
"Finally, defining the new name for `Nat` using `abbrev` instead of `def` "
"allows overloading resolution to replace the defined name with its "
"definition. Definitions written using `abbrev` are always unfolded. For "
"instance,"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:150
#: src/hello-world/step-by-step.md:79 src/monads/io.md:30
msgid "and"
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:154
msgid "are accepted without issue."
msgstr ""

#: src/getting-to-know/functions-and-definitions.md:156
msgid ""
"Behind the scenes, some definitions are internally marked as being "
"unfoldable during overload resolution, while others are not. Definitions "
"that are to be unfolded are called _reducible_. Control over reducibility is "
"essential to allow Lean to scale: fully unfolding all definitions can result "
"in very large types that are slow for a machine to process and difficult for "
"users to understand. Definitions produced with `abbrev` are marked as "
"reducible."
msgstr ""

#: src/getting-to-know/structures.md:3
msgid ""
"The first step in writing a program is usually to identify the problem "
"domain's concepts, and then find suitable representations for them in code. "
"Sometimes, a domain concept is a collection of other, simpler, concepts. In "
"that case, it can be convenient to group these simpler components together "
"into a single \"package\", which can then be given a meaningful name. In "
"Lean, this is done using _structures_, which are analogous to `struct`s in C "
"or Rust and `record`s in C#."
msgstr ""

#: src/getting-to-know/structures.md:8
msgid ""
"Defining a structure introduces a completely new type to Lean that can't be "
"reduced to any other type. This is useful because multiple structures might "
"represent different concepts that nonetheless contain the same data. For "
"instance, a point might be represented using either Cartesian or polar "
"coordinates, each being a pair of floating-point numbers. Defining separate "
"structures prevents API clients from confusing one for another."
msgstr ""

#: src/getting-to-know/structures.md:13
msgid ""
"Lean's floating-point number type is called `Float`, and floating-point "
"numbers are written in the usual notation."
msgstr ""

#: src/getting-to-know/structures.md:32
msgid ""
"When floating point numbers are written with the decimal point, Lean will "
"infer the type `Float`. If they are written without it, then a type "
"annotation may be necessary."
msgstr ""

#: src/getting-to-know/structures.md:48
msgid ""
"A Cartesian point is a structure with two `Float` fields, called `x` and "
"`y`. This is declared using the `structure` keyword."
msgstr ""

#: src/getting-to-know/structures.md:58
msgid ""
"After this declaration, `Point` is a new structure type. The final line, "
"which says `deriving Repr`, asks Lean to generate code to display values of "
"type `Point`. This code is used by `#eval` to render the result of "
"evaluation for consumption by programmers, analogous to the `repr` function "
"in Python. It is also possible to override the compiler's generated display "
"code."
msgstr ""

#: src/getting-to-know/structures.md:63
msgid ""
"The typical way to create a value of a structure type is to provide values "
"for all of its fields inside of curly braces. The origin of a Cartesian "
"plane is where `x` and `y` are both zero:"
msgstr ""

#: src/getting-to-know/structures.md:70
msgid ""
"If the `deriving Repr` line in `Point`'s definition were omitted, then "
"attempting `#eval origin` would yield an error similar to that which occurs "
"when omitting a function's argument:"
msgstr ""

#: src/getting-to-know/structures.md:80
msgid ""
"That message is saying that the evaluation machinery doesn't know how to "
"communicate the result of evaluation back to the user."
msgstr ""

#: src/getting-to-know/structures.md:82
msgid ""
"Happily, with `deriving Repr`, the result of `#eval origin` looks very much "
"like the definition of `origin`."
msgstr ""

#: src/getting-to-know/structures.md:87
msgid ""
"Because structures exist to \"bundle up\" a collection of data, naming it "
"and treating it as a single unit, it is also important to be able to extract "
"the individual fields of a structure. This is done using dot notation, as in "
"C, Python, or Rust."
msgstr ""

#: src/getting-to-know/structures.md:104
msgid ""
"This can be used to define functions that take structures as arguments. For "
"instance, addition of points is performed by adding the underlying "
"coordinate values. It should be the case that `#eval addPoints { x := 1.5, y "
":= 32 } { x := -8, y := 0.2 }` yields"
msgstr ""

#: src/getting-to-know/structures.md:110
msgid ""
"The function itself takes two `Points` as arguments, called `p1` and `p2`. "
"The resulting point is based on the `x` and `y` fields of both `p1` and `p2`:"
msgstr ""

#: src/getting-to-know/structures.md:117
msgid ""
"Similarly, the distance between two points, which is the square root of the "
"sum of the squares of the differences in their `x` and `y` components, can "
"be written:"
msgstr ""

#: src/getting-to-know/structures.md:122
msgid "For example, the distance between (1, 2) and (5, -1) is 5:"
msgstr ""

#: src/getting-to-know/structures.md:131
msgid ""
"Multiple structures may have fields with the same names. For instance, a "
"three-dimensional point datatype may share the fields `x` and `y`, and be "
"instantiated with the same field names:"
msgstr ""

#: src/getting-to-know/structures.md:142
msgid ""
"This means that the structure's expected type must be known in order to use "
"the curly-brace syntax. If the type is not known, Lean will not be able to "
"instantiate the structure. For instance,"
msgstr ""

#: src/getting-to-know/structures.md:148
msgid "leads to the error"
msgstr ""

#: src/getting-to-know/structures.md:153
msgid "As usual, the situation can be remedied by providing a type annotation."
msgstr ""

#: src/getting-to-know/structures.md:161
msgid ""
"To make programs more concise, Lean also allows the structure type "
"annotation inside the curly braces."
msgstr ""

#: src/getting-to-know/structures.md:169
msgid "Updating Structures"
msgstr ""

#: src/getting-to-know/structures.md:171
msgid ""
"Imagine a function `zeroX` that replaces the `x` field of a `Point` with "
"`0.0`. In most programming language communities, this sentence would mean "
"that the memory location pointed to by `x` was to be overwritten with a new "
"value. However, Lean does not have mutable state. In functional programming "
"communities, what is almost always meant by this kind of statement is that a "
"fresh `Point` is allocated with the `x` field pointing to the new value, and "
"all other fields pointing to the original values from the input. One way to "
"write `zeroX` is to follow this description literally, filling out the new "
"value for `x` and manually transferring `y`:"
msgstr ""

#: src/getting-to-know/structures.md:180
msgid ""
"This style of programming has drawbacks, however. First off, if a new field "
"is added to a structure, then every site that updates any field at all must "
"be updated, causing maintenance difficulties. Secondly, if the structure "
"contains multiple fields with the same type, then there is a real risk of "
"copy-paste coding leading to field contents being duplicated or switched. "
"Finally, the program becomes long and bureaucratic."
msgstr ""

#: src/getting-to-know/structures.md:185
msgid ""
"Lean provides a convenient syntax for replacing some fields in a structure "
"while leaving the others alone. This is done by using the `with` keyword in "
"a structure initialization. The source of unchanged fields occurs before the "
"`with`, and the new fields occur after. For instance, `zeroX` can be written "
"with only the new `x` value:"
msgstr ""

#: src/getting-to-know/structures.md:195
msgid ""
"Remember that this structure update syntax does not modify existing "
"values—it creates new values that share some fields with old values. For "
"instance, given the point `fourAndThree`:"
msgstr ""

#: src/getting-to-know/structures.md:201
msgid ""
"evaluating it, then evaluating an update of it using `zeroX`, then "
"evaluating it again yields the original value:"
msgstr ""

#: src/getting-to-know/structures.md:221
msgid ""
"One consequence of the fact that structure updates do not modify the "
"original structure is that it becomes easier to reason about cases where the "
"new value is computed from the old one. All references to the old structure "
"continue to refer to the same field values in all of the new values provided."
msgstr ""

#: src/getting-to-know/structures.md:227
msgid "Behind the Scenes"
msgstr ""

#: src/getting-to-know/structures.md:229
msgid ""
"Every structure has a _constructor_. Here, the term \"constructor\" may be a "
"source of confusion. Unlike constructors in languages such as Java or "
"Python, constructors in Lean are not arbitrary code to be run when a "
"datatype is initialized. Instead, constructors simply gather the data to be "
"stored in the newly-allocated data structure. It is not possible to provide "
"a custom constructor that pre-processes data or rejects invalid arguments. "
"This is really a case of the word \"constructor\" having different, but "
"related, meanings in the two contexts."
msgstr ""

#: src/getting-to-know/structures.md:237
msgid ""
"By default, the constructor for a structure named `S` is named `S.mk`. Here, "
"`S` is a namespace qualifier, and `mk` is the name of the constructor "
"itself. Instead of using curly-brace initialization syntax, the constructor "
"can also be applied directly."
msgstr ""

#: src/getting-to-know/structures.md:243
msgid ""
"However, this is not generally considered to be good Lean style, and Lean "
"even returns its feedback using the standard structure initializer syntax."
msgstr ""

#: src/getting-to-know/structures.md:248
msgid ""
"Constructors have function types, which means they can be used anywhere that "
"a function is expected. For instance, `Point.mk` is a function that accepts "
"two `Float`s (respectively `x` and `y`) and returns a new `Point`."
msgstr ""

#: src/getting-to-know/structures.md:256
msgid ""
"To override a structure's constructor name, write it with two colons at the "
"beginning. For instance, to use `Point.point` instead of `Point.mk`, write:"
msgstr ""

#: src/getting-to-know/structures.md:266
msgid ""
"In addition to the constructor, an accessor function is defined for each "
"field of a structure. These have the same name as the field, in the "
"structure's namespace. For `Point`, accessor functions `Point.x` and "
"`Point.y` are generated."
msgstr ""

#: src/getting-to-know/structures.md:283
msgid ""
"In fact, just as the curly-braced structure construction syntax is converted "
"to a call to the structure's constructor behind the scenes, the syntax "
"`p1.x` in the prior definition of `addPoints` is converted into a call to "
"the `Point.x` accessor. That is, `#eval origin.x` and `#eval Point.x origin` "
"both yield"
msgstr ""

#: src/getting-to-know/structures.md:289
msgid ""
"Accessor dot notation is usable with more than just structure fields. It can "
"also be used for functions that take any number of arguments. More "
"generally, accessor notation has the form `TARGET.f ARG1 ARG2 ...`. If "
"`TARGET` has type `T`, the function named `T.f` is called. `TARGET` becomes "
"its leftmost argument of type `T`, which is often but not always the first "
"one, and `ARG1 ARG2 ...` are provided in order as the remaining arguments. "
"For instance, `String.append` can be invoked from a string with accessor "
"notation, even though `String` is not a structure with an `append` field."
msgstr ""

#: src/getting-to-know/structures.md:295
msgid ""
"```lean\n"
"#eval \"one string\".append \" and another\"\n"
"```"
msgstr ""

#: src/getting-to-know/structures.md:298
msgid ""
"```output info\n"
"\"one string and another\"\n"
"```"
msgstr ""

#: src/getting-to-know/structures.md:301
msgid ""
"In that example, `TARGET` represents `\"one string\"` and `ARG1` represents "
"`\" and another\"`."
msgstr ""

#: src/getting-to-know/structures.md:303
msgid ""
"The function `Point.modifyBoth` (that is, `modifyBoth` defined in the "
"`Point` namespace) applies a function to both fields in a `Point`:"
msgstr ""

#: src/getting-to-know/structures.md:308
msgid ""
"Even though the `Point` argument comes after the function argument, it can "
"be used with dot notation as well:"
msgstr ""

#: src/getting-to-know/structures.md:315
msgid ""
"In this case, `TARGET` represents `fourAndThree`, while `ARG1` is "
"`Float.floor`. This is because the target of the accessor notation is used "
"as the first argument in which the type matches, not necessarily the first "
"argument."
msgstr ""

#: src/getting-to-know/structures.md:320
msgid ""
"Define a structure named `RectangularPrism` that contains the height, width, "
"and depth of a rectangular prism, each as a `Float`."
msgstr ""

#: src/getting-to-know/structures.md:321
msgid ""
"Define a function named `volume : RectangularPrism → Float` that computes "
"the volume of a rectangular prism."
msgstr ""

#: src/getting-to-know/structures.md:322
msgid ""
"Define a structure named `Segment` that represents a line segment by its "
"endpoints, and define a function `length : Segment → Float` that computes "
"the length of a line segment. `Segment` should have at most two fields."
msgstr ""

#: src/getting-to-know/structures.md:323
msgid "Which names are introduced by the declaration of `RectangularPrism`?"
msgstr ""

#: src/getting-to-know/structures.md:324
msgid ""
"Which names are introduced by the following declarations of `Hamster` and "
"`Book`? What are their types?"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:1
msgid "Datatypes and Patterns"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:3
msgid ""
"Structures enable multiple independent pieces of data to be combined into a "
"coherent whole that is represented by a brand new type. Types such as "
"structures that group together a collection of values are called _product "
"types_. Many domain concepts, however, can't be naturally represented as "
"structures. For instance, an application might need to track user "
"permissions, where some users are document owners, some may edit documents, "
"and others may only read them. A calculator has a number of binary "
"operators, such as addition, subtraction, and multiplication. Structures do "
"not provide an easy way to encode multiple choices."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:10
msgid ""
"Similarly, while a structure is an excellent way to keep track of a fixed "
"set of fields, many applications require data that may contain an arbitrary "
"number of elements. Most classic data structures, such as trees and lists, "
"have a recursive structure, where the tail of a list is itself a list, or "
"where the left and right branches of a binary tree are themselves binary "
"trees. In the aforementioned calculator, the structure of expressions "
"themselves is recursive. The summands in an addition expression may "
"themselves be multiplication expressions, for instance."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:15
msgid ""
"Datatypes that allow choices are called _sum types_ and datatypes that can "
"include instances of themselves are called _recursive datatypes_. Recursive "
"sum types are called _inductive datatypes_, because mathematical induction "
"may be used to prove statements about them. When programming, inductive "
"datatypes are consumed through pattern matching and recursive functions."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:19
msgid ""
"Many of the built-in types are actually inductive datatypes in the standard "
"library. For instance, `Bool` is an inductive datatype:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:26
msgid ""
"This definition has two main parts. The first line provides the name of the "
"new type (`Bool`), while the remaining lines each describe a constructor. As "
"with constructors of structures, constructors of inductive datatypes are "
"mere inert receivers of and containers for other data, rather than places to "
"insert arbitrary initialization and validation code. Unlike structures, "
"inductive datatypes may have multiple constructors. Here, there are two "
"constructors, `true` and `false`, and neither takes any arguments. Just as a "
"structure declaration places its names in a namespace named after the "
"declared type, an inductive datatype places the names of its constructors in "
"a namespace. In the Lean standard library, `true` and `false` are "
"re-exported from this namespace so that they can be written alone, rather "
"than as `Bool.true` and `Bool.false`, respectively."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:34
msgid ""
"From a data modeling perspective, inductive datatypes are used in many of "
"the same contexts where a sealed abstract class might be used in other "
"languages. In languages like C# or Java, one might write a similar "
"definition of `Bool`:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:41
msgid ""
"However, the specifics of these representations are fairly different. In "
"particular, each non-abstract class creates both a new type and new ways of "
"allocating data. In the object-oriented example, `True` and `False` are both "
"types that are more specific than `Bool`, while the Lean definition "
"introduces only the new type `Bool`."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:43
msgid "The type `Nat` of non-negative integers is an inductive datatype:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:49
msgid ""
"Here, `zero` represents 0, while `succ` represents the successor of some "
"other number. The `Nat` mentioned in `succ`'s declaration is the very type "
"`Nat` that is in the process of being defined. _Successor_ means \"one "
"greater than\", so the successor of five is six and the successor of 32,185 "
"is 32,186. Using this definition, `4` is represented as `Nat.succ (Nat.succ "
"(Nat.succ (Nat.succ Nat.zero)))`. This definition is almost like the "
"definition of `Bool` with slightly different names. The only real difference "
"is that `succ` is followed by `(n : Nat)`, which specifies that the "
"constructor `succ` takes an argument of type `Nat` which happens to be named "
"`n`. The names `zero` and `succ` are in a namespace named after their type, "
"so they must be referred to as `Nat.zero` and `Nat.succ`, respectively."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:57
msgid ""
"Argument names, such as `n`, may occur in Lean's error messages and in "
"feedback provided when writing mathematical proofs. Lean also has an "
"optional syntax for providing arguments by name. Generally, however, the "
"choice of argument name is less important than the choice of a structure "
"field name, as it does not form as large a part of the API."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:61
msgid "In C# or Java, `Nat` could be defined as follows:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:72
msgid ""
"Just as in the `Bool` example above, this defines more types than the Lean "
"equivalent. Additionally, this example highlights how Lean datatype "
"constructors are much more like subclasses of an abstract class than they "
"are like constructors in C# or Java, as the constructor shown here contains "
"initialization code to be executed."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:75
msgid ""
"Sum types are also similar to using a string tag to encode discriminated "
"unions in TypeScript. In TypeScript, `Nat` could be defined as follows:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:77
msgid ""
"```typescript\n"
"interface Zero {\n"
"    tag: \"zero\";\n"
"}\n"
"\n"
"interface Succ {\n"
"    tag: \"succ\";\n"
"    predecessor: Nat;\n"
"}\n"
"\n"
"type Nat = Zero | Succ;\n"
"```"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:89
msgid ""
"Just like C# and Java, this encoding ends up with more types than in Lean, "
"because `Zero` and `Succ` are each a type on their own. It also illustrates "
"that Lean constructors correspond to objects in JavaScript or TypeScript "
"that include a tag that identifies the contents."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:92
msgid "Pattern Matching"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:94
msgid ""
"In many languages, these kinds of data are consumed by first using an "
"instance-of operator to check which subclass has been received and then "
"reading the values of the fields that are available in the given subclass. "
"The instance-of check determines which code to run, ensuring that the data "
"needed by this code is available, while the fields themselves provide the "
"data. In Lean, both of these purposes are simultaneously served by _pattern "
"matching_."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:98
msgid ""
"An example of a function that uses pattern matching is `isZero`, which is a "
"function that returns `true` when its argument is `Nat.zero`, or false "
"otherwise."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:105
msgid ""
"The `match` expression is provided the function's argument `n` for "
"destructuring. If `n` was constructed by `Nat.zero`, then the first branch "
"of the pattern match is taken, and the result is `true`. If `n` was "
"constructed by `Nat.succ`, then the second branch is taken, and the result "
"is `false`."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:109
msgid "Step-by-step, evaluation of `isZero Nat.zero` proceeds as follows:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:120
msgid "Evaluation of `isZero 5` proceeds similarly:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:133
msgid ""
"The `k` in the second branch of the pattern in `isZero` is not decorative. "
"It makes the `Nat` that is the argument to `succ` visible, with the provided "
"name. That smaller number can then be used to compute the final result of "
"the expression."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:137
msgid ""
"Just as the successor of some number \\\\( n \\\\) is one greater than \\\\( "
"n \\\\) (that is, \\\\( n + 1\\\\)), the predecessor of a number is one less "
"than it. If `pred` is a function that finds the predecessor of a `Nat`, then "
"it should be the case that the following examples find the expected result:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:151
msgid ""
"Because `Nat` cannot represent negative numbers, `0` is a bit of a "
"conundrum. Usually, when working with `Nat`, operators that would ordinarily "
"produce a negative number are redefined to produce `0` itself:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:160
msgid ""
"To find the predecessor of a `Nat`, the first step is to check which "
"constructor was used to create it. If it was `Nat.zero`, then the result is "
"`Nat.zero`. If it was `Nat.succ`, then the name `k` is used to refer to the "
"`Nat` underneath it. And this `Nat` is the desired predecessor, so the "
"result of the `Nat.succ` branch is `k`."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:170
msgid "Applying this function to `5` yields the following steps:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:183
msgid ""
"Pattern matching can be used with structures as well as with sum types. For "
"instance, a function that extracts the third dimension from a `Point3D` can "
"be written as follows:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:190
msgid ""
"In this case, it would have been much simpler to just use the `z` accessor, "
"but structure patterns are occasionally the simplest way to write a function."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:192
msgid "Recursive Functions"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:194
msgid ""
"Definitions that refer to the name being defined are called _recursive "
"definitions_. Inductive datatypes are allowed to be recursive; indeed, `Nat` "
"is an example of such a datatype because `succ` demands another `Nat`. "
"Recursive datatypes can represent arbitrarily large data, limited only by "
"technical factors like available memory. Just as it would be impossible to "
"write down one constructor for each natural number in the datatype "
"definition, it is also impossible to write down a pattern match case for "
"each possibility."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:199
msgid ""
"Recursive datatypes are nicely complemented by recursive functions. A simple "
"recursive function over `Nat` checks whether its argument is even. In this "
"case, `zero` is even. Non-recursive branches of the code like this one are "
"called _base cases_. The successor of an odd number is even, and the "
"successor of an even number is odd. This means that a number built with "
"`succ` is even if and only if its argument is not even."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:212
msgid ""
"This pattern of thought is typical for writing recursive functions on `Nat`. "
"First, identify what to do for `zero`. Then, determine how to transform a "
"result for an arbitrary `Nat` into a result for its successor, and apply "
"this transformation to the result of the recursive call. This pattern is "
"called _structural recursion_."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:217
msgid ""
"Unlike many languages, Lean ensures by default that every recursive function "
"will eventually reach a base case. From a programming perspective, this "
"rules out accidental infinite loops. But this feature is especially "
"important when proving theorems, where infinite loops cause major "
"difficulties. A consequence of this is that Lean will not accept a version "
"of `even` that attempts to invoke itself recursively on the original number:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:228
msgid ""
"The important part of the error message is that Lean could not determine "
"that the recursive function always reaches a base case (because it doesn't)."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:238
msgid ""
"Even though addition takes two arguments, only one of them needs to be "
"inspected. To add zero to a number \\\\( n \\\\), just return \\\\( n \\\\). "
"To add the successor of \\\\( k \\\\) to \\\\( n \\\\), take the successor "
"of the result of adding \\\\( k \\\\) to \\\\( n \\\\)."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:247
msgid ""
"In the definition of `plus`, the name `k'` is chosen to indicate that it is "
"connected to, but not identical with, the argument `k`. For instance, "
"walking through the evaluation of `plus 3 2` yields the following steps:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:275
msgid ""
"One way to think about addition is that \\\\( n + k \\\\) applies `Nat.succ` "
"\\\\( k \\\\) times to \\\\( n \\\\). Similarly, multiplication \\\\( n × k "
"\\\\) adds \\\\( n \\\\) to itself \\\\( k \\\\) times and subtraction \\\\( "
"n - k \\\\) takes \\\\( n \\\\)'s predecessor \\\\( k \\\\) times."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:289
msgid ""
"Not every function can be easily written using structural recursion. The "
"understanding of addition as iterated `Nat.succ`, multiplication as iterated "
"addition, and subtraction as iterated predecessor suggests an implementation "
"of division as iterated subtraction. In this case, if the numerator is less "
"than the divisor, the result is zero. Otherwise, the result is the successor "
"of dividing the numerator minus the divisor by the divisor."
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:299
msgid ""
"As long as the second argument is not `0`, this program terminates, as it "
"always makes progress towards the base case. However, it is not structurally "
"recursive, because it doesn't follow the pattern of finding a result for "
"zero and transforming a result for a smaller `Nat` into a result for its "
"successor. In particular, the recursive invocation of the function is "
"applied to the result of another function call, rather than to an input "
"constructor's argument. Thus, Lean rejects it with the following message:"
msgstr ""

#: src/getting-to-know/datatypes-and-patterns.md:319
msgid ""
"This message means that `div` requires a manual proof of termination. This "
"topic is explored in [the final "
"chapter](../programs-proofs/inequalities.md#division-as-iterated-subtraction)."
msgstr ""

#: src/getting-to-know/polymorphism.md:3
msgid ""
"Just as in most languages, types in Lean can take arguments. For instance, "
"the type `List Nat` describes lists of natural numbers, `List String` "
"describes lists of strings, and `List (List Point)` describes lists of lists "
"of points. This is very similar to `List<Nat>`, `List<String>`, or "
"`List<List<Point>>` in a language like C# or Java. Just as Lean uses a space "
"to pass an argument to a function, it uses a space to pass an argument to a "
"type."
msgstr ""

#: src/getting-to-know/polymorphism.md:8
msgid ""
"In functional programming, the term _polymorphism_ typically refers to "
"datatypes and definitions that take types as arguments. This is different "
"from the object-oriented programming community, where the term typically "
"refers to subclasses that may override some behavior of their superclass. In "
"this book, \"polymorphism\" always refers to the first sense of the word. "
"These type arguments can be used in the datatype or definition, which allows "
"the same datatype or definition to be used with any type that results from "
"replacing the arguments' names with some other types."
msgstr ""

#: src/getting-to-know/polymorphism.md:13
msgid ""
"The `Point` structure requires that both the `x` and `y` fields are "
"`Float`s. There is, however, nothing about points that require a specific "
"representation for each coordinate. A polymorphic version of `Point`, called "
"`PPoint`, can take a type as an argument, and then use that type for both "
"fields:"
msgstr ""

#: src/getting-to-know/polymorphism.md:22
msgid ""
"Just as a function definition's arguments are written immediately after the "
"name being defined, a structure's arguments are written immediately after "
"the structure's name. It is customary to use Greek letters to name type "
"arguments in Lean when no more specific name suggests itself. `Type` is a "
"type that describes other types, so `Nat`, `List String`, and `PPoint Int` "
"all have type `Type`."
msgstr ""

#: src/getting-to-know/polymorphism.md:26
msgid ""
"Just like `List`, `PPoint` can be used by providing a specific type as its "
"argument:"
msgstr ""

#: src/getting-to-know/polymorphism.md:31
msgid ""
"In this example, both fields are expected to be `Nat`s. Just as a function "
"is called by replacing its argument variables with its argument values, "
"providing `PPoint` with the type `Nat` as an argument yields a structure in "
"which the fields `x` and `y` have the type `Nat`, because the argument name "
"`α` has been replaced by the argument type `Nat`. Types are ordinary "
"expressions in Lean, so passing arguments to polymorphic types (like "
"`PPoint`) doesn't require any special syntax."
msgstr ""

#: src/getting-to-know/polymorphism.md:35
msgid ""
"Definitions may also take types as arguments, which makes them polymorphic. "
"The function `replaceX` replaces the `x` field of a `PPoint` with a new "
"value. In order to allow `replaceX` to work with _any_ polymorphic point, it "
"must be polymorphic itself. This is achieved by having its first argument be "
"the type of the point's fields, with later arguments referring back to the "
"first argument's name."
msgstr ""

#: src/getting-to-know/polymorphism.md:43
msgid ""
"In other words, when the types of the arguments `point` and `newX` mention "
"`α`, they are referring to _whichever type was provided as the first "
"argument_. This is similar to the way that function argument names refer to "
"the values that were provided when they occur in the function's body."
msgstr ""

#: src/getting-to-know/polymorphism.md:46
msgid ""
"This can be seen by asking Lean to check the type of `replaceX`, and then "
"asking it to check the type of `replaceX Nat`."
msgstr ""

#: src/getting-to-know/polymorphism.md:53
msgid ""
"This function type includes the _name_ of the first argument, and later "
"arguments in the type refer back to this name. Just as the value of a "
"function application is found by replacing the argument name with the "
"provided argument value in the function's body, the type of a function "
"application is found by replacing the argument's name with the provided "
"value in the function's return type. Providing the first argument, `Nat`, "
"causes all occurrences of `α` in the remainder of the type to be replaced "
"with `Nat`:"
msgstr ""

#: src/getting-to-know/polymorphism.md:62
msgid ""
"Because the remaining arguments are not explicitly named, no further "
"substitution occurs as more arguments are provided:"
msgstr ""

#: src/getting-to-know/polymorphism.md:75
msgid ""
"The fact that the type of the whole function application expression was "
"determined by passing a type as an argument has no bearing on the ability to "
"evaluate it."
msgstr ""

#: src/getting-to-know/polymorphism.md:83
msgid ""
"Polymorphic functions work by taking a named type argument and having later "
"types refer to the argument's name. However, there's nothing special about "
"type arguments that allows them to be named. Given a datatype that "
"represents positive or negative signs:"
msgstr ""

#: src/getting-to-know/polymorphism.md:91
msgid ""
"it is possible to write a function whose argument is a sign. If the argument "
"is positive, the function returns a `Nat`, while if it's negative, it "
"returns an `Int`:"
msgstr ""

#: src/getting-to-know/polymorphism.md:99
msgid ""
"Because types are first class and can be computed using the ordinary rules "
"of the Lean language, they can be computed by pattern-matching against a "
"datatype. When Lean is checking this function, it uses the fact that the "
"`match`\\-expression in the function's body corresponds to the "
"`match`\\-expression in the type to make `Nat` be the expected type for the "
"`pos` case and to make `Int` be the expected type for the `neg` case."
msgstr ""

#: src/getting-to-know/polymorphism.md:102
msgid ""
"Applying `posOrNegThree` to `Sign.pos` results in the argument name `s` in "
"both the body of the function and its return type being replaced by "
"`Sign.pos`. Evaluation can occur both in the expression and its type:"
msgstr ""

#: src/getting-to-know/polymorphism.md:117
msgid "Linked Lists"
msgstr ""

#: src/getting-to-know/polymorphism.md:119
msgid ""
"Lean's standard library includes a canonical linked list datatype, called "
"`List`, and special syntax that makes it more convenient to use. Lists are "
"written in square brackets. For instance, a list that contains the prime "
"numbers less than 10 can be written:"
msgstr ""

#: src/getting-to-know/polymorphism.md:126
msgid "Behind the scenes, `List` is an inductive datatype, defined like this:"
msgstr ""

#: src/getting-to-know/polymorphism.md:132
msgid ""
"The actual definition in the standard library is slightly different, because "
"it uses features that have not yet been presented, but it is substantially "
"similar. This definition says that `List` takes a single type as its "
"argument, just as `PPoint` did. This type is the type of the entries stored "
"in the list. According to the constructors, a `List α` can be built with "
"either `nil` or `cons`. The constructor `nil` represents empty lists and the "
"constructor `cons` is used for non-empty lists. The first argument to `cons` "
"is the head of the list, and the second argument is its tail. A list that "
"contains \\\\( n \\\\) entries contains \\\\( n \\\\) `cons` constructors, "
"the last of which has `nil` as its tail."
msgstr ""

#: src/getting-to-know/polymorphism.md:140
msgid ""
"The `primesUnder10` example can be written more explicitly by using `List`'s "
"constructors directly:"
msgstr ""

#: src/getting-to-know/polymorphism.md:145
msgid ""
"These two definitions are completely equivalent, but `primesUnder10` is much "
"easier to read than `explicitPrimesUnder10`."
msgstr ""

#: src/getting-to-know/polymorphism.md:147
msgid ""
"Functions that consume `List`s can be defined in much the same way as "
"functions that consume `Nat`s. Indeed, one way to think of a linked list is "
"as a `Nat` that has an extra data field dangling off each `succ` "
"constructor. From this point of view, computing the length of a list is the "
"process of replacing each `cons` with a `succ` and the final `nil` with a "
"`zero`. Just as `replaceX` took the type of the fields of the point as an "
"argument, `length` takes the type of the list's entries. For example, if the "
"list contains strings, then the first argument is `String`: `length String "
"[\"Sourdough\", \"bread\"]`. It should compute like this:"
msgstr ""

#: src/getting-to-know/polymorphism.md:153
msgid ""
"```\n"
"length String [\"Sourdough\", \"bread\"]\n"
"===>\n"
"length String (List.cons \"Sourdough\" (List.cons \"bread\" List.nil))\n"
"===>\n"
"Nat.succ (length String (List.cons \"bread\" List.nil))\n"
"===>\n"
"Nat.succ (Nat.succ (length String List.nil))\n"
"===>\n"
"Nat.succ (Nat.succ Nat.zero)\n"
"===>\n"
"2\n"
"```"
msgstr ""

#: src/getting-to-know/polymorphism.md:167
msgid ""
"The definition of `length` is both polymorphic (because it takes the list "
"entry type as an argument) and recursive (because it refers to itself). "
"Generally, functions follow the shape of the data: recursive datatypes lead "
"to recursive functions, and polymorphic datatypes lead to polymorphic "
"functions."
msgstr ""

#: src/getting-to-know/polymorphism.md:176
msgid ""
"Names such as `xs` and `ys` are conventionally used to stand for lists of "
"unknown values. The `s` in the name indicates that they are plural, so they "
"are pronounced \"exes\" and \"whys\" rather than \"x s\" and \"y s\"."
msgstr ""

#: src/getting-to-know/polymorphism.md:179
msgid ""
"To make it easier to read functions on lists, the bracket notation `[]` can "
"be used to pattern-match against `nil`, and an infix `::` can be used in "
"place of `cons`:"
msgstr ""

#: src/getting-to-know/polymorphism.md:187
msgid "Implicit Arguments"
msgstr ""

#: src/getting-to-know/polymorphism.md:189
msgid ""
"Both `replaceX` and `length` are somewhat bureaucratic to use, because the "
"type argument is typically uniquely determined by the later values. Indeed, "
"in most languages, the compiler is perfectly capable of determining type "
"arguments on its own, and only occasionally needs help from users. This is "
"also the case in Lean. Arguments can be declared _implicit_ by wrapping them "
"in curly braces instead of parentheses when defining a function. For "
"instance, a version of `replaceX` with an implicit type argument looks like "
"this:"
msgstr ""

#: src/getting-to-know/polymorphism.md:198
msgid ""
"It can be used with `natOrigin` without providing `Nat` explicitly, because "
"Lean can _infer_ the value of `α` from the later arguments:"
msgstr ""

#: src/getting-to-know/polymorphism.md:206
msgid "Similarly, `length` can be redefined to take the entry type implicitly:"
msgstr ""

#: src/getting-to-know/polymorphism.md:213
msgid "This `length` function can be applied directly to `primesUnder10`:"
msgstr ""

#: src/getting-to-know/polymorphism.md:221
msgid ""
"In the standard library, Lean calls this function `List.length`, which means "
"that the dot syntax that is used for structure field access can also be used "
"to find the length of a list:"
msgstr ""

#: src/getting-to-know/polymorphism.md:230
msgid ""
"Just as C# and Java require type arguments to be provided explicitly from "
"time to time, Lean is not always capable of finding implicit arguments. In "
"these cases, they can be provided using their names. For instance, a version "
"of `List.length` that only works for lists of integers can be specified by "
"setting `α` to `Int`:"
msgstr ""

#: src/getting-to-know/polymorphism.md:240
msgid "More Built-In Datatypes"
msgstr ""

#: src/getting-to-know/polymorphism.md:242
msgid ""
"In addition to lists, Lean's standard library contains a number of other "
"structures and inductive datatypes that can be used in a variety of contexts."
msgstr ""

#: src/getting-to-know/polymorphism.md:244
msgid "`Option`"
msgstr ""

#: src/getting-to-know/polymorphism.md:245
msgid ""
"Not every list has a first entry—some lists are empty. Many operations on "
"collections may fail to find what they are looking for. For instance, a "
"function that finds the first entry in a list may not find any such entry. "
"It must therefore have a way to signal that there was no first entry."
msgstr ""

#: src/getting-to-know/polymorphism.md:250
msgid ""
"Many languages have a `null` value that represents the absence of a value. "
"Instead of equipping existing types with a special `null` value, Lean "
"provides a datatype called `Option` that equips some other type with an "
"indicator for missing values. For instance, a nullable `Int` is represented "
"by `Option Int`, and a nullable list of strings is represented by the type "
"`Option (List String)`. Introducing a new type to represent nullability "
"means that the type system ensures that checks for `null` cannot be "
"forgotten, because an `Option Int` can't be used in a context where an `Int` "
"is expected."
msgstr ""

#: src/getting-to-know/polymorphism.md:255
msgid ""
"`Option` has two constructors, called `some` and `none`, that respectively "
"represent the non-null and null versions of the underlying type. The "
"non-null constructor, `some`, contains the underlying value, while `none` "
"takes no arguments:"
msgstr ""

#: src/getting-to-know/polymorphism.md:263
msgid ""
"The `Option` type is very similar to nullable types in languages like C# and "
"Kotlin, but it is not identical. In these languages, if a type (say, "
"`Boolean`) always refers to actual values of the type (`true` and `false`), "
"the type `Boolean?` or `Nullable<Boolean>` additionally admits the `null` "
"value. Tracking this in the type system is very useful: the type checker and "
"other tooling can help programmers remember to check for null, and APIs that "
"explicitly describe nullability through type signatures are more informative "
"than ones that don't. However, these nullable types differ from Lean's "
"`Option` in one very important way, which is that they don't allow multiple "
"layers of optionality. `Option (Option Int)` can be constructed with `none`, "
"`some none`, or `some (some 360)`. C#, on the other hand, forbids multiple "
"layers of nullability by only allowing `?` to be added to non-nullable "
"types, while Kotlin treats `T??` as being equivalent to `T?`. This subtle "
"difference is rarely relevant in practice, but it can matter from time to "
"time."
msgstr ""

#: src/getting-to-know/polymorphism.md:271
msgid ""
"To find the first entry in a list, if it exists, use `List.head?`. The "
"question mark is part of the name, and is not related to the use of question "
"marks to indicate nullable types in C# or Kotlin. In the definition of "
"`List.head?`, an underscore is used to represent the tail of the list. In "
"patterns, underscores match anything at all, but do not introduce variables "
"to refer to the matched data. Using underscores instead of names is a way to "
"clearly communicate to readers that part of the input is ignored."
msgstr ""

#: src/getting-to-know/polymorphism.md:282
msgid ""
"A Lean naming convention is to define operations that might fail in groups "
"using the suffixes `?` for a version that returns an `Option`, `!` for a "
"version that crashes when provided with invalid input, and `D` for a version "
"that returns a default value when the operation would otherwise fail. For "
"instance, `head` requires the caller to provide mathematical evidence that "
"the list is not empty, `head?` returns an `Option`, `head!` crashes the "
"program when passed an empty list, and `headD` takes a default value to "
"return in case the list is empty. The question mark and exclamation mark are "
"part of the name, not special syntax, as Lean's naming rules are more "
"liberal than many languages."
msgstr ""

#: src/getting-to-know/polymorphism.md:286
msgid ""
"Because `head?` is defined in the `List` namespace, it can be used with "
"accessor notation:"
msgstr ""

#: src/getting-to-know/polymorphism.md:293
msgid "However, attempting to test it on the empty list leads to two errors:"
msgstr ""

#: src/getting-to-know/polymorphism.md:308
msgid ""
"This is because Lean was unable to fully determine the expression's type. In "
"particular, it could neither find the implicit type argument to "
"`List.head?`, nor could it find the implicit type argument to `List.nil`. In "
"Lean's output, `?m.XYZ` represents a part of a program that could not be "
"inferred. These unknown parts are called _metavariables_, and they occur in "
"some error messages. In order to evaluate an expression, Lean needs to be "
"able to find its type, and the type was unavailable because the empty list "
"does not have any entries from which the type can be found. Explicitly "
"providing a type allows Lean to proceed:"
msgstr ""

#: src/getting-to-know/polymorphism.md:320
msgid "The type can also be provided with a type annotation:"
msgstr ""

#: src/getting-to-know/polymorphism.md:327
msgid ""
"The error messages provide a useful clue. Both messages use the _same_ "
"metavariable to describe the missing implicit argument, which means that "
"Lean has determined that the two missing pieces will share a solution, even "
"though it was unable to determine the actual value of the solution."
msgstr ""

#: src/getting-to-know/polymorphism.md:330
msgid "`Prod`"
msgstr ""

#: src/getting-to-know/polymorphism.md:332
msgid ""
"The `Prod` structure, short for \"Product\", is a generic way of joining two "
"values together. For instance, a `Prod Nat String` contains a `Nat` and a "
"`String`. In other words, `PPoint Nat` could be replaced by `Prod Nat Nat`. "
"`Prod` is very much like C#'s tuples, the `Pair` and `Triple` types in "
"Kotlin, and `tuple` in C++. Many applications are best served by defining "
"their own structures, even for simple cases like `Point`, because using "
"domain terminology can make it easier to read the code. Additionally, "
"defining structure types helps catch more errors by assigning different "
"types to different domain concepts, preventing them from being mixed up."
msgstr ""

#: src/getting-to-know/polymorphism.md:339
msgid ""
"On the other hand, there are some cases where it is not worth the overhead "
"of defining a new type. Additionally, some libraries are sufficiently "
"generic that there is no more specific concept than \"pair\". Finally, the "
"standard library contains a variety of convenience functions that make it "
"easier to work with the built-in pair type."
msgstr ""

#: src/getting-to-know/polymorphism.md:343
msgid "The standard pair structure is called `Prod`."
msgstr ""

#: src/getting-to-know/polymorphism.md:349
msgid ""
"Lists are used so frequently that there is special syntax to make them more "
"readable. For the same reason, both the product type and its constructor "
"have special syntax. The type `Prod α β` is typically written `α × β`, "
"mirroring the usual notation for a Cartesian product of sets. Similarly, the "
"usual mathematical notation for pairs is available for `Prod`. In other "
"words, instead of writing:"
msgstr ""

#: src/getting-to-know/polymorphism.md:354
msgid ""
"```lean\n"
"def fives : String × Int := { fst := \"five\", snd := 5 }\n"
"```"
msgstr ""

#: src/getting-to-know/polymorphism.md:357
msgid "it suffices to write:"
msgstr ""

#: src/getting-to-know/polymorphism.md:358
msgid ""
"```lean\n"
"def fives : String × Int := (\"five\", 5)\n"
"```"
msgstr ""

#: src/getting-to-know/polymorphism.md:362
msgid ""
"Both notations are right-associative. This means that the following "
"definitions are equivalent:"
msgstr ""

#: src/getting-to-know/polymorphism.md:364
msgid ""
"```lean\n"
"def sevens : String × Int × Nat := (\"VII\", 7, 4 + 3)\n"
"\n"
"def sevens : String × (Int × Nat) := (\"VII\", (7, 4 + 3))\n"
"```"
msgstr ""

#: src/getting-to-know/polymorphism.md:369
msgid ""
"In other words, all products of more than two types, and their corresponding "
"constructors, are actually nested products and nested pairs behind the "
"scenes."
msgstr ""

#: src/getting-to-know/polymorphism.md:373
msgid "`Sum`"
msgstr ""

#: src/getting-to-know/polymorphism.md:375
msgid ""
"The `Sum` datatype is a generic way of allowing a choice between values of "
"two different types. For instance, a `Sum String Int` is either a `String` "
"or an `Int`. Like `Prod`, `Sum` should be used either when writing very "
"generic code, for a very small section of code where there is no sensible "
"domain-specific type, or when the standard library contains useful "
"functions. In most situations, it is more readable and maintainable to use a "
"custom inductive type."
msgstr ""

#: src/getting-to-know/polymorphism.md:380
msgid ""
"Values of type `Sum α β` are either the constructor `inl` applied to a value "
"of type `α` or the constructor `inr` applied to a value of type `β`:"
msgstr ""

#: src/getting-to-know/polymorphism.md:386
msgid ""
"These names are abbreviations for \"left injection\" and \"right "
"injection\", respectively. Just as the Cartesian product notation is used "
"for `Prod`, a \"circled plus\" notation is used for `Sum`, so `α ⊕ β` is "
"another way to write `Sum α β`. There is no special syntax for `Sum.inl` and "
"`Sum.inr`."
msgstr ""

#: src/getting-to-know/polymorphism.md:390
msgid ""
"For instance, if pet names can either be dog names or cat names, then a type "
"for them can be introduced as a sum of strings:"
msgstr ""

#: src/getting-to-know/polymorphism.md:394
msgid ""
"In a real program, it would usually be better to define a custom inductive "
"datatype for this purpose with informative constructor names. Here, "
"`Sum.inl` is to be used for dog names, and `Sum.inr` is to be used for cat "
"names. These constructors can be used to write a list of animal names:"
msgstr ""

#: src/getting-to-know/polymorphism.md:397
msgid ""
"```lean\n"
"def animals : List PetName :=\n"
"  [Sum.inl \"Spot\", Sum.inr \"Tiger\", Sum.inl \"Fifi\", Sum.inl \"Rex\", "
"Sum.inr \"Floof\"]\n"
"```"
msgstr ""

#: src/getting-to-know/polymorphism.md:401
msgid ""
"Pattern matching can be used to distinguish between the two constructors. "
"For instance, a function that counts the number of dogs in a list of animal "
"names (that is, the number of `Sum.inl` constructors) looks like this:"
msgstr ""

#: src/getting-to-know/polymorphism.md:410
msgid ""
"Function calls are evaluated before infix operators, so `howManyDogs "
"morePets + 1` is the same as `(howManyDogs morePets) + 1`. As expected, "
"`#eval howManyDogs animals` yields `3`."
msgstr ""

#: src/getting-to-know/polymorphism.md:413
msgid "`Unit`"
msgstr ""

#: src/getting-to-know/polymorphism.md:415
msgid ""
"`Unit` is a type with just one argumentless constructor, called `unit`. In "
"other words, it describes only a single value, which consists of said "
"constructor applied to no arguments whatsoever. `Unit` is defined as follows:"
msgstr ""

#: src/getting-to-know/polymorphism.md:423
msgid ""
"On its own, `Unit` is not particularly useful. However, in polymorphic code, "
"it can be used as a placeholder for data that is missing. For instance, the "
"following inductive datatype represents arithmetic expressions:"
msgstr ""

#: src/getting-to-know/polymorphism.md:433
msgid ""
"The type argument `ann` stands for annotations, and each constructor is "
"annotated. Expressions coming from a parser might be annotated with source "
"locations, so a return type of `ArithExpr SourcePos` ensures that the parser "
"put a `SourcePos` at each subexpression. Expressions that don't come from "
"the parser, however, will not have source locations, so their type can be "
"`ArithExpr Unit`."
msgstr ""

#: src/getting-to-know/polymorphism.md:438
msgid ""
"Additionally, because all Lean functions have arguments, zero-argument "
"functions in other languages can be represented as functions that take a "
"`Unit` argument. In a return position, the `Unit` type is similar to `void` "
"in languages derived from C. In the C family, a function that returns `void` "
"will return control to its caller, but it will not return any interesting "
"value. By being an intentionally uninteresting value, `Unit` allows this to "
"be expressed without requiring a special-purpose `void` feature in the type "
"system. Unit's constructor can be written as empty parentheses: `() : Unit`."
msgstr ""

#: src/getting-to-know/polymorphism.md:444
msgid "`Empty`"
msgstr ""

#: src/getting-to-know/polymorphism.md:446
msgid ""
"The `Empty` datatype has no constructors whatsoever. Thus, it indicates "
"unreachable code, because no series of calls can ever terminate with a value "
"at type `Empty`."
msgstr ""

#: src/getting-to-know/polymorphism.md:449
msgid ""
"`Empty` is not used nearly as often as `Unit`. However, it is useful in some "
"specialized contexts. Many polymorphic datatypes do not use all of their "
"type arguments in all of their constructors. For instance, `Sum.inl` and "
"`Sum.inr` each use only one of `Sum`'s type arguments. Using `Empty` as one "
"of the type arguments to `Sum` can rule out one of the constructors at a "
"particular point in a program. This can allow generic code to be used in "
"contexts that have additional restrictions."
msgstr ""

#: src/getting-to-know/polymorphism.md:456
msgid "Naming: Sums, Products, and Units"
msgstr ""

#: src/getting-to-know/polymorphism.md:458
msgid ""
"Generally speaking, types that offer multiple constructors are called _sum "
"types_, while types whose single constructor takes multiple arguments are "
"called _product types_. These terms are related to sums and products used in "
"ordinary arithmetic. The relationship is easiest to see when the types "
"involved contain a finite number of values. If `α` and `β` are types that "
"contain \\\\( n \\\\) and \\\\( k \\\\) distinct values, respectively, then "
"`α ⊕ β` contains \\\\( n + k \\\\) distinct values and `α × β` contains "
"\\\\( n \\times k \\\\) distinct values. For instance, `Bool` has two "
"values: `true` and `false`, and `Unit` has one value: `Unit.unit`. The "
"product `Bool × Unit` has the two values `(true, Unit.unit)` and `(false, "
"Unit.unit)`, and the sum `Bool ⊕ Unit` has the three values `Sum.inl true`, "
"`Sum.inl false`, and `Sum.inr unit`. Similarly, \\\\( 2 \\times 1 = 2 \\\\), "
"and \\\\( 2 + 1 = 3 \\\\)."
msgstr ""

#: src/getting-to-know/polymorphism.md:468
msgid ""
"Not all definable structures or inductive types can have the type `Type`. In "
"particular, if a constructor takes an arbitrary type as an argument, then "
"the inductive type must have a different type. These errors usually state "
"something about \"universe levels\". For example, for this inductive type:"
msgstr ""

#: src/getting-to-know/polymorphism.md:476
msgid "Lean gives the following error:"
msgstr ""

#: src/getting-to-know/polymorphism.md:485
msgid ""
"A later chapter describes why this is the case, and how to modify "
"definitions to make them work. For now, try making the type an argument to "
"the inductive type as a whole, rather than to the constructor."
msgstr ""

#: src/getting-to-know/polymorphism.md:488
msgid ""
"Similarly, if a constructor's argument is a function that takes the datatype "
"being defined as an argument, then the definition is rejected. For example:"
msgstr ""

#: src/getting-to-know/polymorphism.md:494
msgid "yields the message:"
msgstr ""

#: src/getting-to-know/polymorphism.md:498
msgid ""
"For technical reasons, allowing these datatypes could make it possible to "
"undermine Lean's internal logic, making it unsuitable for use as a theorem "
"prover."
msgstr ""

#: src/getting-to-know/polymorphism.md:500
msgid ""
"Forgetting an argument to an inductive type can also yield a confusing "
"message. For example, when the argument `α` is not passed to `MyType` in "
"`ctor`'s type:"
msgstr ""

#: src/getting-to-know/polymorphism.md:506
msgid "Lean replies with the following error:"
msgstr ""

#: src/getting-to-know/polymorphism.md:511
msgid ""
"The error message is saying that `MyType`'s type, which is `Type → Type`, "
"does not itself describe types. `MyType` requires an argument to become an "
"actual honest-to-goodness type."
msgstr ""

#: src/getting-to-know/polymorphism.md:514
msgid ""
"The same message can appear when type arguments are omitted in other "
"contexts, such as in a type signature for a definition:"
msgstr ""

#: src/getting-to-know/polymorphism.md:524
msgid ""
"Write a function to find the last entry in a list. It should return an "
"`Option`."
msgstr ""

#: src/getting-to-know/polymorphism.md:525
msgid ""
"Write a function that finds the first entry in a list that satisfies a given "
"predicate. Start the definition with `def List.findFirst? {α : Type} (xs : "
"List α) (predicate : α → Bool) : Option α :=`"
msgstr ""

#: src/getting-to-know/polymorphism.md:526
msgid ""
"Write a function `Prod.swap` that swaps the two fields in a pair. Start the "
"definition with `def Prod.swap {α β : Type} (pair : α × β) : β × α :=`"
msgstr ""

#: src/getting-to-know/polymorphism.md:527
msgid ""
"Rewrite the `PetName` example to use a custom datatype and compare it to the "
"version that uses `Sum`."
msgstr ""

#: src/getting-to-know/polymorphism.md:528
msgid ""
"Write a function `zip` that combines two lists into a list of pairs. The "
"resulting list should be as long as the shortest input list. Start the "
"definition with `def zip {α β : Type} (xs : List α) (ys : List β) : List (α "
"× β) :=`."
msgstr ""

#: src/getting-to-know/polymorphism.md:529
msgid ""
"Write a polymorphic function `take` that returns the first \\\\( n \\\\) "
"entries in a list, where \\\\( n \\\\) is a `Nat`. If the list contains "
"fewer than `n` entries, then the resulting list should be the input list. "
"`#eval take 3 [\"bolete\", \"oyster\"]` should yield `[\"bolete\", "
"\"oyster\"]`, and `#eval take 1 [\"bolete\", \"oyster\"]` should yield "
"`[\"bolete\"]`."
msgstr ""

#: src/getting-to-know/polymorphism.md:530
msgid ""
"Using the analogy between types and arithmetic, write a function that "
"distributes products over sums. In other words, it should have type `α × (β "
"⊕ γ) → (α × β) ⊕ (α × γ)`."
msgstr ""

#: src/getting-to-know/polymorphism.md:531
msgid ""
"Using the analogy between types and arithmetic, write a function that turns "
"multiplication by two into a sum. In other words, it should have type `Bool "
"× α → α ⊕ α`."
msgstr ""

#: src/getting-to-know/conveniences.md:3
msgid ""
"Lean contains a number of convenience features that make programs much more "
"concise."
msgstr ""

#: src/getting-to-know/conveniences.md:5
msgid "Automatic Implicit Arguments"
msgstr ""

#: src/getting-to-know/conveniences.md:7
msgid ""
"When writing polymorphic functions in Lean, it is typically not necessary to "
"list all the implicit arguments. Instead, they can simply be mentioned. If "
"Lean can determine their type, then they are automatically inserted as "
"implicit arguments. In other words, the previous definition of `length`:"
msgstr ""

#: src/getting-to-know/conveniences.md:17
msgid "can be written without `{α : Type}`:"
msgstr ""

#: src/getting-to-know/conveniences.md:24
msgid ""
"This can greatly simplify highly polymorphic definitions that take many "
"implicit arguments."
msgstr ""

#: src/getting-to-know/conveniences.md:26
msgid "Pattern-Matching Definitions"
msgstr ""

#: src/getting-to-know/conveniences.md:28
msgid ""
"When defining functions with `def`, it is quite common to name an argument "
"and then immediately use it with pattern matching. For instance, in "
"`length`, the argument `xs` is used only in `match`. In these situations, "
"the cases of the `match` expression can be written directly, without naming "
"the argument at all."
msgstr ""

#: src/getting-to-know/conveniences.md:32
msgid ""
"The first step is to move the arguments' types to the right of the colon, so "
"the return type is a function type. For instance, the type of `length` is "
"`List α → Nat`. Then, replace the `:=` with each case of the pattern match:"
msgstr ""

#: src/getting-to-know/conveniences.md:41
msgid ""
"This syntax can also be used to define functions that take more than one "
"argument. In this case, their patterns are separated by commas. For "
"instance, `drop` takes a number \\\\( n \\\\) and a list, and returns the "
"list after removing the first \\\\( n \\\\) entries."
msgstr ""

#: src/getting-to-know/conveniences.md:51
msgid ""
"Named arguments and patterns can also be used in the same definition. For "
"instance, a function that takes a default value and an optional value, and "
"returns the default when the optional value is `none`, can be written:"
msgstr ""

#: src/getting-to-know/conveniences.md:58
msgid ""
"This function is called `Option.getD` in the standard library, and can be "
"called with dot notation:"
msgstr ""

#: src/getting-to-know/conveniences.md:59
msgid ""
"```lean\n"
"#eval (some \"salmonberry\").getD \"\"\n"
"```"
msgstr ""

#: src/getting-to-know/conveniences.md:62
msgid ""
"```output info\n"
"\"salmonberry\"\n"
"```"
msgstr ""

#: src/getting-to-know/conveniences.md:65
msgid ""
"```lean\n"
"#eval none.getD \"\"\n"
"```"
msgstr ""

#: src/getting-to-know/conveniences.md:68
msgid ""
"```output info\n"
"\"\"\n"
"```"
msgstr ""

#: src/getting-to-know/conveniences.md:72
msgid "Local Definitions"
msgstr ""

#: src/getting-to-know/conveniences.md:74
msgid ""
"It is often useful to name intermediate steps in a computation. In many "
"cases, intermediate values represent useful concepts all on their own, and "
"naming them explicitly can make the program easier to read. In other cases, "
"the intermediate value is used more than once. As in most other languages, "
"writing down the same code twice in Lean causes it to be computed twice, "
"while saving the result in a variable leads to the result of the computation "
"being saved and re-used."
msgstr ""

#: src/getting-to-know/conveniences.md:79
msgid ""
"For instance, `unzip` is a function that transforms a list of pairs into a "
"pair of lists. When the list of pairs is empty, then the result of `unzip` "
"is a pair of empty lists. When the list of pairs has a pair at its head, "
"then the two fields of the pair are added to the result of unzipping the "
"rest of the list. This definition of `unzip` follows that description "
"exactly:"
msgstr ""

#: src/getting-to-know/conveniences.md:89
msgid ""
"Unfortunately, there is a problem: this code is slower than it needs to be. "
"Each entry in the list of pairs leads to two recursive calls, which makes "
"this function take exponential time. However, both recursive calls will have "
"the same result, so there is no reason to make the recursive call twice."
msgstr ""

#: src/getting-to-know/conveniences.md:94
msgid ""
"In Lean, the result of the recursive call can be named, and thus saved, "
"using `let`. Local definitions with `let` resemble top-level definitions "
"with `def`: it takes a name to be locally defined, arguments if desired, a "
"type signature, and then a body following `:=`. After the local definition, "
"the expression in which the local definition is available (called the _body_ "
"of the `let`\\-expression) must be on a new line, starting at a column in "
"the file that is less than or equal to that of the `let` keyword. For "
"instance, `let` can be used in `unzip` like this:"
msgstr ""

#: src/getting-to-know/conveniences.md:105
msgid ""
"To use `let` on a single line, separate the local definition from the body "
"with a semicolon."
msgstr ""

#: src/getting-to-know/conveniences.md:107
msgid ""
"Local definitions with `let` may also use pattern matching when one pattern "
"is enough to match all cases of a datatype. In the case of `unzip`, the "
"result of the recursive call is a pair. Because pairs have only a single "
"constructor, the name `unzipped` can be replaced with a pair pattern:"
msgstr ""

#: src/getting-to-know/conveniences.md:117
msgid ""
"Judicious use of patterns with `let` can make code easier to read, compared "
"to writing the accessor calls by hand."
msgstr ""

#: src/getting-to-know/conveniences.md:119
msgid ""
"The biggest difference between `let` and `def` is that recursive `let` "
"definitions must be explicitly indicated by writing `let rec`. For instance, "
"one way to reverse a list involves a recursive helper function, as in this "
"definition:"
msgstr ""

#: src/getting-to-know/conveniences.md:128
msgid ""
"The helper function walks down the input list, moving one entry at a time "
"over to `soFar`. When it reaches the end of the input list, `soFar` contains "
"a reversed version of the input."
msgstr ""

#: src/getting-to-know/conveniences.md:132
msgid "Type Inference"
msgstr ""

#: src/getting-to-know/conveniences.md:134
msgid ""
"In many situations, Lean can automatically determine an expression's type. "
"In these cases, explicit types may be omitted from both top-level "
"definitions (with `def`) and local definitions (with `let`). For instance, "
"the recursive call to `unzip` does not need an annotation:"
msgstr ""

#: src/getting-to-know/conveniences.md:145
msgid ""
"As a rule of thumb, omitting the types of literal values (like strings and "
"numbers) usually works, although Lean may pick a type for literal numbers "
"that is more specific than the intended type. Lean can usually determine a "
"type for a function application, because it already knows the argument types "
"and the return type. Omitting return types for function definitions will "
"often work, but function arguments typically require annotations. "
"Definitions that are not functions, like `unzipped` in the example, do not "
"need type annotations if their bodies do not need type annotations, and the "
"body of this definition is a function application."
msgstr ""

#: src/getting-to-know/conveniences.md:150
msgid ""
"Omitting the return type for `unzip` is possible when using an explicit "
"`match` expression:"
msgstr ""

#: src/getting-to-know/conveniences.md:161
msgid ""
"Generally speaking, it is a good idea to err on the side of too many, rather "
"than too few, type annotations. First off, explicit types communicate "
"assumptions about the code to readers. Even if Lean can determine the type "
"on its own, it can still be easier to read code without having to repeatedly "
"query Lean for type information. Secondly, explicit types help localize "
"errors. The more explicit a program is about its types, the more informative "
"the error messages can be. This is especially important in a language like "
"Lean that has a very expressive type system. Thirdly, explicit types make it "
"easier to write the program in the first place. The type is a specification, "
"and the compiler's feedback can be a helpful tool in writing a program that "
"meets the specification. Finally, Lean's type inference is a best-effort "
"system. Because Lean's type system is so expressive, there is no \"best\" or "
"most general type to find for all expressions. This means that even if you "
"get a type, there's no guarantee that it's the _right_ type for a given "
"application. For instance, `14` can be a `Nat` or an `Int`:"
msgstr ""

#: src/getting-to-know/conveniences.md:186
msgid ""
"Missing type annotations can give confusing error messages. Omitting all "
"types from the definition of `unzip`:"
msgstr ""

#: src/getting-to-know/conveniences.md:196
msgid "leads to a message about the `match` expression:"
msgstr ""

#: src/getting-to-know/conveniences.md:201
msgid ""
"This is because `match` needs to know the type of the value being inspected, "
"but that type was not available. A \"metavariable\" is an unknown part of a "
"program, written `?m.XYZ` in error messages—they are described in the "
"[section on Polymorphism](polymorphism.md). In this program, the type "
"annotation on the argument is required."
msgstr ""

#: src/getting-to-know/conveniences.md:205
msgid ""
"Even some very simple programs require type annotations. For instance, the "
"identity function just returns whatever argument it is passed. With argument "
"and type annotations, it looks like this:"
msgstr ""

#: src/getting-to-know/conveniences.md:211
msgid "Lean is capable of determining the return type on its own:"
msgstr ""

#: src/getting-to-know/conveniences.md:215
msgid "Omitting the argument type, however, causes an error:"
msgstr ""

#: src/getting-to-know/conveniences.md:223
msgid ""
"In general, messages that say something like \"failed to infer\" or that "
"mention metavariables are often a sign that more type annotations are "
"necessary. Especially while still learning Lean, it is useful to provide "
"most types explicitly."
msgstr ""

#: src/getting-to-know/conveniences.md:226
msgid "Simultaneous Matching"
msgstr ""

#: src/getting-to-know/conveniences.md:228
msgid ""
"Pattern-matching expressions, just like pattern-matching definitions, can "
"match on multiple values at once. Both the expressions to be inspected and "
"the patterns that they match against are written with commas between them, "
"similarly to the syntax used for definitions. Here is a version of `drop` "
"that uses simultaneous matching:"
msgstr ""

#: src/getting-to-know/conveniences.md:239
msgid "Natural Number Patterns"
msgstr ""

#: src/getting-to-know/conveniences.md:241
msgid ""
"In the section on [datatypes and patterns](datatypes-and-patterns.md), "
"`even` was defined like this:"
msgstr ""

#: src/getting-to-know/conveniences.md:248
msgid ""
"Just as there is special syntax to make list patterns more readable than "
"using `List.cons` and `List.nil` directly, natural numbers can be matched "
"using literal numbers and `+`. For instance, `even` can also be defined like "
"this:"
msgstr ""

#: src/getting-to-know/conveniences.md:256
msgid ""
"In this notation, the arguments to the `+` pattern serve different roles. "
"Behind the scenes, the left argument (`n` above) becomes an argument to some "
"number of `Nat.succ` patterns, and the right argument (`1` above) determines "
"how many `Nat.succ`s to wrap around the pattern. The explicit patterns in "
"`halve`, which divides a `Nat` by two and drops the remainder:"
msgstr ""

#: src/getting-to-know/conveniences.md:265
msgid "can be replaced by numeric literals and `+`:"
msgstr ""

#: src/getting-to-know/conveniences.md:272
msgid ""
"Behind the scenes, both definitions are completely equivalent. Remember: "
"`halve n + 1` is equivalent to `(halve n) + 1`, not `halve (n + 1)`."
msgstr ""

#: src/getting-to-know/conveniences.md:275
msgid ""
"When using this syntax, the second argument to `+` should always be a "
"literal `Nat`. Even though addition is commutative, flipping the arguments "
"in a pattern can result in errors like the following:"
msgstr ""

#: src/getting-to-know/conveniences.md:287
msgid ""
"This restriction enables Lean to transform all uses of the `+` notation in a "
"pattern into uses of the underlying `Nat.succ`, keeping the language simpler "
"behind the scenes."
msgstr ""

#: src/getting-to-know/conveniences.md:289
msgid "Anonymous Functions"
msgstr ""

#: src/getting-to-know/conveniences.md:291
msgid ""
"Functions in Lean need not be defined at the top level. As expressions, "
"functions are produced with the `fun` syntax. Function expressions begin "
"with the keyword `fun`, followed by one or more arguments, which are "
"separated from the return expression using `=>`. For instance, a function "
"that adds one to a number can be written:"
msgstr ""

#: src/getting-to-know/conveniences.md:301
msgid ""
"Type annotations are written the same way as on `def`, using parentheses and "
"colons:"
msgstr ""

#: src/getting-to-know/conveniences.md:308
msgid "Similarly, implicit arguments may be written with curly braces:"
msgstr ""

#: src/getting-to-know/conveniences.md:315
msgid ""
"This style of anonymous function expression is often referred to as a "
"_lambda expression_, because the typical notation used in mathematical "
"descriptions of programming languages uses the Greek letter λ (lambda) where "
"Lean has the keyword `fun`. Even though Lean does permit `λ` to be used "
"instead of `fun`, it is most common to write `fun`."
msgstr ""

#: src/getting-to-know/conveniences.md:318
msgid ""
"Anonymous functions also support the multiple-pattern style used in `def`. "
"For instance, a function that returns the predecessor of a natural number if "
"it exists can be written:"
msgstr ""

#: src/getting-to-know/conveniences.md:331
msgid ""
"Note that Lean's own description of the function has a named argument and a "
"`match` expression. Many of Lean's convenient syntactic shorthands are "
"expanded to simpler syntax behind the scenes, and the abstraction sometimes "
"leaks."
msgstr ""

#: src/getting-to-know/conveniences.md:334
msgid ""
"Definitions using `def` that take arguments may be rewritten as function "
"expressions. For instance, a function that doubles its argument can be "
"written as follows:"
msgstr ""

#: src/getting-to-know/conveniences.md:342
msgid ""
"When an anonymous function is very simple, like `fun x => x + 1`, the syntax "
"for creating the function can be fairly verbose. In that particular example, "
"six non-whitespace characters are used to introduce the function, and its "
"body consists of only three non-whitespace characters. For these simple "
"cases, Lean provides a shorthand. In an expression surrounded by "
"parentheses, a centered dot character `·` can stand for an argument, and the "
"expression inside the parentheses becomes the function's body. That "
"particular function can also be written `(· + 1)`."
msgstr ""

#: src/getting-to-know/conveniences.md:348
msgid ""
"The centered dot always creates a function out of the _closest_ surrounding "
"set of parentheses. For instance, `(· + 5, 3)` is a function that returns a "
"pair of numbers, while `((· + 5), 3)` is a pair of a function and a number. "
"If multiple dots are used, then they become arguments from left to right:"
msgstr ""

#: src/getting-to-know/conveniences.md:359
msgid ""
"Anonymous functions can be applied in precisely the same way as functions "
"defined using `def` or `let`. The command `#eval (fun x => x + x) 5` results "
"in:"
msgstr ""

#: src/getting-to-know/conveniences.md:364
msgid "while `#eval (· * 2) 5` results in:"
msgstr ""

#: src/getting-to-know/conveniences.md:369
msgid "Namespaces"
msgstr ""

#: src/getting-to-know/conveniences.md:371
msgid ""
"Each name in Lean occurs in a _namespace_, which is a collection of names. "
"Names are placed in namespaces using `.`, so `List.map` is the name `map` in "
"the `List` namespace. Names in different namespaces do not conflict with "
"each other, even if they are otherwise identical. This means that `List.map` "
"and `Array.map` are different names. Namespaces may be nested, so "
"`Project.Frontend.User.loginTime` is the name `loginTime` in the nested "
"namespace `Project.Frontend.User`."
msgstr ""

#: src/getting-to-know/conveniences.md:377
msgid ""
"Names can be directly defined within a namespace. For instance, the name "
"`double` can be defined in the `Nat` namespace:"
msgstr ""

#: src/getting-to-know/conveniences.md:382
msgid ""
"Because `Nat` is also the name of a type, dot notation is available to call "
"`Nat.double` on expressions with type `Nat`:"
msgstr ""

#: src/getting-to-know/conveniences.md:390
msgid ""
"In addition to defining names directly in a namespace, a sequence of "
"declarations can be placed in a namespace using the `namespace` and `end` "
"commands. For instance, this defines `triple` and `quadruple` in the "
"namespace `NewNamespace`:"
msgstr ""

#: src/getting-to-know/conveniences.md:398
msgid "To refer to them, prefix their names with `NewNamespace.`:"
msgstr ""

#: src/getting-to-know/conveniences.md:412
msgid ""
"Namespaces may be _opened_, which allows the names in them to be used "
"without explicit qualification. Writing `open MyNamespace in` before an "
"expression causes the contents of `MyNamespace` to be available in the "
"expression. For example, `timesTwelve` uses both `quadruple` and `triple` "
"after opening `NewNamespace`:"
msgstr ""

#: src/getting-to-know/conveniences.md:420
msgid ""
"Namespaces can also be opened prior to a command. This allows all parts of "
"the command to refer to the contents of the namespace, rather than just a "
"single expression. To do this, place the `open ... in` prior to the command."
msgstr ""

#: src/getting-to-know/conveniences.md:430
msgid ""
"Function signatures show the name's full namespace. Namespaces may "
"additionally be opened for _all_ following commands for the rest of the "
"file. To do this, simply omit the `in` from a top-level usage of `open`."
msgstr ""

#: src/getting-to-know/conveniences.md:434
msgid "if let"
msgstr ""

#: src/getting-to-know/conveniences.md:436
msgid ""
"When consuming values that have a sum type, it is often the case that only a "
"single constructor is of interest. For instance, given this type that "
"represents a subset of Markdown inline elements:"
msgstr ""

#: src/getting-to-know/conveniences.md:445
msgid ""
"a function that recognizes string elements and extracts their contents can "
"be written:"
msgstr ""

#: src/getting-to-know/conveniences.md:452
msgid ""
"An alternative way of writing this function's body uses `if` together with "
"`let`:"
msgstr ""

#: src/getting-to-know/conveniences.md:459
msgid ""
"This is very much like the pattern-matching `let` syntax. The difference is "
"that it can be used with sum types, because a fallback is provided in the "
"`else` case. In some contexts, using `if let` instead of `match` can make "
"code easier to read."
msgstr ""

#: src/getting-to-know/conveniences.md:463
msgid "Positional Structure Arguments"
msgstr ""

#: src/getting-to-know/conveniences.md:465
msgid ""
"The [section on structures](structures.md) presents two ways of constructing "
"structures:"
msgstr ""

#: src/getting-to-know/conveniences.md:466
msgid "The constructor can be called directly, as in `Point.mk 1 2`."
msgstr ""

#: src/getting-to-know/conveniences.md:467
msgid "Brace notation can be used, as in `{ x := 1, y := 2 }`."
msgstr ""

#: src/getting-to-know/conveniences.md:469
msgid ""
"In some contexts, it can be convenient to pass arguments positionally, "
"rather than by name, but without naming the constructor directly. For "
"instance, defining a variety of similar structure types can help keep domain "
"concepts separate, but the natural way to read the code may treat each of "
"them as being essentially a tuple. In these contexts, the arguments can be "
"enclosed in angle brackets `⟨` and `⟩`. A `Point` can be written `⟨1, 2⟩`. "
"Be careful! Even though they look like the less-than sign `<` and "
"greater-than sign `>`, these brackets are different. They can be input using "
"`\\<` and `\\>`, respectively."
msgstr ""

#: src/getting-to-know/conveniences.md:477
msgid ""
"Just as with the brace notation for named constructor arguments, this "
"positional syntax can only be used in a context where Lean can determine the "
"structure's type, either from a type annotation or from other type "
"information in the program. For instance, `#eval ⟨1, 2⟩` yields the "
"following error:"
msgstr ""

#: src/getting-to-know/conveniences.md:483
msgid ""
"The metavariable in the error is because there is no type information "
"available. Adding an annotation, such as in `#eval (⟨1, 2⟩ : Point)`, solves "
"the problem:"
msgstr ""

#: src/getting-to-know/conveniences.md:490
msgid "String Interpolation"
msgstr ""

#: src/getting-to-know/conveniences.md:492
msgid ""
"In Lean, prefixing a string with `s!` triggers _interpolation_, where "
"expressions contained in curly braces inside the string are replaced with "
"their values. This is similar to `f`\\-strings in Python and `$`\\-prefixed "
"strings in C#. For instance,"
msgstr ""

#: src/getting-to-know/conveniences.md:495
msgid ""
"```lean\n"
"#eval s!\"three fives is {NewNamespace.triple 5}\"\n"
"```"
msgstr ""

#: src/getting-to-know/conveniences.md:498
#: src/getting-to-know/conveniences.md:508
msgid "yields the output"
msgstr ""

#: src/getting-to-know/conveniences.md:499
msgid ""
"```output info\n"
"\"three fives is 15\"\n"
"```"
msgstr ""

#: src/getting-to-know/conveniences.md:503
msgid ""
"Not all expressions can be interpolated into a string. For instance, "
"attempting to interpolate a function results in an error."
msgstr ""

#: src/getting-to-know/conveniences.md:505
msgid ""
"```lean\n"
"#check s!\"three fives is {NewNamespace.triple}\"\n"
"```"
msgstr ""

#: src/getting-to-know/conveniences.md:513
msgid ""
"This is because there is no standard way to convert functions into strings. "
"The Lean compiler maintains a table that describes how to convert values of "
"various types into strings, and the message `failed to synthesize instance` "
"means that the Lean compiler didn't find an entry in this table for the "
"given type. This uses the same language feature as the `deriving Repr` "
"syntax that was described in the [section on structures](structures.md)."
msgstr ""

#: src/getting-to-know/summary.md:5
msgid ""
"In Lean, computation occurs when expressions are evaluated. This follows the "
"usual rules of mathematical expressions: sub-expressions are replaced by "
"their values following the usual order of operations, until the entire "
"expression has become a value. When evaluating an `if` or a `match`, the "
"expressions in the branches are not evaluated until the value of the "
"condition or the match subject has been found."
msgstr ""

#: src/getting-to-know/summary.md:9
msgid ""
"Once they have been given a value, variables never change. Similarly to "
"mathematics but unlike most programming languages, Lean variables are simply "
"placeholders for values, rather than addresses to which new values can be "
"written. Variables' values may come from global definitions with `def`, "
"local definitions with `let`, as named arguments to functions, or from "
"pattern matching."
msgstr ""

#: src/getting-to-know/summary.md:13
msgid "Functions"
msgstr ""

#: src/getting-to-know/summary.md:15
msgid ""
"Functions in Lean are first-class values, meaning that they can be passed as "
"arguments to other functions, saved in variables, and used like any other "
"value. Every Lean function takes exactly one argument. To encode a function "
"that takes more than one argument, Lean uses a technique called currying, "
"where providing the first argument returns a function that expects the "
"remaining arguments. To encode a function that takes no arguments, Lean uses "
"the `Unit` type, which is the least informative possible argument."
msgstr ""

#: src/getting-to-know/summary.md:20
msgid "There are three primary ways of creating functions:"
msgstr ""

#: src/getting-to-know/summary.md:21
msgid ""
"Anonymous functions are written using `fun`. For instance, a function that "
"swaps the fields of a `Point` can be written `fun (point : Point) => { x := "
"point.y, y := point.x : Point }`"
msgstr ""

#: src/getting-to-know/summary.md:23
msgid ""
"Very simple anonymous functions are written by placing one or more centered "
"dots `·` inside of parentheses. Each centered dot becomes an argument to the "
"function, and the parentheses delimit its body. For instance, a function "
"that subtracts one from its argument can be written as `(· - 1)` instead of "
"as `fun x => x - 1`."
msgstr ""

#: src/getting-to-know/summary.md:26
msgid ""
"Functions can be defined using `def` or `let` by adding an argument list or "
"by using pattern-matching notation."
msgstr ""

#: src/getting-to-know/summary.md:30
msgid ""
"Lean checks that every expression has a type. Types, such as `Int`, `Point`, "
"`{α : Type} → Nat → α → List α`, and `Option (String ⊕ (Nat × String))`, "
"describe the values that may eventually be found for an expression. Like "
"other languages, types in Lean can express lightweight specifications for "
"programs that are checked by the Lean compiler, obviating the need for "
"certain classes of unit test. Unlike most languages, Lean's types can also "
"express arbitrary mathematics, unifying the worlds of programming and "
"theorem proving. While using Lean for proving theorems is mostly out of "
"scope for this book, _[Theorem Proving in Lean "
"4](https://leanprover.github.io/theorem_proving_in_lean4/)_ contains more "
"information on this topic."
msgstr ""

#: src/getting-to-know/summary.md:36
msgid ""
"Some expressions can be given multiple types. For instance, `3` can be an "
"`Int` or a `Nat`. In Lean, this should be understood as two separate "
"expressions, one with type `Nat` and one with type `Int`, that happen to be "
"written in the same way, rather than as two different types for the same "
"thing."
msgstr ""

#: src/getting-to-know/summary.md:40
msgid ""
"Lean is sometimes able to determine types automatically, but types must "
"often be provided by the user. This is because Lean's type system is so "
"expressive. Even when Lean can find a type, it may not find the desired "
"type—`3` could be intended to be used as an `Int`, but Lean will give it the "
"type `Nat` if there are no further constraints. In general, it is a good "
"idea to write most types explicitly, only letting Lean fill out the very "
"obvious types. This improves Lean's error messages and helps make programmer "
"intent more clear."
msgstr ""

#: src/getting-to-know/summary.md:46
msgid ""
"Some functions or datatypes take types as arguments. They are called "
"_polymorphic_. Polymorphism allows programs such as one that calculates the "
"length of a list without caring what type the entries in the list have. "
"Because types are first class in Lean, polymorphism does not require any "
"special syntax, so types are passed just like other arguments. Giving an "
"argument a name in a function type allows later types to mention that "
"argument, and the type of applying that function to an argument is found by "
"replacing the argument's name with the argument's value."
msgstr ""

#: src/getting-to-know/summary.md:52
msgid "Structures and Inductive Types"
msgstr ""

#: src/getting-to-know/summary.md:54
msgid ""
"Brand new datatypes can be introduced to Lean using the `structure` or "
"`inductive` features. These new types are not considered to be equivalent to "
"any other type, even if their definitions are otherwise identical. Datatypes "
"have _constructors_ that explain the ways in which their values can be "
"constructed, and each constructor takes some number of arguments. "
"Constructors in Lean are not the same as constructors in object-oriented "
"languages: Lean's constructors are inert holders of data, rather than active "
"code that initializes an allocated object."
msgstr ""

#: src/getting-to-know/summary.md:59
msgid ""
"Typically, `structure` is used to introduce a product type (that is, a type "
"with just one constructor that takes any number of arguments), while "
"`inductive` is used to introduce a sum type (that is, a type with many "
"distinct constructors). Datatypes defined with `structure` are provided with "
"one accessor function for each of the constructor's arguments. Both "
"structures and inductive datatypes may be consumed with pattern matching, "
"which exposes the values stored inside of constructors using a subset of the "
"syntax used to call said constructors. Pattern matching means that knowing "
"how to create a value implies knowing how to consume it."
msgstr ""

#: src/getting-to-know/summary.md:65
msgid "Recursion"
msgstr ""

#: src/getting-to-know/summary.md:67
msgid ""
"A definition is recursive when the name being defined is used in the "
"definition itself. Because Lean is an interactive theorem prover in addition "
"to being a programming language, there are certain restrictions placed on "
"recursive definitions. In Lean's logical side, circular definitions could "
"lead to logical inconsistency."
msgstr ""

#: src/getting-to-know/summary.md:71
msgid ""
"In order to ensure that recursive definitions do not undermine the logical "
"side of Lean, Lean must be able to prove that all recursive functions "
"terminate, no matter what arguments they are called with. In practice, this "
"means either that recursive calls are all performed on a "
"structurally-smaller piece of the input, which ensures that there is always "
"progress towards a base case, or that users must provide some other evidence "
"that the function always terminates. Similarly, recursive inductive types "
"are not allowed to have a constructor that takes a function _from_ the type "
"as an argument, because this would make it possible to encode "
"non-terminating functions."
msgstr ""

#: src/hello-world.md:3
msgid ""
"While Lean has been designed to have a rich interactive environment in which "
"programmers can get quite a lot of feedback from the language without "
"leaving the confines of their favorite text editor, it is also a language in "
"which real programs can be written. This means that it also has a batch-mode "
"compiler, a build system, a package manager, and all the other tools that "
"are necessary for writing programs."
msgstr ""

#: src/hello-world.md:6
msgid ""
"While the [previous chapter](./getting-to-know.md) presented the basics of "
"functional programming in Lean, this chapter explains how to start a "
"programming project, compile it, and run the result. Programs that run and "
"interact with their environment (e.g. by reading input from standard input "
"or creating files) are difficult to reconcile with the understanding of "
"computation as the evaluation of mathematical expressions. In addition to a "
"description of the Lean build tools, this chapter also provides a way to "
"think about functional programs that interact with the world."
msgstr ""

#: src/hello-world/running-a-program.md:3
msgid ""
"The simplest way to run a Lean program is to use the `--run` option to the "
"Lean executable. Create a file called `Hello.lean` and enter the following "
"contents:"
msgstr ""

#: src/hello-world/running-a-program.md:5
msgid ""
"```lean\n"
"def main : IO Unit := IO.println \"Hello, world!\"\n"
"```"
msgstr ""

#: src/hello-world/running-a-program.md:8
msgid "Then, from the command line, run:"
msgstr ""

#: src/hello-world/running-a-program.md:12
msgid "The program displays `Hello, world!` and exits."
msgstr ""

#: src/hello-world/running-a-program.md:14
msgid "Anatomy of a Greeting"
msgstr ""

#: src/hello-world/running-a-program.md:16
msgid ""
"When Lean is invoked with the `--run` option, it invokes the program's "
"`main` definition. In programs that do not take command-line arguments, "
"`main` should have type `IO Unit`. This means that `main` is not a function, "
"because there are no arrows (`→`) in its type. Instead of being a function "
"that has side effects, `main` consists of a description of effects to be "
"carried out."
msgstr ""

#: src/hello-world/running-a-program.md:21
msgid ""
"As discussed in [the preceding chapter](../getting-to-know/polymorphism.md), "
"`Unit` is the simplest inductive type. It has a single constructor called "
"`unit` that takes no arguments. Languages in the C tradition have a notion "
"of a `void` function that does not return any value at all. In Lean, all "
"functions take an argument and return a value, and the lack of interesting "
"arguments or return values can be signaled by using the `Unit` type instead. "
"If `Bool` represents a single bit of information, `Unit` represents zero "
"bits of information."
msgstr ""

#: src/hello-world/running-a-program.md:27
msgid ""
"`IO α` is the type of a program that, when executed, will either throw an "
"exception or return a value of type `α`. During execution, this program may "
"have side effects. These programs are referred to as `IO` _actions_. Lean "
"distinguishes between _evaluation_ of expressions, which strictly adheres to "
"the mathematical model of substitution of values for variables and reduction "
"of sub-expressions without side effects, and _execution_ of `IO` actions, "
"which rely on an external system to interact with the world. `IO.println` is "
"a function from strings to `IO` actions that, when executed, write the given "
"string to standard output. Because this action doesn't read any interesting "
"information from the environment in the process of emitting the string, "
"`IO.println` has type `String → IO Unit`. If it did return something "
"interesting, then that would be indicated by the `IO` action having a type "
"other than `Unit`."
msgstr ""

#: src/hello-world/running-a-program.md:36
msgid "Functional Programming vs Effects"
msgstr ""

#: src/hello-world/running-a-program.md:38
msgid ""
"Lean's model of computation is based on the evaluation of mathematical "
"expressions, in which variables are given exactly one value that does not "
"change over time. The result of evaluating an expression does not change, "
"and evaluating the same expression again will always yield the same result."
msgstr ""

#: src/hello-world/running-a-program.md:41
msgid ""
"On the other hand, useful programs must interact with the world. A program "
"that performs neither input nor output can't ask a user for data, create "
"files on disk, or open network connections. Lean is written in itself, and "
"the Lean compiler certainly reads files, creates files, and interacts with "
"text editors. How can a language in which the same expression always yields "
"the same result support programs that read files from disk, when the "
"contents of these files might change over time?"
msgstr ""

#: src/hello-world/running-a-program.md:46
msgid ""
"This apparent contradiction can be resolved by thinking a bit differently "
"about side effects. Imagine a café that sells coffee and sandwiches. This "
"café has two employees: a cook who fulfills orders, and a worker at the "
"counter who interacts with customers and places order slips. The cook is a "
"surly person, who really prefers not to have any contact with the world "
"outside, but who is very good at consistently delivering the food and drinks "
"that the café is known for. In order to do this, however, the cook needs "
"peace and quiet, and can't be disturbed with conversation. The counter "
"worker is friendly, but completely incompetent in the kitchen. Customers "
"interact with the counter worker, who delegates all actual cooking to the "
"cook. If the cook has a question for a customer, such as clarifying an "
"allergy, they send a little note to the counter worker, who interacts with "
"the customer and passes a note back to the cook with the result."
msgstr ""

#: src/hello-world/running-a-program.md:55
msgid ""
"In this analogy, the cook is the Lean language. When provided with an order, "
"the cook faithfully and consistently delivers what is requested. The counter "
"worker is the surrounding run-time system that interacts with the world and "
"can accept payments, dispense food, and have conversations with customers. "
"Working together, the two employees serve all the functions of the "
"restaurant, but their responsibilities are divided, with each performing the "
"tasks that they're best at. Just as keeping customers away allows the cook "
"to focus on making truly excellent coffee and sandwiches, Lean's lack of "
"side effects allows programs to be used as part of formal mathematical "
"proofs. It also helps programmers understand the parts of the program in "
"isolation from each other, because there are no hidden state changes that "
"create subtle coupling between components. The cook's notes represent `IO` "
"actions that are produced by evaluating Lean expressions, and the counter "
"worker's replies are the values that are passed back from effects."
msgstr ""

#: src/hello-world/running-a-program.md:63
msgid ""
"This model of side effects is quite similar to how the overall aggregate of "
"the Lean language, its compiler, and its run-time system (RTS) work. "
"Primitives in the run-time system, written in C, implement all the basic "
"effects. When running a program, the RTS invokes the `main` action, which "
"returns new `IO` actions to the RTS for execution. The RTS executes these "
"actions, delegating to the user's Lean code to carry out computations. From "
"the internal perspective of Lean, programs are free of side effects, and "
"`IO` actions are just descriptions of tasks to be carried out. From the "
"external perspective of the program's user, there is a layer of side effects "
"that create an interface to the program's core logic."
msgstr ""

#: src/hello-world/running-a-program.md:71
msgid "Real-World Functional Programming"
msgstr ""

#: src/hello-world/running-a-program.md:73
msgid ""
"The other useful way to think about side effects in Lean is by considering "
"`IO` actions to be functions that take the entire world as an argument and "
"return a value paired with a new world. In this case, reading a line of text "
"from standard input _is_ a pure function, because a different world is "
"provided as an argument each time. Writing a line of text to standard output "
"is a pure function, because the world that the function returns is different "
"from the one that it began with. Programs do need to be careful to never "
"re-use the world, nor to fail to return a new world—this would amount to "
"time travel or the end of the world, after all. Careful abstraction "
"boundaries can make this style of programming safe. If every primitive `IO` "
"action accepts one world and returns a new one, and they can only be "
"combined with tools that preserve this invariant, then the problem cannot "
"occur."
msgstr ""

#: src/hello-world/running-a-program.md:80
msgid ""
"This model cannot be implemented. After all, the entire universe cannot be "
"turned into a Lean value and placed into memory. However, it is possible to "
"implement a variation of this model with an abstract token that stands for "
"the world. When the program is started, it is provided with a world token. "
"This token is then passed on to the IO primitives, and their returned tokens "
"are similarly passed to the next step. At the end of the program, the token "
"is returned to the operating system."
msgstr ""

#: src/hello-world/running-a-program.md:87
msgid ""
"This model of side effects is a good description of how `IO` actions as "
"descriptions of tasks to be carried out by the RTS are represented "
"internally in Lean. The actual functions that transform the real world are "
"behind an abstraction barrier. But real programs typically consist of a "
"sequence of effects, rather than just one. To enable programs to use "
"multiple effects, there is a sub-language of Lean called `do` notation that "
"allows these primitive `IO` actions to be safely composed into a larger, "
"useful program."
msgstr ""

#: src/hello-world/running-a-program.md:92
msgid "Combining `IO` Actions"
msgstr ""

#: src/hello-world/running-a-program.md:94
msgid ""
"Most useful programs accept input in addition to producing output. "
"Furthermore, they may take decisions based on input, using the input data as "
"part of a computation. The following program, called `HelloName.lean`, asks "
"the user for their name and then greets them:"
msgstr ""

#: src/hello-world/running-a-program.md:97
msgid ""
"```lean\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""

#: src/hello-world/running-a-program.md:109
msgid ""
"In this program, the `main` action consists of a `do` block. This block "
"contains a sequence of _statements_, which can be both local variables "
"(introduced using `let`) and actions that are to be executed. Just as SQL "
"can be thought of as a special-purpose language for interacting with "
"databases, the `do` syntax can be thought of as a special-purpose "
"sub-language within Lean that is dedicated to modeling imperative programs. "
"`IO` actions that are built with a `do` block are executed by executing the "
"statements in order."
msgstr ""

#: src/hello-world/running-a-program.md:114
msgid "This program can be run in the same manner as the prior program:"
msgstr ""

#: src/hello-world/running-a-program.md:118
msgid ""
"If the user responds with `David`, a session of interaction with the program "
"reads:"
msgstr ""

#: src/hello-world/running-a-program.md:125
msgid "The type signature line is just like the one for `Hello.lean`:"
msgstr ""

#: src/hello-world/running-a-program.md:129
msgid ""
"The only difference is that it ends with the keyword `do`, which initiates a "
"sequence of commands. Each indented line following the keyword `do` is part "
"of the same sequence of commands."
msgstr ""

#: src/hello-world/running-a-program.md:132
msgid "The first two lines, which read:"
msgstr ""

#: src/hello-world/running-a-program.md:137
msgid ""
"retrieve the `stdin` and `stdout` handles by executing the library actions "
"`IO.getStdin` and `IO.getStdout`, respectively. In a `do` block, `let` has a "
"slightly different meaning than in an ordinary expression. Ordinarily, the "
"local definition in a `let` can be used in just one expression, which "
"immediately follows the local definition. In a `do` block, local bindings "
"introduced by `let` are available in all statements in the remainder of the "
"`do` block, rather than just the next one. Additionally, `let` typically "
"connects the name being defined to its definition using `:=`, while some "
"`let` bindings in `do` use a left arrow (`←` or `<-`) instead. Using an "
"arrow means that the value of the expression is an `IO` action that should "
"be executed, with the result of the action saved in the local variable. In "
"other words, if the expression to the right of the arrow has type `IO α`, "
"then the variable has type `α` in the remainder of the `do` block. "
"`IO.getStdin` and `IO.getStdout` are `IO` actions in order to allow `stdin` "
"and `stdout` to be locally overridden in a program, which can be convenient. "
"If they were global variables as in C, then there would be no meaningful way "
"to override them, but `IO` actions can return different values each time "
"they are executed."
msgstr ""

#: src/hello-world/running-a-program.md:147
msgid ""
"The next part of the `do` block is responsible for asking the user for their "
"name:"
msgstr ""

#: src/hello-world/running-a-program.md:148
msgid ""
"```lean\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"```"
msgstr ""

#: src/hello-world/running-a-program.md:153
msgid ""
"The first line writes the question to `stdout`, the second line requests "
"input from `stdin`, and the third line removes the trailing newline (plus "
"any other trailing whitespace) from the input line. The definition of `name` "
"uses `:=`, rather than `←`, because `String.dropRightWhile` is an ordinary "
"function on strings, rather than an `IO` action."
msgstr ""

#: src/hello-world/running-a-program.md:156
msgid "Finally, the last line in the program is:"
msgstr ""

#: src/hello-world/running-a-program.md:157
msgid ""
"```\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""

#: src/hello-world/running-a-program.md:160
msgid ""
"It uses [string "
"interpolation](../getting-to-know/conveniences.md#string-interpolation) to "
"insert the provided name into a greeting string, writing the result to "
"`stdout`."
msgstr ""

#: src/hello-world/step-by-step.md:3
msgid ""
"A `do` block can be executed one line at a time. Start with the program from "
"the prior section:"
msgstr ""

#: src/hello-world/step-by-step.md:5
msgid ""
"```lean\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:14
msgid "Standard IO"
msgstr ""

#: src/hello-world/step-by-step.md:16
msgid "The first line is `  let stdin ← IO.getStdin`, while the remainder is:"
msgstr ""

#: src/hello-world/step-by-step.md:17
msgid ""
"```lean\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:24
msgid ""
"To execute a `let` statement that uses a `←`, start by evaluating the "
"expression to the right of the arrow (in this case, `IO.getStdIn`). Because "
"this expression is just a variable, its value is looked up. The resulting "
"value is a built-in primitive `IO` action. The next step is to execute this "
"`IO` action, resulting in a value that represents the standard input stream, "
"which has type `IO.FS.Stream`. Standard input is then associated with the "
"name to the left of the arrow (here `stdin`) for the remainder of the `do` "
"block."
msgstr ""

#: src/hello-world/step-by-step.md:30
msgid ""
"Executing the second line, `  let stdout ← IO.getStdout`, proceeds "
"similarly. First, the expression `IO.getStdout` is evaluated, yielding an "
"`IO` action that will return the standard output. Next, this action is "
"executed, actually returning the standard output. Finally, this value is "
"associated with the name `stdout` for the remainder of the `do` block."
msgstr ""

#: src/hello-world/step-by-step.md:35
msgid "Asking a Question"
msgstr ""

#: src/hello-world/step-by-step.md:37
msgid ""
"Now that `stdin` and `stdout` have been found, the remainder of the block "
"consists of a question and an answer:"
msgstr ""

#: src/hello-world/step-by-step.md:38
msgid ""
"```lean\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:45
msgid ""
"The first statement in the block, `  stdout.putStrLn \"How would you like to "
"be addressed?\"`, consists of an expression. To execute an expression, it is "
"first evaluated. In this case, `IO.FS.Stream.putStrLn` has type "
"`IO.FS.Stream → String → IO Unit`. This means that it is a function that "
"accepts a stream and a string, returning an `IO` action. The expression uses "
"[accessor notation](../getting-to-know/structures.md#behind-the-scenes) for "
"a function call. This function is applied to two arguments: the standard "
"output stream and a string. The value of the expression is an `IO` action "
"that will write the string and a newline character to the output stream. "
"Having found this value, the next step is to execute it, which causes the "
"string and newline to actually be written to `stdout`. Statements that "
"consist only of expressions do not introduce any new variables."
msgstr ""

#: src/hello-world/step-by-step.md:55
msgid ""
"The next statement in the block is `  let input ← stdin.getLine`. "
"`IO.FS.Stream.getLine` has type `IO.FS.Stream → IO String`, which means that "
"it is a function from a stream to an `IO` action that will return a string. "
"Once again, this is an example of accessor notation. This `IO` action is "
"executed, and the program waits until the user has typed a complete line of "
"input. Assume the user writes \"`David`\". The resulting line (`\"David\\n"
"\"`) is associated with `input`, where the escape sequence `\\n"
"` denotes the newline character."
msgstr ""

#: src/hello-world/step-by-step.md:62
msgid ""
"```lean\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:67
msgid ""
"The next line, `  let name := input.dropRightWhile Char.isWhitespace`, is a "
"`let` statement. Unlike the other `let` statements in this program, it uses "
"`:=` instead of `←`. This means that the expression will be evaluated, but "
"the resulting value need not be an `IO` action and will not be executed. In "
"this case, `String.dropRightWhile` takes a string and a predicate over "
"characters and returns a new string from which all the characters at the end "
"of the string that satisfy the predicate have been removed. For example,"
msgstr ""

#: src/hello-world/step-by-step.md:72
msgid ""
"```lean\n"
"#eval \"Hello!!!\".dropRightWhile (· == '!')\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:75 src/hello-world/step-by-step.md:83
#: src/type-classes/out-params.md:165
msgid "yields"
msgstr ""

#: src/hello-world/step-by-step.md:76 src/hello-world/step-by-step.md:84
msgid ""
"```output info\n"
"\"Hello\"\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:80
msgid ""
"```lean\n"
"#eval \"Hello...   \".dropRightWhile (fun c => not (c.isAlphanum))\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:87
msgid ""
"in which all non-alphanumeric characters have been removed from the right "
"side of the string. In the current line of the program, whitespace "
"characters (including the newline) are removed from the right side of the "
"input string, resulting in `\"David\"`, which is associated with `name` for "
"the remainder of the block."
msgstr ""

#: src/hello-world/step-by-step.md:91
msgid "Greeting the User"
msgstr ""

#: src/hello-world/step-by-step.md:93
msgid "All that remains to be executed in the `do` block is a single statement:"
msgstr ""

#: src/hello-world/step-by-step.md:94
msgid ""
"```lean\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:97
msgid ""
"The string argument to `putStrLn` is constructed via string interpolation, "
"yielding the string `\"Hello, David!\"`. Because this statement is an "
"expression, it is evaluated to yield an `IO` action that will print this "
"string with a newline to standard output. Once the expression has been "
"evaluated, the resulting `IO` action is executed, resulting in the greeting."
msgstr ""

#: src/hello-world/step-by-step.md:101
msgid "`IO` Actions as Values"
msgstr ""

#: src/hello-world/step-by-step.md:103
msgid ""
"In the above description, it can be difficult to see why the distinction "
"between evaluating expressions and executing `IO` actions is necessary. "
"After all, each action is executed immediately after it is produced. Why not "
"simply carry out the effects during evaluation, as is done in other "
"languages?"
msgstr ""

#: src/hello-world/step-by-step.md:107
msgid ""
"The answer is twofold. First off, separating evaluation from execution means "
"that programs must be explicit about which functions can have side effects. "
"Because the parts of the program that do not have effects are much more "
"amenable to mathematical reasoning, whether in the heads of programmers or "
"using Lean's facilities for formal proof, this separation can make it easier "
"to avoid bugs. Secondly, not all `IO` actions need be executed at the time "
"that they come into existence. The ability to mention an action without "
"carrying it out allows ordinary functions to be used as control structures."
msgstr ""

#: src/hello-world/step-by-step.md:113
msgid ""
"For instance, the function `twice` takes an `IO` action as its argument, "
"returning a new action that will execute the first one twice."
msgstr ""

#: src/hello-world/step-by-step.md:119
msgid "For instance, executing"
msgstr ""

#: src/hello-world/step-by-step.md:120
msgid ""
"```lean\n"
"twice (IO.println \"shy\")\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:123 src/type-classes/standard-classes.md:266
#: src/monads/io.md:22 src/monads/io.md:34
msgid "results in"
msgstr ""

#: src/hello-world/step-by-step.md:128
msgid ""
"being printed. This can be generalized to a version that runs the underlying "
"action any number of times:"
msgstr ""

#: src/hello-world/step-by-step.md:137
msgid ""
"In the base case for `Nat.zero`, the result is `pure ()`. The function "
"`pure` creates an `IO` action that has no side effects, but returns `pure`'s "
"argument, which in this case is the constructor for `Unit`. As an action "
"that does nothing and returns nothing interesting, `pure ()` is at the same "
"time utterly boring and very useful. In the recursive step, a `do` block is "
"used to create an action that first executes `action` and then executes the "
"result of the recursive call. Executing `nTimes (IO.println \"Hello\") 3` "
"causes the following output:"
msgstr ""

#: src/hello-world/step-by-step.md:148
msgid ""
"In addition to using functions as control structures, the fact that `IO` "
"actions are first-class values means that they can be saved in data "
"structures for later execution. For instance, the function `countdown` takes "
"a `Nat` and returns a list of unexecuted `IO` actions, one for each `Nat`:"
msgstr ""

#: src/hello-world/step-by-step.md:150
msgid ""
"```lean\n"
"def countdown : Nat → List (IO Unit)\n"
"  | 0 => [IO.println \"Blast off!\"]\n"
"  | n + 1 => IO.println s!\"{n + 1}\" :: countdown n\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:155
msgid ""
"This function has no side effects, and does not print anything. For example, "
"it can be applied to an argument, and the length of the resulting list of "
"actions can be checked:"
msgstr ""

#: src/hello-world/step-by-step.md:160
msgid ""
"This list contains six elements (one for each number, plus a `\"Blast "
"off!\"` action for zero):"
msgstr ""

#: src/hello-world/step-by-step.md:168
msgid ""
"The function `runActions` takes a list of actions and constructs a single "
"action that runs them all in order:"
msgstr ""

#: src/hello-world/step-by-step.md:176
msgid ""
"Its structure is essentially the same as that of `nTimes`, except instead of "
"having one action that is executed for each `Nat.succ`, the action under "
"each `List.cons` is to be executed. Similarly, `runActions` does not itself "
"run the actions. It creates a new action that will run them, and that action "
"must be placed in a position where it will be executed as a part of `main`:"
msgstr ""

#: src/hello-world/step-by-step.md:182
msgid "Running this program results in the following output:"
msgstr ""

#: src/hello-world/step-by-step.md:192
msgid ""
"What happens when this program is run? The first step is to evaluate `main`. "
"That occurs as follows:"
msgstr ""

#: src/hello-world/step-by-step.md:194
msgid ""
"```lean\n"
"main\n"
"===>\n"
"runActions from5\n"
"===>\n"
"runActions (countdown 5)\n"
"===>\n"
"runActions\n"
"  [IO.println \"5\",\n"
"   IO.println \"4\",\n"
"   IO.println \"3\",\n"
"   IO.println \"2\",\n"
"   IO.println \"1\",\n"
"   IO.println \"Blast off!\"]\n"
"===>\n"
"do IO.println \"5\"\n"
"   IO.println \"4\"\n"
"   IO.println \"3\"\n"
"   IO.println \"2\"\n"
"   IO.println \"1\"\n"
"   IO.println \"Blast off!\"\n"
"   pure ()\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:217
msgid ""
"The resulting `IO` action is a `do` block. Each step of the `do` block is "
"then executed, one at a time, yielding the expected output. The final step, "
"`pure ()`, does not have any effects, and it is only present because the "
"definition of `runActions` needs a base case."
msgstr ""

#: src/hello-world/step-by-step.md:221 src/hello-world/cat.md:226
#: src/programs-proofs/tail-recursion-proofs.md:464
#: src/programs-proofs/fin.md:41 src/programs-proofs/special-types.md:51
msgid "Exercise"
msgstr ""

#: src/hello-world/step-by-step.md:223
msgid "Step through the execution of the following program on a piece of paper:"
msgstr ""

#: src/hello-world/step-by-step.md:224
msgid ""
"```lean\n"
"def main : IO Unit := do\n"
"  let englishGreeting := IO.println \"Hello!\"\n"
"  IO.println \"Bonjour!\"\n"
"  englishGreeting\n"
"```"
msgstr ""

#: src/hello-world/step-by-step.md:230
msgid ""
"While stepping through the program's execution, identify when an expression "
"is being evaluated and when an `IO` action is being executed. When executing "
"an `IO` action results in a side effect, write it down. After doing this, "
"run the program with Lean and double-check that your predictions about the "
"side effects were correct."
msgstr ""

#: src/hello-world/starting-a-project.md:3
msgid ""
"As a program written in Lean becomes more serious, an ahead-of-time "
"compiler-based workflow that results in an executable becomes more "
"attractive. Like other languages, Lean has tools for building multiple-file "
"packages and managing dependencies. The standard Lean build tool is called "
"Lake (short for \"Lean Make\"), and it is configured in Lean. Just as Lean "
"contains a special-purpose language for writing programs with effects (the "
"`do` language), Lake contains a special-purpose language for configuring "
"builds. These languages are referred to as _embedded domain-specific "
"languages_ (or sometimes _domain-specific embedded languages_, abbreviated "
"EDSL or DSEL). They are _domain-specific_ in the sense that they are used "
"for a particular purpose, with concepts from some sub-domain, and they are "
"typically not suitable for general-purpose programming. They are _embedded_ "
"because they occur inside another language's syntax. While Lean contains "
"rich facilities for creating EDSLs, they are beyond the scope of this book."
msgstr ""

#: src/hello-world/starting-a-project.md:12
msgid "First steps"
msgstr ""

#: src/hello-world/starting-a-project.md:14
msgid ""
"To get started with a project that uses Lake, use the command `lake new "
"greeting` in a directory that does not already contain a file or directory "
"called `greeting`. This creates a directory called `greeting` that contains "
"the following files:"
msgstr ""

#: src/hello-world/starting-a-project.md:17
msgid ""
"`Main.lean` is the file in which the Lean compiler will look for the `main` "
"action."
msgstr ""

#: src/hello-world/starting-a-project.md:18
msgid ""
"`Greeting.lean` and `Greeting/Basic.lean` are the scaffolding of a support "
"library for the program."
msgstr ""

#: src/hello-world/starting-a-project.md:19
msgid ""
"`lakefile.lean` contains the configuration that `lake` needs to build the "
"application."
msgstr ""

#: src/hello-world/starting-a-project.md:20
msgid ""
"`lean-toolchain` contains an identifier for the specific version of Lean "
"that is used for the project."
msgstr ""

#: src/hello-world/starting-a-project.md:22
msgid ""
"Additionally, `lake new` initializes the project as a Git repository and "
"configures its `.gitignore` file to ignore intermediate build products. "
"Typically, the majority of the application logic will be in a collection of "
"libraries for the program, while `Main.lean` will contain a small wrapper "
"around these pieces that does things like parsing command lines and "
"executing the central application logic. To create a project in an "
"already-existing directory, run `lake init` instead of `lake new`."
msgstr ""

#: src/hello-world/starting-a-project.md:26
msgid ""
"By default, the library file `Greeting/Basic.lean` contains a single "
"definition:"
msgstr ""

#: src/hello-world/starting-a-project.md:27
msgid ""
"```lean\n"
"def hello := \"world\"\n"
"```"
msgstr ""

#: src/hello-world/starting-a-project.md:30
msgid "The library file `Greeting.lean` imports `Greeting/Basic.lean`:"
msgstr ""

#: src/hello-world/starting-a-project.md:36
msgid ""
"This means that everything defined in `Greetings/Basic.lean` is also "
"available to files that import `Greetings.lean`. In `import` statements, "
"dots are interpreted as directories on disk. Placing guillemets around a "
"name, as in `«Greeting»`, allow it to contain spaces or other characters "
"that are normally not allowed in Lean names, and it allows reserved keywords "
"such as `if` or `def` to be used as ordinary names by writing `«if»` or "
"`«def»`. This prevents issues when the package name provided to `lake new` "
"contains such characters."
msgstr ""

#: src/hello-world/starting-a-project.md:41
msgid "The executable source `Main.lean` contains:"
msgstr ""

#: src/hello-world/starting-a-project.md:42
msgid ""
"```lean\n"
"import «Greeting»\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}!\"\n"
"```"
msgstr ""

#: src/hello-world/starting-a-project.md:48
msgid ""
"Because `Main.lean` imports `Greetings.lean` and `Greetings.lean` imports "
"`Greetings/Basic.lean`, the definition of `hello` is available in `main`."
msgstr ""

#: src/hello-world/starting-a-project.md:50
msgid ""
"To build the package, run the command `lake build`. After a number of build "
"commands scroll by, the resulting binary has been placed in `build/bin`. "
"Running `./build/bin/greeting` results in `Hello, world!`."
msgstr ""

#: src/hello-world/starting-a-project.md:54
msgid "Lakefiles"
msgstr ""

#: src/hello-world/starting-a-project.md:56
msgid ""
"A `lakefile.lean` describes a _package_, which is a coherent collection of "
"Lean code for distribution, analogous to an `npm` or `nuget` package or a "
"Rust crate. A package may contain any number of libraries or executables. "
"While the [documentation for "
"Lake](https://github.com/leanprover/lean4/blob/master/src/lake/README.md) "
"describes the available options in a lakefile, it makes use of a number of "
"Lean features that have not yet been described here. The generated "
"`lakefile.lean` contains the following:"
msgstr ""

#: src/hello-world/starting-a-project.md:79
msgid "This initial Lakefile consists of three items:"
msgstr ""

#: src/hello-world/starting-a-project.md:80
msgid "a _package_ declaration, named `greeting`,"
msgstr ""

#: src/hello-world/starting-a-project.md:81
msgid "a _library_ declaration, named `Greeting`, and"
msgstr ""

#: src/hello-world/starting-a-project.md:82
msgid "an _executable_, also named `greeting`."
msgstr ""

#: src/hello-world/starting-a-project.md:84
msgid ""
"Each of these names is enclosed in guillemets to allow users more freedom in "
"picking package names."
msgstr ""

#: src/hello-world/starting-a-project.md:86
msgid ""
"Each Lakefile will contain exactly one package, but any number of libraries "
"or executables. Additionally, Lakefiles may contain _external libraries_, "
"which are libraries not written in Lean to be statically linked with the "
"resulting executable, _custom targets_, which are build targets that don't "
"fit naturally into the library/executable taxonomy, _dependencies_, which "
"are declarations of other Lean packages (either locally or from remote Git "
"repositories), and _scripts_, which are essentially `IO` actions (similar to "
"`main`), but that additionally have access to metadata about the package "
"configuration. The items in the Lakefile allow things like source file "
"locations, module hierarchies, and compiler flags to be configured. "
"Generally speaking, however, the defaults are reasonable."
msgstr ""

#: src/hello-world/starting-a-project.md:91
msgid ""
"Libraries, executables, and custom targets are all called _targets_. By "
"default, `lake build` builds those targets that are annotated with "
"`@[default_target]`. This annotation is an _attribute_, which is metadata "
"that can be associated with a Lean declaration. Attributes are similar to "
"Java annotations or C# and Rust attributes. They are used pervasively "
"throughout Lean. To build a target that is not annotated with "
"`@[default_target]`, specify the target's name as an argument after `lake "
"build`."
msgstr ""

#: src/hello-world/starting-a-project.md:98
msgid "Libraries and Imports"
msgstr ""

#: src/hello-world/starting-a-project.md:100
msgid ""
"A Lean library consists of a hierarchically organized collection of source "
"files from which names can be imported, called _modules_. By default, a "
"library has a single root file that matches its name. In this case, the root "
"file for the library `Greeting` is `Greeting.lean`. The first line of "
"`Main.lean`, which is `import Greeting`, makes the contents of "
"`Greeting.lean` available in `Main.lean`."
msgstr ""

#: src/hello-world/starting-a-project.md:105
msgid ""
"Additional module files may be added to the library by creating a directory "
"called `Greeting` and placing them inside. These names can be imported by "
"replacing the directory separator with a dot. For instance, creating the "
"file `Greeting/Smile.lean` with the contents:"
msgstr ""

#: src/hello-world/starting-a-project.md:108
msgid ""
"```lean\n"
"def expression : String := \"a big smile\"\n"
"```"
msgstr ""

#: src/hello-world/starting-a-project.md:111
msgid "means that `Main.lean` can use the definition as follows:"
msgstr ""

#: src/hello-world/starting-a-project.md:112
msgid ""
"```lean\n"
"import Greeting\n"
"import Greeting.Smile\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}, with {expression}!\"\n"
"```"
msgstr ""

#: src/hello-world/starting-a-project.md:120
msgid ""
"The module name hierarchy is decoupled from the namespace hierarchy. In "
"Lean, modules are units of code distribution, while namespaces are units of "
"code organization. That is, names defined in the module `Greeting.Smile` are "
"not automatically in a corresponding namespace `Greeting.Smile`. Modules may "
"place names into any namespace they like, and the code that imports them may "
"`open` the namespace or not. `import` is used to make the contents of a "
"source file available, while `open` makes names from a namespace available "
"in the current context without prefixes. In the Lakefile, the line `import "
"Lake` makes the contents of the `Lake` module available, while the line "
"`open Lake DSL` makes the contents of the `Lake` and `Lake.DSL` namespaces "
"available without any prefixes. `Lake.DSL` is opened because opening `Lake` "
"makes `Lake.DSL` available as just `DSL`, just like all other names in the "
"`Lake` namespace. The `Lake` module places names into both the `Lake` and "
"`Lake.DSL` namespaces."
msgstr ""

#: src/hello-world/starting-a-project.md:129
msgid ""
"Namespaces may also be opened _selectively_, making only some of their names "
"available without explicit prefixes. This is done by writing the desired "
"names in parentheses. For example, `Nat.toFloat` converts a natural number "
"to a `Float`. It can be made available as `toFloat` using `open Nat "
"(toFloat)`."
msgstr ""

#: src/hello-world/cat.md:3
msgid ""
"The standard Unix utility `cat` takes a number of command-line options, "
"followed by zero or more input files. If no files are provided, or if one of "
"them is a dash (`-`), then it takes the standard input as the corresponding "
"input instead of reading a file. The contents of the inputs are written, one "
"after the other, to the standard output. If a specified input file does not "
"exist, this is noted on standard error, but `cat` continues concatenating "
"the remaining inputs. A non-zero exit code is returned if any of the input "
"files do not exist."
msgstr ""

#: src/hello-world/cat.md:9
msgid ""
"This section describes a simplified version of `cat`, called `feline`. "
"Unlike commonly-used versions of `cat`, `feline` has no command-line options "
"for features such as numbering lines, indicating non-printing characters, or "
"displaying help text. Furthermore, it cannot read more than once from a "
"standard input that's associated with a terminal device."
msgstr ""

#: src/hello-world/cat.md:13
msgid ""
"To get the most benefit from this section, follow along yourself. It's OK to "
"copy-paste the code examples, but it's even better to type them in by hand. "
"This makes it easier to learn the mechanical process of typing in code, "
"recovering from mistakes, and interpreting feedback from the compiler."
msgstr ""

#: src/hello-world/cat.md:17
msgid "Getting started"
msgstr ""

#: src/hello-world/cat.md:19
msgid ""
"The first step in implementing `feline` is to create a package and decide "
"how to organize the code. In this case, because the program is so simple, "
"all the code will be placed in `Main.lean`. The first step is to run `lake "
"new feline`. Edit the Lakefile to remove the library, and delete the "
"generated library code and the reference to it from `Main.lean`. Once this "
"has been done, `lakefile.lean` should contain:"
msgstr ""

#: src/hello-world/cat.md:39
msgid "and `Main.lean` should contain something like:"
msgstr ""

#: src/hello-world/cat.md:40
msgid ""
"```lean\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, cats!\"\n"
"```"
msgstr ""

#: src/hello-world/cat.md:44
msgid ""
"Alternatively, running `lake new feline exe` instructs `lake` to use a "
"template that does not include a library section, making it unnecessary to "
"edit the file."
msgstr ""

#: src/hello-world/cat.md:46
msgid "Ensure that the code can be built by running `lake build`."
msgstr ""

#: src/hello-world/cat.md:49
msgid "Concatenating Streams"
msgstr ""

#: src/hello-world/cat.md:51
msgid ""
"Now that the basic skeleton of the program has been built, it's time to "
"actually enter the code. A proper implementation of `cat` can be used with "
"infinite IO streams, such as `/dev/random`, which means that it can't read "
"its input into memory before outputting it. Furthermore, it should not work "
"one character at a time, as this leads to frustratingly slow performance. "
"Instead, it's better to read contiguous blocks of data all at once, "
"directing the data to the standard output one block at a time."
msgstr ""

#: src/hello-world/cat.md:56
msgid ""
"The first step is to decide how big of a block to read. For the sake of "
"simplicity, this implementation uses a conservative 20 kilobyte block. "
"`USize` is analogous to `size_t` in C—it's an unsigned integer type that is "
"big enough to represent all valid array sizes."
msgstr ""

#: src/hello-world/cat.md:63
msgid "Streams"
msgstr ""

#: src/hello-world/cat.md:65
msgid ""
"The main work of `feline` is done by `dump`, which reads input one block at "
"a time, dumping the result to standard output, until the end of the input "
"has been reached:"
msgstr ""

#: src/hello-world/cat.md:76
msgid ""
"The `dump` function is declared `partial`, because it calls itself "
"recursively on input that is not immediately smaller than an argument. When "
"a function is declared to be partial, Lean does not require a proof that it "
"terminates. On the other hand, partial functions are also much less amenable "
"to proofs of correctness, because allowing infinite loops in Lean's logic "
"would make it unsound. However, there is no way to prove that `dump` "
"terminates, because infinite input (such as from `/dev/random`) would mean "
"that it does not, in fact, terminate. In cases like this, there is no "
"alternative to declaring the function `partial`."
msgstr ""

#: src/hello-world/cat.md:82
msgid ""
"The type `IO.FS.Stream` represents a POSIX stream. Behind the scenes, it is "
"represented as a structure that has one field for each POSIX stream "
"operation. Each operation is represented as an IO action that provides the "
"corresponding operation:"
msgstr ""

#: src/hello-world/cat.md:93
msgid ""
"The Lean compiler contains `IO` actions (such as `IO.getStdout`, which is "
"called in `dump`) to get streams that represent standard input, standard "
"output, and standard error. These are `IO` actions rather than ordinary "
"definitions because Lean allows these standard POSIX streams to be replaced "
"in a process, which makes it easier to do things like capturing the output "
"from a program into a string by writing a custom `IO.FS.Stream`."
msgstr ""

#: src/hello-world/cat.md:96
msgid ""
"The control flow in `dump` is essentially a `while` loop. When `dump` is "
"called, if the stream has reached the end of the file, `pure ()` terminates "
"the function by returning the constructor for `Unit`. If the stream has not "
"yet reached the end of the file, one block is read, and its contents are "
"written to `stdout`, after which `dump` calls itself directly. The recursive "
"calls continue until `stream.read` returns an empty byte array, which "
"indicates that the end of the file has been reached."
msgstr ""

#: src/hello-world/cat.md:101
msgid ""
"When an `if` expression occurs as a statement in a `do`, as in `dump`, each "
"branch of the `if` is implicitly provided with a `do`. In other words, the "
"sequence of steps following the `else` are treated as a sequence of `IO` "
"actions to be executed, just as if they had a `do` at the beginning. Names "
"introduced with `let` in the branches of the `if` are visible only in their "
"own branches, and are not in scope outside of the `if`."
msgstr ""

#: src/hello-world/cat.md:105
msgid ""
"There is no danger of running out of stack space while calling `dump` "
"because the recursive call happens as the very last step in the function, "
"and its result is returned directly rather than being manipulated or "
"computed with. This kind of recursion is called _tail recursion_, and it is "
"described in more detail [later in this "
"book](../programs-proofs/tail-recursion.md). Because the compiled code does "
"not need to retain any state, the Lean compiler can compile the recursive "
"call to a jump."
msgstr ""

#: src/hello-world/cat.md:109
msgid ""
"If `feline` only redirected standard input to standard output, then `dump` "
"would be sufficient. However, it also needs to be able to open files that "
"are provided as command-line arguments and emit their contents. When its "
"argument is the name of a file that exists, `fileStream` returns a stream "
"that reads the file's contents. When the argument is not a file, "
"`fileStream` emits an error and returns `none`."
msgstr ""

#: src/hello-world/cat.md:113
msgid ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := "
"do\n"
"  let fileExists ← filename.pathExists\n"
"  if not fileExists then\n"
"    let stderr ← IO.getStderr\n"
"    stderr.putStrLn s!\"File not found: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"
msgstr ""

#: src/hello-world/cat.md:124
msgid ""
"Opening a file as a stream takes two steps. First, a file handle is created "
"by opening the file in read mode. A Lean file handle tracks an underlying "
"file descriptor. When there are no references to the file handle value, a "
"finalizer closes the file descriptor. Second, the file handle is given the "
"same interface as a POSIX stream using `IO.FS.Stream.ofHandle`, which fills "
"each field of the `Stream` structure with the corresponding `IO` action that "
"works on file handles."
msgstr ""

#: src/hello-world/cat.md:130
msgid "Handling Input"
msgstr ""

#: src/hello-world/cat.md:132
msgid ""
"The main loop of `feline` is another tail-recursive function, called "
"`process`. In order to return a non-zero exit code if any of the inputs "
"could not be read, `process` takes an argument `exitCode` that represents "
"the current exit code for the whole program. Additionally, it takes a list "
"of input files to be processed."
msgstr ""

#: src/hello-world/cat.md:135
msgid ""
"```lean\n"
"def process (exitCode : UInt32) (args : List String) : IO UInt32 := do\n"
"  match args with\n"
"  | [] => pure exitCode\n"
"  | \"-\" :: args =>\n"
"    let stdin ← IO.getStdin\n"
"    dump stdin\n"
"    process exitCode args\n"
"  | filename :: args =>\n"
"    let stream ← fileStream ⟨filename⟩\n"
"    match stream with\n"
"    | none =>\n"
"      process 1 args\n"
"    | some stream =>\n"
"      dump stream\n"
"      process exitCode args\n"
"```"
msgstr ""

#: src/hello-world/cat.md:152
msgid ""
"Just as with `if`, each branch of a `match` that is used as a statement in a "
"`do` is implicitly provided with its own `do`."
msgstr ""

#: src/hello-world/cat.md:154
msgid ""
"There are three possibilities. One is that no more files remain to be "
"processed, in which case `process` returns the error code unchanged. Another "
"is that the specified filename is `\"-\"`, in which case `process` dumps the "
"contents of the standard input and then processes the remaining filenames. "
"The final possibility is that an actual filename was specified. In this "
"case, `fileStream` is used to attempt to open the file as a POSIX stream. "
"Its argument is encased in `⟨ ... ⟩` because a `FilePath` is a single-field "
"structure that contains a string. If the file could not be opened, it is "
"skipped, and the recursive call to `process` sets the exit code to `1`. If "
"it could, then it is dumped, and the recursive call to `process` leaves the "
"exit code unchanged."
msgstr ""

#: src/hello-world/cat.md:163
msgid ""
"`process` does not need to be marked `partial` because it is structurally "
"recursive. Each recursive call is provided with the tail of the input list, "
"and all Lean lists are finite. Thus, `process` does not introduce any "
"non-termination."
msgstr ""

#: src/hello-world/cat.md:167
msgid "Main"
msgstr ""

#: src/hello-world/cat.md:169
msgid ""
"The final step is to write the `main` action. Unlike prior examples, `main` "
"in `feline` is a function. In Lean, `main` can have one of three types:"
msgstr ""

#: src/hello-world/cat.md:172
msgid ""
"`main : IO Unit` corresponds to programs that cannot read their command-line "
"arguments and always indicate success with an exit code of `0`,"
msgstr ""

#: src/hello-world/cat.md:173
msgid ""
"`main : IO UInt32` corresponds to `int main(void)` in C, for programs "
"without arguments that return exit codes, and"
msgstr ""

#: src/hello-world/cat.md:174
msgid ""
"`main : List String → IO UInt32` corresponds to `int main(int argc, char "
"**argv)` in C, for programs that take arguments and signal success or "
"failure."
msgstr ""

#: src/hello-world/cat.md:176
msgid ""
"If no arguments were provided, `feline` should read from standard input as "
"if it were called with a single `\"-\"` argument. Otherwise, the arguments "
"should be processed one after the other."
msgstr ""

#: src/hello-world/cat.md:178
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 :=\n"
"  match args with\n"
"  | [] => process 0 [\"-\"]\n"
"  | _ =>  process 0 args\n"
"```"
msgstr ""

#: src/hello-world/cat.md:186
msgid "Meow!"
msgstr ""

#: src/hello-world/cat.md:188
msgid ""
"To check whether `feline` works, the first step is to build it with `lake "
"build`. First off, when called without arguments, it should emit what it "
"receives from standard input. Check that"
msgstr ""

#: src/hello-world/cat.md:191
msgid ""
"```\n"
"echo \"It works!\" | ./build/bin/feline\n"
"```"
msgstr ""

#: src/hello-world/cat.md:194
msgid "emits `It works!`."
msgstr ""

#: src/hello-world/cat.md:196
msgid ""
"Secondly, when called with files as arguments, it should print them. If the "
"file `test1.txt` contains"
msgstr ""

#: src/hello-world/cat.md:201
msgid "and `test2.txt` contains"
msgstr ""

#: src/hello-world/cat.md:205
msgid "then the command"
msgstr ""

#: src/hello-world/cat.md:209
msgid "should emit"
msgstr ""

#: src/hello-world/cat.md:215
msgid "Finally, the `-` argument should be handled appropriately."
msgstr ""

#: src/hello-world/cat.md:216
msgid ""
"```\n"
"echo \"and purr\" | ./build/bin/feline test1.txt - test2.txt\n"
"```"
msgstr ""

#: src/hello-world/cat.md:219 src/type-classes/out-params.md:188
msgid "should yield"
msgstr ""

#: src/hello-world/cat.md:228
msgid ""
"Extend `feline` with support for usage information. The extended version "
"should accept a command-line argument `--help` that causes documentation "
"about the available command-line options to be written to standard output."
msgstr ""

#: src/hello-world/conveniences.md:4
msgid "Nested Actions"
msgstr ""

#: src/hello-world/conveniences.md:6
msgid ""
"Many of the functions in `feline` exhibit a repetitive pattern in which an "
"`IO` action's result is given a name, and then used immediately and only "
"once. For instance, in `dump`:"
msgstr ""

#: src/hello-world/conveniences.md:18
msgid "the pattern occurs for `stdout`:"
msgstr ""

#: src/hello-world/conveniences.md:23
msgid "Similarly, `fileStream` contains the following snippet:"
msgstr ""

#: src/hello-world/conveniences.md:29
msgid ""
"When Lean is compiling a `do` block, expressions that consist of a left "
"arrow immediately under parentheses are lifted to the nearest enclosing "
"`do`, and their results are bound to a unique name. This unique name "
"replaces the origin of the expression. This means that `dump` can also be "
"written as follows:"
msgstr ""

#: src/hello-world/conveniences.md:41
msgid ""
"This version of `dump` avoids introducing names that are used only once, "
"which can greatly simplify a program. `IO` actions that Lean lifts from a "
"nested expression context are called _nested actions_."
msgstr ""

#: src/hello-world/conveniences.md:44
msgid "`fileStream` can be simplified using the same technique:"
msgstr ""

#: src/hello-world/conveniences.md:45
msgid ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := "
"do\n"
"  if not (← filename.pathExists) then\n"
"    (← IO.getStderr).putStrLn s!\"File not found: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"
msgstr ""

#: src/hello-world/conveniences.md:54
msgid ""
"In this case, the local name of `handle` could also have been eliminated "
"using nested actions, but the resulting expression would have been long and "
"complicated. Even though it's often good style to use nested actions, it can "
"still sometimes be helpful to name intermediate results."
msgstr ""

#: src/hello-world/conveniences.md:57
msgid ""
"It is important to remember, however, that nested actions are only a shorter "
"notation for `IO` actions that occur in a surrounding `do` block. The side "
"effects that are involved in executing them still occur in the same order, "
"and execution of side effects is not interspersed with the evaluation of "
"expressions. For an example of where this might be confusing, consider the "
"following helper definitions that return data after announcing to the world "
"that they have been executed:"
msgstr ""

#: src/hello-world/conveniences.md:60
msgid ""
"```lean\n"
"def getNumA : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"A\"\n"
"  pure 5\n"
"\n"
"def getNumB : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"B\"\n"
"  pure 7\n"
"```"
msgstr ""

#: src/hello-world/conveniences.md:69
msgid ""
"These definitions are intended to stand in for more complicated `IO` code "
"that might validate user input, read a database, or open a file."
msgstr ""

#: src/hello-world/conveniences.md:71
msgid ""
"A program that prints `0` when number A is five, or number `B` otherwise, "
"can be written as follows:"
msgstr ""

#: src/hello-world/conveniences.md:72
msgid ""
"```lean\n"
"def test : IO Unit := do\n"
"  let a : Nat := if (← getNumA) == 5 then 0 else (← getNumB)\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"
msgstr ""

#: src/hello-world/conveniences.md:77
msgid ""
"However, this program probably has more side effects (such as prompting for "
"user input or reading a database) than was intended. The definition of "
"`getNumA` makes it clear that it will always return `5`, and thus the "
"program should not read number B. However, running the program results in "
"the following output:"
msgstr ""

#: src/hello-world/conveniences.md:85
msgid "`getNumB` was executed because `test` is equivalent to this definition:"
msgstr ""

#: src/hello-world/conveniences.md:86
msgid ""
"```lean\n"
"def test : IO Unit := do\n"
"  let x ← getNumA\n"
"  let y ← getNumB\n"
"  let a : Nat := if x == 5 then 0 else y\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"
msgstr ""

#: src/hello-world/conveniences.md:93
msgid ""
"This is due to the rule that nested actions are lifted to the _closest "
"enclosing_ `do` block. The branches of the `if` were not implicitly wrapped "
"in `do` blocks because the `if` is not itself a statement in the `do` "
"block—the statement is the `let` that defines `a`. Indeed, they could not be "
"wrapped this way, because the type of the conditional expression is `Nat`, "
"not `IO Nat`."
msgstr ""

#: src/hello-world/conveniences.md:97
msgid "Flexible Layouts for `do`"
msgstr ""

#: src/hello-world/conveniences.md:99
msgid ""
"In Lean, `do` expressions are whitespace-sensitive. Each `IO` action or "
"local binding in the `do` is expected to start on its own line, and they "
"should all have the same indentation. Almost all uses of `do` should be "
"written this way. In some rare contexts, however, manual control over "
"whitespace and indentation may be necessary, or it may be convenient to have "
"multiple small actions on a single line. In these cases, newlines can be "
"replaced with a semicolon and indentation can be replaced with curly braces."
msgstr ""

#: src/hello-world/conveniences.md:105
msgid "For instance, all of the following programs are equivalent:"
msgstr ""

#: src/hello-world/conveniences.md:106
msgid ""
"```lean\n"
"-- This version uses only whitespace-sensitive layout\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"\n"
"-- This version is as explicit as possible\n"
"def main : IO Unit := do {\n"
"  let stdin ← IO.getStdin;\n"
"  let stdout ← IO.getStdout;\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\";\n"
"  let name := (← stdin.getLine).trim;\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"}\n"
"\n"
"-- This version uses a semicolon to put two actions on the same line\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin; let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""

#: src/hello-world/conveniences.md:135
msgid "Idiomatic Lean code uses curly braces with `do` very rarely."
msgstr ""

#: src/hello-world/conveniences.md:137
msgid "Running `IO` Actions With `#eval`"
msgstr ""

#: src/hello-world/conveniences.md:139
msgid ""
"Lean's `#eval` command can be used to execute `IO` actions, rather than just "
"evaluating them. Normally, adding a `#eval` command to a Lean file causes "
"Lean to evaluate the provided expression, convert the resulting value to a "
"string, and provide that string as a tooltip and in the info window. Rather "
"than failing because `IO` actions can't be converted to strings, `#eval` "
"executes them, carrying out their side effects. If the result of execution "
"is the `Unit` value `()`, then no result string is shown, but if it is a "
"type that can be converted to a string, then Lean displays the resulting "
"value."
msgstr ""

#: src/hello-world/conveniences.md:144
msgid ""
"This means that, given the prior definitions of `countdown` and `runActions`,"
msgstr ""

#: src/hello-world/conveniences.md:148
msgid "displays"
msgstr ""

#: src/hello-world/conveniences.md:155
msgid ""
"This is the output produced by running the `IO` action, rather than some "
"opaque representation of the action itself. In other words, for `IO` "
"actions, `#eval` both _evaluates_ the provided expression and _executes_ the "
"resulting action value."
msgstr ""

#: src/hello-world/conveniences.md:158
msgid ""
"Quickly testing `IO` actions with `#eval` can be much more convenient that "
"compiling and running whole programs. However, there are some limitations. "
"For instance, reading from standard input simply returns empty input. "
"Additionally, the `IO` action is re-executed whenever Lean needs to update "
"the diagnostic information that it provides to users, and this can happen at "
"unpredictable times. An action that reads and writes files, for instance, "
"may do so at inconvenient times."
msgstr ""

#: src/hello-world/summary.md:3
msgid "Evaluation vs Execution"
msgstr ""

#: src/hello-world/summary.md:5
msgid ""
"Side effects are aspects of program execution that go beyond the evaluation "
"of mathematical expressions, such as reading files, throwing exceptions, or "
"triggering industrial machinery. While most languages allow side effects to "
"occur during evaluation, Lean does not. Instead, Lean has a type called `IO` "
"that represents _descriptions_ of programs that use side effects. These "
"descriptions are then executed by the language's run-time system, which "
"invokes the Lean expression evaluator to carry out specific computations. "
"Values of type `IO α` are called _`IO` actions_. The simplest is `pure`, "
"which returns its argument and has no actual side effects."
msgstr ""

#: src/hello-world/summary.md:12
msgid ""
"`IO` actions can also be understood as functions that take the whole world "
"as an argument and return a new world in which the side effect has occurred. "
"Behind the scenes, the `IO` library ensures that the world is never "
"duplicated, created, or destroyed. While this model of side effects cannot "
"actually be implemented, as the whole universe is too big to fit in memory, "
"the real world can be represented by a token that is passed around through "
"the program."
msgstr ""

#: src/hello-world/summary.md:16
msgid ""
"An `IO` action `main` is executed when the program starts. `main` can have "
"one of three types:"
msgstr ""

#: src/hello-world/summary.md:18
msgid ""
"`main : IO Unit` is used for simple programs that cannot read their "
"command-line arguments and always return exit code `0`,"
msgstr ""

#: src/hello-world/summary.md:19
msgid ""
"`main : IO UInt32` is used for programs without arguments that may signal "
"success or failure, and"
msgstr ""

#: src/hello-world/summary.md:20
msgid ""
"`main : List String → IO UInt32` is used for programs that take command-line "
"arguments and signal success or failure."
msgstr ""

#: src/hello-world/summary.md:23
msgid "`do` Notation"
msgstr ""

#: src/hello-world/summary.md:25
msgid ""
"The Lean standard library provides a number of basic `IO` actions that "
"represent effects such as reading from and writing to files and interacting "
"with standard input and standard output. These base `IO` actions are "
"composed into larger `IO` actions using `do` notation, which is a built-in "
"domain-specific language for writing descriptions of programs with side "
"effects. A `do` expression contains a sequence of _statements_, which may be:"
msgstr ""

#: src/hello-world/summary.md:28
msgid "expressions that represent `IO` actions,"
msgstr ""

#: src/hello-world/summary.md:29
msgid ""
"ordinary local definitions with `let` and `:=`, where the defined name "
"refers to the value of the provided expression, or"
msgstr ""

#: src/hello-world/summary.md:30
msgid ""
"local definitions with `let` and `←`, where the defined name refers to the "
"result of executing the value of the provided expression."
msgstr ""

#: src/hello-world/summary.md:32
msgid ""
"`IO` actions that are written with `do` are executed one statement at a time."
msgstr ""

#: src/hello-world/summary.md:34
msgid ""
"Furthermore, `if` and `match` expressions that occur immediately under a "
"`do` are implicitly considered to have their own `do` in each branch. Inside "
"of a `do` expression, _nested actions_ are expressions with a left arrow "
"immediately under parentheses. The Lean compiler implicitly lifts them to "
"the nearest enclosing `do`, which may be implicitly part of a branch of a "
"`match` or `if` expression, and gives them a unique name. This unique name "
"then replaces the origin site of the nested action."
msgstr ""

#: src/hello-world/summary.md:40
msgid "Compiling and Running Programs"
msgstr ""

#: src/hello-world/summary.md:42
msgid ""
"A Lean program that consists of a single file with a `main` definition can "
"be run using `lean --run FILE`. While this can be a nice way to get started "
"with a simple program, most programs will eventually graduate to a "
"multiple-file project that should be compiled before running."
msgstr ""

#: src/hello-world/summary.md:45
msgid ""
"Lean projects are organized into _packages_, which are collections of "
"libraries and executables together with information about dependencies and a "
"build configuration. Packages are described using Lake, a Lean build tool. "
"Use `lake new` to create a Lake package in a new directory, or `lake init` "
"to create one in the current directory. Lake package configuration is "
"another domain-specific language. Use `lake build` to build a project."
msgstr ""

#: src/hello-world/summary.md:51
msgid "Partiality"
msgstr ""

#: src/hello-world/summary.md:53
msgid ""
"One consequence of following the mathematical model of expression evaluation "
"is that every expression must have a value. This rules out both incomplete "
"pattern matches that fail to cover all constructors of a datatype and "
"programs that can fall into an infinite loop. Lean ensures that all `match` "
"expressions cover all cases, and that all recursive functions are either "
"structurally recursive or have an explicit proof of termination."
msgstr ""

#: src/hello-world/summary.md:57
msgid ""
"However, some real programs require the possibility of looping infinitely, "
"because they handle potentially-infinite data, such as POSIX streams. Lean "
"provides an escape hatch: functions whose definition is marked `partial` are "
"not required to terminate. This comes at a cost. Because types are a "
"first-class part of the Lean language, functions can return types. Partial "
"functions, however, are not evaluated during type checking, because an "
"infinite loop in a function could cause the type checker to enter an "
"infinite loop. Furthermore, mathematical proofs are unable to inspect the "
"definitions of partial functions, which means that programs that use them "
"are much less amenable to formal proof."
msgstr ""

#: src/props-proofs-indexing.md:3
msgid ""
"Like many languages, Lean uses square brackets for indexing into arrays and "
"lists. For instance, if `woodlandCritters` is defined as follows:"
msgstr ""

#: src/props-proofs-indexing.md:5
msgid ""
"```lean\n"
"def woodlandCritters : List String :=\n"
"  [\"hedgehog\", \"deer\", \"snail\"]\n"
"```"
msgstr ""

#: src/props-proofs-indexing.md:9
msgid "then the individual components can be extracted:"
msgstr ""

#: src/props-proofs-indexing.md:15
msgid ""
"However, attempting to extract the fourth element results in a compile-time "
"error, rather than a run-time error:"
msgstr ""

#: src/props-proofs-indexing.md:27
msgid ""
"This error message is saying Lean tried to automatically mathematically "
"prove that `3 < List.length woodlandCritters`, which would mean that the "
"lookup was safe, but that it could not do so. Out-of-bounds errors are a "
"common class of bugs, and Lean uses its dual nature as a programming "
"language and a theorem prover to rule out as many as possible."
msgstr ""

#: src/props-proofs-indexing.md:30
msgid ""
"Understanding how this works requires an understanding of three key ideas: "
"propositions, proofs, and tactics."
msgstr ""

#: src/props-proofs-indexing.md:32
msgid "Propositions and Proofs"
msgstr ""

#: src/props-proofs-indexing.md:34
msgid ""
"A _proposition_ is a statement that can be true or false. All of the "
"following are propositions:"
msgstr ""

#: src/props-proofs-indexing.md:37
msgid "1 + 1 = 2"
msgstr ""

#: src/props-proofs-indexing.md:38
msgid "Addition is commutative"
msgstr ""

#: src/props-proofs-indexing.md:39
msgid "There are infinitely many prime numbers"
msgstr ""

#: src/props-proofs-indexing.md:40
msgid "1 + 1 = 15"
msgstr ""

#: src/props-proofs-indexing.md:41
msgid "Paris is the capital of France"
msgstr ""

#: src/props-proofs-indexing.md:42
msgid "Buenos Aires is the capital of South Korea"
msgstr ""

#: src/props-proofs-indexing.md:43
msgid "All birds can fly"
msgstr ""

#: src/props-proofs-indexing.md:45
msgid ""
"On the other hand, nonsense statements are not propositions. None of the "
"following are propositions:"
msgstr ""

#: src/props-proofs-indexing.md:48
msgid "1 + green = ice cream"
msgstr ""

#: src/props-proofs-indexing.md:49
msgid "All capital cities are prime numbers"
msgstr ""

#: src/props-proofs-indexing.md:50
msgid "At least one gorg is a fleep"
msgstr ""

#: src/props-proofs-indexing.md:52
msgid ""
"Propositions come in two varieties: those that are purely mathematical, "
"relying only on our definitions of concepts, and those that are facts about "
"the world. Theorem provers like Lean are concerned with the former category, "
"and have nothing to say about the flight capabilities of penguins or the "
"legal status of cities."
msgstr ""

#: src/props-proofs-indexing.md:55
msgid ""
"A _proof_ is a convincing argument that a proposition is true. For "
"mathematical propositions, these arguments make use of the definitions of "
"the concepts that are involved as well as the rules of logical "
"argumentation. Most proofs are written for people to understand, and leave "
"out many tedious details. Computer-aided theorem provers like Lean are "
"designed to allow mathematicians to write proofs while omitting many "
"details, and it is the software's responsibility to fill in the missing "
"explicit steps. This decreases the likelihood of oversights or mistakes."
msgstr ""

#: src/props-proofs-indexing.md:61
msgid ""
"In Lean, a program's type describes the ways it can be interacted with. For "
"instance, a program of type `Nat → List String` is a function that takes a "
"`Nat` argument and produces a list of strings. In other words, each type "
"specifies what counts as a program with that type."
msgstr ""

#: src/props-proofs-indexing.md:65
msgid ""
"In Lean, propositions are in fact types. They specify what counts as "
"evidence that the statement is true. The proposition is proved by providing "
"this evidence. On the other hand, if the proposition is false, then it will "
"be impossible to construct this evidence."
msgstr ""

#: src/props-proofs-indexing.md:70
msgid ""
"For example, the proposition \"1 + 1 = 2\" can be written directly in Lean. "
"The evidence for this proposition is the constructor `rfl`, which is short "
"for _reflexivity_:"
msgstr ""

#: src/props-proofs-indexing.md:75
msgid ""
"On the other hand, `rfl` does not prove the false proposition \"1 + 1 = 15\":"
msgstr ""

#: src/props-proofs-indexing.md:87
msgid ""
"This error message indicates that `rfl` can prove that two expressions are "
"equal when both sides of the equality statement are already the same number. "
"Because `1 + 1` evaluates directly to `2`, they are considered to be the "
"same, which allows `onePlusOneIsTwo` to be accepted. Just as `Type` "
"describes types such as `Nat`, `String`, and `List (Nat × String × (Int → "
"Float))` that represent data structures and functions, `Prop` describes "
"propositions."
msgstr ""

#: src/props-proofs-indexing.md:91
msgid ""
"When a proposition has been proven, it is called a _theorem_. In Lean, it is "
"conventional to declare theorems with the `theorem` keyword instead of "
"`def`. This helps readers see which declarations are intended to be read as "
"mathematical proofs, and which are definitions. Generally speaking, with a "
"proof, what matters is that there is evidence that a proposition is true, "
"but it's not particularly important _which_ evidence was provided. With "
"definitions, on the other hand, it matters very much which particular value "
"is selected—after all, a definition of addition that always returns `0` is "
"clearly wrong."
msgstr ""

#: src/props-proofs-indexing.md:97
msgid "The prior example could be rewritten as follows:"
msgstr ""

#: src/props-proofs-indexing.md:104
msgid "Tactics"
msgstr ""

#: src/props-proofs-indexing.md:106
msgid ""
"Proofs are normally written using _tactics_, rather than by providing "
"evidence directly. Tactics are small programs that construct evidence for a "
"proposition. These programs run in a _proof state_ that tracks the statement "
"that is to be proved (called the _goal_) along with the assumptions that are "
"available to prove it. Running a tactic on a goal results in a new proof "
"state that contains new goals. The proof is complete when all goals have "
"been proven."
msgstr ""

#: src/props-proofs-indexing.md:112
msgid ""
"To write a proof with tactics, begin the definition with `by`. Writing `by` "
"puts Lean into tactic mode until the end of the next indented block. While "
"in tactic mode, Lean provides ongoing feedback about the current proof "
"state. Written with tactics, `onePlusOneIsTwo` is still quite short:"
msgstr ""

#: src/props-proofs-indexing.md:120
msgid ""
"The `simp` tactic, short for \"simplify\", is the workhorse of Lean proofs. "
"It rewrites the goal to as simple a form as possible, taking care of parts "
"of the proof that are small enough. In particular, it proves simple equality "
"statements. Behind the scenes, a detailed formal proof is constructed, but "
"using `simp` hides this complexity."
msgstr ""

#: src/props-proofs-indexing.md:125
msgid "Tactics are useful for a number of reasons:"
msgstr ""

#: src/props-proofs-indexing.md:126
msgid ""
"Many proofs are complicated and tedious when written out down to the "
"smallest detail, and tactics can automate these uninteresting parts."
msgstr ""

#: src/props-proofs-indexing.md:127
msgid ""
"Proofs written with tactics are easier to maintain over time, because "
"flexible automation can paper over small changes to definitions."
msgstr ""

#: src/props-proofs-indexing.md:128
msgid ""
"Because a single tactic can prove many different theorems, Lean can use "
"tactics behind the scenes to free users from writing proofs by hand. For "
"instance, an array lookup requires a proof that the index is in bounds, and "
"a tactic can typically construct that proof without the user needing to "
"worry about it."
msgstr ""

#: src/props-proofs-indexing.md:130
msgid ""
"Behind the scenes, indexing notation uses a tactic to prove that the user's "
"lookup operation is safe. This tactic is `simp`, configured to take certain "
"arithmetic identities into account."
msgstr ""

#: src/props-proofs-indexing.md:134
msgid "Connectives"
msgstr ""

#: src/props-proofs-indexing.md:136
msgid ""
"The basic building blocks of logic, such as \"and\", \"or\", \"true\", "
"\"false\", and \"not\", are called _logical connectives_. Each connective "
"defines what counts as evidence of its truth. For example, to prove a "
"statement \"_A_ and _B_\", one must prove both _A_ and _B_. This means that "
"evidence for \"_A_ and _B_\" is a pair that contains both evidence for _A_ "
"and evidence for _B_. Similarly, evidence for \"_A_ or _B_\" consists of "
"either evidence for _A_ or evidence for _B_."
msgstr ""

#: src/props-proofs-indexing.md:142
msgid ""
"In particular, most of these connectives are defined like datatypes, and "
"they have constructors. If `A` and `B` are propositions, then \"`A` and "
"`B`\" (written `A ∧ B`) is a proposition. Evidence for `A ∧ B` consists of "
"the constructor `And.intro`, which has the type `A → B → A ∧ B`. Replacing "
"`A` and `B` with concrete propositions, it is possible to prove `1 + 1 = 2 ∧ "
"\"Str\".append \"ing\" = \"String\"` with `And.intro rfl rfl`. Of course, "
"`simp` is also powerful enough to find this proof:"
msgstr ""

#: src/props-proofs-indexing.md:147
msgid ""
"```leantac\n"
"theorem addAndAppend : 1 + 1 = 2 ∧ \"Str\".append \"ing\" = \"String\" := by "
"simp\n"
"```"
msgstr ""

#: src/props-proofs-indexing.md:151
msgid ""
"Similarly, \"`A` or `B`\" (written `A ∨ B`) has two constructors, because a "
"proof of \"`A` or `B`\" requires only that one of the two underlying "
"propositions be true. There are two constructors: `Or.inl`, with type `A → A "
"∨ B`, and `Or.inr`, with type `B → A ∨ B`."
msgstr ""

#: src/props-proofs-indexing.md:154
msgid ""
"Implication (if _A_ then _B_) is represented using functions. In particular, "
"a function that transforms evidence for _A_ into evidence for _B_ is itself "
"evidence that _A_ implies _B_. This is different from the usual description "
"of implication, in which `A → B` is shorthand for `¬A ∨ B`, but the two "
"formulations are equivalent."
msgstr ""

#: src/props-proofs-indexing.md:158
msgid ""
"Because evidence for an \"and\" is a constructor, it can be used with "
"pattern matching. For instance, a proof that _A_ and _B_ implies _A_ or _B_ "
"is a function that pulls the evidence of _A_ (or of _B_) out of the evidence "
"for _A_ and _B_, and then uses this evidence to produce evidence of _A_ or "
"_B_:"
msgstr ""

#: src/props-proofs-indexing.md:168
msgid "Connective"
msgstr ""

#: src/props-proofs-indexing.md:168
msgid "Lean Syntax"
msgstr ""

#: src/props-proofs-indexing.md:168
msgid "Evidence"
msgstr ""

#: src/props-proofs-indexing.md:170
msgid "True"
msgstr ""

#: src/props-proofs-indexing.md:170
msgid "`True`"
msgstr ""

#: src/props-proofs-indexing.md:170
msgid "`True.intro : True`"
msgstr ""

#: src/props-proofs-indexing.md:171
msgid "False"
msgstr ""

#: src/props-proofs-indexing.md:171
msgid "`False`"
msgstr ""

#: src/props-proofs-indexing.md:171
msgid "No evidence"
msgstr ""

#: src/props-proofs-indexing.md:172
msgid "_A_ and _B_"
msgstr ""

#: src/props-proofs-indexing.md:172
msgid "`A ∧ B`"
msgstr ""

#: src/props-proofs-indexing.md:172
msgid "`And.intro : A → B → A ∧ B`"
msgstr ""

#: src/props-proofs-indexing.md:173
msgid "_A_ or _B_"
msgstr ""

#: src/props-proofs-indexing.md:173
msgid "`A ∨ B`"
msgstr ""

#: src/props-proofs-indexing.md:173
msgid "Either `Or.inl : A → A ∨ B` or `Or.inr : B → A ∨ B`"
msgstr ""

#: src/props-proofs-indexing.md:174
msgid "_A_ implies _B_"
msgstr ""

#: src/props-proofs-indexing.md:174
msgid "`A → B`"
msgstr ""

#: src/props-proofs-indexing.md:174
msgid "A function that transforms evidence of _A_ into evidence of _B_"
msgstr ""

#: src/props-proofs-indexing.md:175
msgid "not _A_"
msgstr ""

#: src/props-proofs-indexing.md:175
msgid "`¬A`"
msgstr ""

#: src/props-proofs-indexing.md:175
msgid "A function that would transform evidence of _A_ into evidence of `False`"
msgstr ""

#: src/props-proofs-indexing.md:177
msgid ""
"The `simp` tactic can prove theorems that use these connectives. For example:"
msgstr ""

#: src/props-proofs-indexing.md:187
msgid "Evidence as Arguments"
msgstr ""

#: src/props-proofs-indexing.md:189
msgid ""
"While `simp` does a great job proving propositions that involve equalities "
"and inequalities of specific numbers, it is not very good at proving "
"statements that involve variables. For instance, `simp` can prove that `4 < "
"15`, but it can't easily tell that because `x < 4`, it's also true that `x < "
"15`. Because index notation uses `simp` behind the scenes to prove that "
"array access is safe, it can require a bit of hand-holding."
msgstr ""

#: src/props-proofs-indexing.md:193
msgid ""
"One of the easiest ways to make indexing notation work well is to have the "
"function that performs a lookup into a data structure take the required "
"evidence of safety as an argument. For instance, a function that returns the "
"third entry in a list is not generally safe because lists might contain "
"zero, one, or two entries:"
msgstr ""

#: src/props-proofs-indexing.md:208
msgid ""
"However, the obligation to show that the list has at least three entries can "
"be imposed on the caller by adding an argument that consists of evidence "
"that the indexing operation is safe:"
msgstr ""

#: src/props-proofs-indexing.md:212
msgid ""
"In this example, `xs.length > 2` is not a program that checks _whether_ `xs` "
"has more than 2 entries. It is a proposition that could be true or false, "
"and the argument `ok` must be evidence that it is true."
msgstr ""

#: src/props-proofs-indexing.md:215
msgid ""
"When the function is called on a concrete list, its length is known. In "
"these cases, `by simp` can construct the evidence automatically:"
msgstr ""

#: src/props-proofs-indexing.md:220
msgid ""
"```output info\n"
"\"snail\"\n"
"```"
msgstr ""

#: src/props-proofs-indexing.md:224
msgid "Indexing Without Evidence"
msgstr ""

#: src/props-proofs-indexing.md:226
msgid ""
"In cases where it's not practical to prove that an indexing operation is in "
"bounds, there are other alternatives. Adding a question mark results in an "
"`Option`, where the result is `some` if the index is in bounds, and `none` "
"otherwise. For example:"
msgstr ""

#: src/props-proofs-indexing.md:234
msgid ""
"```output info\n"
"some \"snail\"\n"
"```"
msgstr ""

#: src/props-proofs-indexing.md:237
msgid ""
"```lean\n"
"#eval thirdOption [\"only\", \"two\"]\n"
"```"
msgstr ""

#: src/props-proofs-indexing.md:244
msgid ""
"There is also a version that crashes the program when the index is out of "
"bounds, rather than returning an `Option`:"
msgstr ""

#: src/props-proofs-indexing.md:248
msgid ""
"```output info\n"
"\"deer\"\n"
"```"
msgstr ""

#: src/props-proofs-indexing.md:251
msgid ""
"Be careful! Because code that is run with `#eval` runs in the context of the "
"Lean compiler, selecting the wrong index can crash your IDE."
msgstr ""

#: src/props-proofs-indexing.md:256
msgid ""
"In addition to the error that occurs when Lean is unable to find "
"compile-time evidence that an indexing operation is safe, polymorphic "
"functions that use unsafe indexing may produce the following message:"
msgstr ""

#: src/props-proofs-indexing.md:264
msgid ""
"This is due to a technical restriction that is part of keeping Lean usable "
"as both a logic for proving theorems and a programming language. In "
"particular, only programs whose types contain at least one value are allowed "
"to crash. This is because a proposition in Lean is a kind of type that "
"classifies evidence of its truth. False propositions have no such evidence. "
"If a program with an empty type could crash, then that crashing program "
"could be used as a kind of fake evidence for a false proposition."
msgstr ""

#: src/props-proofs-indexing.md:270
msgid ""
"Internally, Lean contains a table of types that are known to have at least "
"one value. This error is saying that some arbitrary type `α` is not "
"necessarily in that table. The next chapter describes how to add to this "
"table, and how to successfully write functions like `unsafeThird`."
msgstr ""

#: src/props-proofs-indexing.md:274
msgid ""
"Adding whitespace between a list and the brackets used for lookup can cause "
"another message:"
msgstr ""

#: src/props-proofs-indexing.md:284
msgid ""
"Adding a space causes Lean to treat the expression as a function "
"application, and the index as a list that contains a single number. This "
"error message results from having Lean attempt to treat `woodlandCritters` "
"as a function."
msgstr ""

#: src/props-proofs-indexing.md:289
msgid ""
"Prove the following theorems using `rfl`: `2 + 3 = 5`, `15 - 8 = 7`, "
"`\"Hello, \".append \"world\" = \"Hello, world\"`. What happens if `rfl` is "
"used to prove `5 < 18`? Why?"
msgstr ""

#: src/props-proofs-indexing.md:290
msgid ""
"Prove the following theorems using `by simp`: `2 + 3 = 5`, `15 - 8 = 7`, "
"`\"Hello, \".append \"world\" = \"Hello, world\"`, `5 < 18`."
msgstr ""

#: src/props-proofs-indexing.md:291
msgid ""
"Write a function that looks up the fifth entry in a list. Pass the evidence "
"that this lookup is safe as an argument to the function."
msgstr ""

#: src/type-classes.md:3
msgid ""
"In many languages, the built-in datatypes get special treatment. For "
"example, in C and Java, `+` can be used to add `float`s and `int`s, but not "
"arbitrary-precision numbers from a third-party library. Similarly, numeric "
"literals can be used directly for the built-in types, but not for "
"user-defined number types. Other languages provide an _overloading_ "
"mechanism for operators, where the same operator can be given a meaning for "
"a new type. In these languages, such as C++ and C#, a wide variety of "
"built-in operators can be overloaded, and the compiler uses the type checker "
"to select a particular implementation."
msgstr ""

#: src/type-classes.md:9
msgid ""
"In addition to numeric literals and operators, many languages allow "
"overloading of functions or methods. In C++, Java, C# and Kotlin, multiple "
"implementations of a method are allowed, with differing numbers and types of "
"arguments. The compiler uses the number of arguments and their types to "
"determine which overload was intended."
msgstr ""

#: src/type-classes.md:13
msgid ""
"Function and operator overloading has a key limitation: polymorphic "
"functions can't restrict their type arguments to types for which a given "
"overload exists. For example, an overloaded method might be defined for "
"strings, byte arrays, and file pointers, but there's no way to write a "
"second method that works for any of these. Instead, this second method must "
"itself be overloaded for each type that has an overload of the original "
"method, resulting in many boilerplate definitions instead of a single "
"polymorphic definition. Another consequence of this restriction is that some "
"operators (such as equality in Java) end up being defined for _every_ "
"combination of arguments, even when it is not necessarily sensible to do so. "
"If programmers are not very careful, this can lead to programs that crash at "
"runtime or silently compute an incorrect result."
msgstr ""

#: src/type-classes.md:19
msgid ""
"Lean implements overloading using a mechanism called _type classes_, "
"pioneered in Haskell, that allows overloading of operators, functions, and "
"literals in a manner that works well with polymorphism. A type class "
"describes a collection of overloadable operations. To overload these "
"operations for a new type, an _instance_ is created that contains an "
"implementation of each operation for the new type. For example, a type class "
"named `Add` describes types that allow addition, and an instance of `Add` "
"for `Nat` provides an implementation of addition for `Nat`."
msgstr ""

#: src/type-classes.md:24
msgid ""
"The terms _class_ and _instance_ can be confusing for those who are used to "
"object-oriented languages, because they are not closely related to classes "
"and instances in object-oriented languages. However, they do share common "
"roots: in everyday language, the term \"class\" refers to a group that "
"shares some common attributes. While classes in object-oriented programming "
"certainly describe groups of objects with common attributes, the term "
"additionally refers to a specific mechanism in a programming language for "
"describing such a group. Type classes are also a means of describing types "
"that share common attributes (namely, implementations of certain "
"operations), but they don't really have anything else in common with classes "
"as found in object-oriented programming."
msgstr ""

#: src/type-classes.md:29
msgid ""
"A Lean type class is much more analogous to a Java or C# _interface_. Both "
"type classes and interfaces describe a conceptually related set of "
"operations that are implemented for a type or collection of types. "
"Similarly, an instance of a type class is akin to the code in a Java or C# "
"class that is prescribed by the implemented interfaces, rather than an "
"instance of a Java or C# class. Unlike Java or C#'s interfaces, types can be "
"given instances for type classes that the author of the type does not have "
"access to. In this way, they are very similar to Rust traits."
msgstr ""

#: src/type-classes/pos.md:3
msgid ""
"In some applications, only positive numbers make sense. For example, "
"compilers and interpreters typically use one-indexed line and column numbers "
"for source positions, and a datatype that represents only non-empty lists "
"will never report a length of zero. Rather than relying on natural numbers, "
"and littering the code with assertions that the number is not zero, it can "
"be useful to design a datatype that represents only positive numbers."
msgstr ""

#: src/type-classes/pos.md:7
msgid ""
"One way to represent positive numbers is very similar to `Nat`, except with "
"`one` as the base case instead of `zero`:"
msgstr ""

#: src/type-classes/pos.md:13
msgid ""
"This datatype represents exactly the intended set of values, but it is not "
"very convenient to use. For example, numeric literals are rejected:"
msgstr ""

#: src/type-classes/pos.md:22
msgid "Instead, the constructors must be used directly:"
msgstr ""

#: src/type-classes/pos.md:28
msgid "Similarly, addition and multiplication are not easy to use:"
msgstr ""

#: src/type-classes/pos.md:44
msgid ""
"Each of these error messages begins with `failed to synthesize instance`. "
"This indicates that the error is due to an overloaded operation that has not "
"been implemented, and it describes the type class that must be implemented."
msgstr ""

#: src/type-classes/pos.md:47
msgid "Classes and Instances"
msgstr ""

#: src/type-classes/pos.md:49
msgid ""
"A type class consists of a name, some parameters, and a collection of "
"_methods_. The parameters describe the types for which overloadable "
"operations are being defined, and the methods are the names and type "
"signatures of the overloadable operations. Once again, there is a "
"terminology clash with object-oriented languages. In object-oriented "
"programming, a method is essentially a function that is connected to a "
"particular object in memory, with special access to the object's private "
"state. Objects are interacted with via their methods. In Lean, the term "
"\"method\" refers to an operation that has been declared to be overloadable, "
"with no special connection to objects or values or private fields."
msgstr ""

#: src/type-classes/pos.md:56
msgid ""
"One way to overload addition is to define a type class named `Plus`, with an "
"addition method named `plus`. Once an instance of `Plus` for `Nat` has been "
"defined, it becomes possible to add two `Nat`s using `Plus.plus`:"
msgstr ""

#: src/type-classes/pos.md:64
msgid "Adding more instances allows `Plus.plus` to take more types of arguments."
msgstr ""

#: src/type-classes/pos.md:66
msgid ""
"In the following type class declaration, `Plus` is the name of the class, `α "
": Type` is the only argument, and `plus : α → α → α` is the only method:"
msgstr ""

#: src/type-classes/pos.md:71
msgid ""
"This declaration says that there is a type class `Plus` that overloads "
"operations with respect to a type `α`. In particular, there is one "
"overloaded operation called `plus` that takes two `α`s and returns an `α`."
msgstr ""

#: src/type-classes/pos.md:74
msgid ""
"Type classes are first class, just as types are first class. In particular, "
"a type class is another kind of type. The type of `Plus` is `Type → Type`, "
"because it takes a type as an argument (`α`) and results in a new type that "
"describes the overloading of `Plus`'s operation for `α`."
msgstr ""

#: src/type-classes/pos.md:79
msgid "To overload `plus` for a particular type, write an instance:"
msgstr ""

#: src/type-classes/pos.md:84
msgid ""
"The colon after `instance` indicates that `Plus Nat` is indeed a type. Each "
"method of class `Plus` should be assigned a value using `:=`. In this case, "
"there is only one method: `plus`."
msgstr ""

#: src/type-classes/pos.md:88
msgid ""
"By default, type class methods are defined in a namespace with the same name "
"as the type class. It can be convenient to `open` the namespace so that "
"users don't need to type the name of the class first. Parentheses in an "
"`open` command indicate that only the indicated names from the namespace are "
"to be made accessible:"
msgstr ""

#: src/type-classes/pos.md:100
msgid ""
"Defining an addition function for `Pos` and an instance of `Plus Pos` allows "
"`plus` to be used to add both `Pos` and `Nat` values:"
msgstr ""

#: src/type-classes/pos.md:112
msgid ""
"Because there is not yet an instance of `Plus Float`, attempting to add two "
"floating-point numbers with `plus` fails with a familiar message:"
msgstr ""

#: src/type-classes/pos.md:120
msgid ""
"These errors mean that Lean was unable to find an instance for a given type "
"class."
msgstr ""

#: src/type-classes/pos.md:122
msgid "Overloaded Addition"
msgstr ""

#: src/type-classes/pos.md:124
msgid ""
"Lean's built-in addition operator is syntactic sugar for a type class called "
"`HAdd`, which flexibly allows the arguments to addition to have different "
"types. `HAdd` is short for _heterogeneous addition_. For example, an `HAdd` "
"instance can be written to allow a `Nat` to be added to a `Float`, resulting "
"in a new `Float`. When a programmer writes `x + y`, it is interpreted as "
"meaning `HAdd.hAdd x y`."
msgstr ""

#: src/type-classes/pos.md:129
msgid ""
"While an understanding of the full generality of `HAdd` relies on features "
"that are discussed in [another section in this chapter](out-params.md), "
"there is a simpler type class called `Add` that does not allow the types of "
"the arguments to be mixed. The Lean libraries are set up so that an instance "
"of `Add` will be found when searching for an instance of `HAdd` in which "
"both arguments have the same type."
msgstr ""

#: src/type-classes/pos.md:132
msgid ""
"Defining an instance of `Add Pos` allows `Pos` values to use ordinary "
"addition syntax:"
msgstr ""

#: src/type-classes/pos.md:140
msgid "Conversion to Strings"
msgstr ""

#: src/type-classes/pos.md:142
msgid ""
"Another useful built-in class is called `ToString`. Instances of `ToString` "
"provide a standard way of converting values from a given type into strings. "
"For example, a `ToString` instance is used when a value occurs in an "
"interpolated string, and it determines how the `IO.println` function used at "
"the [beginning of the description of "
"`IO`](../hello-world/running-a-program.html#running-a-program) will display "
"a value."
msgstr ""

#: src/type-classes/pos.md:146
msgid ""
"For example, one way to convert a `Pos` into a `String` is to reveal its "
"inner structure. The function `posToString` takes a `Bool` that determines "
"whether to parenthesize uses of `Pos.succ`, which should be `true` in the "
"initial call to the function and `false` in all recursive calls."
msgstr ""

#: src/type-classes/pos.md:148
msgid ""
"```lean\n"
"def posToString (atTop : Bool) (p : Pos) : String :=\n"
"  let paren s := if atTop then s else \"(\" ++ s ++ \")\"\n"
"  match p with\n"
"  | Pos.one => \"Pos.one\"\n"
"  | Pos.succ n => paren s!\"Pos.succ {posToString false n}\"\n"
"```"
msgstr ""

#: src/type-classes/pos.md:155
msgid "Using this function for a `ToString` instance:"
msgstr ""

#: src/type-classes/pos.md:160
msgid "results in informative, yet overwhelming, output:"
msgstr ""

#: src/type-classes/pos.md:161
msgid ""
"```lean\n"
"#eval s!\"There are {seven}\"\n"
"```"
msgstr ""

#: src/type-classes/pos.md:164
msgid ""
"```output info\n"
"\"There are Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ "
"Pos.one)))))\"\n"
"```"
msgstr ""

#: src/type-classes/pos.md:168
msgid ""
"On the other hand, every positive number has a corresponding `Nat`. "
"Converting it to a `Nat` and then using the `ToString Nat` instance (that "
"is, the overloading of `toString` for `Nat`) is a quick way to generate much "
"shorter output:"
msgstr ""

#: src/type-classes/pos.md:170
msgid ""
"```lean\n"
"def Pos.toNat : Pos → Nat\n"
"  | Pos.one => 1\n"
"  | Pos.succ n => n.toNat + 1\n"
"\n"
"instance : ToString Pos where\n"
"  toString x := toString (x.toNat)\n"
"\n"
"#eval s!\"There are {seven}\"\n"
"```"
msgstr ""

#: src/type-classes/pos.md:180
msgid ""
"```output info\n"
"\"There are 7\"\n"
"```"
msgstr ""

#: src/type-classes/pos.md:183
msgid ""
"When more than one instance is defined, the most recent takes precedence. "
"Additionally, if a type has a `ToString` instance, then it can be used to "
"display the result of `#eval` even if the type in question was not defined "
"with `deriving Repr`, so `#eval seven` outputs `7`."
msgstr ""

#: src/type-classes/pos.md:186
msgid "Overloaded Multiplication"
msgstr ""

#: src/type-classes/pos.md:188
msgid ""
"For multiplication, there is a type class called `HMul` that allows mixed "
"argument types, just like `HAdd`. Just as `x + y` is interpreted as "
"`HAdd.hAdd x y`, `x * y` is interpreted as `HMul.hMul x y`. For the common "
"case of multiplication of two arguments with the same type, a `Mul` instance "
"suffices."
msgstr ""

#: src/type-classes/pos.md:192
msgid ""
"An instance of `Mul` allows ordinary multiplication syntax to be used with "
"`Pos`:"
msgstr ""

#: src/type-classes/pos.md:201
msgid "With this instance, multiplication works as expected:"
msgstr ""

#: src/type-classes/pos.md:211
msgid "Literal Numbers"
msgstr ""

#: src/type-classes/pos.md:213
msgid ""
"It is quite inconvenient to write out a sequence of constructors for "
"positive numbers. One way to work around the problem would be to provide a "
"function to convert a `Nat` into a `Pos`. However, this approach has "
"downsides. First off, because `Pos` cannot represent `0`, the resulting "
"function would either convert a `Nat` to a bigger number, or it would return "
"`Option Pos`. Neither is particularly convenient for users. Secondly, the "
"need to call the function explicitly would make programs that use positive "
"numbers much less convenient to write than programs that use `Nat`. Having a "
"trade-off between precise types and convenient APIs means that the precise "
"types become less useful."
msgstr ""

#: src/type-classes/pos.md:221
msgid ""
"In Lean, natural number literals are interpreted using a type class called "
"`OfNat`:"
msgstr ""

#: src/type-classes/pos.md:226
msgid ""
"This type class takes two arguments: `α` is the type for which a natural "
"number is overloaded, and the unnamed `Nat` argument is the actual literal "
"number that was encountered in the program. The method `ofNat` is then used "
"as the value of the numeric literal. Because the class contains the `Nat` "
"argument, it becomes possible to define only instances for those values "
"where the number makes sense."
msgstr ""

#: src/type-classes/pos.md:230
msgid ""
"`OfNat` demonstrates that the arguments to type classes do not need to be "
"types. Because types in Lean are first-class participants in the language "
"that can be passed as arguments to functions and given definitions with "
"`def` and `abbrev`, there is no barrier that prevents non-type arguments in "
"positions where a less-flexible language could not permit them. This "
"flexibility allows overloaded operations to be provided for particular "
"values as well as particular types."
msgstr ""

#: src/type-classes/pos.md:234
msgid ""
"For example, a sum type that represents natural numbers less than four can "
"be defined as follows:"
msgstr ""

#: src/type-classes/pos.md:243
msgid ""
"While it would not make sense to allow _any_ literal number to be used for "
"this type, numbers less than four clearly make sense:"
msgstr ""

#: src/type-classes/pos.md:257
msgid "With these instances, the following examples work:"
msgstr ""

#: src/type-classes/pos.md:270
msgid "On the other hand, out-of-bounds literals are still not allowed:"
msgstr ""

#: src/type-classes/pos.md:279
msgid ""
"For `Pos`, the `OfNat` instance should work for _any_ `Nat` other than "
"`Nat.zero`. Another way to phrase this is to say that for all natural "
"numbers `n`, the instance should work for `n + 1`. Just as names like `α` "
"automatically become implicit arguments to functions that Lean fills out on "
"its own, instances can take automatic implicit arguments. In this instance, "
"the argument `n` stands for any `Nat`, and the instance is defined for a "
"`Nat` that's one greater:"
msgstr ""

#: src/type-classes/pos.md:291
msgid ""
"Because `n` stands for a `Nat` that's one less than what the user wrote, the "
"helper function `natPlusOne` returns a `Pos` that's one greater than its "
"argument. This makes it possible to use natural number literals for positive "
"numbers, but not for zero:"
msgstr ""

#: src/type-classes/pos.md:305
msgid "Another Representation"
msgstr ""

#: src/type-classes/pos.md:307
msgid ""
"An alternative way to represent a positive number is as the successor of "
"some `Nat`. Replace the definition of `Pos` with a structure whose "
"constructor is named `succ` that contains a `Nat`:"
msgstr ""

#: src/type-classes/pos.md:314
msgid ""
"Define instances of `Add`, `Mul`, `ToString`, and `OfNat` that allow this "
"version of `Pos` to be used conveniently."
msgstr ""

#: src/type-classes/pos.md:316
msgid "Even Numbers"
msgstr ""

#: src/type-classes/pos.md:318
msgid ""
"Define a datatype that represents only even numbers. Define instances of "
"`Add`, `Mul`, and `ToString` that allow it to be used conveniently. `OfNat` "
"requires a feature that is introduced in [the next section](polymorphism.md)."
msgstr ""

#: src/type-classes/pos.md:321
msgid "HTTP Requests"
msgstr ""

#: src/type-classes/pos.md:323
msgid ""
"An HTTP request begins with an identification of a HTTP method, such as "
"`GET` or `POST`, along with a URI and an HTTP version. Define an inductive "
"type that represents an interesting subset of the HTTP methods, and a "
"structure that represents HTTP responses. Responses should have a `ToString` "
"instance that makes it possible to debug them. Use a type class to associate "
"different `IO` actions with each HTTP method, and write a test harness as an "
"`IO` action that calls each method and prints the result."
msgstr ""

#: src/type-classes/polymorphism.md:3
msgid ""
"It can be useful to write functions that work for _any_ overloading of a "
"given function. For instance, `IO.println` works for any type that has an "
"instance of `ToString`. This is indicated using square brackets around the "
"required instance: the type of `IO.println` is `{α : Type} → [ToString α] → "
"α → IO Unit`. This type says that `IO.println` accepts an argument of type "
"`α`, which Lean should determine automatically, and that there must be a "
"`ToString` instance available for `α`. It returns an `IO` action."
msgstr ""

#: src/type-classes/polymorphism.md:10
msgid "Checking Polymorphic Functions' Types"
msgstr ""

#: src/type-classes/polymorphism.md:12
msgid ""
"Checking the type of a function that takes implicit arguments or uses type "
"classes requires the use of some additional syntax. Simply writing"
msgstr ""

#: src/type-classes/polymorphism.md:17
msgid "yields a type with metavariables:"
msgstr ""

#: src/type-classes/polymorphism.md:21
msgid ""
"This is because Lean does its best to discover implicit arguments, and the "
"presence of metavariables indicates that it did not yet discover enough type "
"information to do so. To understand the signature of a function, this "
"feature can be suppressed with an at-sign (`@`) before the function's name:"
msgstr ""

#: src/type-classes/polymorphism.md:29
msgid ""
"In this output, the instance itself has been given the name `inst`. "
"Additionally, there is a `u_1` after `Type`, which uses a feature of Lean "
"that has not yet been introduced. For now, ignore these parameters to `Type`."
msgstr ""

#: src/type-classes/polymorphism.md:33
msgid "Defining Polymorphic Functions with Instance Implicits"
msgstr ""

#: src/type-classes/polymorphism.md:35
msgid ""
"A function that sums all entries in a list needs two instances: `Add` allows "
"the entries to be added, and an `OfNat` instance for `0` provides a sensible "
"value to return for the empty list:"
msgstr ""

#: src/type-classes/polymorphism.md:41
msgid "This function can be used for a list of `Nat`s:"
msgstr ""

#: src/type-classes/polymorphism.md:50
msgid "but not for a list of `Pos` numbers:"
msgstr ""

#: src/type-classes/polymorphism.md:61
msgid ""
"Specifications of required instances in square brackets are called _instance "
"implicits_. Behind the scenes, every type class defines a structure that has "
"a field for each overloaded operation. Instances are values of that "
"structure type, with each field containing an implementation. At a call "
"site, Lean is responsible for finding an instance value to pass for each "
"instance implicit argument. The most important difference between ordinary "
"implicit arguments and instance implicits is the strategy that Lean uses to "
"find an argument value. In the case of ordinary implicit arguments, Lean "
"uses a technique called _unification_ to find a single unique argument value "
"that would allow the program to pass the type checker. This process relies "
"only on the specific types involved in the function's definition and the "
"call site. For instance implicits, Lean instead consults a built-in table of "
"instance values."
msgstr ""

#: src/type-classes/polymorphism.md:70
msgid ""
"Just as the `OfNat` instance for `Pos` took a natural number `n` as an "
"automatic implicit argument, instances may also take instance implicit "
"arguments themselves. The [section on "
"polymorphism](../getting-to-know/polymorphism.md) presented a polymorphic "
"point type:"
msgstr ""

#: src/type-classes/polymorphism.md:78
msgid ""
"Addition of points should add the underlying `x` and `y` fields. Thus, an "
"`Add` instance for `PPoint` requires an `Add` instance for whatever type "
"these fields have. In other words, the `Add` instance for `PPoint` requires "
"a further `Add` instance for `α`:"
msgstr ""

#: src/type-classes/polymorphism.md:85
msgid ""
"When Lean encounters an addition of two points, it searches for and finds "
"this instance. It then performs a further search for the `Add α` instance."
msgstr ""

#: src/type-classes/polymorphism.md:88
msgid ""
"The instance values that are constructed in this way are values of the type "
"class's structure type. A successful recursive instance search results in a "
"structure value that has a reference to another structure value. An instance "
"of `Add (PPoint Nat)` contains a reference to the instance of `Add Nat` that "
"was found."
msgstr ""

#: src/type-classes/polymorphism.md:92
msgid ""
"This recursive search process means that type classes offer significantly "
"more power than plain overloaded functions. A library of polymorphic "
"instances is a set of code building blocks that the compiler will assemble "
"on its own, given nothing but the desired type. Polymorphic functions that "
"take instance arguments are latent requests to the type class mechanism to "
"assemble helper functions behind the scenes. The API's clients are freed "
"from the burden of plumbing together all of the necessary parts by hand."
msgstr ""

#: src/type-classes/polymorphism.md:98
msgid "Methods and Implicit Arguments"
msgstr ""

#: src/type-classes/polymorphism.md:101
msgid ""
"The type of `@OfNat.ofNat` may be surprising. It is `{α : Type} → (n : Nat) "
"→ [OfNat α n] → α`, in which the `Nat` argument `n` occurs as an explicit "
"function argument. In the declaration of the method, however, `ofNat` simply "
"has type `α`. This seeming discrepancy is because declaring a type class "
"really results in the following:"
msgstr ""

#: src/type-classes/polymorphism.md:106
msgid ""
"A structure type to contain the implementation of each overloaded operation"
msgstr ""

#: src/type-classes/polymorphism.md:107
msgid "A namespace with the same name as the class"
msgstr ""

#: src/type-classes/polymorphism.md:108
msgid ""
"For each method, a function in the class's namespace that retrieves its "
"implementation from an instance"
msgstr ""

#: src/type-classes/polymorphism.md:110
msgid ""
"This is analogous to the way that declaring a new structure also declares "
"accessor functions. The primary difference is that a structure's accessors "
"take the structure value as an explicit argument, while the type class "
"methods take the instance value as an instance implicit to be found "
"automatically by Lean."
msgstr ""

#: src/type-classes/polymorphism.md:113
msgid ""
"In order for Lean to find an instance, its arguments must be available. This "
"means that each argument to the type class must be an argument to the method "
"that occurs before the instance. It is most convenient when these arguments "
"are implicit, because Lean does the work of discovering their values. For "
"example, `@Add.add` has the type `{α : Type} → [Add α] → α → α → α`. In this "
"case, the type argument `α` can be implicit because the arguments to "
"`Add.add` provide information about which type the user intended. This type "
"can then be used to search for the `Add` instance."
msgstr ""

#: src/type-classes/polymorphism.md:120
msgid ""
"In the case of `ofNat`, however, the particular `Nat` literal to be decoded "
"does not appear as part of any other argument. This means that Lean would "
"have no information to use when attempting to figure out the implicit "
"argument `n`. The result would be a very inconvenient API. Thus, in these "
"cases, Lean uses an explicit argument for the class's method."
msgstr ""

#: src/type-classes/polymorphism.md:129
msgid "Even Number Literals"
msgstr ""

#: src/type-classes/polymorphism.md:131
msgid ""
"Write an instance of `OfNat` for the even number datatype from the [previous "
"section's exercises](pos.md#even-numbers) that uses recursive instance "
"search. For the base instance, it is necessary to write `OfNat Even "
"Nat.zero` instead of `OfNat Even 0`."
msgstr ""

#: src/type-classes/polymorphism.md:134
msgid "Recursive Instance Search Depth"
msgstr ""

#: src/type-classes/polymorphism.md:136
msgid ""
"There is a limit to how many times the Lean compiler will attempt a "
"recursive instance search. This places a limit on the size of even number "
"literals defined in the previous exercise. Experimentally determine what the "
"limit is."
msgstr ""

#: src/type-classes/out-params.md:3
msgid ""
"An instance of the `Add` class is sufficient to allow two expressions with "
"type `Pos` to be conveniently added, producing another `Pos`. However, in "
"many cases, it can be useful to be more flexible and allow _heterogeneous_ "
"operator overloading, where the arguments may have different types. For "
"example, adding a `Nat` to a `Pos` or a `Pos` to a `Nat` will always yield a "
"`Pos`:"
msgstr ""

#: src/type-classes/out-params.md:15
msgid ""
"These functions allow natural numbers to be added to positive numbers, but "
"they cannot be used with the `Add` type class, which expects both arguments "
"to `add` to have the same type."
msgstr ""

#: src/type-classes/out-params.md:17
msgid "Heterogeneous Overloadings"
msgstr ""

#: src/type-classes/out-params.md:19
msgid ""
"As mentioned in the section on [overloaded "
"addition](pos.md#overloaded-addition), Lean provides a type class called "
"`HAdd` for overloading addition heterogeneously. The `HAdd` class takes "
"three type parameters: the two argument types and the return type. Instances "
"of `HAdd Nat Pos Pos` and `HAdd Pos Nat Pos` allow ordinary addition "
"notation to be used to mix the types:"
msgstr ""

#: src/type-classes/out-params.md:29
msgid "Given the above two instances, the following examples work:"
msgstr ""

#: src/type-classes/out-params.md:43
msgid ""
"The definition of the `HAdd` type class is very much like the following "
"definition of `HPlus` with the corresponding instances:"
msgstr ""

#: src/type-classes/out-params.md:54
msgid ""
"However, instances of `HPlus` are significantly less useful than instances "
"of `HAdd`. When attempting to use these instances with `#eval`, an error "
"occurs:"
msgstr ""

#: src/type-classes/out-params.md:63
msgid ""
"This happens because there is a metavariable in the type, and Lean has no "
"way to solve it."
msgstr ""

#: src/type-classes/out-params.md:65
msgid ""
"As discussed in [the initial description of "
"polymorphism](../getting-to-know/polymorphism.md), metavariables represent "
"unknown parts of a program that could not be inferred. When an expression is "
"written following `#eval`, Lean attempts to determine its type "
"automatically. In this case, it could not. Because the third type parameter "
"for `HPlus` was unknown, Lean couldn't carry out type class instance search, "
"but instance search is the only way that Lean could determine the "
"expression's type. That is, the `HPlus Pos Nat Pos` instance can only apply "
"if the expression should have type `Pos`, but there's nothing in the program "
"other than the instance itself to indicate that it should have this type."
msgstr ""

#: src/type-classes/out-params.md:71
msgid ""
"One solution to the problem is to ensure that all three types are available "
"by adding a type annotation to the whole expression:"
msgstr ""

#: src/type-classes/out-params.md:78
msgid ""
"However, this solution is not very convenient for users of the positive "
"number library."
msgstr ""

#: src/type-classes/out-params.md:81
msgid "Output Parameters"
msgstr ""

#: src/type-classes/out-params.md:83
msgid ""
"This problem can also be solved by declaring `γ` to be an _output "
"parameter_. Most type class parameters are inputs to the search algorithm: "
"they are used to select an instance. For example, in an `OfNat` instance, "
"both the type and the natural number are used to select a particular "
"interpretation of a natural number literal. However, in some cases, it can "
"be convenient to start the search process even when some of the type "
"parameters are not yet known, and use the instances that are discovered in "
"the search to determine values for metavariables. The parameters that aren't "
"needed to start instance search are outputs of the process, which is "
"declared with the `outParam` modifier:"
msgstr ""

#: src/type-classes/out-params.md:93
msgid ""
"With this output parameter, type class instance search is able to select an "
"instance without knowing `γ` in advance. For instance:"
msgstr ""

#: src/type-classes/out-params.md:102
msgid ""
"It might be helpful to think of output parameters as defining a kind of "
"function. Any given instance of a type class that has one or more output "
"parameters provides Lean with instructions for determining the outputs from "
"the inputs. The process of searching for an instance, possibly recursively, "
"ends up being more powerful than mere overloading. Output parameters can "
"determine other types in the program, and instance search can assemble a "
"collection of underlying instances into a program that has this type."
msgstr ""

#: src/type-classes/out-params.md:107
msgid "Default Instances"
msgstr ""

#: src/type-classes/out-params.md:109
msgid ""
"Deciding whether a parameter is an input or an output controls the "
"circumstances under which Lean will initiate type class search. In "
"particular, type class search does not occur until all inputs are known. "
"However, in some cases, output parameters are not enough, and instance "
"search should also occur when some inputs are unknown. This is a bit like "
"default values for optional function arguments in Python or Kotlin, except "
"default _types_ are being selected."
msgstr ""

#: src/type-classes/out-params.md:114
msgid ""
"_Default instances_ are instances that are available for instance search "
"_even when not all their inputs are known_. When one of these instances can "
"be used, it will be used. This can cause programs to successfully type "
"check, rather than failing with errors related to unknown types and "
"metavariables. On the other hand, default instances can make instance "
"selection less predictable. In particular, if an undesired default instance "
"is selected, then an expression may have a different type than expected, "
"which can cause confusing type errors to occur elsewhere in the program. Be "
"selective about where default instances are used!"
msgstr ""

#: src/type-classes/out-params.md:121
msgid ""
"One example of where default instances can be useful is an instance of "
"`HPlus` that can be derived from an `Add` instance. In other words, ordinary "
"addition is a special case of heterogeneous addition in which all three "
"types happen to be the same. This can be implemented using the following "
"instance:"
msgstr ""

#: src/type-classes/out-params.md:128
msgid "With this instance, `hPlus` can be used for any addable type, like `Nat`:"
msgstr ""

#: src/type-classes/out-params.md:136
msgid ""
"However, this instance will only be used in situations where the types of "
"both arguments are known. For example,"
msgstr ""

#: src/type-classes/out-params.md:141
msgid "yields the type"
msgstr ""

#: src/type-classes/out-params.md:145
msgid "as expected, but"
msgstr ""

#: src/type-classes/out-params.md:149
msgid ""
"yields a type that contains two metavariables, one for the remaining "
"argument and one for the return type:"
msgstr ""

#: src/type-classes/out-params.md:154
msgid ""
"In the vast majority of cases, when someone supplies one argument to "
"addition, the other argument will have the same type. To make this instance "
"into a default instance, apply the `default_instance` attribute:"
msgstr ""

#: src/type-classes/out-params.md:161
msgid "With this default instance, the example has a more useful type:"
msgstr ""

#: src/type-classes/out-params.md:170
msgid ""
"Each operator that exists in overloadable heterogeneous and homogeneous "
"versions follows the pattern of a default instance that allows the "
"homogeneous version to be used in contexts where the heterogeneous is "
"expected. The infix operator is replaced with a call to the heterogeneous "
"version, and the homogeneous default instance is selected when possible."
msgstr ""

#: src/type-classes/out-params.md:173
msgid ""
"Similarly, simply writing `5` gives a `Nat` rather than a type with a "
"metavariable that is waiting for more information in order to select an "
"`OfNat` instance. This is because the `OfNat` instance for `Nat` is a "
"default instance."
msgstr ""

#: src/type-classes/out-params.md:176
msgid ""
"Default instances can also be assigned _priorities_ that affect which will "
"be chosen in situations where more than one might apply. For more "
"information on default instance priorities, please consult the Lean manual."
msgstr ""

#: src/type-classes/out-params.md:182
msgid ""
"Define an instance of `HMul (PPoint α) α (PPoint α)` that multiplies both "
"projections by the scalar. It should work for any type `α` for which there "
"is a `Mul α` instance. For example,"
msgstr ""

#: src/type-classes/indexing.md:3
msgid ""
"The [Interlude](../props-proofs-indexing.md) describes how to use indexing "
"notation in order to look up entries in a list by their position. This "
"syntax is also governed by a type class, and it can be used for a variety of "
"different types."
msgstr ""

#: src/type-classes/indexing.md:6
msgid "Arrays"
msgstr ""

#: src/type-classes/indexing.md:7
msgid ""
"For instance, Lean arrays are much more efficient than linked lists for most "
"purposes. In Lean, the type `Array α` is a dynamically-sized array holding "
"values of type `α`, much like a Java `ArrayList`, a C++ `std::vector`, or a "
"Rust `Vec`. Unlike `List`, which has a pointer indirection on each use of "
"the `cons` constructor, arrays occupy a contiguous region of memory, which "
"is much better for processor caches. Also, looking up a value in an array "
"takes constant time, while lookup in a linked list takes time proportional "
"to the index being accessed."
msgstr ""

#: src/type-classes/indexing.md:12
msgid ""
"In pure functional languages like Lean, it is not possible to mutate a given "
"position in a data structure. Instead, a copy is made that has the desired "
"modifications. When using an array, the Lean compiler and runtime contain an "
"optimization that can allow modifications to be implemented as mutations "
"behind the scenes when there is only a single unique reference to an array."
msgstr ""

#: src/type-classes/indexing.md:16
msgid "Arrays are written similarly to lists, but with a leading `#`:"
msgstr ""

#: src/type-classes/indexing.md:17
msgid ""
"```lean\n"
"def northernTrees : Array String :=\n"
"  #[\"sloe\", \"birch\", \"elm\", \"oak\"]\n"
"```"
msgstr ""

#: src/type-classes/indexing.md:21
msgid ""
"The number of values in an array can be found using `Array.size`. For "
"instance, `northernTrees.size` evaluates to `4`. For indices that are "
"smaller than an array's size, indexing notation can be used to find the "
"corresponding value, just as with lists. That is, `northernTrees[2]` "
"evaluates to `\"elm\"`. Similarly, the compiler requires a proof that an "
"index is in bounds, and attempting to look up a value outside the bounds of "
"the array results in a compile-time error, just as with lists. For instance, "
"`northernTrees[8]` results in:"
msgstr ""

#: src/type-classes/indexing.md:36
msgid "Non-Empty Lists"
msgstr ""

#: src/type-classes/indexing.md:38
msgid ""
"A datatype that represents non-empty lists can be defined as a structure "
"with a field for the head of the list and a field for the tail, which is an "
"ordinary, potentially empty list:"
msgstr ""

#: src/type-classes/indexing.md:44
msgid ""
"For example, the non-empty list `idahoSpiders` (which contains some spider "
"species native to the US state of Idaho) consists of `\"Banded Garden "
"Spider\"` followed by four other spiders, for a total of five spiders:"
msgstr ""

#: src/type-classes/indexing.md:45
msgid ""
"```lean\n"
"def idahoSpiders : NonEmptyList String := {\n"
"  head := \"Banded Garden Spider\",\n"
"  tail := [\n"
"    \"Long-legged Sac Spider\",\n"
"    \"Wolf Spider\",\n"
"    \"Hobo Spider\",\n"
"    \"Cat-faced Spider\"\n"
"  ]\n"
"}\n"
"```"
msgstr ""

#: src/type-classes/indexing.md:57
msgid ""
"Looking up the value at a specific index in this list with a recursive "
"function should consider three possibilities:"
msgstr ""

#: src/type-classes/indexing.md:58
msgid "The index is `0`, in which case the head of the list should be returned."
msgstr ""

#: src/type-classes/indexing.md:59
msgid ""
"The index is `n + 1` and the tail is empty, in which case the index is out "
"of bounds."
msgstr ""

#: src/type-classes/indexing.md:60
msgid ""
"The index is `n + 1` and the tail is non-empty, in which case the function "
"can be called recursively on the tail and `n`."
msgstr ""

#: src/type-classes/indexing.md:62
msgid ""
"For example, a lookup function that returns an `Option` can be written as "
"follows:"
msgstr ""

#: src/type-classes/indexing.md:69
msgid ""
"Each case in the pattern match corresponds to one of the possibilities "
"above. The recursive call to `get?` does not require a `NonEmptyList` "
"namespace qualifier because the body of the definition is implicitly in the "
"definition's namespace. Another way to write this function uses `get?` for "
"lists when the index is greater than zero:"
msgstr ""

#: src/type-classes/indexing.md:78
msgid ""
"If the list contains one entry, then only `0` is a valid index. If it "
"contains two entries, then both `0` and `1` are valid indices. If it "
"contains three entries, then `0`, `1`, and `2` are valid indices. In other "
"words, the valid indices into a non-empty list are natural numbers that are "
"strictly less than the length of the list, which are less than or equal to "
"the length of the tail."
msgstr ""

#: src/type-classes/indexing.md:83
msgid ""
"The definition of what it means for an index to be in bounds should be "
"written as an `abbrev` because the tactics used to find evidence that "
"indices are acceptable are able to solve inequalities of numbers, but they "
"don't know anything about the name `NonEmptyList.inBounds`:"
msgstr ""

#: src/type-classes/indexing.md:88
msgid ""
"This function returns a proposition that might be true or false. For "
"instance, `2` is in bounds for `idahoSpiders`, while `5` is not:"
msgstr ""

#: src/type-classes/indexing.md:95
msgid ""
"The logical negation operator has a very low precedence, which means that "
"`¬idahoSpiders.inBounds 5` is equivalent to `¬(idahoSpiders.inBounds 5)`."
msgstr ""

#: src/type-classes/indexing.md:98
msgid ""
"This fact can be used to write a lookup function that requires evidence that "
"the index is valid, and thus need not return `Option`, by delegating to the "
"version for lists that checks the evidence at compile time:"
msgstr ""

#: src/type-classes/indexing.md:105
msgid ""
"It is, of course, possible to write this function to use the evidence "
"directly, rather than delegating to a standard library function that happens "
"to be able to use the same evidence. This requires techniques for working "
"with proofs and propositions that are described later in this book."
msgstr ""

#: src/type-classes/indexing.md:109
msgid "Overloading Indexing"
msgstr ""

#: src/type-classes/indexing.md:111
msgid ""
"Indexing notation for a collection type can be overloaded by defining an "
"instance of the `GetElem` type class. For the sake of flexiblity, `GetElem` "
"has four parameters:"
msgstr ""

#: src/type-classes/indexing.md:113
msgid "The type of the collection"
msgstr ""

#: src/type-classes/indexing.md:114
msgid "The type of the index"
msgstr ""

#: src/type-classes/indexing.md:115
msgid "The type of elements that are extracted from the collection"
msgstr ""

#: src/type-classes/indexing.md:116
msgid ""
"A function that determines what counts as evidence that the index is in "
"bounds"
msgstr ""

#: src/type-classes/indexing.md:118
msgid ""
"The element type and the evidence function are both output parameters. "
"`GetElem` has a single method, `getElem`, which takes a collection value, an "
"index value, and evidence that the index is in bounds as arguments, and "
"returns an element:"
msgstr ""

#: src/type-classes/indexing.md:125
msgid "In the case of `NonEmptyList α`, these parameters are:"
msgstr ""

#: src/type-classes/indexing.md:126
msgid "The collection is `NonEmptyList α`"
msgstr ""

#: src/type-classes/indexing.md:127
msgid "Indices have type `Nat`"
msgstr ""

#: src/type-classes/indexing.md:128
msgid "The type of elements is `α`"
msgstr ""

#: src/type-classes/indexing.md:129
msgid ""
"An index is in bounds if it is less than or equal to the length of the tail"
msgstr ""

#: src/type-classes/indexing.md:131
msgid ""
"In fact, the `GetElem` instance can delegate directly to `NonEmptyList.get`:"
msgstr ""

#: src/type-classes/indexing.md:136
msgid ""
"With this instance, `NonEmptyList` becomes just as convenient to use as "
"`List`. Evaluating `idahoSpiders[0]` yields `\"Banded Garden Spider\"`, "
"while `idahoSpiders[9]` leads to the compile-time error:"
msgstr ""

#: src/type-classes/indexing.md:147
msgid ""
"Because both the collection type and the index type are input parameters to "
"the `GetElem` type class, new types can be used to index into existing "
"collections. The positive number type `Pos` is a perfectly reasonable index "
"into a `List`, with the caveat that it cannot point at the first entry. The "
"follow instance of `GetElem` allows `Pos` to be used just as conveniently as "
"`Nat` to find a list entry:"
msgstr ""

#: src/type-classes/indexing.md:155
msgid ""
"Indexing can also make sense for non-numeric indices. For example, `Bool` "
"can be used to select between the fields in a point, with `false` "
"corresponding to `x` and `true` corresponding to `y`:"
msgstr ""

#: src/type-classes/indexing.md:162
msgid ""
"In this case, both Booleans are valid indices. Because every possible `Bool` "
"is in bounds, the evidence is simply the true proposition `True`."
msgstr ""

#: src/type-classes/standard-classes.md:3
msgid ""
"This section presents a variety of operators and functions that can be "
"overloaded using type classes in Lean. Each operator or function corresponds "
"to a method of a type class. Unlike C++, infix operators in Lean are defined "
"as abbreviations for named functions; this means that overloading them for "
"new types is not done using the operator itself, but rather using the "
"underlying name (such as `HAdd.hAdd`)."
msgstr ""

#: src/type-classes/standard-classes.md:7
msgid "Arithmetic"
msgstr ""

#: src/type-classes/standard-classes.md:9
msgid ""
"Most arithmetic operators are available in a heterogeneous form, where the "
"arguments may have different type and an output parameter decides the type "
"of the resulting expression. For each heterogeneous operator, there is a "
"corresponding homogeneous version that can found by removing the letter `h`, "
"so that `HAdd.hAdd` becomes `Add.add`. The following arithmetic operators "
"are overloaded:"
msgstr ""

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98 src/monad-transformers/do.md:424
#: src/programs-proofs/arrays-termination.md:19
msgid "Expression"
msgstr ""

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98
#: src/programs-proofs/arrays-termination.md:19
msgid "Desugaring"
msgstr ""

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98
#: src/programs-proofs/arrays-termination.md:19
msgid "Class Name"
msgstr ""

#: src/type-classes/standard-classes.md:15
msgid "`x + y`"
msgstr ""

#: src/type-classes/standard-classes.md:15
msgid "`HAdd.hAdd x y`"
msgstr ""

#: src/type-classes/standard-classes.md:15
msgid "`HAdd`"
msgstr ""

#: src/type-classes/standard-classes.md:16
msgid "`x - y`"
msgstr ""

#: src/type-classes/standard-classes.md:16
msgid "`HSub.hSub x y`"
msgstr ""

#: src/type-classes/standard-classes.md:16
msgid "`HSub`"
msgstr ""

#: src/type-classes/standard-classes.md:17
msgid "`x * y`"
msgstr ""

#: src/type-classes/standard-classes.md:17
msgid "`HMul.hMul x y`"
msgstr ""

#: src/type-classes/standard-classes.md:17
msgid "`HMul`"
msgstr ""

#: src/type-classes/standard-classes.md:18
msgid "`x / y`"
msgstr ""

#: src/type-classes/standard-classes.md:18
msgid "`HDiv.hDiv x y`"
msgstr ""

#: src/type-classes/standard-classes.md:18
msgid "`HDiv`"
msgstr ""

#: src/type-classes/standard-classes.md:19
msgid "`x % y`"
msgstr ""

#: src/type-classes/standard-classes.md:19
msgid "`HMod.hMod x y`"
msgstr ""

#: src/type-classes/standard-classes.md:19
msgid "`HMod`"
msgstr ""

#: src/type-classes/standard-classes.md:20
msgid "`x ^ y`"
msgstr ""

#: src/type-classes/standard-classes.md:20
msgid "`HPow.hPow x y`"
msgstr ""

#: src/type-classes/standard-classes.md:20
msgid "`HPow`"
msgstr ""

#: src/type-classes/standard-classes.md:21
msgid "`(- x)`"
msgstr ""

#: src/type-classes/standard-classes.md:21
msgid "`Neg.neg x`"
msgstr ""

#: src/type-classes/standard-classes.md:21
msgid "`Neg`"
msgstr ""

#: src/type-classes/standard-classes.md:24
msgid "Bitwise Operators"
msgstr ""

#: src/type-classes/standard-classes.md:26
msgid ""
"Lean contains a number of standard bitwise operators that are overloaded "
"using type classes. There are instances for fixed-width types such as "
"`UInt8`, `UInt16`, `UInt32`, `UInt64`, and `USize`. The latter is the size "
"of words on the current platform, typically 32 or 64 bits. The following "
"bitwise operators are overloaded:"
msgstr ""

#: src/type-classes/standard-classes.md:33
msgid "`x &&& y`"
msgstr ""

#: src/type-classes/standard-classes.md:33
msgid "`HAnd.hAnd x y`"
msgstr ""

#: src/type-classes/standard-classes.md:33
msgid "`HAnd`"
msgstr ""

#: src/type-classes/standard-classes.md:34
msgid "x \\|\\|\\| y "
msgstr ""

#: src/type-classes/standard-classes.md:34
msgid "`HOr.hOr x y`"
msgstr ""

#: src/type-classes/standard-classes.md:34
msgid "`HOr`"
msgstr ""

#: src/type-classes/standard-classes.md:35
msgid "`x ^^^ y`"
msgstr ""

#: src/type-classes/standard-classes.md:35
msgid "`HXor.hXor x y`"
msgstr ""

#: src/type-classes/standard-classes.md:35
msgid "`HXor`"
msgstr ""

#: src/type-classes/standard-classes.md:36
msgid "`~~~ x`"
msgstr ""

#: src/type-classes/standard-classes.md:36
msgid "`Complement.complement x`"
msgstr ""

#: src/type-classes/standard-classes.md:36
msgid "`Complement`"
msgstr ""

#: src/type-classes/standard-classes.md:37
msgid "`x >>> y`"
msgstr ""

#: src/type-classes/standard-classes.md:37
msgid "`HShiftRight.hShiftRight x y`"
msgstr ""

#: src/type-classes/standard-classes.md:37
msgid "`HShiftRight`"
msgstr ""

#: src/type-classes/standard-classes.md:38
msgid "`x <<< y`"
msgstr ""

#: src/type-classes/standard-classes.md:38
msgid "`HShiftLeft.hShiftLeft x y`"
msgstr ""

#: src/type-classes/standard-classes.md:38
msgid "`HShiftLeft`"
msgstr ""

#: src/type-classes/standard-classes.md:40
msgid ""
"Because the names `And` and `Or` are already taken as the names of logical "
"connectives, the homogeneous versions of `HAnd` and `HOr` are called `AndOp` "
"and `OrOp` rather than `And` and `Or`."
msgstr ""

#: src/type-classes/standard-classes.md:42
msgid "Equality and Ordering"
msgstr ""

#: src/type-classes/standard-classes.md:44
msgid ""
"Testing equality of two values typically uses the `BEq` class, which is "
"short for \"Boolean equality\". Due to Lean's use as a theorem prover, there "
"are really two kinds of equality operators in Lean:"
msgstr ""

#: src/type-classes/standard-classes.md:46
msgid ""
"_Boolean equality_ is the same kind of equality that is found in other "
"programming languages. It is a function that takes two values and returns a "
"`Bool`. Boolean equality is written with two equals signs, just as in Python "
"and C#. Because Lean is a pure functional language, there's no separate "
"notions of reference vs value equality—pointers cannot be observed directly."
msgstr ""

#: src/type-classes/standard-classes.md:47
msgid ""
"_Propositional equality_ is the mathematical statement that two things are "
"equal. Propositional equality is not a function; rather, it is a "
"mathematical statement that admits proof. It is written with a single equals "
"sign. A statement of propositional equality is like a type that classifies "
"evidence of this equality."
msgstr ""

#: src/type-classes/standard-classes.md:49
msgid ""
"Both notions of equality are important, and used for different purposes. "
"Boolean equality is useful in programs, when a decision needs to be made "
"about whether two values are equal. For example, `\"Octopus\" ==  "
"\"Cuttlefish\"` evaluates to `false`, and `\"Octopodes\" ==  \"Octo\".append "
"\"podes\"` evaluates to `true`. Some values, such as functions, cannot be "
"checked for equality. For example, `(fun (x : Nat) => 1 + x) == (Nat.succ "
"·)` yields the error:"
msgstr ""

#: src/type-classes/standard-classes.md:58
msgid ""
"As this message indicates, `==` is overloaded using a type class. The "
"expression `x == y` is actually shorthand for `BEq.beq x y`."
msgstr ""

#: src/type-classes/standard-classes.md:61
msgid ""
"Propositional equality is a mathematical statement rather than an invocation "
"of a program. Because propositions are like types that describe evidence for "
"some statement, propositional equality has more in common with types like "
"`String` and `Nat → List Int` than it does with Boolean equality. This means "
"that it can't automatically be checked. However, the equality of any two "
"expressions can be stated in Lean, so long as they have the same type. The "
"statement `(fun (x : Nat) => 1 + x) = (Nat.succ ·)` is a perfectly "
"reasonable statement. From the perspective of mathematics, two functions are "
"equal if they map equal inputs to equal outputs, so this statement is even "
"true, though it requires a two-line proof to convince Lean of this fact."
msgstr ""

#: src/type-classes/standard-classes.md:68
msgid ""
"Generally speaking, when using Lean as a programming language, it's easiest "
"to stick to Boolean functions rather than propositions. However, as the "
"names `true` and `false` for `Bool`'s constructors suggest, this difference "
"is sometimes blurred. Some propositions are _decidable_, which means that "
"they can be checked just like a Boolean function. The function that checks "
"whether the proposition is true or false is called a _decision procedure_, "
"and it returns _evidence_ of the truth or falsity of the proposition. Some "
"examples of decidable propositions include equality and inequality of "
"natural numbers, equality of strings, and \"ands\" and \"ors\" of "
"propositions that are themselves decidable."
msgstr ""

#: src/type-classes/standard-classes.md:74
msgid ""
"In Lean, `if` works with decidable propositions. For example, `2 < 4` is a "
"proposition:"
msgstr ""

#: src/type-classes/standard-classes.md:82
msgid ""
"Nonetheless, it is perfectly acceptable to write it as the condition in an "
"`if`. For example, `if 2 < 4 then 1 else 2` has type `Nat` and evaluates to "
"`1`."
msgstr ""

#: src/type-classes/standard-classes.md:86
msgid ""
"Not all propositions are decidable. If they were, then computers would be "
"able to prove any true proposition just by running the decision procedure, "
"and mathematicians would be out of a job. More specifically, decidable "
"propositions have an instance of the `Decidable` type class which has a "
"method that is the decision procedure. Trying to use a proposition that "
"isn't decidable as if it were a `Bool` results in a failure to find the "
"`Decidable` instance. For example, `if (fun (x : Nat) => 1 + x) = (Nat.succ "
"·) then \"yes\" else \"no\"` results in:"
msgstr ""

#: src/type-classes/standard-classes.md:96
msgid ""
"The following propositions, that are usually decidable, are overloaded with "
"type classes:"
msgstr ""

#: src/type-classes/standard-classes.md:100
#: src/programs-proofs/arrays-termination.md:21
msgid "`x < y`"
msgstr ""

#: src/type-classes/standard-classes.md:100
#: src/programs-proofs/arrays-termination.md:21
msgid "`LT.lt x y`"
msgstr ""

#: src/type-classes/standard-classes.md:100
#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:21
#: src/programs-proofs/arrays-termination.md:23
msgid "`LT`"
msgstr ""

#: src/type-classes/standard-classes.md:101
#: src/programs-proofs/arrays-termination.md:22
msgid "`x ≤ y`"
msgstr ""

#: src/type-classes/standard-classes.md:101
#: src/programs-proofs/arrays-termination.md:22
msgid "`LE.le x y`"
msgstr ""

#: src/type-classes/standard-classes.md:101
#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:22
#: src/programs-proofs/arrays-termination.md:24
msgid "`LE`"
msgstr ""

#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:23
msgid "`x > y`"
msgstr ""

#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:23
msgid "`LT.lt y x`"
msgstr ""

#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:24
msgid "`x ≥ y`"
msgstr ""

#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:24
msgid "`LE.le y x`"
msgstr ""

#: src/type-classes/standard-classes.md:105
msgid ""
"Because defining new propositions hasn't yet been demonstrated, it may be "
"difficult to define new instances of `LT` and `LE`."
msgstr ""

#: src/type-classes/standard-classes.md:107
msgid ""
"Additionally, comparing values using `<`, `==`, and `>` can be inefficient. "
"Checking first whether one value is less than another, and then whether they "
"are equal, can require two traversals over large data structures. To solve "
"this problem, Java and C# have standard `compareTo` and `CompareTo` methods "
"(respectively) that can be overridden by a class in order to implement all "
"three operations at the same time. These methods return a negative integer "
"if the receiver is less than the argument, zero if they are equal, and a "
"positive integer if the receiver is greater than the argument. Rather than "
"overload the meaning of integers, Lean has a built-in inductive type that "
"describes these three possibilities:"
msgstr ""

#: src/type-classes/standard-classes.md:118
msgid ""
"The `Ord` type class can be overloaded to produce these comparisons. For "
"`Pos`, an implementation can be:"
msgstr ""

#: src/type-classes/standard-classes.md:130
msgid ""
"In situations where `compareTo` would be the right approach in Java, use "
"`Ord.compare` in Lean."
msgstr ""

#: src/type-classes/standard-classes.md:132
msgid "Hashing"
msgstr ""

#: src/type-classes/standard-classes.md:134
msgid ""
"Java and C# have `hashCode` and `GetHashCode` methods, respectively, that "
"compute a hash of a value for use in data structures such as hash tables. "
"The Lean equivalent is a type class called `Hashable`:"
msgstr ""

#: src/type-classes/standard-classes.md:140
msgid ""
"If two values are considered equal according to a `BEq` instance for their "
"type, then they should have the same hashes. In other words, if `x == y` "
"then `hash x == hash y`. If `x ≠ y`, then `hash x` won't necessarily differ "
"from `hash y` (after all, there are infinitely more `Nat` values than there "
"are `UInt64` values), but data structures built on hashing will have better "
"performance if unequal values are likely to have unequal hashes. This is the "
"same expectation as in Java and C#."
msgstr ""

#: src/type-classes/standard-classes.md:145
msgid ""
"The standard library contains a function `mixHash` with type `UInt64 → "
"UInt64 → UInt64` that can be used to combine hashes for different fields for "
"a constructor. A reasonable hash function for an inductive datatype can be "
"written by assigning a unique number to each constructor, and then mixing "
"that number with the hashes of each field. For example, a `Hashable` "
"instance for `Pos` can be written:"
msgstr ""

#: src/type-classes/standard-classes.md:156
msgid ""
"`Hashable` instances for polymorphic types can use recursive instance "
"search. Hashing a `NonEmptyList α` is only possible when `α` can be hashed:"
msgstr ""

#: src/type-classes/standard-classes.md:162
msgid ""
"Binary trees use both recursion and recursive instance search in the "
"implementations of `BEq` and `Hashable`:"
msgstr ""

#: src/type-classes/standard-classes.md:190
msgid "Deriving Standard Classes"
msgstr ""

#: src/type-classes/standard-classes.md:192
msgid ""
"Instance of classes like `BEq` and `Hashable` are often quite tedious to "
"implement by hand. Lean includes a feature called _instance deriving_ that "
"allows the compiler to automatically construct well-behaved instances of "
"many type classes. In fact, the `deriving Repr` phrase in the definition of "
"`Point` in the [section on structures](../getting-to-know/structures.md) is "
"an example of instance deriving."
msgstr ""

#: src/type-classes/standard-classes.md:196
msgid ""
"Instances can be derived in two ways. The first can be used when defining a "
"structure or inductive type. In this case, add `deriving` to the end of the "
"type declaration followed by the names of the classes for which instances "
"should be derived. For a type that is already defined, a standalone "
"`deriving` command can be used. Write `deriving instance C1, C2, ... for T` "
"to derive instances of `C1, C2, ...` for the type `T` after the fact."
msgstr ""

#: src/type-classes/standard-classes.md:202
msgid ""
"`BEq` and `Hashable` instances can be derived for `Pos` and `NonEmptyList` "
"using a very small amount of code:"
msgstr ""

#: src/type-classes/standard-classes.md:208
msgid "Instances can be derived for at least the following classes:"
msgstr ""

#: src/type-classes/standard-classes.md:209
msgid "`Inhabited`"
msgstr ""

#: src/type-classes/standard-classes.md:210
msgid "`BEq`"
msgstr ""

#: src/type-classes/standard-classes.md:211
msgid "`Repr`"
msgstr ""

#: src/type-classes/standard-classes.md:212
msgid "`Hashable`"
msgstr ""

#: src/type-classes/standard-classes.md:213
msgid "`Ord`"
msgstr ""

#: src/type-classes/standard-classes.md:215
msgid ""
"In some cases, however, the derived `Ord` instance may not produce precisely "
"the ordering desired in an application. When this is the case, it's fine to "
"write an `Ord` instance by hand. The collection of classes for which "
"instances can be derived can be extended by advanced users of Lean."
msgstr ""

#: src/type-classes/standard-classes.md:219
msgid ""
"Aside from the clear advantages in programmer productivity and code "
"readability, deriving instances also makes code easier to maintain, because "
"the instances are updated as the definitions of types evolve. Changesets "
"involving updates to datatypes are easier to read without line after line of "
"formulaic modifications to equality tests and hash computation."
msgstr ""

#: src/type-classes/standard-classes.md:222
msgid "Appending"
msgstr ""

#: src/type-classes/standard-classes.md:224
msgid ""
"Many datatypes have some sort of append operator. In Lean, appending two "
"values is overloaded with the type class `HAppend`, which is a heterogeneous "
"operation like that used for arithmetic operations:"
msgstr ""

#: src/type-classes/standard-classes.md:230
msgid ""
"The syntax `xs ++ ys` desugars to `HAppend.hAppend xs ys`. For homogeneous "
"cases, it's enough to implement an instance of `Append`, which follows the "
"usual pattern:"
msgstr ""

#: src/type-classes/standard-classes.md:238
msgid "After defining the above instance,"
msgstr ""

#: src/type-classes/standard-classes.md:242
msgid "has the following output:"
msgstr ""

#: src/type-classes/standard-classes.md:243
msgid ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"tail := [\"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\",\n"
"         \"Banded Garden Spider\",\n"
"         \"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\"] }\n"
"```"
msgstr ""

#: src/type-classes/standard-classes.md:256
msgid ""
"Similarly, a definition of `HAppend` allows non-empty lists to be appended "
"to ordinary lists:"
msgstr ""

#: src/type-classes/standard-classes.md:262
msgid "With this instance available,"
msgstr ""

#: src/type-classes/standard-classes.md:263
msgid ""
"```lean\n"
"#eval idahoSpiders ++ [\"Trapdoor Spider\"]\n"
"```"
msgstr ""

#: src/type-classes/standard-classes.md:267
msgid ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"  tail := [\"Long-legged Sac Spider\", \"Wolf Spider\", \"Hobo Spider\", "
"\"Cat-faced Spider\", \"Trapdoor Spider\"] }\n"
"```"
msgstr ""

#: src/type-classes/standard-classes.md:272 src/type-classes/summary.md:40
msgid "Functors"
msgstr ""

#: src/type-classes/standard-classes.md:274
msgid ""
"A polymorphic type is a _functor_ if it has an overload for a function named "
"`map` that transforms every element contained in it by a function. While "
"most languages use this terminology, C#'s equivalent to `map` is called "
"`System.Linq.Enumerable.Select`. For example, mapping a function over a list "
"constructs a new list in which each entry from the starting list has been "
"replaced by the result of the function on that entry. Mapping a function `f` "
"over an `Option` leaves `none` untouched, and replaces `some x` with `some "
"(f x)`."
msgstr ""

#: src/type-classes/standard-classes.md:279
msgid ""
"Here are some examples of functors and how their `Functor` instances "
"overload `map`:"
msgstr ""

#: src/type-classes/standard-classes.md:280
msgid "`Functor.map (· + 5) [1, 2, 3]` evaluates to `[6, 7, 8]`"
msgstr ""

#: src/type-classes/standard-classes.md:281
msgid ""
"`Functor.map toString (some (List.cons 5 List.nil))` evaluates to `some "
"\"[5]\"`"
msgstr ""

#: src/type-classes/standard-classes.md:282
msgid ""
"`Functor.map List.reverse [[1, 2, 3], [4, 5, 6]]` evaluates to `[[3, 2, 1], "
"[6, 5, 4]]`"
msgstr ""

#: src/type-classes/standard-classes.md:284
msgid ""
"Because `Functor.map` is a bit of a long name for this common operation, "
"Lean also provides an infix operator for mapping a function, namely `<$>`. "
"The prior examples can be rewritten as follows:"
msgstr ""

#: src/type-classes/standard-classes.md:286
msgid "`(· + 5) <$> [1, 2, 3]` evaluates to `[6, 7, 8]`"
msgstr ""

#: src/type-classes/standard-classes.md:287
msgid "`toString <$> (some (List.cons 5 List.nil))` evaluates to `some \"[5]\"`"
msgstr ""

#: src/type-classes/standard-classes.md:288
msgid ""
"`List.reverse <$> [[1, 2, 3], [4, 5, 6]]` evaluates to `[[3, 2, 1], [6, 5, "
"4]]`"
msgstr ""

#: src/type-classes/standard-classes.md:290
msgid ""
"An instance of `Functor` for `NonEmptyList` requires specifying the `map` "
"function."
msgstr ""

#: src/type-classes/standard-classes.md:295
msgid ""
"Here, `map` uses the `Functor` instance for `List` to map the function over "
"the tail. This instance is defined for `NonEmptyList` rather than for "
"`NonEmptyList α` because the argument type `α` plays no role in resolving "
"the type class. A `NonEmptyList` can have a function mapped over it _no "
"matter what the type of entries is_. If `α` were a parameter to the class, "
"then it would be possible to make versions of `Functor` that only worked for "
"`NonEmptyList Nat`, but part of being a functor is that `map` works for any "
"entry type."
msgstr ""

#: src/type-classes/standard-classes.md:300
msgid "Here is an instance of `Functor` for `PPoint`:"
msgstr ""

#: src/type-classes/standard-classes.md:305
msgid "In this case, `f` has been applied to both `x` and `y`."
msgstr ""

#: src/type-classes/standard-classes.md:307
msgid ""
"Even when the type contained in a functor is itself a functor, mapping a "
"function only goes down one layer. That is, when using `map` on a "
"`NonEmptyList (PPoint Nat)`, the function being mapped should take `PPoint "
"Nat` as its argument rather than `Nat`."
msgstr ""

#: src/type-classes/standard-classes.md:310
msgid ""
"The definition of the `Functor` class uses one more language feature that "
"has not yet been discussed: default method definitions. Normally, a class "
"will specify some minimal set of overloadable operations that make sense "
"together, and then use polymorphic functions with instance implicit "
"arguments that build on the overloaded operations to provide a larger "
"library of features. For example, the function `concat` can concatenate any "
"non-empty list whose entries are appendable:"
msgstr ""

#: src/type-classes/standard-classes.md:320
msgid ""
"However, for some classes, there are operations that can be more efficiently "
"implemented with knowledge of the internals of a datatype."
msgstr ""

#: src/type-classes/standard-classes.md:322
msgid ""
"In these cases, a default method definition can be provided. A default "
"method definition provides a default implementation of a method in terms of "
"the other methods. However, instance implementors may choose to override "
"this default with something more efficient. Default method definitions "
"contain `:=` in a `class` definition."
msgstr ""

#: src/type-classes/standard-classes.md:327
msgid ""
"In the case of `Functor`, some types have a more efficient way of "
"implementing `map` when the function being mapped ignores its argument. "
"Functions that ignore their arguments are called _constant functions_ "
"because they always return the same value. Here is the definition of "
"`Functor`, in which `mapConst` has a default implementation:"
msgstr ""

#: src/type-classes/standard-classes.md:338
msgid ""
"Just as a `Hashable` instance that doesn't respect `BEq` is buggy, a "
"`Functor` instance that moves around the data as it maps the function is "
"also buggy. For example, a buggy `Functor` instance for `List` might throw "
"away its argument and always return the empty list, or it might reverse the "
"list. A bad instance for `PPoint` might place `f x` in both the `x` and the "
"`y` fields. Specifically, `Functor` instances should follow two rules:"
msgstr ""

#: src/type-classes/standard-classes.md:342
msgid "Mapping the identity function should result in the original argument."
msgstr ""

#: src/type-classes/standard-classes.md:343
msgid ""
"Mapping two composed functions should have the same effect as composing "
"their mapping."
msgstr ""

#: src/type-classes/standard-classes.md:345
msgid ""
"More formally, the first rule says that `id <$> x` equals `x`. The second "
"rule says that `map (fun y => f (g y)) x` equals `map f (map g x)`. The "
"composition `fun y => f (g y)` can also be written `f ∘ g`. These rules "
"prevent implementations of `map` that move the data around or delete some of "
"it."
msgstr ""

#: src/type-classes/standard-classes.md:352
msgid ""
"Lean is not able to derive instances for all classes. For example, the code"
msgstr ""

#: src/type-classes/standard-classes.md:361
msgid ""
"Invoking `deriving instance` causes Lean to consult an internal table of "
"code generators for type class instances. If the code generator is found, "
"then it is invoked on the provided type to create the instance. This "
"message, however, means that no code generator was found for `ToString`."
msgstr ""

#: src/type-classes/standard-classes.md:367
msgid ""
"Write an instance of `HAppend (List α) (NonEmptyList α) (NonEmptyList α)` "
"and test it."
msgstr ""

#: src/type-classes/standard-classes.md:368
msgid "Implement a `Functor` instance for the binary tree datatype."
msgstr ""

#: src/type-classes/coercion.md:3
msgid ""
"In mathematics, it is common to use the same symbol to stand for different "
"aspects of some object in different contexts. For example, if a ring is "
"referred to in a context where a set is expected, then it is understood that "
"the ring's underlying set is what's intended. In programming languages, it "
"is common to have rules to automatically translate values of one type into "
"values of another type. For instance, Java allows a `byte` to be "
"automatically promoted to an `int`, and Kotlin allows a non-nullable type to "
"be used in a context that expects a nullable version of the type."
msgstr ""

#: src/type-classes/coercion.md:8
msgid ""
"In Lean, both purposes are served by a mechanism called _coercions_. When "
"Lean encounters an expression of one type in a context that expects a "
"different type, it will attempt to coerce the expression before reporting a "
"type error. Unlike Java, C, and Kotlin, the coercions are extensible by "
"defining instances of type classes."
msgstr ""

#: src/type-classes/coercion.md:14
msgid ""
"For example, every positive number corresponds to a natural number. The "
"function `Pos.toNat` that was defined earlier converts a `Pos` to the "
"corresponding `Nat`:"
msgstr ""

#: src/type-classes/coercion.md:21
msgid ""
"The function `List.drop`, with type `{α : Type} → Nat → List α → List α`, "
"removes a prefix of a list. Applying `List.drop` to a `Pos`, however, leads "
"to a type error:"
msgstr ""

#: src/type-classes/coercion.md:36
msgid ""
"Because the author of `List.drop` did not make it a method of a type class, "
"it can't be overridden by defining a new instance."
msgstr ""

#: src/type-classes/coercion.md:38
msgid ""
"The type class `Coe` describes overloaded ways of coercing from one type to "
"another:"
msgstr ""

#: src/type-classes/coercion.md:43
msgid "An instance of `Coe Pos Nat` is enough to allow the prior code to work:"
msgstr ""

#: src/type-classes/coercion.md:53
msgid ""
"Using `#check` shows the result of the instance search that was used behind "
"the scenes:"
msgstr ""

#: src/type-classes/coercion.md:61
msgid "Chaining Coercions"
msgstr ""

#: src/type-classes/coercion.md:63
msgid ""
"When searching for coercions, Lean will attempt to assemble a coercion out "
"of a chain of smaller coercions. For example, there is already a coercion "
"from `Nat` to `Int`. Because of that instance, combined with the `Coe Pos "
"Nat` instance, the following code is accepted:"
msgstr ""

#: src/type-classes/coercion.md:69
msgid ""
"This definition uses two coercions: from `Pos` to `Nat`, and then from `Nat` "
"to `Int`."
msgstr ""

#: src/type-classes/coercion.md:71
msgid ""
"The Lean compiler does not get stuck in the presence of circular coercions. "
"For example, even if two types `A` and `B` can be coerced to one another, "
"their mutual coercions can be used to find a path:"
msgstr ""

#: src/type-classes/coercion.md:91
msgid ""
"Remember: the double parentheses `()` is short for the constructor "
"`Unit.unit`. After deriving a `Repr B` instance,"
msgstr ""

#: src/type-classes/coercion.md:96 src/monad-transformers/conveniences.md:16
msgid "results in:"
msgstr ""

#: src/type-classes/coercion.md:101
msgid ""
"The `Option` type can be used similarly to nullable types in C# and Kotlin: "
"the `none` constructor represents the absence of a value. The Lean standard "
"library defines a coercion from any type `α` to `Option α` that wraps the "
"value in `some`. This allows option types to be used in a manner even more "
"similar to nullable types, because `some` can be omitted. For instance, the "
"function `List.getLast?` that finds the last entry in a list can be written "
"without a `some` around the return value `x`:"
msgstr ""

#: src/type-classes/coercion.md:111
msgid ""
"Instance search finds the coercion, and inserts a call to `coe`, which wraps "
"the argument in `some`. These coercions can be chained, so that nested uses "
"of `Option` don't require nested `some` constructors:"
msgstr ""

#: src/type-classes/coercion.md:113
msgid ""
"```lean\n"
"def perhapsPerhapsPerhaps : Option (Option (Option String)) :=\n"
"  \"Please don't tell me\"\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:118
msgid ""
"Coercions are only activated automatically when Lean encounters a mismatch "
"between an inferred type and a type that is imposed from the rest of the "
"program. In cases with other errors, coercions are not activated. For "
"example, if the error is that an instance is missing, coercions will not be "
"used:"
msgstr ""

#: src/type-classes/coercion.md:130
msgid ""
"This can be worked around by manually indicating the desired type to be used "
"for `OfNat`:"
msgstr ""

#: src/type-classes/coercion.md:135
msgid "Additionally, coercions can be manually inserted using an up arrow:"
msgstr ""

#: src/type-classes/coercion.md:140
msgid ""
"In some cases, this can be used to ensure that Lean finds the right "
"instances. It can also make the programmer's intentions more clear."
msgstr ""

#: src/type-classes/coercion.md:144
msgid "Non-Empty Lists and Dependent Coercions"
msgstr ""

#: src/type-classes/coercion.md:146
msgid ""
"An instance of `Coe α β` makes sense when the type `β` has a value that can "
"represent each value from the type `α`. Coercing from `Nat` to `Int` makes "
"sense, because the type `Int` contains all the natural numbers. Similarly, a "
"coercion from non-empty lists to ordinary lists makes sense because the "
"`List` type can represent every non-empty list:"
msgstr ""

#: src/type-classes/coercion.md:154
msgid "This allows non-empty lists to be used with the entire `List` API."
msgstr ""

#: src/type-classes/coercion.md:156
msgid ""
"On the other hand, it is impossible to write an instance of `Coe (List α) "
"(NonEmptyList α)`, because there's no non-empty list that can represent the "
"empty list. This limitation can be worked around by using another version of "
"coercions, which are called _dependent coercions_. Dependent coercions can "
"be used when the ability to coerce from one type to another depends on which "
"particular value is being coerced. Just as the `OfNat` type class takes the "
"particular `Nat` being overloaded as a parameter, dependent coercion takes "
"the value being coerced as a parameter:"
msgstr ""

#: src/type-classes/coercion.md:164
msgid ""
"This is a chance to select only certain values, either by imposing further "
"type class constraints on the value or by writing certain constructors "
"directly. For example, any `List` that is not actually empty can be coerced "
"to a `NonEmptyList`:"
msgstr ""

#: src/type-classes/coercion.md:171
msgid "Coercing to Types"
msgstr ""

#: src/type-classes/coercion.md:173
msgid ""
"In mathematics, it is common to have a concept that consists of a set "
"equipped with additional structure. For example, a monoid is some set _S_, "
"an element _s_ of _S_, and an associative binary operator on _S_, such that "
"_s_ is neutral on the left and right of the operator. _S_ is referred to as "
"the \"carrier set\" of the monoid. The natural numbers with zero and "
"addition form a monoid, because addition is associative and adding zero to "
"any number is the identity. Similarly, the natural numbers with one and "
"multiplication also form a monoid. Monoids are also widely used in "
"functional programming: lists, the empty list, and the append operator form "
"a monoid, as do strings, the empty string, and string append:"
msgstr ""

#: src/type-classes/coercion.md:179
msgid ""
"```lean\n"
"structure Monoid where\n"
"  Carrier : Type\n"
"  neutral : Carrier\n"
"  op : Carrier → Carrier → Carrier\n"
"\n"
"def natMulMonoid : Monoid :=\n"
"  { Carrier := Nat, neutral := 1, op := (· * ·) }\n"
"\n"
"def natAddMonoid : Monoid :=\n"
"  { Carrier := Nat, neutral := 0, op := (· + ·) }\n"
"\n"
"def stringMonoid : Monoid :=\n"
"  { Carrier := String, neutral := \"\", op := String.append }\n"
"\n"
"def listMonoid (α : Type) : Monoid :=\n"
"  { Carrier := List α, neutral := [], op := List.append }\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:197
msgid ""
"Given a monoid, it is possible to write the `foldMap` function that, in a "
"single pass, transforms the entries in a list into a monoid's carrier set "
"and then combines them using the monoid's operator. Because monoids have a "
"neutral element, there is a natural result to return when the list is empty, "
"and because the operator is associative, clients of the function don't have "
"to care whether the recursive function combines elements from left to right "
"or from right to left."
msgstr ""

#: src/type-classes/coercion.md:207
msgid ""
"Even though a monoid consists of three separate pieces of information, it is "
"common to just refer to the monoid's name in order to refer to its set. "
"Instead of saying \"Let A be a monoid and let _x_ and _y_ be elements of its "
"carrier set\", it is common to say \"Let _A_ be a monoid and let _x_ and _y_ "
"be elements of _A_\". This practice can be encoded in Lean by defining a new "
"kind of coercion, from the monoid to its carrier set."
msgstr ""

#: src/type-classes/coercion.md:211
msgid ""
"The `CoeSort` class is just like the `Coe` class, with the exception that "
"the target of the coercion must be a _sort_, namely `Type` or `Prop`. The "
"term _sort_ in Lean refers to these types that classify other types—`Type` "
"classifies types that themselves classify data, and `Prop` classifies "
"propositions that themselves classify evidence of their truth. Just as `Coe` "
"is checked when a type mismatch occurs, `CoeSort` is used when something "
"other than a sort is provided in a context where a sort would be expected."
msgstr ""

#: src/type-classes/coercion.md:215
msgid "The coercion from a monoid into its carrier set extracts the carrier:"
msgstr ""

#: src/type-classes/coercion.md:220
msgid "With this coercion, the type signatures become less bureaucratic:"
msgstr ""

#: src/type-classes/coercion.md:229
msgid ""
"Another useful example of `CoeSort` is used to bridge the gap between `Bool` "
"and `Prop`. As discussed in [the section on ordering and "
"equality](standard-classes.md#equality-and-ordering), Lean's `if` expression "
"expects the condition to be a decidable proposition rather than a `Bool`. "
"Programs typically need to be able to branch based on Boolean values, "
"however. Rather than have two kinds of `if` expression, the Lean standard "
"library defines a coercion from `Bool` to the proposition that the `Bool` in "
"question is equal to `true`:"
msgstr ""

#: src/type-classes/coercion.md:237
msgid "In this case, the sort in question is `Prop` rather than `Type`."
msgstr ""

#: src/type-classes/coercion.md:239
msgid "Coercing to Functions"
msgstr ""

#: src/type-classes/coercion.md:241
msgid ""
"Many datatypes that occur regularly in programming consist of a function "
"along with some extra information about it. For example, a function might be "
"accompanied by a name to show in logs or by some configuration data. "
"Additionally, putting a type in a field of a structure, similarly to the "
"`Monoid` example, can make sense in contexts where there is more than one "
"way to implement an operation and more manual control is needed than type "
"classes would allow. For example, the specific details of values emitted by "
"a JSON serializer may be important because another application expects a "
"particular format. Sometimes, the function itself may be derivable from just "
"the configuration data."
msgstr ""

#: src/type-classes/coercion.md:247
msgid ""
"A type class called `CoeFun` can transform values from non-function types to "
"function types. `CoeFun` has two parameters: the first is the type whose "
"values should be transformed into functions, and the second is an output "
"parameter that determines exactly which function type is being targeted."
msgstr ""

#: src/type-classes/coercion.md:253
msgid ""
"The second parameter is itself a function that computes a type. In Lean, "
"types are first-class and can be passed to functions or returned from them, "
"just like anything else."
msgstr ""

#: src/type-classes/coercion.md:256
msgid ""
"For example, a function that adds a constant amount to its argument can be "
"represented as a wrapper around the amount to add, rather than by defining "
"an actual function:"
msgstr ""

#: src/type-classes/coercion.md:261
msgid ""
"A function that adds five to its argument has a `5` in the `howMuch` field:"
msgstr ""

#: src/type-classes/coercion.md:265
msgid ""
"This `Adder` type is not a function, and applying it to an argument results "
"in an error:"
msgstr ""

#: src/type-classes/coercion.md:275
msgid ""
"Defining a `CoeFun` instance causes Lean to transform the adder into a "
"function with type `Nat → Nat`:"
msgstr ""

#: src/type-classes/coercion.md:285
msgid ""
"Because all `Adder`s should be transformed into `Nat → Nat` functions, the "
"argument to `CoeFun`'s second parameter was ignored."
msgstr ""

#: src/type-classes/coercion.md:287
msgid ""
"When the value itself is needed to determine the right function type, then "
"`CoeFun`'s second parameter is no longer ignored. For example, given the "
"following representation of JSON values:"
msgstr ""

#: src/type-classes/coercion.md:300
msgid ""
"a JSON serializer is a structure that tracks the type it knows how to "
"serialize along with the serialization code itself:"
msgstr ""

#: src/type-classes/coercion.md:306
msgid ""
"A serializer for strings need only wrap the provided string in the "
"`JSON.string` constructor:"
msgstr ""

#: src/type-classes/coercion.md:313
msgid ""
"Viewing JSON serializers as functions that serialize their argument requires "
"extracting the inner type of serializable data:"
msgstr ""

#: src/type-classes/coercion.md:318
msgid "Given this instance, a serializer can be applied directly to an argument:"
msgstr ""

#: src/type-classes/coercion.md:319
msgid ""
"```lean\n"
"def buildResponse (title : String) (R : Serializer) (record : R.Contents) : "
"JSON :=\n"
"  JSON.object [\n"
"    (\"title\", JSON.string title),\n"
"    (\"status\", JSON.number 200),\n"
"    (\"record\", R record)\n"
"  ]\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:327
msgid "The serializer can be passed directly to `buildResponse`:"
msgstr ""

#: src/type-classes/coercion.md:328
msgid ""
"```lean\n"
"#eval buildResponse \"Functional Programming in Lean\" Str \"Programming is "
"fun!\"\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:331
msgid ""
"```output info\n"
"JSON.object\n"
"  [(\"title\", JSON.string \"Functional Programming in Lean\"),\n"
"   (\"status\", JSON.number 200.000000),\n"
"   (\"record\", JSON.string \"Programming is fun!\")]\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:338
msgid "Aside: JSON as a String"
msgstr ""

#: src/type-classes/coercion.md:340
msgid ""
"It can be a bit difficult to understand JSON when encoded as Lean objects. "
"To help make sure that the serialized response was what was expected, it can "
"be convenient to write a simple converter from `JSON` to `String`. The first "
"step is to simplify the display of numbers. `JSON` doesn't distinguish "
"between integers and floating point numbers, and the type `Float` is used to "
"represent both. In Lean, `Float.toString` includes a number of trailing "
"zeros:"
msgstr ""

#: src/type-classes/coercion.md:348
msgid ""
"```output info\n"
"\"5.000000\"\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:351
msgid ""
"The solution is to write a little function that cleans up the presentation "
"by dropping all trailing zeros, followed by a trailing decimal point:"
msgstr ""

#: src/type-classes/coercion.md:359
msgid ""
"With this definition, `#eval dropDecimals (5 : Float).toString` yields "
"`\"5\"`, and `#eval dropDecimals (5.2 : Float).toString` yields `\"5.2\"`."
msgstr ""

#: src/type-classes/coercion.md:361
msgid ""
"The next step is to define a helper function to append a list of strings "
"with a separator in between them:"
msgstr ""

#: src/type-classes/coercion.md:362
msgid ""
"```lean\n"
"def String.separate (sep : String) (strings : List String) : String :=\n"
"  match strings with\n"
"  | [] => \"\"\n"
"  | x :: xs => String.join (x :: xs.map (sep ++ ·))\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:368
msgid ""
"This function is useful to account for comma-separated elements in JSON "
"arrays and objects. `#eval \", \".separate [\"1\", \"2\"]` yields `\"1, "
"2\"`, `#eval \", \".separate [\"1\"]` yields `\"1\"`, and `#eval \", "
"\".separate []` yields `\"\"`."
msgstr ""

#: src/type-classes/coercion.md:371
msgid ""
"Finally, a string escaping procedure is needed for JSON strings, so that the "
"Lean string containing `\"Hello!\"` can be output as `\"\\\"Hello!\\\"\"`. "
"Fortunately, the Lean compiler contains an internal function for escaping "
"JSON strings already, called `Lean.Json.escape`. To access this function, "
"add `import Lean` to the beginning of your file."
msgstr ""

#: src/type-classes/coercion.md:375
msgid ""
"The function that emits a string from a `JSON` value is declared `partial` "
"because Lean cannot see that it terminates. This is because recursive calls "
"to `asString` occur in functions that are being applied by `List.map`, and "
"this pattern of recursion is complicated enough that Lean cannot see that "
"the recursive calls are actually being performed on smaller values. In an "
"application that just needs to produce JSON strings and doesn't need to "
"mathematically reason about the process, having the function be `partial` is "
"not likely to cause problems."
msgstr ""

#: src/type-classes/coercion.md:378
msgid ""
"```lean\n"
"partial def JSON.asString (val : JSON) : String :=\n"
"  match val with\n"
"  | true => \"true\"\n"
"  | false => \"false\"\n"
"  | null => \"null\"\n"
"  | string s => \"\\\"\" ++ Lean.Json.escape s ++ \"\\\"\"\n"
"  | number n => dropDecimals n.toString\n"
"  | object members =>\n"
"    let memberToString mem :=\n"
"      \"\\\"\" ++ Lean.Json.escape mem.fst ++ \"\\\": \" ++ asString "
"mem.snd\n"
"    \"{\" ++ \", \".separate (members.map memberToString) ++ \"}\"\n"
"  | array elements =>\n"
"    \"[\" ++ \", \".separate (elements.map asString) ++ \"]\"\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:393
msgid "With this definition, the output of serialization is easier to read:"
msgstr ""

#: src/type-classes/coercion.md:394
msgid ""
"```lean\n"
"#eval (buildResponse \"Functional Programming in Lean\" Str \"Programming is "
"fun!\").asString\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:397
msgid ""
"```output info\n"
"\"{\\\\\"title\\\\\": \\\\\"Functional Programming in Lean\\\\\", "
"\\\\\"status\\\\\": 200, \\\\\"record\\\\\": \\\\\"Programming is "
"fun!\\\\\"}\"\n"
"```"
msgstr ""

#: src/type-classes/coercion.md:404
msgid ""
"Natural number literals are overloaded with the `OfNat` type class. Because "
"coercions fire in cases where types don't match, rather than in cases of "
"missing instances, a missing `OfNat` instance for a type does not cause a "
"coercion from `Nat` to be applied:"
msgstr ""

#: src/type-classes/coercion.md:415
msgid "Design Considerations"
msgstr ""

#: src/type-classes/coercion.md:417
msgid ""
"Coercions are a powerful tool that should be used responsibly. On the one "
"hand, they can allow an API to naturally follow the everyday rules of the "
"domain being modeled. This can be the difference between a bureaucratic mess "
"of manual conversion functions and a clear program. As Abelson and Sussman "
"wrote in the preface to _Structure and Interpretation of Computer Programs_ "
"(MIT Press, 1996),"
msgstr ""

#: src/type-classes/coercion.md:422
msgid ""
"Programs must be written for people to read, and only incidentally for "
"machines to execute."
msgstr ""

#: src/type-classes/coercion.md:424
msgid ""
"Coercions, used wisely, are a valuable means of achieving readable code that "
"can serve as the basis for communication with domain experts. APIs that rely "
"heavily on coercions have a number of important limitations, however. Think "
"carefully about these limitations before using coercions in your own "
"libraries."
msgstr ""

#: src/type-classes/coercion.md:428
msgid ""
"First off, coercions are only applied in contexts where enough type "
"information is available for Lean to know all of the types involved, because "
"there are no output parameters in the coercion type classes. This means that "
"a return type annotation on a function can be the difference between a type "
"error and a successfully applied coercion. For example, the coercion from "
"non-empty lists to lists makes the following program work:"
msgstr ""

#: src/type-classes/coercion.md:434
msgid ""
"On the other hand, if the type annotation is omitted, then the result type "
"is unknown, so Lean is unable to find the coercion:"
msgstr ""

#: src/type-classes/coercion.md:449
msgid ""
"More generally, when a coercion is not applied for some reason, the user "
"receives the original type error, which can make it difficult to debug "
"chains of coercions."
msgstr ""

#: src/type-classes/coercion.md:451
msgid ""
"Finally, coercions are not applied in the context of field accessor "
"notation. This means that there is still an important difference between "
"expressions that need to be coerced and those that don't, and this "
"difference is visible to users of your API."
msgstr ""

#: src/type-classes/conveniences.md:3
msgid "Constructor Syntax for Instances"
msgstr ""

#: src/type-classes/conveniences.md:5
msgid ""
"Behind the scenes, type classes are structure types and instances are values "
"of these types. The only differences are that Lean stores additional "
"information about type classes, such as which parameters are output "
"parameters, and that instances are registered for searching. While values "
"that have structure types are typically defined using either `⟨...⟩` syntax "
"or with braces and fields, and instances are typically defined using "
"`where`, both syntaxes work for both kinds of definition."
msgstr ""

#: src/type-classes/conveniences.md:9
msgid "For example, a forestry application might represent trees as follows:"
msgstr ""

#: src/type-classes/conveniences.md:10
msgid ""
"```lean\n"
"structure Tree : Type where\n"
"  latinName : String\n"
"  commonNames : List String\n"
"\n"
"def oak : Tree :=\n"
"  ⟨\"Quercus robur\", [\"common oak\", \"European oak\"]⟩\n"
"\n"
"def birch : Tree :=\n"
"  { latinName := \"Betula pendula\",\n"
"    commonNames := [\"silver birch\", \"warty birch\"]\n"
"  }\n"
"\n"
"def sloe : Tree where\n"
"  latinName := \"Prunus spinosa\"\n"
"  commonNames := [\"sloe\", \"blackthorn\"]\n"
"```"
msgstr ""

#: src/type-classes/conveniences.md:27
msgid "All three syntaxes are equivalent."
msgstr ""

#: src/type-classes/conveniences.md:29
msgid "Similarly, type class instances can be defined using all three syntaxes:"
msgstr ""

#: src/type-classes/conveniences.md:44
msgid ""
"Generally speaking, the `where` syntax should be used for instances, and the "
"curly-brace syntax should be used for structures. The `⟨...⟩` syntax can be "
"useful when emphasizing that a structure type is very much like a tuple in "
"which the fields happen to be named, but the names are not important at the "
"moment. However, there are situations where it can make sense to use other "
"alternatives. In particular, a library might provide a function that "
"constructs an instance value. Placing a call to this function after `:=` in "
"an instance declaration is the easiest way to use such a function."
msgstr ""

#: src/type-classes/conveniences.md:50
msgid "Examples"
msgstr ""

#: src/type-classes/conveniences.md:52
msgid ""
"When experimenting with Lean code, definitions can be more convenient to use "
"than `#eval` or `#check` commands. First off, definitions don't produce any "
"output, which can help keep the reader's focus on the most interesting "
"output. Secondly, it's easiest to write most Lean programs by starting with "
"a type signature, allowing Lean to provide more assistance and better error "
"messages while writing the program itself. On the other hand, `#eval` and "
"`#check` are easiest to use in contexts where Lean is able to determine the "
"type from the provided expression. Thirdly, `#eval` cannot be used with "
"expressions whose types don't have `ToString` or `Repr` instances, such as "
"functions. Finally, multi-step `do` blocks, `let`\\-expressions, and other "
"syntactic forms that take multiple lines are particularly difficult to write "
"with a type annotation in `#eval` or `#check`, simply because the required "
"parenthesization can be difficult to predict."
msgstr ""

#: src/type-classes/conveniences.md:59
msgid ""
"To work around these issues, Lean supports the explicit indication of "
"examples in a source file. An example is like a definition without a name. "
"For instance, a non-empty list of birds commonly found in Copenhagen's green "
"spaces can be written:"
msgstr ""

#: src/type-classes/conveniences.md:62
msgid ""
"```lean\n"
"example : NonEmptyList String :=\n"
"  { head := \"Sparrow\",\n"
"    tail := [\"Duck\", \"Swan\", \"Magpie\", \"Eurasian coot\", \"Crow\"]\n"
"  }\n"
"```"
msgstr ""

#: src/type-classes/conveniences.md:69
msgid "Examples may define functions by accepting arguments:"
msgstr ""

#: src/type-classes/conveniences.md:74
msgid ""
"While this creates a function behind the scenes, this function has no name "
"and cannot be called. Nonetheless, this is useful for demonstrating how a "
"library can be used with arbitrary or unknown values of some given type. In "
"source files, `example` declarations are best paired with comments that "
"explain how the example illustrates the concepts of the library."
msgstr ""

#: src/type-classes/summary.md:3
msgid "Type Classes and Overloading"
msgstr ""

#: src/type-classes/summary.md:5
msgid ""
"Type classes are Lean's mechanism for overloading functions and operators. A "
"polymorphic function can be used with multiple types, but it behaves in the "
"same manner no matter which type it is used with. For example, a polymorphic "
"function that appends two lists can be used no matter the type of the "
"entries in the list, but it is unable to have different behavior depending "
"on which particular type is found. An operation that is overloaded with type "
"classes, on the other hand, can also be used with multiple types. However, "
"each type requires its own implementation of the overloaded operation. This "
"means that the behavior can vary based on which type is provided."
msgstr ""

#: src/type-classes/summary.md:12
msgid ""
"A _type class_ has a name, parameters, and a body that consists of a number "
"of names with types. The name is a way to refer to the overloaded "
"operations, the parameters determine which aspects of the definitions can be "
"overloaded, and the body provides the names and type signatures of the "
"overloadable operations. Each overloadable operation is called a _method_ of "
"the type class. Type classes may provide default implementations of some "
"methods in terms of the others, freeing implementors from defining each "
"overload by hand when it is not needed."
msgstr ""

#: src/type-classes/summary.md:17
msgid ""
"An _instance_ of a type class provides implementations of the methods for "
"given parameters. Instances may be polymorphic, in which case they can work "
"for a variety of parameters, and they may optionally provide more specific "
"implementations of default methods in cases where a more efficient version "
"exists for some particular type."
msgstr ""

#: src/type-classes/summary.md:20
msgid ""
"Type class parameters are either _input parameters_ (the default), or "
"_output parameters_ (indicated by an `outParam` modifier). Lean will not "
"begin searching for an instance until all input parameters are no longer "
"metavariables, while output parameters may be solved while searching for "
"instances. Parameters to a type class need not be types—they may also be "
"ordinary values. The `OfNat` type class, used to overload natural number "
"literals, takes the overloaded `Nat` itself as a parameter, which allows "
"instances to restrict the allowed numbers."
msgstr ""

#: src/type-classes/summary.md:25
msgid ""
"Instances may be marked with a `@[default_instance]` attribute. When an "
"instance is a default instance, then it will be chosen as a fallback when "
"Lean would otherwise fail to find an instance due to the presence of "
"metavariables in the type."
msgstr ""

#: src/type-classes/summary.md:28
msgid "Type Classes for Common Syntax"
msgstr ""

#: src/type-classes/summary.md:30
msgid ""
"Most infix operators in Lean are overridden with a type class. For instance, "
"the addition operator corresponds to a type class called `Add`. Most of "
"these operators have a corresponding heterogeneous version, in which the two "
"arguments need not have the same type. These heterogenous operators are "
"overloaded using a version of the class whose name starts with `H`, such as "
"`HAdd`."
msgstr ""

#: src/type-classes/summary.md:35
msgid ""
"Indexing syntax is overloaded using a type class called `GetElem`, which "
"involves proofs. `GetElem` has two output parameters, which are the type of "
"elements to be extracted from the collection and a function that can be used "
"to determine what counts as evidence that the index value is in bounds for "
"the collection. This evidence is described by a proposition, and Lean "
"attempts to prove this proposition when array indexing is used. When Lean is "
"unable to check that list or array access operations are in bounds at "
"compile time, the check can be deferred to run time by appending a `?` to "
"the indexing operation."
msgstr ""

#: src/type-classes/summary.md:42
msgid ""
"A functor is a polymorphic type that supports a mapping operation. This "
"mapping operation transforms all elements \"in place\", changing no other "
"structure. For instance, lists are functors and the mapping operation may "
"neither drop, duplicate, nor mix up entries in the list."
msgstr ""

#: src/type-classes/summary.md:46
msgid ""
"While functors are defined by having `map`, the `Functor` type class in Lean "
"contains an additional default method that is responsible for mapping the "
"constant function over a value, replacing all values whose type are given by "
"polymorphic type variable with the same new value. For some functors, this "
"can be done more efficiently than traversing the entire structure."
msgstr ""

#: src/type-classes/summary.md:49
msgid "Deriving Instances"
msgstr ""

#: src/type-classes/summary.md:51
msgid ""
"Many type classes have very standard implementations. For instance, the "
"Boolean equality class `BEq` is usually implemented by first checking "
"whether both arguments are built with the same constructor, and then "
"checking whether all their arguments are equal. Instances for these classes "
"can be created _automatically_."
msgstr ""

#: src/type-classes/summary.md:55
msgid ""
"When defining an inductive type or a structure, a `deriving` clause at the "
"end of the declaration will cause instances to be created automatically. "
"Additionally, the `deriving instance ... for ...` command can be used "
"outside of the definition of a datatype to cause an instance to be "
"generated. Because each class for which instances can be derived requires "
"special handling, not all classes are derivable."
msgstr ""

#: src/type-classes/summary.md:61
msgid ""
"Coercions allow Lean to recover from what would normally be a compile-time "
"error by inserting a call to a function that transforms data from one type "
"to another. For example, the coercion from any type `α` to the type `Option "
"α` allows values to be written directly, rather than with the `some` "
"constructor, making `Option` work more like nullable types from "
"object-oriented languages."
msgstr ""

#: src/type-classes/summary.md:64
msgid ""
"There are multiple kinds of coercion. They can recover from different kinds "
"of errors, and they are represented by their own type classes. The `Coe` "
"class is used to recover from type errors. When Lean has an expression of "
"type `α` in a context that expects something with type `β`, Lean first "
"attempts to string together a chain of coercions that can transform `α`s "
"into `β`s, and only displays the error when this cannot be done. The "
"`CoeDep` class takes the specific value being coerced as an extra parameter, "
"allowing either further type class search to be done on the value or "
"allowing constructors to be used in the instance to limit the scope of the "
"conversion. The `CoeFun` class intercepts what would otherwise be a \"not a "
"function\" error when compiling a function application, and allows the value "
"in the function position to be transformed into an actual function if "
"possible."
msgstr ""

#: src/monads.md:3
msgid ""
"In C# and Kotlin, the `?.` operator is a way to look up a property or call a "
"method on a potentially-null value. If the receiver is `null`, the whole "
"expression is null. Otherwise, the underlying non-`null` value receives the "
"call. Uses of `?.` can be chained, in which case the first `null` result "
"terminates the chain of lookups. Chaining null-checks like this is much more "
"convenient than writing and maintaining deeply nested `if`s."
msgstr ""

#: src/monads.md:9
msgid ""
"Similarly, exceptions are significantly more convenient than manually "
"checking and propagating error codes. At the same time, logging is easiest "
"to accomplish by having a dedicated logging framework, rather than having "
"each function return both its log results and its return value. Chained null "
"checks and exceptions typically require language designers to anticipate "
"this use case, while logging frameworks typically make use of side effects "
"to decouple code that logs from the accumulation of the logs."
msgstr ""

#: src/monads.md:13
msgid ""
"All these features and more can be implemented in library code as instances "
"of a common API called `Monad`. Lean provides dedicated syntax that makes "
"this API convenient to use, but can also get in the way of understanding "
"what is going on behind the scenes. This chapter begins with the "
"nitty-gritty presentation of manually nesting null checks, and builds from "
"there to the convenient, general API. Please suspend your disbelief in the "
"meantime."
msgstr ""

#: src/monads.md:18
msgid "Checking for `none`: Don't Repeat Yourself"
msgstr ""

#: src/monads.md:20
msgid ""
"In Lean, pattern matching can be used to chain checks for null. Getting the "
"first entry from a list can just use the optional indexing notation:"
msgstr ""

#: src/monads.md:26
msgid ""
"The result must be an `Option` because empty lists have no first entry. "
"Extracting the first and third entries requires a check that each is not "
"`none`:"
msgstr ""

#: src/monads.md:38
msgid ""
"Similarly, extracting the first, third, and fifth entries requires more "
"checks that the values are not `none`:"
msgstr ""

#: src/monads.md:52
msgid ""
"And adding the seventh entry to this sequence begins to become quite "
"unmanageable:"
msgstr ""

#: src/monads.md:71
msgid ""
"The fundamental problem with this code is that it addresses two concerns: "
"extracting the numbers and checking that all of them are present, but the "
"second concern is addressed by copying and pasting the code that handles the "
"`none` case. It is often good style to lift a repetitive segment into a "
"helper function:"
msgstr ""

#: src/monads.md:79
msgid ""
"This helper, which is used similarly to `?.` in C# and Kotlin, takes care of "
"propagating `none` values. It takes two arguments: an optional value and a "
"function to apply when the value is not `none`. If the first argument is "
"`none`, then the helper returns `none`. If the first argument is not `none`, "
"then the function is applied to the contents of the `some` constructor."
msgstr ""

#: src/monads.md:84
msgid ""
"Now, `firstThird` can be rewritten to use `andThen` instead of pattern "
"matching:"
msgstr ""

#: src/monads.md:91
msgid ""
"In Lean, functions don't need to be enclosed in parentheses when passed as "
"arguments. The following equivalent definition uses more parentheses and "
"indents the bodies of functions:"
msgstr ""

#: src/monads.md:99
msgid ""
"The `andThen` helper provides a sort of \"pipeline\" through which values "
"flow, and the version with the somewhat unusual indentation is more "
"suggestive of this fact. Improving the syntax used to write `andThen` can "
"make these computations even easier to understand."
msgstr ""

#: src/monads.md:102
msgid "Infix Operators"
msgstr ""

#: src/monads.md:104
msgid ""
"In Lean, infix operators can be declared using the `infix`, `infixl`, and "
"`infixr` commands, which create (respectively) non-associative, "
"left-associative, and right-associative operators. When used multiple times "
"in a row, a _left associative_ operator stacks up the opening parentheses on "
"the left side of the expression. The addition operator `+` is left "
"associative, so `w + x + y + z` is equivalent to `(((w + x) + y) + z)`. The "
"exponentiation operator `^` is right associative, so `w ^ x ^ y ^ z` is "
"equivalent to `(w ^ (x ^ (y ^ z)))`. Comparison operators such as `<` are "
"non-associative, so `x < y < z` is a syntax error and requires manual "
"parentheses."
msgstr ""

#: src/monads.md:110
msgid "The following declaration makes `andThen` into an infix operator:"
msgstr ""

#: src/monads.md:111
msgid ""
"```lean\n"
"infixl:55 \" ~~> \" => andThen\n"
"```"
msgstr ""

#: src/monads.md:114
msgid ""
"The number following the colon declares the _precedence_ of the new infix "
"operator. In ordinary mathematical notation, `x + y * z` is equivalent to `x "
"+ (y * z)` even though both `+` and `*` are left associative. In Lean, `+` "
"has precedence 65 and `*` has precedence 70. Higher-precedence operators are "
"applied before lower-precedence operators. According to the declaration of "
"`~~>`, both `+` and `*` have higher precedence, and thus apply first. "
"Typically, figuring out the most convenient precedences for a group of "
"operators requires some experimentation and a large collection of examples."
msgstr ""

#: src/monads.md:121
msgid ""
"Following the new infix operator is a double arrow `=>`, which specifies the "
"named function to be used for the infix operator. Lean's standard library "
"uses this feature to define `+` and `*` as infix operators that point at "
"`HAdd.hAdd` and `HMul.hMul`, respectively, allowing type classes to be used "
"to overload the infix operators. Here, however, `andThen` is just an "
"ordinary function."
msgstr ""

#: src/monads.md:125
msgid ""
"Having defined an infix operator for `andThen`, `firstThird` can be "
"rewritten in a way that brings the \"pipeline\" feeling of `none`\\-checks "
"front and center:"
msgstr ""

#: src/monads.md:132
msgid "This style is much more concise when writing larger functions:"
msgstr ""

#: src/monads.md:142
msgid "Propagating Error Messages"
msgstr ""

#: src/monads.md:144
msgid ""
"Pure functional languages such as Lean have no built-in exception mechanism "
"for error handling, because throwing or catching an exception is outside of "
"the step-by-step evaluation model for expressions. However, functional "
"programs certainly need to handle errors. In the case of "
"`firstThirdFifthSeventh`, it is likely relevant for a user to know just how "
"long the list was and where the lookup failed."
msgstr ""

#: src/monads.md:148
msgid ""
"This is typically accomplished by defining a datatype that can be either an "
"error or a result, and translating functions with exceptions into functions "
"that return this datatype:"
msgstr ""

#: src/monads.md:155
msgid ""
"The type variable `ε` stands for the type of errors that can be produced by "
"the function. Callers are expected to handle both errors and successes, "
"which makes the type variable `ε` play a role that is a bit like that of a "
"list of checked exceptions in Java."
msgstr ""

#: src/monads.md:158
msgid ""
"Similarly to `Option`, `Except` can be used to indicate a failure to find an "
"entry in a list. In this case, the error type is a `String`:"
msgstr ""

#: src/monads.md:160
msgid ""
"```lean\n"
"def get (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => Except.error s!\"Index {i} not found (maximum is {xs.length - "
"1})\"\n"
"  | some x => Except.ok x\n"
"```"
msgstr ""

#: src/monads.md:166
msgid "Looking up an in-bounds value yields an `Except.ok`:"
msgstr ""

#: src/monads.md:167
msgid ""
"```lean\n"
"def ediblePlants : List String :=\n"
"  [\"ramsons\", \"sea plantain\", \"sea buckthorn\", \"garden nasturtium\"]\n"
"\n"
"#eval get ediblePlants 2\n"
"```"
msgstr ""

#: src/monads.md:173
msgid ""
"```output info\n"
"Except.ok \"sea buckthorn\"\n"
"```"
msgstr ""

#: src/monads.md:176
msgid "Looking up an out-of-bounds value yields an `Except.error`:"
msgstr ""

#: src/monads.md:180
msgid ""
"```output info\n"
"Except.error \"Index 4 not found (maximum is 3)\"\n"
"```"
msgstr ""

#: src/monads.md:184
msgid "A single list lookup can conveniently return a value or an error:"
msgstr ""

#: src/monads.md:189
msgid ""
"However, performing two list lookups requires handling potential failures:"
msgstr ""

#: src/monads.md:200
msgid ""
"Adding another list lookup to the function requires still more error "
"handling:"
msgstr ""

#: src/monads.md:214
msgid "And one more list lookup begins to become quite unmanageable:"
msgstr ""

#: src/monads.md:232
msgid ""
"Once again, a common pattern can be factored out into a helper. Each step "
"through the function checks for an error, and only proceeds with the rest of "
"the computation if the result was a success. A new version of `andThen` can "
"be defined for `Except`:"
msgstr ""

#: src/monads.md:241
msgid ""
"Just as with `Option`, this version of `andThen` allows a more concise "
"definition of `firstThird`:"
msgstr ""

#: src/monads.md:249
msgid ""
"In both the `Option` and `Except` case, there are two repeating patterns: "
"there is the checking of intermediate results at each step, which has been "
"factored out into `andThen`, and there is the final successful result, which "
"is `some` or `Except.ok`, respectively. For the sake of convenience, success "
"can be factored out into a helper called `ok`:"
msgstr ""

#: src/monads.md:254
msgid "Similarly, failure can be factored out into a helper called `fail`:"
msgstr ""

#: src/monads.md:258
msgid "Using `ok` and `fail` makes `get` a little more readable:"
msgstr ""

#: src/monads.md:259
msgid ""
"```lean\n"
"def get (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => fail s!\"Index {i} not found (maximum is {xs.length - 1})\"\n"
"  | some x => ok x\n"
"```"
msgstr ""

#: src/monads.md:267
msgid ""
"After adding the infix declaration for `andThen`, `firstThird` can be just "
"as concise as the version that returns an `Option`:"
msgstr ""

#: src/monads.md:268
msgid ""
"```lean\n"
"infixl:55 \" ~~> \" => andThen\n"
"\n"
"def firstThird (xs : List α) : Except String (α × α) :=\n"
"  get xs 0 ~~> fun first =>\n"
"  get xs 2 ~~> fun third =>\n"
"  ok (first, third)\n"
"```"
msgstr ""

#: src/monads.md:276
msgid "The technique scales similarly to larger functions:"
msgstr ""

#: src/monads.md:286
msgid "Logging"
msgstr ""

#: src/monads.md:288
msgid "A number is even if dividing it by 2 leaves no remainder:"
msgstr ""

#: src/monads.md:293
msgid ""
"The function `sumAndFindEvens` computes the sum of a list while remembering "
"the even numbers encountered along the way:"
msgstr ""

#: src/monads.md:301
msgid ""
"This function is a simplified example of a common pattern. Many programs "
"need to traverse a data structure once, while both computing a main result "
"and accumulating some kind of tertiary extra result. One example of this is "
"logging: a program that is an `IO` action can always log to a file on disk, "
"but because the disk is outside of the mathematical world of Lean functions, "
"it becomes much more difficult to prove things about logs based on `IO`. "
"Another example is a function that computes the sum of all the nodes in a "
"tree with an inorder traversal, while simultaneously recording each nodes "
"visited:"
msgstr ""

#: src/monads.md:315
msgid ""
"Both `sumAndFindEvens` and `inorderSum` have a common repetitive structure. "
"Each step of computation returns a pair that consists of a list of data that "
"have been saved along with the primary result. The lists are then appended, "
"and the primary result is computed and paired with the appended lists. The "
"common structure becomes more apparent with a small rewrite of "
"`sumAndFindEvens` that more cleanly separates the concerns of saving even "
"numbers and computing the sum:"
msgstr ""

#: src/monads.md:328
msgid ""
"For the sake of clarity, a pair that consists of an accumulated result "
"together with a value can be given its own name:"
msgstr ""

#: src/monads.md:334
msgid ""
"Similarly, the process of saving a list of accumulated results while passing "
"a value on to the next step of a computation can be factored out into a "
"helper, once again named `andThen`:"
msgstr ""

#: src/monads.md:341
msgid ""
"In the case of errors, `ok` represents an operation that always succeeds. "
"Here, however, it is an operation that simply returns a value without "
"logging anything:"
msgstr ""

#: src/monads.md:346
msgid ""
"Just as `Except` provides `fail` as a possibility, `WithLog` should allow "
"items to be added to a log. This has no interesting return value associated "
"with it, so it returns `Unit`:"
msgstr ""

#: src/monads.md:353
msgid ""
"`WithLog`, `andThen`, `ok`, and `save` can be used to separate the logging "
"concern from the summing concern in both programs:"
msgstr ""

#: src/monads.md:370
msgid "And, once again, the infix operator helps put focus on the correct steps:"
msgstr ""

#: src/monads.md:371
msgid ""
"```lean\n"
"infixl:55 \" ~~> \" => andThen\n"
"\n"
"def sumAndFindEvens : List Int → WithLog Int Int\n"
"  | [] => ok 0\n"
"  | i :: is =>\n"
"    (if isEven i then save i else ok ()) ~~> fun () =>\n"
"    sumAndFindEvens is ~~> fun sum =>\n"
"    ok (i + sum)\n"
"\n"
"def inorderSum : BinTree Int → WithLog Int Int\n"
"  | BinTree.leaf => ok 0\n"
"  | BinTree.branch l x r =>\n"
"    inorderSum l ~~> fun leftSum =>\n"
"    save x ~~> fun () =>\n"
"    inorderSum r ~~> fun rightSum =>\n"
"    ok (leftSum + x + rightSum)\n"
"```"
msgstr ""

#: src/monads.md:390
msgid "Numbering Tree Nodes"
msgstr ""

#: src/monads.md:392
msgid ""
"An _inorder numbering_ of a tree associates each data point in the tree with "
"the step it would be visited at in an inorder traversal of the tree. For "
"example, consider `aTree`:"
msgstr ""

#: src/monads.md:394
msgid ""
"```lean\n"
"open BinTree in\n"
"def aTree :=\n"
"  branch\n"
"    (branch\n"
"       (branch leaf \"a\" (branch leaf \"b\" leaf))\n"
"       \"c\"\n"
"       leaf)\n"
"    \"d\"\n"
"    (branch leaf \"e\" leaf)\n"
"```"
msgstr ""

#: src/monads.md:405
msgid "Its inorder numbering is:"
msgstr ""

#: src/monads.md:406
msgid ""
"```output info\n"
"BinTree.branch\n"
"  (BinTree.branch\n"
"    (BinTree.branch (BinTree.leaf) (0, \"a\") (BinTree.branch (BinTree.leaf) "
"(1, \"b\") (BinTree.leaf)))\n"
"    (2, \"c\")\n"
"    (BinTree.leaf))\n"
"  (3, \"d\")\n"
"  (BinTree.branch (BinTree.leaf) (4, \"e\") (BinTree.leaf))\n"
"```"
msgstr ""

#: src/monads.md:416
msgid ""
"Trees are most naturally processed with recursive functions, but the usual "
"pattern of recursion on trees makes it difficult to compute an inorder "
"numbering. This is because the highest number assigned anywhere in the left "
"subtree is used to determine the numbering of a node's data value, and then "
"again to determine the starting point for numbering the right subtree. In an "
"imperative language, this issue can be worked around by using a mutable "
"variable that contains the next number to be assigned. The following Python "
"program computes an inorder numbering using a mutable variable:"
msgstr ""

#: src/monads.md:427
msgid "'Branch("
msgstr ""

#: src/monads.md:427
msgid ", left="
msgstr ""

#: src/monads.md:427
msgid ", right="
msgstr ""

#: src/monads.md:427
msgid ")'"
msgstr ""

#: src/monads.md:444
msgid "The numbering of the Python equivalent of `aTree` is:"
msgstr ""

#: src/monads.md:446
msgid "\"d\""
msgstr ""

#: src/monads.md:447
msgid "\"c\""
msgstr ""

#: src/monads.md:448
msgid "\"a\""
msgstr ""

#: src/monads.md:448
msgid "\"b\""
msgstr ""

#: src/monads.md:450
msgid "\"e\""
msgstr ""

#: src/monads.md:452
msgid "and its numbering is:"
msgstr ""

#: src/monads.md:459
msgid ""
"Even though Lean does not have mutable variables, a workaround exists. From "
"the point of view of the rest of the world, the mutable variable can be "
"thought of as having two relevant aspects: its value when the function is "
"called, and its value when the function returns. In other words, a function "
"that uses a mutable variable can be seen as a function that takes the "
"mutable variable's starting value as an argument, returning a pair of the "
"variable's final value and the function's result. This final value can then "
"be passed as an argument to the next step."
msgstr ""

#: src/monads.md:464
msgid ""
"Just as the Python example uses an outer function that establishes a mutable "
"variable and an inner helper function that changes the variable, a Lean "
"version of the function uses an outer function that provides the variable's "
"starting value and explicitly returns the function's result along with an "
"inner helper function that threads the variable's value while computing the "
"numbered tree:"
msgstr ""

#: src/monads.md:475
msgid ""
"This code, like the `none`\\-propagating `Option` code, the "
"`error`\\-propagating `Except` code, and the log-accumulating `WithLog` "
"code, commingles two concerns: propagating the value of the counter, and "
"actually traversing the tree to find the result. Just as in those cases, an "
"`andThen` helper can be defined to propagate state from one step of a "
"computation to another. The first step is to give a name to the pattern of "
"taking an input state as an argument and returning an output state together "
"with a value:"
msgstr ""

#: src/monads.md:483
msgid ""
"In the case of `State`, `ok` is a function that returns the input state "
"unchanged, along with the provided value:"
msgstr ""

#: src/monads.md:488
msgid ""
"When working with a mutable variable, there are two fundamental operations: "
"reading the value and replacing it with a new one. Reading the current value "
"is accomplished with a function that places the input state unmodified into "
"the output state, and also places it into the value field:"
msgstr ""

#: src/monads.md:494
msgid ""
"Writing a new value consists of ignoring the input state, and placing the "
"provided new value into the output state:"
msgstr ""

#: src/monads.md:499
msgid ""
"Finally, two computations that use state can be sequenced by finding both "
"the output state and return value of the first function, then passing them "
"both into the next function:"
msgstr ""

#: src/monads.md:500
msgid ""
"```lean\n"
"def andThen (first : State σ α) (next : α → State σ β) : State σ β :=\n"
"  fun s =>\n"
"    let (s', x) := first s\n"
"    next x s'\n"
"\n"
"infixl:55 \" ~~> \" => andThen\n"
"```"
msgstr ""

#: src/monads.md:509
msgid "Using `State` and its helpers, local mutable state can be simulated:"
msgstr ""

#: src/monads.md:522
msgid ""
"Because `State` simulates only a single local variable, `get` and `set` "
"don't need to refer to any particular variable name."
msgstr ""

#: src/monads.md:524
msgid "Monads: A Functional Design Pattern"
msgstr ""

#: src/monads.md:526
msgid "Each of these examples has consisted of:"
msgstr ""

#: src/monads.md:527
msgid ""
"A polymorphic type, such as `Option`, `Except ε`, `WithLog logged`, or "
"`State σ`"
msgstr ""

#: src/monads.md:528
msgid ""
"An operator `andThen` that takes care of some repetitive aspect of "
"sequencing programs that have this type"
msgstr ""

#: src/monads.md:529
msgid ""
"An operator `ok` that is (in some sense) the most boring way to use the type"
msgstr ""

#: src/monads.md:530
msgid ""
"A collection of other operations, such as `none`, `fail`, `save`, and `get`, "
"that name ways of using the type"
msgstr ""

#: src/monads.md:532
msgid ""
"This style of API is called a _monad_. While the idea of monads is derived "
"from a branch of mathematics called category theory, no understanding of "
"category theory is needed in order to use them for programming. The key idea "
"of monads is that each monad encodes a particular kind of side effect using "
"the tools provided by the pure functional language Lean. For example, "
"`Option` represents programs that can fail by returning `none`, `Except` "
"represents programs that can throw exceptions, `WithLog` represents programs "
"that accumulate a log while running, and `State` represents programs with a "
"single mutable variable."
msgstr ""

#: src/monads/class.md:3
msgid ""
"Rather than having to import an operator like `ok` or `andThen` for each "
"type that is a monad, the Lean standard library contains a type class that "
"allow them to be overloaded, so that the same operators can be used for "
"_any_ monad. Monads have two operations, which are the equivalent of `ok` "
"and `andThen`:"
msgstr ""

#: src/monads/class.md:10
msgid ""
"This definition is slightly simplified. The actual definition in the Lean "
"library is somewhat more involved, and will be presented later."
msgstr ""

#: src/monads/class.md:13
msgid ""
"The `Monad` instances for `Option` and `Except` can be created by adapting "
"the definitions of their respective `andThen` operations:"
msgstr ""

#: src/monads/class.md:30
msgid ""
"As an example, `firstThirdFifthSeventh` was defined separately for `Option "
"α` and `Except String α` return types. Now, it can be defined "
"polymorphically for _any_ monad. It does, however, require a lookup function "
"as an argument, because different monads might fail to find a result in "
"different ways. The infix version of `bind` is `>>=`, which plays the same "
"role as `~~>` in the examples."
msgstr ""

#: src/monads/class.md:43
msgid ""
"Given example lists of slow mammals and fast birds, this implementation of "
"`firstThirdFifthSeventh` can be used with `Option`:"
msgstr ""

#: src/monads/class.md:44
msgid ""
"```lean\n"
"def slowMammals : List String :=\n"
"  [\"Three-toed sloth\", \"Slow loris\"]\n"
"\n"
"def fastBirds : List String := [\n"
"  \"Peregrine falcon\",\n"
"  \"Saker falcon\",\n"
"  \"Golden eagle\",\n"
"  \"Gray-headed albatross\",\n"
"  \"Spur-winged goose\",\n"
"  \"Swift\",\n"
"  \"Anna's hummingbird\"\n"
"]\n"
"\n"
"#eval firstThirdFifthSeventh (fun xs i => xs[i]?) slowMammals\n"
"```"
msgstr ""

#: src/monads/class.md:66
msgid ""
"```output info\n"
"some (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", "
"\"Anna's hummingbird\")\n"
"```"
msgstr ""

#: src/monads/class.md:70
msgid ""
"After renaming `Except`'s lookup function `get` to something more specific, "
"the very same  implementation of `firstThirdFifthSeventh` can be used with "
"`Except` as well:"
msgstr ""

#: src/monads/class.md:71
msgid ""
"```lean\n"
"def getOrExcept (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => Except.error s!\"Index {i} not found (maximum is {xs.length - "
"1})\"\n"
"  | some x => Except.ok x\n"
"\n"
"#eval firstThirdFifthSeventh getOrExcept slowMammals\n"
"```"
msgstr ""

#: src/monads/class.md:79
msgid ""
"```output info\n"
"Except.error \"Index 2 not found (maximum is 1)\"\n"
"```"
msgstr ""

#: src/monads/class.md:85
msgid ""
"```output info\n"
"Except.ok (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", "
"\"Anna's hummingbird\")\n"
"```"
msgstr ""

#: src/monads/class.md:88
msgid ""
"The fact that `m` must have a `Monad` instance means that the `>>=` and "
"`pure` operations are available."
msgstr ""

#: src/monads/class.md:91
msgid "General Monad Operations"
msgstr ""

#: src/monads/class.md:93
msgid ""
"Because many different types are monads, functions that are polymorphic over "
"_any_ monad are very powerful. For example, the function `mapM` is a version "
"of `map` that uses a `Monad` to sequence and combine the results of applying "
"a function:"
msgstr ""

#: src/monads/class.md:103
msgid ""
"The return type of the function argument `f` determines which `Monad` "
"instance will be used. In other words, `mapM` can be used for functions that "
"produce logs, for functions that can fail, or for functions that use mutable "
"state. Because `f`'s type determines the available effects, they can be "
"tightly controlled by API designers."
msgstr ""

#: src/monads/class.md:107
msgid ""
"As described in [this chapter's "
"introduction](../monads.md#numbering-tree-nodes), `State σ α` represents "
"programs that make use of a mutable variable of type `σ` and return a value "
"of type `α`. These programs are actually functions from a starting state to "
"a pair of a value and a final state. The `Monad` class requires that its "
"parameter expect a single type argument—that is, it should be a `Type → "
"Type`. This means that the instance for `State` should mention the state "
"type `σ`, which becomes a parameter to the instance:"
msgstr ""

#: src/monads/class.md:119
msgid ""
"This means that the type of the state cannot change between calls to `get` "
"and `set` that are sequenced using `bind`, which is a reasonable rule for "
"stateful computations. The operator `increment` increases a saved state by a "
"given amount, returning the old value:"
msgstr ""

#: src/monads/class.md:128
msgid ""
"Using `mapM` with `increment` results in a program that computes the sum of "
"the entries in a list. More specifically, the mutable variable contains the "
"sum so far, while the resulting list contains a running sum. In other words, "
"`mapM increment` has type `List Int → State Int (List Int)`, and expanding "
"the definition of `State` yields `List Int → Int → (Int × List Int)`. It "
"takes an initial sum as an argument, which should be `0`:"
msgstr ""

#: src/monads/class.md:139
msgid ""
"A [logging effect](../monads.md#logging) can be represented using `WithLog`. "
"Just like `State`, its `Monad` instance is polymorphic with respect to the "
"type of the logged data:"
msgstr ""

#: src/monads/class.md:149
msgid ""
"`saveIfEven` is a function that logs even numbers but returns its argument "
"unchanged:"
msgstr ""

#: src/monads/class.md:157
msgid ""
"Using this function with `mapM` results in a log containing even numbers "
"paired with an unchanged input list:"
msgstr ""

#: src/monads/class.md:167
msgid "The Identity Monad"
msgstr ""

#: src/monads/class.md:169
msgid ""
"Monads encode programs with effects, such as failure, exceptions, or "
"logging, into explicit representations as data and functions. Sometimes, "
"however, an API will be written to use a monad for flexibility, but the "
"API's client may not require any encoded effects. The _identity monad_ is a "
"monad that has no effects, and allows pure code to be used with monadic APIs:"
msgstr ""

#: src/monads/class.md:179
msgid ""
"The type of `pure` should be `α → Id α`, but `Id α` reduces to just `α`. "
"Similarly, the type of `bind` should be `α → (α → Id β) → Id β`. Because "
"this reduces to `α → (α → β) → β`, the second argument can be applied to the "
"first to find the result."
msgstr ""

#: src/monads/class.md:183
msgid ""
"With the identity monad, `mapM` becomes equivalent to `map`. To call it this "
"way, however, Lean requires a hint that the intended monad is `Id`:"
msgstr ""

#: src/monads/class.md:191
msgid "Omitting the hint results in an error:"
msgstr ""

#: src/monads/class.md:199
msgid ""
"In this error, the application of one metavariable to another indicates that "
"Lean doesn't run the type-level computation backwards. The return type of "
"the function is expected to be the monad applied to some other type. "
"Similarly, using `mapM` with a function whose type doesn't provide any "
"specific hints about which monad is to be used results in an \"instance "
"problem stuck\" message:"
msgstr ""

#: src/monads/class.md:211
msgid "The Monad Contract"
msgstr ""

#: src/monads/class.md:212
msgid ""
"Just as every pair of instances of `BEq` and `Hashable` should ensure that "
"any two equal values have the same hash, there is a contract that each "
"instance of `Monad` should obey. First, `pure` should be a left identity of "
"`bind`. That is, `bind (pure v) f` should be the same as `f v`. Secondly, "
"`pure` should be a right identity of `bind`, so `bind v pure` is the same as "
"`v`. Finally, `bind` should be associative, so `bind (bind v f) g` is the "
"same as `bind v (fun x => bind (f x) g)`."
msgstr ""

#: src/monads/class.md:218
msgid ""
"This contract specifies the expected properties of programs with effects "
"more generally. Because `pure` has no effects, sequencing its effects with "
"`bind` shouldn't change the result. The associative property of `bind` "
"basically says that the sequencing bookkeeping itself doesn't matter, so "
"long as the order in which things are happening is preserved."
msgstr ""

#: src/monads/class.md:224
msgid "Mapping on a Tree"
msgstr ""

#: src/monads/class.md:226
msgid ""
"Define a function `BinTree.mapM`. By analogy to `mapM` for lists, this "
"function should apply a monadic function to each data entry in a tree, as a "
"preorder traversal. The type signature should be:"
msgstr ""

#: src/monads/class.md:234
msgid "The Option Monad Contract"
msgstr ""

#: src/monads/class.md:236
msgid ""
"First, write a convincing argument that the `Monad` instance for `Option` "
"satisfies the monad contract. Then, consider the following instance:"
msgstr ""

#: src/monads/class.md:243
msgid ""
"Both methods have the correct type. Why does this instance violate the monad "
"contract?"
msgstr ""

#: src/monads/arithmetic.md:3
msgid ""
"Monads are a way of encoding programs with side effects into a language that "
"does not have them. It would be easy to read this as a sort of admission "
"that pure functional programs are missing something important, requiring "
"programmers to jump through hoops just to write a normal program. However, "
"while using the `Monad` API does impose a syntactic cost on a program, it "
"brings two important benefits:"
msgstr ""

#: src/monads/arithmetic.md:6
msgid ""
"Programs must be honest about which effects they use in their types. A quick "
"glance at a type signature describes _everything_ that the program can do, "
"rather than just what it accepts and what it returns."
msgstr ""

#: src/monads/arithmetic.md:7
msgid ""
"Not every language provides the same effects. For example, only some "
"language have exceptions. Other languages have unique, exotic effects, such "
"as [Icon's searching over multiple "
"values](https://www2.cs.arizona.edu/icon/) and Scheme or Ruby's "
"continuations. Because monads can encode _any_ effect, programmers can "
"choose which ones are the best fit for a given application, rather than "
"being stuck with what the language developers provided."
msgstr ""

#: src/monads/arithmetic.md:9
msgid ""
"One example of a program that can make sense in a variety of monads is an "
"evaluator for arithmetic expressions."
msgstr ""

#: src/monads/arithmetic.md:11
msgid "Arithmetic Expressions"
msgstr ""

#: src/monads/arithmetic.md:13
msgid ""
"An arithmetic expression is either a literal integer or a primitive binary "
"operator applied to two expressions. The operators are addition, "
"subtraction, multiplication, and division:"
msgstr ""

#: src/monads/arithmetic.md:26
msgid "The expression `2 + 3` is represented:"
msgstr ""

#: src/monads/arithmetic.md:33
msgid "and `14 / (45 - 5 * 9)` is represented:"
msgstr ""

#: src/monads/arithmetic.md:43
msgid ""
"Because expressions include division, and division by zero is undefined, "
"evaluation might fail. One way to represent failure is to use `Option`:"
msgstr ""

#: src/monads/arithmetic.md:57
msgid ""
"This definition uses the `Monad Option` instance to propagate failures from "
"evaluating both branches of a binary operator. However, the function mixes "
"two concerns: evaluating subexpressions and applying a binary operator to "
"the results. It can be improved by splitting it into two functions:"
msgstr ""

#: src/monads/arithmetic.md:75
msgid ""
"Running `#eval evaluateOption fourteenDivided` yields `none`, as expected, "
"but this is not a very useful error message. Because the code was written "
"using `>>=` rather than by explicitly handling the `none` constructor, only "
"a small modification is required for it to provide an error message on "
"failure:"
msgstr ""

#: src/monads/arithmetic.md:77
msgid ""
"```lean\n"
"def applyPrim : Arith → Int → Int → Except String Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"\n"
"def evaluateExcept : Expr Arith → Except String Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateExcept e1 >>= fun v1 =>\n"
"    evaluateExcept e2 >>= fun v2 =>\n"
"    applyPrim p v1 v2\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:95
msgid ""
"The only difference is that the type signature mentions `Except String` "
"instead of `Option`, and the failing case uses `Except.error` instead of "
"`none`. By making `evaluate` polymorphic over its monad and passing it "
"`applyPrim` as an argument, a single evaluator becomes capable of both forms "
"of error reporting:"
msgstr ""

#: src/monads/arithmetic.md:97
msgid ""
"```lean\n"
"def applyPrimOption : Arith → Int → Int → Option Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      none\n"
"    else pure (x / y)\n"
"\n"
"def applyPrimExcept : Arith → Int → Int → Except String Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def evaluateM [Monad m] (applyPrim : Arith → Int → Int → m Int): Expr Arith "
"→ m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applyPrim e1 >>= fun v1 =>\n"
"    evaluateM applyPrim e2 >>= fun v2 =>\n"
"    applyPrim p v1 v2\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:123
msgid ""
"Using it with `applyPrimOption` works just like the first version of "
"`evaluate`:"
msgstr ""

#: src/monads/arithmetic.md:130
msgid ""
"Similarly, using it with `applyPrimExcept` works just like the version with "
"error messages:"
msgstr ""

#: src/monads/arithmetic.md:134
msgid ""
"```output info\n"
"Except.error \"Tried to divide 14 by zero\"\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:138
msgid ""
"The code can still be improved. The functions `applyPrimOption` and "
"`applyPrimExcept` differ only in their treatment of division, which can be "
"extracted into another parameter to the evaluator:"
msgstr ""

#: src/monads/arithmetic.md:140
msgid ""
"```lean\n"
"def applyDivOption (x : Int) (y : Int) : Option Int :=\n"
"    if y == 0 then\n"
"      none\n"
"    else pure (x / y)\n"
"\n"
"def applyDivExcept (x : Int) (y : Int) : Except String Int :=\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def applyPrim [Monad m] (applyDiv : Int → Int → m Int) : Arith → Int → Int → "
"m Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y => applyDiv x y\n"
"\n"
"def evaluateM [Monad m] (applyDiv : Int → Int → m Int): Expr Arith → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applyDiv e1 >>= fun v1 =>\n"
"    evaluateM applyDiv e2 >>= fun v2 =>\n"
"    applyPrim applyDiv p v1 v2\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:165
msgid ""
"In this refactored code, the fact that the two code paths differ only in "
"their treatment of failure has been made fully apparent."
msgstr ""

#: src/monads/arithmetic.md:167
msgid "Further Effects"
msgstr ""

#: src/monads/arithmetic.md:169
msgid ""
"Failure and exceptions are not the only kinds of effects that can be "
"interesting when working with an evaluator. While division's only side "
"effect is failure, adding other primitive operators to the expressions make "
"it possible to express other effects."
msgstr ""

#: src/monads/arithmetic.md:172
msgid ""
"The first step is an additional refactoring, extracting division from the "
"datatype of primitives:"
msgstr ""

#: src/monads/arithmetic.md:183
msgid ""
"The name `CanFail` suggests that the effect introduced by division is "
"potential failure."
msgstr ""

#: src/monads/arithmetic.md:185
msgid ""
"The second step is to broaden the scope of the division handler argument to "
"`evaluateM` so that it can process any special operator:"
msgstr ""

#: src/monads/arithmetic.md:186
msgid ""
"```lean\n"
"def divOption : CanFail → Int → Int → Option Int\n"
"  | CanFail.div, x, y => if y == 0 then none else pure (x / y)\n"
"\n"
"def divExcept : CanFail → Int → Int → Except String Int\n"
"  | CanFail.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def applyPrim [Monad m] (applySpecial : special → Int → Int → m Int) : Prim "
"special → Int → Int → m Int\n"
"  | Prim.plus, x, y => pure (x + y)\n"
"  | Prim.minus, x, y => pure (x - y)\n"
"  | Prim.times, x, y => pure (x * y)\n"
"  | Prim.other op, x, y => applySpecial op x y\n"
"\n"
"def evaluateM [Monad m] (applySpecial : special → Int → Int → m Int): Expr "
"(Prim special) → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applySpecial e1 >>= fun v1 =>\n"
"    evaluateM applySpecial e2 >>= fun v2 =>\n"
"    applyPrim applySpecial p v1 v2\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:210
msgid "No Effects"
msgstr ""

#: src/monads/arithmetic.md:212
msgid ""
"The type `Empty` has no constructors, and thus no values, like the `Nothing` "
"type in Scala or Kotlin. In Scala and Kotlin, `Nothing` can represent "
"computations that never return a result, such as functions that crash the "
"program, throw exceptions, or always fall into infinite loops. An argument "
"to a function or method of type `Nothing` indicates dead code, as there will "
"never be a suitable argument value. Lean doesn't support infinite loops and "
"exceptions, but `Empty` is still useful as an indication to the type system "
"that a function cannot be called. Using the syntax `nomatch E` when `E` is "
"an expression whose type has no constructors indicates to Lean that the "
"current expression need not return a result, because it could never have "
"been called. "
msgstr ""

#: src/monads/arithmetic.md:218
msgid ""
"Using `Empty` as the parameter to `Prim` indicates that there are no "
"additional cases beyond `Prim.plus`, `Prim.minus`, and `Prim.times`, because "
"it is impossible to come up with a value of type `Empty` to place in the "
"`Prim.other` constructor. Because a function to apply an operator of type "
"`Empty` to two integers can never be called, it doesn't need to return a "
"result. Thus, it can be used in _any_ monad:"
msgstr ""

#: src/monads/arithmetic.md:225
msgid ""
"This can be used together with `Id`, the identity monad, to evaluate "
"expressions that have no effects whatsoever:"
msgstr ""

#: src/monads/arithmetic.md:234
msgid "Nondeterministic Search"
msgstr ""

#: src/monads/arithmetic.md:236
msgid ""
"Instead of simply failing when encountering division by zero, it would also "
"be sensible to backtrack and try a different input. Given the right monad, "
"the very same `evaluateM` can perform a nondeterministic search for a _set_ "
"of answers that do not result in failure. This requires, in addition to "
"division, some means of specifying a choice of results. One way to do this "
"is to add a function `choose` to the language of expressions that instructs "
"the evaluator to pick either of its arguments while searching for "
"non-failing results."
msgstr ""

#: src/monads/arithmetic.md:241
msgid ""
"The result of the evaluator is now a multiset of values, rather than a "
"single value. The rules for evaluation into a multiset are:"
msgstr ""

#: src/monads/arithmetic.md:243
msgid "Constants \\\\( n \\\\) evaluate to singleton sets \\\\( {n} \\\\)."
msgstr ""

#: src/monads/arithmetic.md:244
msgid ""
"Arithmetic operators other than division are called on each pair from the "
"Cartesian product of the operators, so \\\\( X + Y \\\\) evaluates to \\\\( "
"\\\\{ x + y \\\\mid x ∈ X, y ∈ Y \\\\} \\\\)."
msgstr ""

#: src/monads/arithmetic.md:245
msgid ""
"Division \\\\( X / Y \\\\) evaluates to \\\\( \\\\{ x / y \\\\mid x ∈ X, y ∈ "
"Y, y ≠ 0\\\\} \\\\). In other words, all \\\\( 0 \\\\) values in \\\\( Y "
"\\\\)  are thrown out."
msgstr ""

#: src/monads/arithmetic.md:246
msgid ""
"A choice \\\\( \\\\mathrm{choose}(x, y) \\\\) evaluates to \\\\( \\\\{ x, y "
"\\\\} \\\\)."
msgstr ""

#: src/monads/arithmetic.md:248
msgid ""
"For example, \\\\( 1 + \\\\mathrm{choose}(2, 5) \\\\) evaluates to \\\\( "
"\\\\{ 3, 6 \\\\} \\\\), \\\\(1 + 2 / 0 \\\\) evaluates to \\\\( \\\\{\\\\} "
"\\\\), and \\\\( 90 / (\\\\mathrm{choose}(-5, 5) + 5) \\\\) evaluates to "
"\\\\( \\\\{ 9 \\\\} \\\\). Using multisets instead of true sets simplifies "
"the code by removing the need to check for uniqueness of elements."
msgstr ""

#: src/monads/arithmetic.md:251
msgid ""
"A monad that represents this non-deterministic effect must be able to "
"represent a situation in which there are no answers, and a situation in "
"which there is at least one answer together with any remaining answers:"
msgstr ""

#: src/monads/arithmetic.md:257
msgid ""
"This datatype looks very much like `List`. The difference is that where "
"`cons` stores the rest of the list, `more` stores a function that should "
"compute the next value on demand. This means that a consumer of `Many` can "
"stop the search when some number of results have been found."
msgstr ""

#: src/monads/arithmetic.md:261
msgid ""
"A single result is represented by a `more` constructor that returns no "
"further results:"
msgstr ""

#: src/monads/arithmetic.md:265
msgid ""
"The union of two multisets of results can be computed by checking whether "
"the first multiset is empty. If so, the second multiset is the union. If "
"not, the union consists of the first element of the first multiset followed "
"by the union of the rest of the first multiset with the second multiset:"
msgstr ""

#: src/monads/arithmetic.md:274
msgid ""
"It can be convenient to start a search process with a list of values. "
"`Many.fromList` converts a list into a multiset of results:"
msgstr ""

#: src/monads/arithmetic.md:281
msgid ""
"Similarly, once a search has been specified, it can be convenient to extract "
"either a number of values, or all the values:"
msgstr ""

#: src/monads/arithmetic.md:293
msgid ""
"A `Monad Many` instance requires a `bind` operator. In a nondeterministic "
"search, sequencing two operations consists of taking all possibilities from "
"the first step and running the rest of the program on each of them, taking "
"the union of the results. In other words, if the first step returns three "
"possible answers, the second step needs to be tried for all three. Because "
"the second step can return any number of answers for each input, taking "
"their union represents the entire search space."
msgstr ""

#: src/monads/arithmetic.md:305
msgid ""
"`Many.one` and `Many.bind` obey the monad contract. To check that `Many.bind "
"(Many.one v) f` is the same as `f v`, start by evaluating the expression as "
"far as possible:"
msgstr ""

#: src/monads/arithmetic.md:316
msgid ""
"The empty multiset is a right identity of `union`, so the answer is "
"equivalent to `f v`. To check that `Many.bind v Many.one` is the same as "
"`v`, consider that `bind` takes the union of applying `Many.one` to each "
"element of `v`. In other words, if `v` has the form `{v1, v2, v3, ..., vn}`, "
"then `Many.bind v Many.one` is `{v1} ∪ {v2} ∪ {v3} ∪ ... ∪ {vn}`, which is "
"`{v1, v2, v3, ..., vn}`."
msgstr ""

#: src/monads/arithmetic.md:320
msgid ""
"Finally, to check that `Many.bind` is associative, check that `Many.bind "
"(Many.bind bind v f) g` is the same as `Many.bind v (fun x => Many.bind (f "
"x) g)`. If `v` has the form `{v1, v2, v3, ..., vn}`, then:"
msgstr ""

#: src/monads/arithmetic.md:327
msgid "which means that"
msgstr ""

#: src/monads/arithmetic.md:337
msgid "Similarly,"
msgstr ""

#: src/monads/arithmetic.md:353
msgid "Thus, both sides are equal, so `Many.bind` is associative."
msgstr ""

#: src/monads/arithmetic.md:355
msgid "The resulting monad instance is:"
msgstr ""

#: src/monads/arithmetic.md:361
msgid ""
"An example search using this monad finds all the combinations of numbers in "
"a list that add to 15:"
msgstr ""

#: src/monads/arithmetic.md:377
msgid ""
"The search process is recursive over the list. The empty list is a "
"successful search when the goal is `0`; otherwise, it fails. When the list "
"is non-empty, there are two possibilities: either the head of the list is "
"greater than the goal, in which case it cannot participate in any successful "
"searches, or it is not, in which case it can. If the head of the list is "
"_not_ a candidate, then the search proceeds to the tail of the list. If the "
"head is a candidate, then there are two possibilities to be combined with "
"`Many.union`: either the solutions found contain the head, or they do not. "
"The solutions that do not contain the head are found with a recursive call "
"on the tail, while the solutions that do contain it result from subtracting "
"the head from the goal, and then attaching the head to the solutions that "
"result from the recursive call."
msgstr ""

#: src/monads/arithmetic.md:384
msgid ""
"Returning to the arithmetic evaluator that produces multisets of results, "
"the `both` and `neither` operators can be written as follows:"
msgstr ""

#: src/monads/arithmetic.md:398
msgid "Using these operators, the earlier examples can be evaluated:"
msgstr ""

#: src/monads/arithmetic.md:420
msgid "Custom Environments"
msgstr ""

#: src/monads/arithmetic.md:422
msgid ""
"The evaluator can be made user-extensible by allowing strings to be used as "
"operators, and then providing a mapping from strings to a function that "
"implements them. For example, users could extend the evaluator with a "
"remainder operator or with one that returns the maximum of its two "
"arguments. The mapping from function names to function implementations is "
"called an _environment_."
msgstr ""

#: src/monads/arithmetic.md:426
msgid ""
"The environments needs to be passed in each recursive call. Initially, it "
"might seem that `evaluateM` needs an extra argument to hold the environment, "
"and that this argument should be passed to each recursive invocation. "
"However, passing an argument like this is another form of monad, so an "
"appropriate `Monad` instance allows the evaluator to be used unchanged."
msgstr ""

#: src/monads/arithmetic.md:430
msgid ""
"Using functions as a monad is typically called a _reader_ monad. When "
"evaluating expressions in the reader monad, the following rules are used:"
msgstr ""

#: src/monads/arithmetic.md:432
msgid ""
"Constants \\\\( n \\\\) evaluate to constant functions \\\\( λ e . n \\\\),"
msgstr ""

#: src/monads/arithmetic.md:433
msgid ""
"Arithmetic operators evaluate to functions that pass their arguments on, so "
"\\\\( f + g \\\\) evaluates to \\\\( λ e . f(e) + g(e) \\\\), and"
msgstr ""

#: src/monads/arithmetic.md:434
msgid ""
"Custom operators evaluate to the result of applying the custom operator to "
"the arguments, so \\\\( f \\\\ \\\\mathrm{OP}\\\\ g \\\\) evaluates to "
"\\\\\\[ λ e . \\\\begin{cases} h(f(e), g(e)) & \\\\mathrm{if}\\\\ e\\\\ "
"\\\\mathrm{contains}\\\\ (\\\\mathrm{OP}, h) \\\\\\\\ 0 & "
"\\\\mathrm{otherwise} \\\\end{cases} \\\\\\] with \\\\( 0 \\\\) serving as a "
"fallback in case an unknown operator is applied."
msgstr ""

#: src/monads/arithmetic.md:444
msgid ""
"To define the reader monad in Lean, the first step is to define the `Reader` "
"type and the effect that allows users to get ahold of the environment:"
msgstr ""

#: src/monads/arithmetic.md:450
msgid ""
"By convention, the Greek letter `ρ`, which is pronounced \"rho\", is used "
"for environments."
msgstr ""

#: src/monads/arithmetic.md:452
msgid ""
"The fact that constants in arithmetic expressions evaluate to constant "
"functions suggests that the appropriate definition of `pure` for `Reader` is "
"a a constant function:"
msgstr ""

#: src/monads/arithmetic.md:457
msgid ""
"On the other hand, `bind` is a bit tricker. Its type is `Reader ρ α → (α → "
"Reader ρ β) → Reader ρ β`. This type can be easier to understand by "
"expanding the definitions of `Reader`, which yields `(ρ → α) → (α → ρ → β) → "
"ρ → β`. It should take an environment-accepting function as its first "
"argument, while the second argument should transform the result of the "
"environment-accepting function into yet another environment-accepting "
"function. The result of combining these is itself a function, waiting for an "
"environment."
msgstr ""

#: src/monads/arithmetic.md:463
msgid ""
"It's possible to use Lean interactively to get help writing this function. "
"The first step is to write down the arguments and return type, being very "
"explicit in order to get as much help as possible, with an underscore for "
"the definition's body:"
msgstr ""

#: src/monads/arithmetic.md:470
msgid ""
"Lean provides a message that describes which variables are available in "
"scope, and the type that's expected for the result. The `⊢` symbol, called a "
"_turnstile_ due to its resemblance to subway entrances, separates the local "
"variables from the desired type, which is `ρ → β` in this message:"
msgstr ""

#: src/monads/arithmetic.md:481
msgid ""
"Because the return type is a function, a good first step is to wrap a `fun` "
"around the underscore:"
msgstr ""

#: src/monads/arithmetic.md:487
msgid ""
"The resulting message now shows the function's argument as a local variable:"
msgstr ""

#: src/monads/arithmetic.md:498
msgid ""
"The only thing in the context that can produce a `β` is `next`, and it will "
"require two arguments to do so. Each argument can itself be an underscore:"
msgstr ""

#: src/monads/arithmetic.md:505
msgid ""
"The two underscores have the following respective messages associated with "
"them:"
msgstr ""

#: src/monads/arithmetic.md:525
msgid ""
"Attacking the first underscore, only one thing in the context can produce an "
"`α`, namely `result`:"
msgstr ""

#: src/monads/arithmetic.md:531
msgid "Now, both underscores have the same error:"
msgstr ""

#: src/monads/arithmetic.md:541
msgid "Happily, both underscores can be replaced by `env`, yielding:"
msgstr ""

#: src/monads/arithmetic.md:548
msgid ""
"The final version can be obtained by undoing the expansion of `Reader` and "
"cleaning up the explicit details:"
msgstr ""

#: src/monads/arithmetic.md:554
msgid ""
"It's not always possible to write correct functions by simply \"following "
"the types\", and it carries the risk of not understanding the resulting "
"program. However, it can also be easier to understand a program that has "
"been written than one that has not, and the process of filling in the "
"underscores can bring insights. In this case, `Reader.bind` works just like "
"`bind` for `Id`, except it accepts an additional argument that it then "
"passes down to its arguments, and this intuition can help in understanding "
"how it works."
msgstr ""

#: src/monads/arithmetic.md:558
msgid ""
"`Reader.pure`, which generates constant functions, and `Reader.bind` obey "
"the monad contract. To check that `Reader.bind (Reader.pure v) f` is the "
"same as `f v`, it's enough to replace definitions until the last step:"
msgstr ""

#: src/monads/arithmetic.md:571
msgid ""
"For every function `f`, `fun x => f x` is the same as `f`, so the first part "
"of the contract is satisfied. To check that `Reader.bind r Reader.pure` is "
"the same as `r`, a similar technique works:"
msgstr ""

#: src/monads/arithmetic.md:582
msgid ""
"Because reader actions `r` are themselves functions, this is the same as "
"`r`. To check associativity, the same thing can be done for both "
"`Reader.bind (Reader.bind r f) g` and `Reader.bind r (fun x => Reader.bind "
"(f x) g)`:"
msgstr ""

#: src/monads/arithmetic.md:606
msgid "Thus, a `Monad (Reader ρ)` instance is justified:"
msgstr ""

#: src/monads/arithmetic.md:613
msgid ""
"The custom environments that will be passed to the expression evaluator can "
"be represented as lists of pairs:"
msgstr ""

#: src/monads/arithmetic.md:617
msgid "For instance, `exampleEnv` contains maximum and modulus functions:"
msgstr ""

#: src/monads/arithmetic.md:618
msgid ""
"```lean\n"
"def exampleEnv : Env := [(\"max\", max), (\"mod\", (· % ·))]\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:622
msgid ""
"Lean already has a function `List.lookup` that finds the value associated "
"with a key in a list of pairs, so `applyPrimReader` needs only check whether "
"the custom function is present in the environment. It returns `0` if the "
"function is unknown:"
msgstr ""

#: src/monads/arithmetic.md:631
msgid ""
"Using `evaluateM` with `applyPrimReader` and an expression results in a "
"function that expects an environment. Luckily, `exampleEnv` is available:"
msgstr ""

#: src/monads/arithmetic.md:633
msgid ""
"```lean\n"
"open Expr Prim in\n"
"#eval evaluateM applyPrimReader (prim (other \"max\") (prim plus (const 5) "
"(const 4)) (prim times (const 3) (const 2))) exampleEnv\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:641
msgid ""
"Like `Many`, `Reader` is an example of an effect that is difficult to encode "
"in most languages, but type classes and monads make it just as convenient as "
"any other effect. The dynamic or special variables found in Common Lisp, "
"Clojure, and Emacs Lisp can be used like `Reader`. Similarly, Scheme and "
"Racket's parameter objects are an effect that exactly correspond to "
"`Reader`. The Kotlin idiom of context objects can solve a similar problem, "
"but they are fundamentally a means of passing function arguments "
"automatically, so this idiom is more like the encoding as a reader monad "
"than it is an effect in the language."
msgstr ""

#: src/monads/arithmetic.md:648
msgid "Checking Contracts"
msgstr ""

#: src/monads/arithmetic.md:650
msgid "Check the monad contract for `State σ` and `Except ε`."
msgstr ""

#: src/monads/arithmetic.md:653
msgid "Readers with Failure"
msgstr ""

#: src/monads/arithmetic.md:654
msgid ""
"Adapt the reader monad example so that it can also indicate failure when the "
"custom operator is not defined, rather than just returning zero. In other "
"words, given these definitions:"
msgstr ""

#: src/monads/arithmetic.md:661
msgid "do the following:"
msgstr ""

#: src/monads/arithmetic.md:662
msgid "Write suitable `pure` and `bind` functions"
msgstr ""

#: src/monads/arithmetic.md:663
msgid "Check that these functions satisfy the `Monad` contract"
msgstr ""

#: src/monads/arithmetic.md:664
msgid "Write `Monad` instances for `ReaderOption` and `ReaderExcept`"
msgstr ""

#: src/monads/arithmetic.md:665
msgid ""
"Define suitable `applyPrim` operators and test them with `evaluateM` on some "
"example expressions"
msgstr ""

#: src/monads/arithmetic.md:667
msgid "A Tracing Evaluator"
msgstr ""

#: src/monads/arithmetic.md:669
msgid ""
"The `WithLog` type can be used with the evaluator to add optional tracing of "
"some operations. In particular, the type `ToTrace` can serve as a signal to "
"trace a given operator:"
msgstr ""

#: src/monads/arithmetic.md:675
msgid ""
"For the tracing evaluator, expressions should have type `Expr (Prim (ToTrace "
"(Prim Empty)))`. This says that the operators in the expression consist of "
"addition, subtraction, and multiplication, augmented with traced versions of "
"each. The innermost argument is `Empty` to signal that there are no further "
"special operators inside of `trace`, only the three basic ones."
msgstr ""

#: src/monads/arithmetic.md:678
msgid "Do the following:"
msgstr ""

#: src/monads/arithmetic.md:679
msgid "Implement a `Monad (WithLog logged)` instance"
msgstr ""

#: src/monads/arithmetic.md:680
msgid ""
"Write an `applyTraced` function to apply traced operators to their "
"arguments, logging both the operator and the arguments, with type `ToTrace "
"(Prim Empty) → Int → Int → WithLog (Prim Empty × Int × Int) Int`"
msgstr ""

#: src/monads/arithmetic.md:682
msgid "If the exercise has been completed correctly, then"
msgstr ""

#: src/monads/arithmetic.md:687
msgid "should result in"
msgstr ""

#: src/monads/arithmetic.md:692
msgid ""
"Hint: values of type `Prim Empty` will appear in the resulting log. In order "
"to display them as a result of `#eval`, the following instances are required:"
msgstr ""

#: src/monads/do.md:3
msgid ""
"While APIs based on monads are very powerful, the explicit use of `>>=` with "
"anonymous functions is still somewhat noisy. Just as infix operators are "
"used instead of explicit calls to `HAdd.hAdd`, Lean provides a syntax for "
"monads called _`do`\\-notation_ that can make programs that use monads "
"easier to read and write. This is the very same `do`\\-notation that is used "
"to write programs in `IO`, and `IO` is also a monad."
msgstr ""

#: src/monads/do.md:7
msgid ""
"In [Hello, World!](../hello-world.md), the `do` syntax is used to combine "
"`IO` actions, but the meaning of these programs is explained directly. "
"Understanding how to program with monads means that `do` can now be "
"explained in terms of how it translates into uses of the underlying monad "
"operators."
msgstr ""

#: src/monads/do.md:10
msgid ""
"The first translation of `do` is used when the only statement in the `do` is "
"a single expression `E`. In this case, the `do` is removed, so"
msgstr ""

#: src/monads/do.md:15 src/monads/do.md:28 src/monads/do.md:43
#: src/monads/do.md:58
msgid "translates to"
msgstr ""

#: src/monads/do.md:20
msgid ""
"The second translation is used when the first statement of the `do` is a "
"`let` with an arrow, binding a local variable. This translates to a use of "
"`>>=` together with a function that binds that very same variable, so"
msgstr ""

#: src/monads/do.md:36
msgid ""
"When the first statement of the `do` block is an expression, then it is "
"considered to be a monadic action that returns `Unit`, so the function "
"matches the `Unit` constructor and"
msgstr ""

#: src/monads/do.md:51
msgid ""
"Finally, when the first statement of the `do` block is a `let` that uses "
"`:=`, the translated form is an ordinary let expression, so"
msgstr ""

#: src/monads/do.md:66
msgid ""
"The definition of `firstThirdFifthSeventh` that uses the `Monad` class looks "
"like this:"
msgstr ""

#: src/monads/do.md:75
msgid "Using `do`\\-notation, it becomes significantly more readable:"
msgstr ""

#: src/monads/do.md:85
msgid ""
"Without the `Monad` type class, the function `number` that numbers the nodes "
"of a tree was written:"
msgstr ""

#: src/monads/do.md:98
msgid "With `Monad` and `do`, its definition is much less noisy:"
msgstr ""

#: src/monads/do.md:113
msgid ""
"All of the conveniences from `do` with `IO` are also available when using it "
"with other monads. For example, nested actions also work in any monad. The "
"original definition of `mapM` was:"
msgstr ""

#: src/monads/do.md:124
msgid "With `do`\\-notation, it can be written:"
msgstr ""

#: src/monads/do.md:133
msgid ""
"Using nested actions makes it almost as short as the original non-monadic "
"`map`:"
msgstr ""

#: src/monads/do.md:140
msgid "Using nested actions, `number` can be made much more concise:"
msgstr ""

#: src/monads/do.md:159
msgid ""
"Rewrite `evaluateM`, its helpers, and the different specific use cases using "
"`do`\\-notation instead of explicit calls to `>>=`."
msgstr ""

#: src/monads/do.md:160
msgid "Rewrite `firstThirdFifthSeventh` using nested actions."
msgstr ""

#: src/monads/io.md:1
msgid "The IO Monad"
msgstr ""

#: src/monads/io.md:3
msgid ""
"`IO` as a monad can be understood from two perspectives, which were "
"described in the section on [running "
"programs](../hello-world/running-a-program.md). Each can help to understand "
"the meanings of `pure` and `bind` for `IO`."
msgstr ""

#: src/monads/io.md:6
msgid ""
"From the first perspective, an `IO` action is an instruction to Lean's "
"run-time system. For example, the instruction might be \"read a string from "
"this file descriptor, then re-invoke the pure Lean code with the string\". "
"This perspective is an _exterior_ one, viewing the program from the "
"perspective of the operating system. In this case, `pure` is an `IO` action "
"that does not request any effects from the RTS, and `bind` instructs the RTS "
"to first carry out one potentially-effectful operation and then invoke the "
"rest of the program with the resulting value."
msgstr ""

#: src/monads/io.md:11
msgid ""
"From the second perspective, an `IO` action transforms the whole world. `IO` "
"actions are actually pure, because they receive a unique world as an "
"argument and then return the changed world. This perspective is an "
"_interior_ one that matches how `IO` is represented inside of Lean. The "
"world is represented in Lean as a token, and the `IO` monad is structured to "
"make sure that each token is used exactly once."
msgstr ""

#: src/monads/io.md:16
msgid ""
"To see how this works, it can be helpful to peel back one definition at a "
"time. The `#print` command reveals the internals of Lean datatypes and "
"definitions. For example,"
msgstr ""

#: src/monads/io.md:40
msgid ""
"Sometimes, the output of `#print` includes Lean features that have not yet "
"been presented in this book. For example,"
msgstr ""

#: src/monads/io.md:45
msgid "produces"
msgstr ""

#: src/monads/io.md:53
msgid ""
"which includes a `.{u}` after the definition's name, and annotates types as "
"`Type u` rather than just `Type`. This can be safely ignored for now."
msgstr ""

#: src/monads/io.md:56
msgid ""
"Printing the definition of `IO` shows that it's defined in terms of simpler "
"structures:"
msgstr ""

#: src/monads/io.md:64
msgid ""
"`IO.Error` represents all the errors that could be thrown by an `IO` action:"
msgstr ""

#: src/monads/io.md:92
msgid ""
"`EIO ε α` represents `IO` actions that will either terminate with an error "
"of type `ε` or succeed with a value of type `α`. This means that, like the "
"`Except ε` monad, the `IO` monad includes the ability to define error "
"handling and exceptions."
msgstr ""

#: src/monads/io.md:95
msgid ""
"Peeling back another layer, `EIO` is itself defined in terms of a simpler "
"structure:"
msgstr ""

#: src/monads/io.md:103
msgid ""
"The `EStateM` monad includes both errors and state—it's a combination of "
"`Except` and `State`. It is defined using another type, `EStateM.Result`:"
msgstr ""

#: src/monads/io.md:112
msgid ""
"In other words, a program with type `EStateM ε σ α` is a function that "
"accepts an initial state of type `σ` and returns an `EStateM.Result ε σ α`."
msgstr ""

#: src/monads/io.md:114
msgid ""
"`EStateM.Result` is very much like the definition of `Except`, with one "
"constructor that indicates a successful termination and one constructor that "
"indicates an error:"
msgstr ""

#: src/monads/io.md:125
msgid ""
"Just like `Except ε α`, the `ok` constructor includes a result of type `α`, "
"and the `error` constructor includes an exception of type `ε`. Unlike "
"`Except`, both constructors have an additional state field that includes the "
"final state of the computation."
msgstr ""

#: src/monads/io.md:128
msgid ""
"The `Monad` instance for `EStateM ε σ` requires `pure` and `bind`. Just as "
"with `State`, the implementation of `pure` for `EStateM` accepts an initial "
"state and returns it unchanged, and just as with `Except`, it returns its "
"argument in the `ok` constructor:"
msgstr ""

#: src/monads/io.md:137
msgid ""
"`protected` means that the full name `EStateM.pure` is needed even if the "
"`EStateM` namespace has been opened."
msgstr ""

#: src/monads/io.md:139
msgid ""
"Similarly, `bind` for `EStateM` takes an initial state as an argument. It "
"passes this initial state to its first action. Like `bind` for `Except`, it "
"then checks whether the result is an error. If so, the error is returned "
"unchanged and the second argument to `bind` remains unused. If the result "
"was a success, then the second argument is applied to both the returned "
"value and to the resulting state."
msgstr ""

#: src/monads/io.md:155
msgid ""
"Putting all of this together, `IO` is a monad that tracks state and errors "
"at the same time. The collection of available errors is that given by the "
"datatype `IO.Error`, which has constructors that describe many things that "
"can go wrong in a program. The state is a type that represents the real "
"world, called `IO.RealWorld`. Each basic `IO` action receives this real "
"world and returns another one, paired either with an error or a result. In "
"`IO`, `pure` returns the world unchanged, while `bind` passes the modified "
"world from one action into the next action."
msgstr ""

#: src/monads/io.md:161
msgid ""
"Because the entire universe doesn't fit in a computer's memory, the world "
"being passed around is just a representation. So long as world tokens are "
"not re-used, the representation is safe. This means that world tokens do not "
"need to contain any data at all:"
msgstr ""

#: src/monads/conveniences.md:3
msgid "Shared Argument Types"
msgstr ""

#: src/monads/conveniences.md:5
msgid ""
"When defining a function that takes multiple arguments that have the same "
"type, both can be written before the same colon. For example,"
msgstr ""

#: src/monads/conveniences.md:14
msgid "can be written"
msgstr ""

#: src/monads/conveniences.md:22
msgid "This is especially useful when the type signature is large."
msgstr ""

#: src/monads/conveniences.md:24
msgid "Leading Dot Notation"
msgstr ""

#: src/monads/conveniences.md:26
msgid ""
"The constructors of an inductive type are in a namespace. This allows "
"multiple related inductive types to use the same constructor names, but it "
"can lead to programs becoming verbose. In contexts where the inductive type "
"in question is known, the namespace can be omitted by preceding the "
"constructor's name with a dot, and Lean uses the expected type to resolve "
"the constructor names. For example, a function that mirrors a binary tree "
"can be written:"
msgstr ""

#: src/monads/conveniences.md:35
msgid ""
"Omitting the namespaces makes it significantly shorter, at the cost of "
"making the program harder to read in contexts like code review tools that "
"don't include the Lean compiler:"
msgstr ""

#: src/monads/conveniences.md:42
msgid ""
"Using the expected type of an expression to disambiguate a namespace is also "
"applicable to names other than constructors. If `BinTree.empty` is defined "
"as an alternative way of creating `BinTree`s, then it can also be used with "
"dot notation:"
msgstr ""

#: src/monads/conveniences.md:53
msgid "Or-Patterns"
msgstr ""

#: src/monads/conveniences.md:55
msgid ""
"In contexts that allow multiple patterns, such as `match`\\-expressions, "
"multiple patterns may share their result expressions. The datatype `Weekday` "
"that represents days of the week:"
msgstr ""

#: src/monads/conveniences.md:69
msgid "Pattern matching can be used to check whether a day is a weekend:"
msgstr ""

#: src/monads/conveniences.md:77
msgid "This can already be simplified by using constructor dot notation:"
msgstr ""

#: src/monads/conveniences.md:85
msgid ""
"Because both weekend patterns have the same result expression (`true`), they "
"can be condensed into one:"
msgstr ""

#: src/monads/conveniences.md:92
msgid ""
"This can be further simplified into a version in which the argument is not "
"named:"
msgstr ""

#: src/monads/conveniences.md:99
msgid ""
"Behind the scenes, the result expression is simply duplicated across each "
"pattern. This means that patterns can bind variables, as in this example "
"that removes the `inl` and `inr` constructors from a sum type in which both "
"contain the same type of value:"
msgstr ""

#: src/monads/conveniences.md:105
msgid ""
"Because the result expression is duplicated, the variables bound by the "
"patterns are not required to have the same types. Overloaded functions that "
"work for multiple types may be used to write a single result expression that "
"works for patterns that bind variables of different types:"
msgstr ""

#: src/monads/conveniences.md:107
msgid ""
"```lean\n"
"def stringy : Nat ⊕ Weekday → String\n"
"  | .inl x | .inr x => s!\"It is {repr x}\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:111
msgid ""
"In practice, only variables shared in all patterns can be referred to in the "
"result expression, because the result must make sense for each pattern. In "
"`getTheNat`, only `n` can be accessed, and attempts to use either `x` or `y` "
"lead to errors."
msgstr ""

#: src/monads/conveniences.md:117
msgid ""
"Attempting to access `x` in a similar definition causes an error because "
"there is no `x` available in the second pattern:"
msgstr ""

#: src/monads/conveniences.md:126
msgid ""
"The fact that the result expression is essentially copy-pasted to each "
"branch of the pattern match can lead to some surprising behavior. For "
"example, the following definitions are acceptable because the `inr` version "
"of the result expression refers to the global definition of `str`:"
msgstr ""

#: src/monads/conveniences.md:128
msgid ""
"```lean\n"
"def str := \"Some string\"\n"
"\n"
"def getTheString : (Nat × String) ⊕ (Nat × β) → String\n"
"  | .inl (n, str) | .inr (n, y) => str\n"
"```"
msgstr ""

#: src/monads/conveniences.md:134
msgid ""
"Calling this function on both constructors reveals the confusing behavior. "
"In the first case, a type annotation is needed to tell Lean which type `β` "
"should be:"
msgstr ""

#: src/monads/conveniences.md:136
msgid ""
"```lean\n"
"#eval getTheString (.inl (20, \"twenty\") : (Nat × String) ⊕ (Nat × "
"String))\n"
"```"
msgstr ""

#: src/monads/conveniences.md:139
msgid ""
"```output info\n"
"\"twenty\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:142
msgid "In the second case, the global definition is used:"
msgstr ""

#: src/monads/conveniences.md:143
msgid ""
"```lean\n"
"#eval getTheString (.inr (20, \"twenty\"))\n"
"```"
msgstr ""

#: src/monads/conveniences.md:146
msgid ""
"```output info\n"
"\"Some string\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:150
msgid ""
"Using or-patterns can vastly simplify some definitions and increase their "
"clarity, as in `Weekday.isWeekend`. Because there is a potential for "
"confusing behavior, it's a good idea to be careful when using them, "
"especially when variables of multiple types or disjoint sets of variables "
"are involved."
msgstr ""

#: src/monads/summary.md:3
msgid "Encoding Side Effects"
msgstr ""

#: src/monads/summary.md:5
msgid ""
"Lean is a pure functional language. This means that it does not include side "
"effects such as mutable variables, logging, or exceptions. However, most "
"side effects can be _encoded_ using a combination of functions and inductive "
"types or structures. For example, mutable state can be encoded as a function "
"from an initial state to a pair of a final state and a result, and "
"exceptions can be encoded as an inductive type with constructors for "
"successful termination and errors."
msgstr ""

#: src/monads/summary.md:10
msgid ""
"Each set of encoded effects is a type. As a result, if a program uses these "
"encoded effects, then this is apparent in its type. Functional programming "
"does not mean that programs can't use effects, it simply requires that they "
"be _honest_ about which effects they use. A Lean type signature describes "
"not only the types of arguments that a function expects and the type of "
"result that it returns, but also which effects it may use."
msgstr ""

#: src/monads/summary.md:17
msgid ""
"It's possible to write purely functional programs in languages that allow "
"effects anywhere. For example, `2 + 3` is a valid Python program that has no "
"effects at all. Similarly, combining programs that have effects requires a "
"way to state the order in which the effects must occur. It matters whether "
"an exception is thrown before or after modifying a variable, after all."
msgstr ""

#: src/monads/summary.md:22
msgid ""
"The type class `Monad` captures these two important properties. It has two "
"methods: `pure` represents programs that have no effects, and `bind` "
"sequences effectful programs. The contract for `Monad` instances ensures "
"that `bind` and `pure` actually capture pure computation and sequencing."
msgstr ""

#: src/monads/summary.md:28
msgid ""
"Rather than being limited to `IO`, `do`\\-notation works for any monad. It "
"allows programs that use monads to be written in a style that is reminiscent "
"of statement-oriented languages, with statements sequenced after one "
"another. Additionally, `do`\\-notation enables a number of additional "
"convenient shorthands, such as nested actions. A program written with `do` "
"is translated to applications of `>>=` behind the scenes."
msgstr ""

#: src/monads/summary.md:33
msgid "Custom Monads"
msgstr ""

#: src/monads/summary.md:35
msgid ""
"Different languages provide different sets of side effects. While most "
"languages feature mutable variables and file I/O, not all have features like "
"exceptions. Other languages offer effects that are rare or unique, like "
"Icon's search-based program execution, Scheme and Ruby's continuations, and "
"Common Lisp's resumable exceptions. An advantage to encoding effects with "
"monads is that programs are not limited to the set of effects that are "
"provided by the language. Because Lean is designed to make programming with "
"any monad convenient, programmers are free to choose exactly the set of side "
"effects that make sense for any given application."
msgstr ""

#: src/monads/summary.md:43
msgid ""
"Programs that can affect the real world are written as `IO` actions in Lean. "
"`IO` is one monad among many. The `IO` monad encodes state and exceptions, "
"with the state being used to keep track of the state of the world and the "
"exceptions modeling failure and recovery."
msgstr ""

#: src/functor-applicative-monad.md:3
msgid ""
"`Functor` and `Monad` both describe operations for types that are still "
"waiting for a type argument. One way to understand them is that `Functor` "
"describes containers in which the contained data can be transformed, and "
"`Monad` describes an encoding of programs with side effects. This "
"understanding is incomplete, however. After all, `Option` has instances for "
"both `Functor` and `Monad`, and simultaneously represents an optional value "
"_and_ a computation that might fail to return a value."
msgstr ""

#: src/functor-applicative-monad.md:8
msgid ""
"From the perspective of data structures, `Option` is a bit like a nullable "
"type or like a list that can contain at most one entry. From the perspective "
"of control structures, `Option` represents a computation that might "
"terminate early without a result. Typically, programs that use the `Functor` "
"instance are easiest to think of as using `Option` as a data structure, "
"while programs that use the `Monad` instance are easiest to think of as "
"using `Option` to allow early failure, but learning to use both of these "
"perspectives fluently is an important part of becoming proficient at "
"functional programming."
msgstr ""

#: src/functor-applicative-monad.md:12
msgid ""
"There is a deeper relationship between functors and monads. It turns out "
"that _every monad is a functor_. Another way to say this is that the monad "
"abstraction is more powerful than the functor abstraction, because not every "
"functor is a monad. Furthermore, there is an additional intermediate "
"abstraction, called _applicative functors_, that has enough power to write "
"many interesting programs and yet permits libraries that cannot use the "
"`Monad` interface. The type class `Applicative` provides the overloadable "
"operations of applicative functors. Every monad is an applicative functor, "
"and every applicative functor is a functor, but the converses do not hold."
msgstr ""

#: src/functor-applicative-monad/inheritance.md:3
msgid ""
"In order to understand the full definitions of `Functor`, `Applicative`, and "
"`Monad`, another Lean feature is necessary: structure inheritance. Structure "
"inheritance allows one structure type to provide the interface of another, "
"along with additional fields. This can be useful when modeling concepts that "
"have a clear taxonomic relationship. For example, take a model of mythical "
"creatures. Some of them are large, and some are small:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:13
msgid ""
"Behind the scenes, defining the `MythicalCreature` structure creates an "
"inductive type with a single constructor called `mk`:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:20
msgid ""
"Similarly, a function `MythicalCreature.large` is created that actually "
"extracts the field from the constructor:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:28
msgid ""
"In most old stories, each monster can be defeated in some way. A description "
"of a monster should include this information, along with whether it is large:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:35
msgid ""
"The `extends MythicalCreature` in the heading states that every monster is "
"also mythical. To define a `Monster`, both the fields from "
"`MythicalCreature` and the fields from `Monster` should be provided. A troll "
"is a large monster that is vulnerable to sunlight:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:38
msgid ""
"```lean\n"
"def troll : Monster where\n"
"  large := true\n"
"  vulnerability := \"sunlight\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:44
msgid ""
"Behind the scenes, inheritance is implemented using composition. The "
"constructor `Monster.mk` takes a `MythicalCreature` as its argument:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:52
msgid ""
"In addition to defining functions to extract the value of each new field, a "
"function `Monster.toMythicalCreature` is defined with type `Monster → "
"MythicalCreature`. This can be used to extract the underlying creature."
msgstr ""

#: src/functor-applicative-monad/inheritance.md:55
msgid ""
"Moving up the inheritance hierarchy in Lean is not the same thing as "
"upcasting in object-oriented languages. An upcast operator causes a value "
"from a derived class to be treated as an instance of the parent class, but "
"the value retains its identity and structure. In Lean, however, moving up "
"the inheritance hierarchy actually erases the underlying information. To see "
"this in action, consider the result of evaluating `troll.toMythicalCreature`:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:65
msgid "Only the fields of `MythicalCreature` remain."
msgstr ""

#: src/functor-applicative-monad/inheritance.md:68
msgid ""
"Just like the `where` syntax, curly-brace notation with field names also "
"works with structure inheritance:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:69
msgid ""
"```lean\n"
"def troll : Monster := {large := true, vulnerability := \"sunlight\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:72
msgid ""
"However, the anonymous angle-bracket notation that delegates to the "
"underlying constructor reveals the internal details:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:73
msgid ""
"```lean\n"
"def troll : Monster := ⟨true, \"sunlight\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:86
msgid ""
"An extra set of angle brackets is required, which invokes "
"`MythicalCreature.mk` on `true`:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:87
msgid ""
"```lean\n"
"def troll : Monster := ⟨⟨true⟩, \"sunlight\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:92
msgid ""
"Lean's dot notation is capable of taking inheritance into account. In other "
"words, the existing `MythicalCreature.large` can be used with a `Monster`, "
"and Lean automatically inserts the call to `Monster.toMythicalCreature` "
"before the call to `MythicalCreature.large`. However, this only occurs when "
"using dot notation, and applying the field lookup function using normal "
"function call syntax results in a type error:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:108
msgid ""
"Dot notation can also take inheritance into account for user-defined "
"functions. A small creature is one that is not large:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:113
msgid ""
"Evaluating `troll.small` yields `false`, while attempting to evaluate "
"`MythicalCreature.small troll` results in:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:125
msgid "Multiple Inheritance"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:127
msgid ""
"A helper is a mythical creature that can provide assistance when given the "
"correct payment:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:134
msgid ""
"For example, a _nisse_ is a kind of small elf that's known to help around "
"the house when provided with tasty porridge:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:135
msgid ""
"```lean\n"
"def nisse : Helper where\n"
"  large := false\n"
"  assistance := \"household tasks\"\n"
"  payment := \"porridge\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:142
msgid ""
"If domesticated, trolls make excellent helpers. They are strong enough to "
"plow a whole field in a single night, though they require model goats to "
"keep them satisfied with their lot in life. A monstrous assistant is a "
"monster that is also a helper:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:149
msgid ""
"A value of this structure type must fill in all of the fields from both "
"parent structures:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:150
msgid ""
"```lean\n"
"def domesticatedTroll : MonstrousAssistant where\n"
"  large := false\n"
"  assistance := \"heavy labor\"\n"
"  payment := \"toy goats\"\n"
"  vulnerability := \"sunlight\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:158
msgid ""
"Both of the parent structure types extend `MythicalCreature`. If multiple "
"inheritance were implemented naïvely, then this could lead to a \"diamond "
"problem\", where it would be unclear which path to `large` should be taken "
"from a given `MonstrousAssistant`. Should it take `large` from the contained "
"`Monster` or from the contained `Helper`? In Lean, the answer is that the "
"first specified path to the grandparent structure is taken, and the "
"additional parent structures' fields are copied rather than having the new "
"structure include both parents directly."
msgstr ""

#: src/functor-applicative-monad/inheritance.md:163
msgid ""
"This can be seen by examining the signature of the constructor for "
"`MonstrousAssistant`:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:170
msgid ""
"It takes a `Monster` as an argument, along with the two fields that `Helper` "
"introduces on top of `MythicalCreature`. Similarly, while "
"`MonstrousAssistant.toMonster` merely extracts the `Monster` from the "
"constructor, `MonstrousAssistant.toHelper` has no `Helper` to extract. The "
"`#print` command exposes its implementation:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:181
msgid ""
"This function constructs a `Helper` from the fields of `MonstrousAssistant`. "
"The `@[reducible]` attribute has the same effect as writing `abbrev`."
msgstr ""

#: src/functor-applicative-monad/inheritance.md:184
msgid "Default Declarations"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:186
msgid ""
"When one structure inherits from another, default field definitions can be "
"used to instantiate the parent structure's fields based on the child "
"structure's fields. If more size specificity is required than whether a "
"creature is large or not, a dedicated datatype describing sizes can be used "
"together with inheritance, yielding a structure in which the `large` field "
"is computed from the contents of the `size` field:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:199
msgid ""
"This default definition is only a default definition, however. Unlike "
"property inheritance in a language like C# or Scala, the definitions in the "
"child structure are only used when no specific value for `large` is "
"provided, and nonsensical results can occur:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:206
msgid ""
"If the child structure should not deviate from the parent structure, there "
"are a few options:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:208
msgid "Documenting the relationship, as is done for `BEq` and `Hashable`"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:209
msgid ""
"Defining a proposition that the fields are related appropriately, and "
"designing the API to require evidence that the proposition is true where it "
"matters"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:210
msgid "Not using inheritance at all"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:212
msgid "The second option could look like this:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:217
msgid ""
"Note that a single equality sign is used to indicate the equality "
"_proposition_, while a double equality sign is used to indicate a function "
"that checks equality and returns a `Bool`. `SizesMatch` is defined as an "
"`abbrev` because it should automatically be unfolded in proofs, so that "
"`simp` can see the equality that should be proven."
msgstr ""

#: src/functor-applicative-monad/inheritance.md:220
msgid ""
"A _huldre_ is a medium-sized mythical creature—in fact, they are the same "
"size as humans. The two sized fields on `huldre` match one another:"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:231
msgid "Type Class Inheritance"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:233
msgid ""
"Behind the scenes, type classes are structures. Defining a new type class "
"defines a new structure, and defining an instance creates a value of that "
"structure type. They are then added to internal tables in Lean that allow it "
"to find the instances upon request. A consequence of this is that type "
"classes may inherit from other type classes."
msgstr ""

#: src/functor-applicative-monad/inheritance.md:238
msgid ""
"Because it uses precisely the same language features, type class inheritance "
"supports all the features of structure inheritance, including multiple "
"inheritance, default implementations of parent types' methods, and automatic "
"collapsing of diamonds. This is useful in many of the same situations that "
"multiple interface inheritance is useful in languages like Java, C# and "
"Kotlin. By carefully designing type class inheritance hierarchies, "
"programmers can get the best of both worlds: a fine-grained collection of "
"independently-implementable abstractions, and automatic construction of "
"these specific abstractions from larger, more general abstractions."
msgstr ""

#: src/functor-applicative-monad/applicative.md:3
msgid ""
"An _applicative functor_ is a functor that has two additional operations "
"available: `pure` and `seq`. `pure` is the same operator used in `Monad`, "
"because `Monad` in fact inherits from `Applicative`. `seq` is much like "
"`map`: it allows a function to be used in order to transform the contents of "
"a datatype. However, with `seq`, the function is itself contained in the "
"datatype: `f (α → β) → (Unit → f α) → f β`. Having the function under the "
"type `f` allows the `Applicative` instance to control how the function is "
"applied, while `Functor.map` unconditionally applies a function. The second "
"argument has a type that begins with `Unit →` to allow the definition of "
"`seq` to short-circuit in cases where the function will never be applied."
msgstr ""

#: src/functor-applicative-monad/applicative.md:10
msgid ""
"The value of this short-circuiting behavior can be seen in the instance of "
"`Applicative Option`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:19
msgid ""
"In this case, if there is no function for `seq` to apply, then there is no "
"need to compute its argument, so `x` is never called. The same consideration "
"informs the instance of `Applicative` for `Except`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:29
msgid ""
"This short-circuiting behavior depends only on the `Option` or `Except` "
"structures that _surround_ the function, rather than on the function itself."
msgstr ""

#: src/functor-applicative-monad/applicative.md:31
msgid ""
"Monads can be seen as a way of capturing the notion of sequentially "
"executing statements into a pure functional language. The result of one "
"statement can affect which further statements run. This can be seen in the "
"type of `bind`: `m α → (α → m β) → m β`. The first statement's resulting "
"value is an input into a function that computes the next statement to "
"execute. Successive uses of `bind` are like a sequence of statements in an "
"imperative programming language, and `bind` is powerful enough to implement "
"control structures like conditionals and loops."
msgstr ""

#: src/functor-applicative-monad/applicative.md:37
msgid ""
"Following this analogy, `Applicative` captures function application in a "
"language that has side effects. The arguments to a function in languages "
"like Kotlin or C# are evaluated from left to right. Side effects performed "
"by earlier arguments occur before those performed by later arguments. A "
"function is not powerful enough to implement custom short-circuiting "
"operators that depend on the specific _value_ of an argument, however."
msgstr ""

#: src/functor-applicative-monad/applicative.md:42
msgid ""
"Typically, `seq` is not invoked directly. Instead, the operator `<*>` is "
"used. This operator wraps its second argument in `fun () => ...`, "
"simplifying the call site. In other words, `E1 <*> E2` is syntactic sugar "
"for `Seq.seq E1 (fun () => E2)`."
msgstr ""

#: src/functor-applicative-monad/applicative.md:48
msgid ""
"The key feature that allows `seq` to be used with multiple arguments is that "
"a multiple-argument Lean function is really a single-argument function that "
"returns another function that's waiting for the rest of the arguments. In "
"other words, if the first argument to `seq` is awaiting multiple arguments, "
"then the result of the `seq` will be awaiting the rest. For example, `some "
"Plus.plus` can have the type `Option (Nat → Nat → Nat)`. Providing one "
"argument, `some Plus.plus <*> some 4`, results in the type `Option (Nat → "
"Nat)`. This can itself be used with `seq`, so `some Plus.plus <*> some 4 <*> "
"some 7` has the type `Option Nat`."
msgstr ""

#: src/functor-applicative-monad/applicative.md:54
msgid ""
"Not every functor is applicative. `Pair` is like the built-in product type "
"`Prod`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:61
msgid ""
"Like `Except`, `Pair` has type `Type → Type → Type`. This means that `Pair "
"α` has type `Type → Type`, and a `Functor` instance is possible:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:67
msgid "This instance obeys the `Functor` contract."
msgstr ""

#: src/functor-applicative-monad/applicative.md:69
msgid ""
"The two properties to check are that `id <$> Pair.mk x y = Pair.mk x y` and "
"that `f <$> g <$> Pair.mk x y = (f ∘ g) <$> Pair.mk x y`. The first property "
"can be checked by just stepping through the evaluation of the left side, and "
"noticing that it evaluates to the right side:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:78
msgid ""
"The second can be checked by stepping through both sides, and noting that "
"they yield the same result:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:93
msgid ""
"Attempting to define an `Applicative` instance, however, does not work so "
"well. It will require a definition of `pure`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:105
msgid ""
"There is a value with type `β` in scope (namely `x`), and the error message "
"from the underscore suggests that the next step is to use the constructor "
"`Pair.mk`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:116
msgid ""
"Unfortunately, there is no `α` available. Because `pure` would need to work "
"for _all possible types_ α to define an instance of `Applicative (Pair α)`, "
"this is impossible. After all, a caller could choose `α` to be `Empty`, "
"which has no values at all."
msgstr ""

#: src/functor-applicative-monad/applicative.md:120
msgid "A Non-Monadic Applicative"
msgstr ""

#: src/functor-applicative-monad/applicative.md:122
msgid ""
"When validating user input to a form, it's generally considered to be best "
"to provide many errors at once, rather than one error at a time. This allows "
"the user to have an overview of what is needed to please the computer, "
"rather than feeling badgered as they correct the errors field by field."
msgstr ""

#: src/functor-applicative-monad/applicative.md:125
msgid ""
"Ideally, validating user input will be visible in the type of the function "
"that's doing the validating. It should return a datatype that is "
"specific—checking that a text box contains a number should return an actual "
"numeric type, for instance. A validation routine could throw an exception "
"when the input does not pass validation. Exceptions have a major drawback, "
"however: they terminate the program at the first error, making it impossible "
"to accumulate a list of errors."
msgstr ""

#: src/functor-applicative-monad/applicative.md:130
msgid ""
"On the other hand, the common design pattern of accumulating a list of "
"errors and then failing when it is non-empty is also problematic. A long "
"nested sequences of `if` statements that validate each sub-section of the "
"input data is hard to maintain, and it's easy to lose track of an error "
"message or two. Ideally, validation can be performed using an API that "
"enables a new value to be returned yet automatically tracks and accumulates "
"error messages."
msgstr ""

#: src/functor-applicative-monad/applicative.md:134
msgid ""
"An applicative functor called `Validate` provides one way to implement this "
"style of API. Like the `Except` monad, `Validate` allows a new value to be "
"constructed that characterizes the validated data accurately. Unlike "
"`Except`, it allows multiple errors to be accumulated, without a risk of "
"forgetting to check whether the list is empty."
msgstr ""

#: src/functor-applicative-monad/applicative.md:138
msgid "User Input"
msgstr ""

#: src/functor-applicative-monad/applicative.md:139
msgid "As an example of user input, take the following structure:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:145
msgid "The business logic to be implemented is the following:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:146
msgid "The name may not be empty"
msgstr ""

#: src/functor-applicative-monad/applicative.md:147
msgid "The birth year must be numeric and non-negative"
msgstr ""

#: src/functor-applicative-monad/applicative.md:148
msgid ""
"The birth year must be greater than 1900, and less than or equal to the year "
"in which the form is validated"
msgstr ""

#: src/functor-applicative-monad/applicative.md:150
msgid ""
"Representing these as a datatype will require a new feature, called "
"_subtypes_. With this tool in hand, a validation framework can be written "
"that uses an applicative functor to track errors, and these rules can be "
"implemented in the framework."
msgstr ""

#: src/functor-applicative-monad/applicative.md:153
msgid "Subtypes"
msgstr ""

#: src/functor-applicative-monad/applicative.md:154
msgid ""
"Representing these conditions is easiest with one additional Lean type, "
"called `Subtype`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:160
msgid ""
"This structure has two type parameters: an implicit parameter that is the "
"type of data `α`, and an explicit parameter `p` that is a predicate over "
"`α`. A _predicate_ is a logical statement with a variable in it that can be "
"replaced with a value to yield an actual statement, like the [parameter to "
"`GetElem`](../type-classes/indexing.md#overloading-indexing) that describes "
"what it means for an index to be in bounds for a lookup. In the case of "
"`Subtype`, the predicate slices out some subset of the values of `α` for "
"which the predicate holds. The structure's two fields are, respectively, a "
"value from `α` and evidence that the value satisfies the predicate `p`. Lean "
"has special syntax for `Subtype`. If `p` has type `α → Prop`, then the type "
"`Subtype p` can also be written `{x : α // p x}`, or even `{x // p x}` when "
"the type can be inferred automatically."
msgstr ""

#: src/functor-applicative-monad/applicative.md:167
msgid ""
"[Representing positive numbers as inductive types](../type-classes/pos.md) "
"is clear and easy to program with. However, it has a key disadvantage. While "
"`Nat` and `Int` have the structure of ordinary inductive types from the "
"perspective of Lean programs, the compiler treats them specially and uses "
"fast arbitrary-precision number libraries to implement them. This is not the "
"case for additional user-defined types. However, a subtype of `Nat` that "
"restricts it to non-zero numbers allows the new type to use the efficient "
"representation while still ruling out zero at compile time:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:172
msgid ""
"```lean\n"
"def FastPos : Type := {x : Nat // x > 0}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:176
msgid ""
"The smallest fast positive number is still one. Now, instead of being a "
"constructor of an inductive type, it's an instance of a structure that's "
"constructed with angle brackets. The first argument is the underlying `Nat`, "
"and the second argument is the evidence that said `Nat` is greater than zero:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:182
msgid ""
"The `OfNat` instance is very much like that for `Pos`, except it uses a "
"short tactic proof to provide evidence that `n + 1 > 0`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:187
msgid ""
"The `simp_arith` tactic is a version of `simp` that takes additional "
"arithmetic identities into account."
msgstr ""

#: src/functor-applicative-monad/applicative.md:189
msgid ""
"Subtypes are a two-edged sword. They allow efficient representation of "
"validation rules, but they transfer the burden of maintaining these rules to "
"the users of the library, who have to _prove_ that they are not violating "
"important invariants. Generally, it's a good idea to use them internally to "
"a library, providing an API to users that automatically ensures that all "
"invariants are satisfied, with any necessary proofs being internal to the "
"library."
msgstr ""

#: src/functor-applicative-monad/applicative.md:193
msgid ""
"Checking whether a value of type `α` is in the subtype `{x : α // p x}` "
"usually requires that the proposition `p x` be decidable. The [section on "
"equality and ordering "
"classes](../type-classes/standard-classes.md#equality-and-ordering) "
"describes how decidable propositions can be used with `if`. When `if` is "
"used with a decidable proposition, a name can be provided. In the `then` "
"branch, the name is bound to evidence that the proposition is true, and in "
"the `else` branch, it is bound to evidence that the proposition is false. "
"This comes in handy when checking whether a given `Nat` is positive:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:204
msgid ""
"In the `then` branch, `h` is bound to evidence that `n > 0`, and this "
"evidence can be used as the second argument to `Subtype`'s constructor."
msgstr ""

#: src/functor-applicative-monad/applicative.md:207
msgid "Validated Input"
msgstr ""

#: src/functor-applicative-monad/applicative.md:209
msgid ""
"The validated user input is a structure that expresses the business logic "
"using multiple techniques:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:210
msgid ""
"The structure type itself encodes the year in which it was checked for "
"validity, so that `CheckedInput 2019` is not the same type as `CheckedInput "
"2020`"
msgstr ""

#: src/functor-applicative-monad/applicative.md:211
msgid "The birth year is represented as a `Nat` rather than a `String`"
msgstr ""

#: src/functor-applicative-monad/applicative.md:212
msgid ""
"Subtypes are used to constrain the allowed values in the name and birth year "
"fields"
msgstr ""

#: src/functor-applicative-monad/applicative.md:213
msgid ""
"```lean\n"
"structure CheckedInput (thisYear : Nat) : Type where\n"
"  name : {n : String // n ≠ \"\"}\n"
"  birthYear : {y : Nat // y > 1900 ∧ y ≤ thisYear}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:219
msgid ""
"An input validator should take the current year and a `RawInput` as "
"arguments, returning either a checked input or at least one validation "
"failure. This is represented by the `Validate` type:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:226
msgid ""
"It looks very much like `Except`. The only difference is that the `error` "
"constructor may contain more than one failure."
msgstr ""

#: src/functor-applicative-monad/applicative.md:229
msgid ""
"Validate is a functor. Mapping a function over it transforms any successful "
"value that might be present, just as in the `Functor` instance for `Except`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:238
msgid ""
"The `Applicative` instance for `Validate` has an important difference from "
"the instance for `Except`: while the instance for `Except` terminates at the "
"first error encountered, the instance for `Validate` is careful to "
"accumulate all errors from _both_ the function and the argument branches:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:251
msgid ""
"Using `.errors` together with the constructor for `NonEmptyList` is a bit "
"verbose. Helpers like `reportError` make code more readable. In this "
"application, error reports will consist of field names paired with messages:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:261
msgid ""
"The `Applicative` instance for `Validate` allows the checking procedures for "
"each field to be written independently and then composed. Checking a name "
"consists of ensuring that a string is non-empty, then returning evidence of "
"this fact in the form of a `Subtype`. This uses the evidence-binding version "
"of `if`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:264
msgid ""
"```lean\n"
"def checkName (name : String) : Validate (Field × String) {n : String // n ≠ "
"\"\"} :=\n"
"  if h : name = \"\" then\n"
"    reportError \"name\" \"Required\"\n"
"  else pure ⟨name, h⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:270
msgid ""
"In the `then` branch, `h` is bound to evidence that `name = \"\"`, while it "
"is bound to evidence that `¬name = \"\"` in the `else` branch."
msgstr ""

#: src/functor-applicative-monad/applicative.md:272
msgid ""
"It's certainly the case that some validation errors make other checks "
"impossible. For example, it makes no sense to check whether the birth year "
"field is greater than 1900 if a confused user wrote the word `\"syzygy\"` "
"instead of a number. Checking the allowed range of the number is only "
"meaningful after ensuring that the field in fact contains a number. This can "
"be expressed using the function `andThen`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:282
msgid ""
"While this function's type signature makes it suitable to be used as `bind` "
"in a `Monad` instance, there are good reasons not to do so. They are "
"described [in the section that describes the `Applicative` "
"contract](applicative-contract.md#additional-stipulations)."
msgstr ""

#: src/functor-applicative-monad/applicative.md:285
msgid ""
"To check that the birth year is a number, a built-in function called "
"`String.toNat? : String → Option Nat` is useful. It's most user-friendly to "
"eliminate leading and trailing whitespace first using `String.trim`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:287
msgid ""
"```lean\n"
"def checkYearIsNat (year : String) : Validate (Field × String) Nat :=\n"
"  match year.trim.toNat? with\n"
"  | none => reportError \"birth year\" \"Must be digits\"\n"
"  | some n => pure n\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:293
msgid ""
"To check that the provided year is in the expected range, nested uses of the "
"evidence-providing form of `if` are in order:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:294
msgid ""
"```leantac\n"
"def checkBirthYear (thisYear year : Nat) : Validate (Field × String) {y : "
"Nat // y > 1900 ∧ y ≤ thisYear} :=\n"
"  if h : year > 1900 then\n"
"    if h' : year ≤ thisYear then\n"
"      pure ⟨year, by simp [*]⟩\n"
"    else reportError \"birth year\" s!\"Must be no later than {thisYear}\"\n"
"  else reportError \"birth year\" \"Must be after 1900\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:303
msgid "Finally, these three components can be combined using `seq`:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:312
msgid ""
"Testing `checkInput` shows that it can indeed return multiple pieces of "
"feedback:"
msgstr ""

#: src/functor-applicative-monad/applicative.md:313
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"David\", birthYear := \"1984\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:316
msgid ""
"```output info\n"
"Validate.ok { name := \"David\", birthYear := 1984 }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:319
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"\", birthYear := \"2045\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:322
msgid ""
"```output info\n"
"Validate.errors { head := (\"name\", \"Required\"), tail := [(\"birth "
"year\", \"Must be no later than 2023\")] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:325
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"David\", birthYear := \"syzygy\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:328
msgid ""
"```output info\n"
"Validate.errors { head := (\"birth year\", \"Must be digits\"), tail := [] "
"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:333
msgid ""
"Form validation with `checkInput` illustrates a key advantage of "
"`Applicative` over `Monad`. Because `>>=` provides enough power to modify "
"the rest of the program's execution based on the value from the first step, "
"it _must_ receive a value from the first step to pass on. If no value is "
"received (e.g. because an error has occurred), then `>>=` cannot execute the "
"rest of the program. `Validate` demonstrates why it can be useful to run the "
"rest of the program anyway: in cases where the earlier data isn't needed, "
"running the rest of the program can yield useful information (in this case, "
"more validation errors). `Applicative`'s `<*>` may run both of its arguments "
"before recombining the results. Similarly, `>>=` forces sequential "
"execution. Each step must complete before the next may run. This is "
"generally useful, but it makes it impossible to have parallel execution of "
"different threads that naturally emerges from the program's actual data "
"dependencies. A more powerful abstraction like `Monad` increases the "
"flexibility that's available to the API consumer, but it decreases the "
"flexibility that is available to the API implementor."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:3
msgid ""
"Just like `Functor`, `Monad`, and types that implement `BEq` and `Hashable`, "
"`Applicative` has a set of rules that all instances should adhere to."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:5
msgid "There are four rules that an applicative functor should follow:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:6
msgid "It should respect identity, so `pure id <*> v = v`"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:7
msgid ""
"It should respect function composition, so `pure (· ∘ ·) <*> u <*> v <*> w = "
"u <*> (v <*> w)`"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:8
msgid ""
"Sequencing pure operations should be a no-op, so `pure f <*> pure x = pure "
"(f x)`"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:9
msgid ""
"The ordering of pure operations doesn't matter, so `u <*> pure x = pure (fun "
"f => f x) <*> u`"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:11
msgid ""
"To check these for the `Applicative Option` instance, start by expanding "
"`pure` into `some`."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:13
msgid ""
"The first rule states that `some id <*> v = v`. The definition of `seq` for "
"`Option` states that this is the same as `id <$> v = v`, which is one of the "
"`Functor` rules that have already been checked."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:16
msgid ""
"The second rule states that `some (· ∘ ·) <*> u <*> v <*> w = u <*> (v <*> "
"w)`. If any of `u`, `v`, or `w` is `none`, then both sides are `none`, so "
"the property holds. Assuming that `u` is `some f`, that `v` is `some g`, and "
"that `w` is `some x`, then this is equivalent to saying that `some (· ∘ ·) "
"<*> some f <*> some g <*> some x = some f <*> (some g <*> some x)`. "
"Evaluating the two sides yields the same result:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:38
msgid "The third rule follows directly from the definition of `seq`:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:47
msgid ""
"In the fourth case, assume that `u` is `some f`, because if it's `none`, "
"both sides of the equation are `none`. `some f <*> some x` evaluates "
"directly to `some (f x)`, as does `some (fun g => g x) <*> some f`."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:51
msgid "All Applicatives are Functors"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:53
msgid "The two operators for `Applicative` are enough to define `map`:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:59
msgid ""
"This can only be used to implement `Functor` if the contract for "
"`Applicative` guarantees the contract for `Functor`, however. The first rule "
"of `Functor` is that `id <$> x = x`, which follows directly from the first "
"rule for `Applicative`. The second rule of `Functor` is that `map (f ∘ g) x "
"= map f (map g x)`. Unfolding the definition of `map` here results in `pure "
"(f ∘ g) <*> x = pure f <*> (pure g <*> x)`. Using the rule that sequencing "
"pure operations is a no-op, the left side can be rewritten to `pure (· ∘ ·) "
"<*> pure f <*> pure g <*> x`. This is an instance of the rule that states "
"that applicative functors respect function composition."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:66
msgid ""
"This justifies a definition of `Applicative` that extends `Functor`, with a "
"default definition of `map` given in terms of `pure` and `seq`:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:74
msgid "All Monads are Applicative Functors"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:76
msgid ""
"An instance of `Monad` already requires an implementation of `pure`. "
"Together with `bind`, this is enough to define `seq`:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:84
msgid ""
"Once again, checking that the `Monad` contract implies the `Applicative` "
"contract will allow this to be used as a default definition for `seq` if "
"`Monad` extends `Applicative`."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:86
msgid ""
"The rest of this section consists of an argument that this implementation of "
"`seq` based on `bind` in fact satisfies the `Applicative` contract. One of "
"the beautiful things about functional programming is that this kind of "
"argument can be worked out on a piece of paper with a pencil, using the "
"kinds of evaluation rules from [the initial section on evaluating "
"expressions](../getting-to-know/evaluating.md). Thinking about the meanings "
"of the operations while reading these arguments can sometimes help with "
"understanding."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:90
msgid ""
"Replacing `do`\\-notation with explicit uses of `>>=` makes it easier to "
"apply the `Monad` rules:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:99
msgid ""
"To check that this definition respects identity, check that `seq (pure id) "
"(fun () => v) = v`. The left hand side is equivalent to `pure id >>= fun g "
"=> (fun () => v) () >>= fun y => pure (g y)`. The unit function in the "
"middle can be eliminated immediately, yielding `pure id >>= fun g => v >>= "
"fun y => pure (g y)`. Using the fact that `pure` is a left identity of "
"`>>=`, this is the same as `v >>= fun y => pure (id y)`, which is `v >>= fun "
"y => pure y`. Because `fun x => f x` is the same as `f`, this is the same as "
"`v >>= pure`, and the fact that `pure` is a right identity of `>>=` can be "
"used to get `v`."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:105
msgid ""
"This kind of informal reasoning can be made easier to read with a bit of "
"reformatting. In the following chart, read \"EXPR1 ={ REASON }= EXPR2\" as "
"\"EXPR1 is the same as EXPR2 because REASON\":"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:139
msgid ""
"To check that it respects function composition, check that `pure (· ∘ ·) <*> "
"u <*> v <*> w = u <*> (v <*> w)`. The first step is to replace `<*>` with "
"this definition of `seq`. After that, a (somewhat long) series of steps that "
"use the identity and associativity rules from the `Monad` contract is enough "
"to get from one to the other:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:277
msgid "To check that sequencing pure operations is a no-op:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:306
msgid ""
"And finally, to check that the ordering of pure operations doesn't matter:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:350
msgid ""
"This justifies a definition of `Monad` that extends `Applicative`, with a "
"default definition of `seq`:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:359
msgid ""
"`Applicative`'s own default definition of `map` means that every `Monad` "
"instance automatically generates `Applicative` and `Functor` instances as "
"well."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:361
msgid "Additional Stipulations"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:363
msgid ""
"In addition to adhering to the individual contracts associated with each "
"type class, combined implementations `Functor`, `Applicative` and `Monad` "
"should work equivalently to these default implementations. In other words, a "
"type that provides both `Applicative` and `Monad` instances should not have "
"an implementation of `seq` that works differently from the version that the "
"`Monad` instance generates as a default implementation. This is important "
"because polymorphic functions may be refactored to replace a use of `>>=` "
"with an equivalent use of `<*>`, or a use of `<*>` with an equivalent use of "
"`>>=`. This refactoring should not change the meaning of programs that use "
"this code."
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:368
msgid ""
"This rule explains why `Validate.andThen` should not be used to implement "
"`bind` in a `Monad` instance. On its own, it obeys the monad contract. "
"However, when it is used to implement `seq`, the behavior is not equivalent "
"to `seq` itself. To see where they differ, take the example of two "
"computations, both of which return errors. Start with an example of a case "
"where two errors should be returned, one from validating a function (which "
"could have just as well resulted from a prior argument to the function), and "
"one from validating an argument:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:373
msgid ""
"```lean\n"
"def notFun : Validate String (Nat → String) :=\n"
"  .errors { head := \"First error\", tail := [] }\n"
"\n"
"def notArg : Validate String Nat :=\n"
"  .errors { head := \"Second error\", tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:381
msgid ""
"Combining them with the version of `<*>` from `Validate`'s `Applicative` "
"instance results in both errors being reported to the user:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:382
msgid ""
"```lean\n"
"notFun <*> notArg\n"
"===>\n"
"match notFun with\n"
"| .ok g => g <$> notArg\n"
"| .errors errs =>\n"
"  match notArg with\n"
"  | .ok _ => .errors errs\n"
"  | .errors errs' => .errors (errs ++ errs')\n"
"===>\n"
"match notArg with\n"
"| .ok _ => .errors { head := \"First error\", tail := [] }\n"
"| .errors errs' => .errors ({ head := \"First error\", tail := [] } ++ "
"errs')\n"
"===>\n"
".errors ({ head := \"First error\", tail := [] } ++ { head := \"Second "
"error\", tail := []})\n"
"===>\n"
".errors { head := \"First error\", tail := [\"Second error\"]}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:401
msgid ""
"Using the version of `seq` that was implemented with `>>=`, here rewritten "
"to `andThen`, results in only the first error being available:"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:402
msgid ""
"```lean\n"
"seq notFun (fun () => notArg)\n"
"===>\n"
"notFun.andThen fun g =>\n"
"notArg.andThen fun y =>\n"
"pure (g y)\n"
"===>\n"
"match notFun with\n"
"| .errors errs => .errors errs\n"
"| .ok val =>\n"
"  (fun g =>\n"
"    notArg.andThen fun y =>\n"
"    pure (g y)) val\n"
"===>\n"
".errors { head := \"First error\", tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:4
msgid "Recovery from Failure"
msgstr ""

#: src/functor-applicative-monad/alternative.md:6
msgid ""
"`Validate` can also be used in situations where there is more than one way "
"for input to be acceptable. For the input form `RawInput`, an alternative "
"set of business rules that implement conventions from a legacy system might "
"be the following:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:9
msgid "All human users must provide a birth year that is four digits."
msgstr ""

#: src/functor-applicative-monad/alternative.md:10
msgid ""
"Users born prior to 1970 do not need to provide names, due to incomplete "
"older records."
msgstr ""

#: src/functor-applicative-monad/alternative.md:11
msgid "Users born after 1970 must provide names."
msgstr ""

#: src/functor-applicative-monad/alternative.md:12
msgid ""
"Companies should enter `\"FIRM\"` as their year of birth and provide a "
"company name."
msgstr ""

#: src/functor-applicative-monad/alternative.md:14
msgid ""
"No particular provision is made for users born in 1970. It is expected that "
"they will either give up, lie about their year of birth, or call. The "
"company considers this an acceptable cost of doing business."
msgstr ""

#: src/functor-applicative-monad/alternative.md:18
msgid ""
"The following inductive type captures the values that can be produced from "
"these stated rules:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:19
msgid ""
"```lean\n"
"abbrev NonEmptyString := {s : String // s ≠ \"\"}\n"
"\n"
"inductive LegacyCheckedInput where\n"
"  | humanBefore1970 :\n"
"    (birthYear : {y : Nat // y > 999 ∧ y < 1970}) →\n"
"    String →\n"
"    LegacyCheckedInput\n"
"  | humanAfter1970 :\n"
"    (birthYear : {y : Nat // y > 1970}) →\n"
"    NonEmptyString →\n"
"    LegacyCheckedInput\n"
"  | company :\n"
"    NonEmptyString →\n"
"    LegacyCheckedInput\n"
"deriving Repr\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:37
msgid ""
"A validator for these rules is more complicated, however, as it must address "
"all three cases. While it can be written as a series of nested `if` "
"expressions, it's easier to design the three cases independently and then "
"combine them. This requires a means of recovering from failure while "
"preserving error messages:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:50
msgid ""
"This pattern of recovery from failures is common enough that Lean has "
"built-in syntax for it, attached to a type class named `OrElse`:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:55
msgid ""
"The expression `E1 <|> E2` is short for `OrElse.orElse E1 (fun () => E2)`. "
"An instance of `OrElse` for `Validate` allows this syntax to be used for "
"error recovery:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:62
msgid ""
"The validator for `LegacyCheckedInput` can be built from a validator for "
"each constructor. The rules for a company state that the birth year should "
"be the string `\"FIRM\"` and that the name should be non-empty. The "
"constructor `LegacyCheckedInput.company`, however, has no representation of "
"the birth year at all, so there's no easy way to carry it out using `<*>`. "
"The key is to use a function with `<*>` that ignores its argument."
msgstr ""

#: src/functor-applicative-monad/alternative.md:67
msgid ""
"Checking that a Boolean condition holds without recording any evidence of "
"this fact in a type can be accomplished with `checkThat`:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:72
msgid ""
"This definition of `checkCompany` uses `checkThat`, and then throws away the "
"resulting `Unit` value:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:73
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) "
"LegacyCheckedInput :=\n"
"  pure (fun () name => .company name) <*>\n"
"    checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a "
"company\" <*>\n"
"    checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:80
msgid ""
"However, this definition is quite noisy. It can be simplified in two ways. "
"The first is to replace the first use of `<*>` with a specialized version "
"that automatically ignores the value returned by the first argument, called "
"`*>`. This operator is also controlled by a type class, called `SeqRight`, "
"and `E1 *> E2` is syntactic sugar for `SeqRight.seqRight E1 (fun () => E2)`:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:88
msgid ""
"There is a default implementation of `seqRight` in terms of `seq`: `seqRight "
"(a : f α) (b : Unit → f β) : f β := pure (fun _ x => x) <*> a <*> b ()`."
msgstr ""

#: src/functor-applicative-monad/alternative.md:90
msgid "Using `seqRight`, `checkCompany` becomes simpler:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:91
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) "
"LegacyCheckedInput :=\n"
"  checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a "
"company\" *>\n"
"  pure .company <*> checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:96
msgid ""
"One more simplification is possible. For every `Applicative`, `pure F <*> E` "
"is equivalent to `f <$> E`. In other words, using `seq` to apply a function "
"that was placed into the `Applicative` type using `pure` is overkill, and "
"the function could have just been applied using `Functor.map`. This "
"simplification yields:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:100
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) "
"LegacyCheckedInput :=\n"
"  checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a "
"company\" *>\n"
"  .company <$> checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:106
msgid ""
"The remaining two constructors of `LegacyCheckedInput` use subtypes for "
"their fields. A general-purpose tool for checking subtypes will make these "
"easier to read:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:108
msgid ""
"```lean\n"
"def checkSubtype {α : Type} (v : α) (p : α → Prop) [Decidable (p v)] (err : "
"ε) : Validate ε {x : α // p x} :=\n"
"  if h : p v then\n"
"    pure ⟨v, h⟩\n"
"  else\n"
"    .errors { head := err, tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:115
msgid ""
"In the function's argument list, it's important that the type class "
"`[Decidable (p v)]` occur after the specification of the arguments `v` and "
"`p`. Otherwise, it would refer to an additional set of automatic implicit "
"arguments, rather than to the manually-provided values. The `Decidable` "
"instance is what allows the proposition `p v` to be checked using `if`."
msgstr ""

#: src/functor-applicative-monad/alternative.md:119
msgid "The two human cases do not need any additional tools:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:120
msgid ""
"```lean\n"
"def checkHumanBefore1970 (input : RawInput) : Validate (Field × String) "
"LegacyCheckedInput :=\n"
"  (checkYearIsNat input.birthYear).andThen fun y =>\n"
"    .humanBefore1970 <$>\n"
"      checkSubtype y (fun x => x > 999 ∧ x < 1970) (\"birth year\", \"less "
"than 1970\") <*>\n"
"      pure input.name\n"
"\n"
"def checkHumanAfter1970 (input : RawInput) : Validate (Field × String) "
"LegacyCheckedInput :=\n"
"  (checkYearIsNat input.birthYear).andThen fun y =>\n"
"    .humanAfter1970 <$>\n"
"      checkSubtype y (· > 1970) (\"birth year\", \"greater than 1970\") <*>\n"
"      checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:134
msgid "The validators for the three cases can be combined using `<|>`:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:140
msgid ""
"The successful cases return constructors of `LegacyCheckedInput`, as "
"expected:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:141
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"Johnny's Troll Groomers\", \"FIRM\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:144
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.company \"Johnny's Troll Groomers\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:147
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"Johnny\", \"1963\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:150
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.humanBefore1970 1963 \"Johnny\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:153
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"\", \"1963\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:156
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.humanBefore1970 1963 \"\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:160
msgid "The worst possible input returns all the possible failures:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:161
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"\", \"1970\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:164
msgid ""
"```output info\n"
"Validate.errors\n"
"  { head := (\"birth year\", \"FIRM if a company\"),\n"
"    tail := [(\"name\", \"Required\"),\n"
"             (\"birth year\", \"less than 1970\"),\n"
"             (\"birth year\", \"greater than 1970\"),\n"
"             (\"name\", \"Required\")] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:174
msgid "The `Alternative` Class"
msgstr ""

#: src/functor-applicative-monad/alternative.md:176
msgid ""
"Many types support a notion of failure and recovery. The `Many` monad from "
"the section on [evaluating arithmetic expressions in a variety of "
"monads](../monads/arithmetic.md#nondeterministic-search) is one such type, "
"as is `Option`. Both support failure without providing a reason (unlike, "
"say, `Except` and `Validate`, which require some indication of what went "
"wrong)."
msgstr ""

#: src/functor-applicative-monad/alternative.md:180
msgid ""
"The `Alternative` class describes applicative functors that have additional "
"operators for failure and recovery:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:186
msgid ""
"Just as implementors of `Add α` get `HAdd α α α` instances for free, "
"implementors of `Alternative` get `OrElse` instances for free:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:192
msgid ""
"The implementation of `Alternative` for `Option` keeps the first none-`none` "
"argument:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:200
msgid ""
"Similarly, the implementation for `Many` follows the general structure of "
"`Many.union`, with minor differences due to the laziness-inducing `Unit` "
"parameters being placed differently:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:211
msgid ""
"Like other type classes, `Alternative` enables the definition of a variety "
"of operations that work for _any_ applicative functor that implements "
"`Alternative`. One of the most important is `guard`, which causes `failure` "
"when a decidable proposition is false:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:219
msgid ""
"It is very useful in monadic programs to terminate execution early. In "
"`Many`, it can be used to filter out a whole branch of a search, as in the "
"following program that computes all even divisors of a natural number:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:232
msgid "Running it on `20` yields the expected results:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:243
msgid "Improve Validation Friendliness"
msgstr ""

#: src/functor-applicative-monad/alternative.md:245
msgid ""
"The errors returned from `Validate` programs that use `<|>` can be difficult "
"to read, because inclusion in the list of errors simply means that the error "
"can be reached through _some_ code path. A more structured error report can "
"be used to guide the user through the process more accurately:"
msgstr ""

#: src/functor-applicative-monad/alternative.md:248
msgid ""
"Replace the `NonEmptyList` in `Validate.error` with a bare type variable, "
"and then update the definitions of the `Applicative (Validate ε)` and "
"`OrElse (Validate ε α)` instances to require only that there be an `Append "
"ε` instance available."
msgstr ""

#: src/functor-applicative-monad/alternative.md:249
msgid ""
"Define a function `Validate.mapErrors : Validate ε α → (ε → ε') → Validate "
"ε' α` that transforms all the errors in a validation run."
msgstr ""

#: src/functor-applicative-monad/alternative.md:250
msgid ""
"Using the datatype `TreeError` to represent errors, rewrite the legacy "
"validation system to track its path through the three alternatives."
msgstr ""

#: src/functor-applicative-monad/alternative.md:251
msgid ""
"Write a function `report : TreeError → String` that outputs a user-friendly "
"view of the `TreeError`'s accumulated warnings and errors."
msgstr ""

#: src/functor-applicative-monad/universes.md:3
msgid ""
"In the interests of simplicity, this book has thus far papered over an "
"important feature of Lean: _universes_. A universe is a type that classifies "
"other types. Two of them are familiar: `Type` and `Prop`. `Type` classifies "
"ordinary types, such as `Nat`, `String`, `Int → String × Char`, and `IO "
"Unit`. `Prop` classifies propositions that may be true or false, such as "
"`\"nisse\" = \"elf\"` or `3 > 2`. The type of `Prop` is `Type`:"
msgstr ""

#: src/functor-applicative-monad/universes.md:16
msgid ""
"For technical reasons, more universes than these two are needed. In "
"particular, `Type` cannot itself be a `Type`. This would allow a logical "
"paradox to be constructed and undermine Lean's usefulness as a theorem "
"prover."
msgstr ""

#: src/functor-applicative-monad/universes.md:20
msgid ""
"The formal argument for this is known as _Girard's Paradox_. It related to a "
"better-known paradox known as _Russell's Paradox_, which was used to show "
"that early versions of set theory were inconsistent. In these set theories, "
"a set can be defined by a property. For example, one might have the set of "
"all red things, the set of all fruit, the set of all natural numbers, or "
"even the set of all sets. Given a set, one can ask whether a given element "
"is contained in it. For instance, a bluebird is not contained in the set of "
"all red things, but the set of all red things is contained in the set of all "
"sets. Indeed, the set of all sets even contains itself."
msgstr ""

#: src/functor-applicative-monad/universes.md:28
msgid ""
"What about the set of all sets that do not contain themselves? It contains "
"the set of all red things, as the set of all red things is not itself red. "
"It does not contain the set of all sets, because the set of all sets "
"contains itself. But does it contain itself? If it does contain itself, then "
"it cannot contain itself. But if it does not, then it must."
msgstr ""

#: src/functor-applicative-monad/universes.md:35
msgid ""
"This is a contradiction, which demonstrates that something was wrong with "
"the initial assumptions. In particular, allowing sets to be constructed by "
"providing an arbitrary property is too powerful. Later versions of set "
"theory restrict the formation of sets to remove the paradox."
msgstr ""

#: src/functor-applicative-monad/universes.md:39
msgid ""
"A related paradox can be constructed in versions of dependent type theory "
"that assign the type `Type` to `Type`. To ensure that Lean has consistent "
"logical foundations and can be used as a tool for mathematics, `Type` needs "
"to have some other type. This type is called `Type 1`:"
msgstr ""

#: src/functor-applicative-monad/universes.md:48
msgid ""
"Similarly, `Type 1` is a `Type 2`, `Type 2` is a `Type 3`, `Type 3` is a "
"`Type 4`, and so forth."
msgstr ""

#: src/functor-applicative-monad/universes.md:52
msgid ""
"Function types occupy the smallest universe that can contain both the "
"argument type and the return type. This means that `Nat → Nat` is a `Type`, "
"`Type → Type` is a `Type 1`, and `Type 1 → Type 2` is a `Type 3`."
msgstr ""

#: src/functor-applicative-monad/universes.md:55
msgid ""
"There is one exception to this rule. If the return type of a function is a "
"`Prop`, then the whole function type is in `Prop`, even if the argument is "
"in a larger universe such as `Type` or even `Type 1`. In particular, this "
"means that predicates over values that have ordinary types are in `Prop`. "
"For example, the type `(n : Nat) → n = n + 0` represents a function from a "
"`Nat` to evidence that it is equal to itself plus zero. Even though `Nat` is "
"in `Type`, this function type is in `Prop` due to this rule. Similarly, even "
"though `Type` is in `Type 1`, the function type `Type → 2 + 2 = 4` is still "
"in `Prop`."
msgstr ""

#: src/functor-applicative-monad/universes.md:62
msgid "User Defined Types"
msgstr ""

#: src/functor-applicative-monad/universes.md:64
msgid ""
"Structures and inductive datatypes can be declared to inhabit particular "
"universes. Lean then checks whether each datatype avoids paradoxes by being "
"in a universe that's large enough to prevent it from containing its own "
"type. For instance, in the following declaration, `MyList` is declared to "
"reside in `Type`, and so is its type argument `α`:"
msgstr ""

#: src/functor-applicative-monad/universes.md:72
msgid ""
"`MyList` itself is a `Type → Type`. This means that it cannot be used to "
"contain actual types, because then its argument would be `Type`, which is a "
"`Type 1`:"
msgstr ""

#: src/functor-applicative-monad/universes.md:89
msgid ""
"Updating `MyList` so that its argument is a `Type 1` results in a definition "
"rejected by Lean:"
msgstr ""

#: src/functor-applicative-monad/universes.md:103
msgid ""
"This error occurs because the argument to `cons` with type `α` is from a "
"larger universe than `MyList`. Placing `MyList` itself in `Type 1` solves "
"this issue, but at the cost of `MyList` now being itself inconvenient to use "
"in contexts that expect a `Type`."
msgstr ""

#: src/functor-applicative-monad/universes.md:106
msgid ""
"The specific rules that govern whether a datatype is allowed are somewhat "
"complicated. Generally speaking, it's easiest to start with the datatype in "
"the same universe as the largest of its arguments. Then, if Lean rejects the "
"definition, increase its level by one, which will usually go through."
msgstr ""

#: src/functor-applicative-monad/universes.md:110
msgid "Universe Polymorphism"
msgstr ""

#: src/functor-applicative-monad/universes.md:112
msgid ""
"Defining a datatype in a specific universe can lead to code duplication. "
"Placing `MyList` in `Type → Type` means that it can't be used for an actual "
"list of types. Placing it in `Type 1 → Type 1` means that it can't be used "
"for a list of lists of types. Rather than copy-pasting the datatype to "
"create versions in `Type`, `Type 1`, `Type 2`, and so on, a feature called "
"_universe polymorphism_ can be used to write a single definition that can be "
"instantiated in any of these universes."
msgstr ""

#: src/functor-applicative-monad/universes.md:117
msgid ""
"Ordinary polymorphic types use variables to stand for types in a definition. "
"This allows Lean to fill in the variables differently, which enables these "
"definitions to be used with a variety of types. Similarly, universe "
"polymorphism allows variables to stand for universes in a definition, "
"enabling Lean to fill them in differently so that they can be used with a "
"variety of universes. Just as type arguments are conventionally named with "
"Greek letters, universe arguments are conventionally named `u`, `v`, and `w`."
msgstr ""

#: src/functor-applicative-monad/universes.md:122
msgid ""
"This definition of `MyList` doesn't specify a particular universe level, but "
"instead uses a variable `u` to stand for any level. If the resulting "
"datatype is used with `Type`, then `u` is `0`, and if it's used with `Type "
"3`, then `u` is `3`:"
msgstr ""

#: src/functor-applicative-monad/universes.md:130
msgid ""
"With this definition, the same definition of `MyList` can be used to contain "
"both actual natural numbers and the natural number type itself:"
msgstr ""

#: src/functor-applicative-monad/universes.md:138
msgid "It can even contain itself:"
msgstr ""

#: src/functor-applicative-monad/universes.md:144
msgid ""
"It would seem that this would make it possible to write a logical paradox. "
"After all, the whole point of the universe system is to rule out "
"self-referential types. Behind the scenes, however, each occurrence of "
"`MyList` is provided with a universe level argument. In essence, the "
"universe-polymorphic definition of `MyList` created a _copy_ of the datatype "
"at each level, and the level argument selects which copy is to be used. "
"These level arguments are written with a dot and curly braces, so "
"`MyList.{0} : Type → Type`, `MyList.{1} : Type 1 → Type 1`, and `MyList.{2} "
": Type 2 → Type 2`."
msgstr ""

#: src/functor-applicative-monad/universes.md:150
msgid "Writing the levels explicitly, the prior example becomes:"
msgstr ""

#: src/functor-applicative-monad/universes.md:162
msgid ""
"When a universe-polymorphic definition takes multiple types as arguments, "
"it's a good idea to give each argument its own level variable for maximum "
"flexibility. For example, a version of `Sum` with a single level argument "
"can be written as follows:"
msgstr ""

#: src/functor-applicative-monad/universes.md:169
msgid "This definition can be used at multiple levels:"
msgstr ""

#: src/functor-applicative-monad/universes.md:170
msgid ""
"```lean\n"
"def stringOrNat : Sum String Nat := .inl \"hello\"\n"
"\n"
"def typeOrType : Sum Type Type := .inr Nat\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:175
msgid "However, it requires that both arguments be in the same universe:"
msgstr ""

#: src/functor-applicative-monad/universes.md:190
msgid ""
"This datatype can be made more flexible by using different variables for the "
"two type arguments' universe levels, and then declaring that the resulting "
"datatype is in the largest of the two:"
msgstr ""

#: src/functor-applicative-monad/universes.md:196
msgid "This allows `Sum` to be used with arguments from different universes:"
msgstr ""

#: src/functor-applicative-monad/universes.md:201
msgid ""
"In positions where Lean expects a universe level, any of the following are "
"allowed:"
msgstr ""

#: src/functor-applicative-monad/universes.md:202
msgid "A concrete level, like `0` or `1`"
msgstr ""

#: src/functor-applicative-monad/universes.md:203
msgid "A variable that stands for a level, such as `u` or `v`"
msgstr ""

#: src/functor-applicative-monad/universes.md:204
msgid "The maximum of two levels, written as `max` applied to the levels"
msgstr ""

#: src/functor-applicative-monad/universes.md:205
msgid "A level increase, written with `+ 1`"
msgstr ""

#: src/functor-applicative-monad/universes.md:207
msgid "Writing Universe-Polymorphic Definitions"
msgstr ""

#: src/functor-applicative-monad/universes.md:209
msgid ""
"Until now, every datatype defined in this book has been in `Type`, the "
"smallest universe of data. When presenting polymorphic datatypes from the "
"Lean standard library, such as `List` and `Sum`, this book created "
"non-universe-polymorphic versions of them. The real versions use universe "
"polymorphism to enable code re-use between type-level and non-type-level "
"programs."
msgstr ""

#: src/functor-applicative-monad/universes.md:213
msgid ""
"There are a few general guidelines to follow when writing "
"universe-polymorphic types. First off, independent type arguments should "
"have different universe variables, which enables the polymorphic definition "
"to be used with a wider variety of arguments, increasing the potential for "
"code reuse. Secondly, the whole type is itself typically either in the "
"maximum of all the universe variables, or one greater than this maximum. Try "
"the smaller of the two first. Finally, it's a good idea to put the new type "
"in as small of a universe as possible, which allows it to be used more "
"flexibly in other contexts. Non-polymorphic types, such as `Nat` and "
"`String`, can be placed directly in `Type 0`."
msgstr ""

#: src/functor-applicative-monad/universes.md:220
msgid "`Prop` and Polymorphism"
msgstr ""

#: src/functor-applicative-monad/universes.md:222
msgid ""
"Just as `Type`, `Type 1`, and so on describe types that classify programs "
"and data, `Prop` classifies logical propositions. A type in `Prop` describes "
"what counts as convincing evidence for the truth of a statement. "
"Propositions are like ordinary types in many ways: they can be declared "
"inductively, they can have constructors, and functions can take propositions "
"as arguments. However, unlike datatypes, it typically doesn't matter _which_ "
"evidence is provided for the truth of a statement, only _that_ evidence is "
"provided. On the other hand, it is very important that a program not only "
"return a `Nat`, but that it's the _correct_ `Nat`."
msgstr ""

#: src/functor-applicative-monad/universes.md:228
msgid ""
"`Prop` is at the bottom of the universe hierarchy, and the type of `Prop` is "
"`Type`. This means that `Prop` is a suitable argument to provide to `List`, "
"for the same reason that `Nat` is. Lists of propositions have type `List "
"Prop`:"
msgstr ""

#: src/functor-applicative-monad/universes.md:231
msgid ""
"```lean\n"
"def someTruePropositions : List Prop := [\n"
"  1 + 1 = 2,\n"
"  \"Hello, \" ++ \"world!\" = \"Hello, world!\"\n"
"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:237
msgid ""
"Filling out the universe argument explicitly demonstrates that `Prop` is a "
"`Type`:"
msgstr ""

#: src/functor-applicative-monad/universes.md:238
msgid ""
"```lean\n"
"def someTruePropositions : List.{0} Prop := [\n"
"  1 + 1 = 2,\n"
"  \"Hello, \" ++ \"world!\" = \"Hello, world!\"\n"
"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:245
msgid ""
"Behind the scenes, `Prop` and `Type` are united into a single hierarchy "
"called `Sort`. `Prop` is the same as `Sort 0`, `Type 0` is `Sort 1`, `Type "
"1` is `Sort 2`, and so forth. In fact, `Type u` is the same as `Sort (u+1)`. "
"When writing programs with Lean, this is typically not relevant, but it may "
"occur in error messages from time to time, and it explains the name of the "
"`CoeSort` class. Additionally, having `Prop` as `Sort 0` allows one more "
"universe operator to become useful. The universe level `imax u v` is `0` "
"when `v` is `0`, or the larger of `u` or `v` otherwise. Together with "
"`Sort`, this allows the special rule for functions that return `Prop`s to be "
"used when writing code that should be as portable as possible between `Prop` "
"and `Type` universes."
msgstr ""

#: src/functor-applicative-monad/universes.md:253
msgid "Polymorphism in Practice"
msgstr ""

#: src/functor-applicative-monad/universes.md:255
msgid ""
"In the remainder of the book, definitions of polymorphic datatypes, "
"structures, and classes will use universe polymorphism in order to be "
"consistent with the Lean standard library. This will enable the complete "
"presentation of the `Functor`, `Applicative`, and `Monad` classes to be "
"completely consistent with their actual definitions."
msgstr ""

#: src/functor-applicative-monad/complete.md:3
msgid ""
"Now that all the relevant language features have been presented, this "
"section describes the complete, honest definitions of `Functor`, "
"`Applicative`, and `Monad` as they occur in the Lean standard library. For "
"the sake of understanding, no details are omitted."
msgstr ""

#: src/functor-applicative-monad/complete.md:6
msgid "Functor"
msgstr ""

#: src/functor-applicative-monad/complete.md:8
msgid ""
"The complete definition of the `Functor` class makes use of universe "
"polymorphism and a default method implementation:"
msgstr ""

#: src/functor-applicative-monad/complete.md:15
msgid ""
"In this definition, `Function.comp` is function composition, which is "
"typically written with the `∘` operator. `Function.const` is the _constant "
"function_, which is a two-argument function that ignores its second "
"argument. Applying this function to only one argument produces a function "
"that always returns the same value, which is useful when an API demands a "
"function but a program doesn't need to compute different results for "
"different arguments. A simple version of `Function.const` can be written as "
"follows:"
msgstr ""

#: src/functor-applicative-monad/complete.md:22
msgid ""
"Using it with one argument as the function argument to `List.map` "
"demonstrates its utility:"
msgstr ""

#: src/functor-applicative-monad/complete.md:23
msgid ""
"```lean\n"
"#eval [1, 2, 3].map (simpleConst \"same\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/complete.md:26
msgid ""
"```output info\n"
"[\"same\", \"same\", \"same\"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/complete.md:29
msgid "The actual function has the following signature:"
msgstr ""

#: src/functor-applicative-monad/complete.md:33
msgid ""
"Here, the type argument `β` is an explicit argument, so the default "
"definition of `Functor.mapConst` provides an `_` argument that instructs "
"Lean to find a unique type to pass to `Function.const` that would cause the "
"program to type check. `(Function.comp map (Function.const _) : α → f β → f "
"α)` is equivalent to `fun (x : α) (y : f β) => map (fun _ => x) y`."
msgstr ""

#: src/functor-applicative-monad/complete.md:36
msgid ""
"The `Functor` type class inhabits a universe that is the greater of `u+1` "
"and `v`. Here, `u` is the level of universes accepted as arguments to `f`, "
"while `v` is the universe returned by `f`. To see why the structure that "
"implements the `Functor` type class must be in a universe that's larger than "
"`u`, begin with a simplified definition of the class:"
msgstr ""

#: src/functor-applicative-monad/complete.md:43
msgid ""
"This type class's structure type is equivalent to the following inductive "
"type:"
msgstr ""

#: src/functor-applicative-monad/complete.md:48
msgid ""
"The implementation of the `map` method that is passed as an argument to "
"`Functor.mk` contains a function that takes two types in `Type u` as "
"arguments. This means that the type of the function itself is in `Type "
"(u+1)`, so `Functor` must also be at a level that is at least `u+1`. "
"Similarly, other arguments to the function have a type built by applying "
"`f`, so it must also have a level that is at least `v`. All the type classes "
"in this section share this property."
msgstr ""

#: src/functor-applicative-monad/complete.md:53
msgid "Applicative"
msgstr ""

#: src/functor-applicative-monad/complete.md:55
msgid ""
"The `Applicative` type class is actually built from a number of smaller "
"classes that each contain some of the relevant methods. The first are `Pure` "
"and `Seq`, which contain `pure` and `seq` respectively:"
msgstr ""

#: src/functor-applicative-monad/complete.md:65
msgid ""
"In addition to these, `Applicative` also depends on `SeqRight` and an "
"analogous `SeqLeft` class:"
msgstr ""

#: src/functor-applicative-monad/complete.md:74
msgid ""
"The `seqRight` function, which was introduced in the [section about "
"alternatives and validation](alternative.md), is easiest to understand from "
"the perspective of effects. `E1 *> E2`, which desugars to `SeqRight.seqRight "
"E1 (fun () => E2)`, can be understood as first executing `E1`, and then "
"`E2`, resulting only in `E2`'s result. Effects from `E1` may result in `E2` "
"not being run, or being run multiple times. Indeed, if `f` has a `Monad` "
"instance, then `E1 *> E2` is equivalent to `do let _ ← E1; E2`, but "
"`seqRight` can be used with types like `Validate` that are not monads."
msgstr ""

#: src/functor-applicative-monad/complete.md:79
msgid ""
"Its cousin `seqLeft` is very similar, except the leftmost expression's value "
"is returned. `E1 <* E2` desugars to `SeqLeft.seqLeft E1 (fun () => E2)`. "
"`SeqLeft.seqLeft` has type `f α → (Unit → f β) → f α`, which is identical to "
"that of `seqRight` except for the fact that it returns `f α`. `E1 <* E2` can "
"be understood as a program that first executes `E1`, and then `E2`, "
"returning the original result for `E1`. If `f` has a `Monad` instance, then "
"`E1 <* E2` is equivalent to `do let x ← E1; _ ← E2; pure x`. Generally "
"speaking, `seqLeft` is useful for specifying extra conditions on a value in "
"a validation or parser-like workflow without changing the value itself."
msgstr ""

#: src/functor-applicative-monad/complete.md:86
msgid ""
"The definition of `Applicative` extends all these classes, along with "
"`Functor`:"
msgstr ""

#: src/functor-applicative-monad/complete.md:93
msgid ""
"A complete definition of `Applicative` requires only definitions for `pure` "
"and `seq`. This is because there are default definitions for all of the "
"methods from `Functor`, `SeqLeft`, and `SeqRight`. The `mapConst` method of "
"`Functor` has its own default implementation in terms of `Functor.map`. "
"These default implementations should only be overridden with new functions "
"that are behaviorally equivalent, but more efficient. The default "
"implementations should be seen as specifications for correctness as well as "
"automatically-created code."
msgstr ""

#: src/functor-applicative-monad/complete.md:99
msgid ""
"The default implementation for `seqLeft` is very compact. Replacing some of "
"the names with their syntactic sugar or their definitions can provide "
"another view on it, so:"
msgstr ""

#: src/functor-applicative-monad/complete.md:104
msgid "becomes"
msgstr ""

#: src/functor-applicative-monad/complete.md:108
msgid ""
"How should `(fun x _ => x) <$> a` be understood? Here, `a` has type `f α`, "
"and `f` is a functor. If `f` is `List`, then `(fun x _ => x) <$> [1, 2, 3]` "
"evaluates to `[fun _ => 1, fun _ => 2, fun _ => 3]`. If `f` is `Option`, "
"then `(fun x _ => x) <$> some \"hello\"` evaluates to `some (fun _ => "
"\"hello\")`. In each case, the values in the functor are replaced by "
"functions that return the original value, ignoring their argument. When "
"combined with `seq`, this function discards the values from `seq`'s second "
"argument."
msgstr ""

#: src/functor-applicative-monad/complete.md:115
msgid ""
"The default implementation for `seqRight` is very similar, except `const` "
"has an additional argument `id`. This definition can be understood "
"similarly, by first introducing some standard syntactic sugar and then "
"replacing some names with their definitions:"
msgstr ""

#: src/functor-applicative-monad/complete.md:126
msgid ""
"How should `(fun _ x => x) <$> a` be understood? Once again, examples are "
"useful. `(fun _ x => x) <$> [1, 2, 3]` is equivalent to `[fun x => x, fun x "
"=> x, fun x => x]`, and `(fun _ x => x) <$> some \"hello\"` is equivalent to "
"`some (fun x => x)`. In other words, `(fun _ x => x) <$> a` preserves the "
"overall shape of `a`, but each value is replaced by the identity function. "
"From the perspective of effects, the side effects of `a` occur, but the "
"values are thrown out when it is used with `seq`."
msgstr ""

#: src/functor-applicative-monad/complete.md:132
msgid "Monad"
msgstr ""

#: src/functor-applicative-monad/complete.md:134
msgid ""
"Just as the constituent operations of `Applicative` are split into their own "
"type classes, `Bind` has its own class as well:"
msgstr ""

#: src/functor-applicative-monad/complete.md:139
msgid "`Monad` extends `Applicative` with `Bind`:"
msgstr ""

#: src/functor-applicative-monad/complete.md:147
msgid ""
"Tracing the collection of inherited methods and default methods from the "
"entire hierarchy shows that a `Monad` instance requires only implementations "
"of `bind` and `pure`. In other words, `Monad` instances automatically yield "
"implementations of `seq`, `seqLeft`, `seqRight`, `map`, and `mapConst`. From "
"the perspective of API boundaries, any type with a `Monad` instance gets "
"instances for `Bind`, `Pure`, `Seq`, `Functor`, `SeqLeft`, and `SeqRight`."
msgstr ""

#: src/functor-applicative-monad/complete.md:154
msgid ""
"Understand the default implementations of `map`, `seq`, `seqLeft`, and "
"`seqRight` in `Monad` by working through examples such as `Option` and "
"`Except`. In other words, substitute their definitions for `bind` and `pure` "
"into the default definitions, and simplify them to recover the versions "
"`map`, `seq`, `seqLeft`, and `seqRight` that would be written by hand."
msgstr ""

#: src/functor-applicative-monad/complete.md:155
msgid ""
"On paper or in a text file, prove to yourself that the default "
"implementations of `map` and `seq` satisfy the contracts for `Functor` and "
"`Applicative`. In this argument, you're allowed to use the rules from the "
"`Monad` contract as well as ordinary expression evaluation."
msgstr ""

#: src/functor-applicative-monad/summary.md:3
msgid "Type Classes and Structures"
msgstr ""

#: src/functor-applicative-monad/summary.md:5
msgid ""
"Behind the scenes, type classes are represented by structures. Defining a "
"class defines a structure, and additionally creates an empty table of "
"instances. Defining an instance creates a value that either has the "
"structure as its type or is a function that can return the structure, and "
"additionally adds an entry to the table. Instance search consists of "
"constructing an instance by consulting the instance tables. Both structures "
"and classes may provide default values for fields (which are default "
"implementations of methods)."
msgstr ""

#: src/functor-applicative-monad/summary.md:13
msgid ""
"Structures may inherit from other structures. Behind the scenes, a structure "
"that inherits from another structure contains an instance of the original "
"structure as a field. In other words, inheritance is implemented with "
"composition. When multiple inheritance is used, only the unique fields from "
"the additional parent structures are used to avoid a diamond problem, and "
"the functions that would normally extract the parent value are instead "
"organized to construct one. Record dot notation takes structure inheritance "
"into account."
msgstr ""

#: src/functor-applicative-monad/summary.md:19
msgid ""
"Because type classes are just structures with some additional automation "
"applied, all of these features are available in type classes. Together with "
"default methods, this can be used to create a fine-grained hierarchy of "
"interfaces that nonetheless does not impose a large burden on clients, "
"because the small classes that the large classes inherit from can be "
"automatically implemented."
msgstr ""

#: src/functor-applicative-monad/summary.md:24
msgid "An applicative functor is a functor with two additional operations:"
msgstr ""

#: src/functor-applicative-monad/summary.md:25
msgid "`pure`, which is the same operator as that for `Monad`"
msgstr ""

#: src/functor-applicative-monad/summary.md:26
msgid ""
"`seq`, which allows a function to be applied in the context of the functor."
msgstr ""

#: src/functor-applicative-monad/summary.md:28
msgid ""
"While monads can represent arbitrary programs with control flow, applicative "
"functors can only run function arguments from left to right. Because they "
"are less powerful, they provide less control to programs written against the "
"interface, while the implementor of the method has a greater degree of "
"freedom. Some useful types can implement `Applicative` but not `Monad`."
msgstr ""

#: src/functor-applicative-monad/summary.md:32
msgid ""
"In fact, the type classes `Functor`, `Applicative`, and `Monad` form a "
"hierarchy of power. Moving up the hierarchy, from `Functor` towards `Monad`, "
"allows more powerful programs to be written, but fewer types implement the "
"more powerful classes. Polymorphic programs should be written to use as weak "
"of an abstraction as possible, while datatypes should be given instances "
"that are as powerful as possible. This maximizes code re-use. The more "
"powerful type classes extend the less powerful ones, which means that an "
"implementation of `Monad` provides implementations of `Functor` and "
"`Applicative` for free."
msgstr ""

#: src/functor-applicative-monad/summary.md:38
msgid ""
"Each class has a set of methods to be implemented and a corresponding "
"contract that specifies additional rules for the methods. Programs that are "
"written against these interfaces expect that the additional rules are "
"followed, and may be buggy if they are not. The default implementations of "
"`Functor`'s methods in terms of `Applicative`'s, and of `Applicative`'s in "
"terms of `Monad`'s, will obey these rules."
msgstr ""

#: src/functor-applicative-monad/summary.md:44
msgid ""
"To allow Lean to be used as both a programming language and a theorem "
"prover, some restrictions on the language are necessary. This includes "
"restrictions on recursive functions that ensure that they all either "
"terminate or are marked as `partial` and written to return types that are "
"not uninhabited. Additionally, it must be impossible to represent certain "
"kinds of logical paradoxes as types."
msgstr ""

#: src/functor-applicative-monad/summary.md:48
msgid ""
"One of the restrictions that rules out certain paradoxes is that every type "
"is assigned to a _universe_. Universes are types such as `Prop`, `Type`, "
"`Type 1`, `Type 2`, and so forth. These types describe other types—just as "
"`0` and `17` are described by `Nat`, `Nat` is itself described by `Type`, "
"and `Type` is described by `Type 1`. The type of functions that take a type "
"as an argument must be a larger universe than the argument's universe."
msgstr ""

#: src/functor-applicative-monad/summary.md:53
msgid ""
"Because each declared datatype has a universe, writing code that uses types "
"like data would quickly become annoying, requiring each polymorphic type to "
"be copy-pasted to take arguments from `Type 1`. A feature called _universe "
"polymorphism_ allows Lean programs and datatypes to take universe levels as "
"arguments, just as ordinary polymorphism allows programs to take types as "
"arguments. Generally speaking, Lean libraries should use universe "
"polymorphism when implementing libraries of polymorphic operations."
msgstr ""

#: src/monad-transformers.md:3
msgid ""
"A monad is a way to encode some collection of side effects in a pure "
"language. Different monads provide different effects, such as state and "
"error handling. Many monads even provide useful effects that aren't "
"available in most languages, such as nondeterministic searches, readers, and "
"even continuations."
msgstr ""

#: src/monad-transformers.md:7
msgid ""
"A typical application has a core set of easily testable functions written "
"without monads paired with an outer wrapper that uses a monad to encode the "
"necessary application logic. These monads are constructed from well-known "
"components. For example:"
msgstr ""

#: src/monad-transformers.md:10
msgid ""
"Mutable state is encoded with a function parameter and a return value that "
"have the same type"
msgstr ""

#: src/monad-transformers.md:11
msgid ""
"Error handling is encoded by having a return type that is similar to "
"`Except`, with constructors for success and failure"
msgstr ""

#: src/monad-transformers.md:12
msgid "Logging is encoded by pairing the return value with the log"
msgstr ""

#: src/monad-transformers.md:14
msgid ""
"Writing each monad by hand is tedious, however, involving boilerplate "
"definitions of the various type classes. Each of these components can also "
"be extracted to a definition that modifies some other monad to add an "
"additional effect. Such a definition is called a _monad transformer_. A "
"concrete monad can be build from a collection of monad transformers, which "
"enables much more code re-use."
msgstr ""

#: src/monad-transformers/reader-io.md:3
msgid ""
"One case where a reader monad can be useful is when there is some notion of "
"the \"current configuration\" of the application that is passed through many "
"recursive calls. An example of such a program is `tree`, which recursively "
"prints the files in the current directory and its subdirectories, indicating "
"their tree structure using characters. The version of `tree` in this "
"chapter, called `doug` after the mighty Douglas Fir tree that adorns the "
"west coast of North America, provides the option of Unicode box-drawing "
"characters or their ASCII equivalents when indicating directory structure."
msgstr ""

#: src/monad-transformers/reader-io.md:7
msgid ""
"For example, the following commands create a directory structure and some "
"empty files in a directory called `doug-demo`:"
msgstr ""

#: src/monad-transformers/reader-io.md:17
msgid "Running `doug` results in the following:"
msgstr ""

#: src/monad-transformers/reader-io.md:32
msgid "Implementation"
msgstr ""

#: src/monad-transformers/reader-io.md:34
msgid ""
"Internally, `doug` passes a configuration value downwards as it recursively "
"traverses the directory structure. This configuration contains two fields: "
"`useASCII` determines whether to use Unicode box-drawing characters or ASCII "
"vertical line and dash characters to indicate structure, and `currentPrefix` "
"contains a string to prepend to each line of output. As the current "
"directory deepens, the prefix string accumulates indicators of being in a "
"directory. The configuration is a structure:"
msgstr ""

#: src/monad-transformers/reader-io.md:38
msgid ""
"```lean\n"
"structure Config where\n"
"  useASCII : Bool := false\n"
"  currentPrefix : String := \"\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:43
msgid ""
"This structure has default definitions for both fields. The default `Config` "
"uses Unicode display with no prefix."
msgstr ""

#: src/monad-transformers/reader-io.md:46
msgid ""
"Users who invoke `doug` will need to be able to provide command-line "
"arguments. The usage information is as follows:"
msgstr ""

#: src/monad-transformers/reader-io.md:48
msgid ""
"```lean\n"
"def usage : String :=\n"
"  \"Usage: doug [--ascii]\n"
"Options:\n"
"\\t--ascii\\tUse ASCII characters to display the directory structure\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:54
msgid ""
"Accordingly, a configuration can be constructed by examining a list of "
"command-line arguments:"
msgstr ""

#: src/monad-transformers/reader-io.md:55
msgid ""
"```lean\n"
"def configFromArgs : List String → Option Config\n"
"  | [] => some {} -- both fields default\n"
"  | [\"--ascii\"] => some {useASCII := true}\n"
"  | _ => none\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:62
msgid ""
"The `main` function is a wrapper around an inner worker, called `dirTree`, "
"that shows the contents of a directory using a configuration. Before calling "
"`dirTree`, `main` is responsible for processing command-line arguments. It "
"must also return the appropriate exit code to the operating system:"
msgstr ""

#: src/monad-transformers/reader-io.md:65
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"  match configFromArgs args with\n"
"  | some config =>\n"
"    dirTree config (← IO.currentDir)\n"
"    pure 0\n"
"  | none =>\n"
"    IO.eprintln s!\"Didn't understand argument(s) {\" \".separate args}\\n"
"\"\n"
"    IO.eprintln usage\n"
"    pure 1\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:77
msgid ""
"Not all paths should be shown in the directory tree. In particular, files "
"named `.` or `..` should be skipped, as they are actually features used for "
"navigation rather than files _per se_. Of those files that should be shown, "
"there are two kinds: ordinary files and directories:"
msgstr ""

#: src/monad-transformers/reader-io.md:85
msgid ""
"To determine whether a file should be shown, along with which kind of entry "
"it is, `doug` uses `toEntry`:"
msgstr ""

#: src/monad-transformers/reader-io.md:86
msgid ""
"```lean\n"
"def toEntry (path : System.FilePath) : IO (Option Entry) := do\n"
"  match path.components.getLast? with\n"
"  | none => pure (some (.dir \"\"))\n"
"  | some \".\" | some \"..\" => pure none\n"
"  | some name =>\n"
"    pure (some (if (← path.isDir) then .dir name else .file name))\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:94
msgid ""
"`System.FilePath.components` converts a path into a list of path components, "
"splitting the name at directory separators. If there is no last component, "
"then the path is the root directory. If the last component is a special "
"navigation file (`.` or `..`), then the file should be excluded. Otherwise, "
"directories and files are wrapped in the corresponding constructors."
msgstr ""

#: src/monad-transformers/reader-io.md:99
msgid ""
"Lean's logic has no way to know that directory trees are finite. Indeed, "
"some systems allow the construction of circular directory structures. Thus, "
"`dirTree` is declared `partial`:"
msgstr ""

#: src/monad-transformers/reader-io.md:114
msgid ""
"The call to `toEntry` is a [nested "
"action](../hello-world/conveniences.md#nested-actions)—the parentheses are "
"optional in positions where the arrow couldn't have any other meaning, such "
"as `match`. When the filename doesn't correspond to an entry in the tree "
"(e.g. because it is `..`), `dirTree` does nothing. When the filename points "
"to an ordinary file, `dirTree` calls a helper to show it with the current "
"configuration. When the filename points to a directory, it is shown with a "
"helper, and then its contents are recursively shown in a new configuration "
"in which the prefix has been extended to account for being in a new "
"directory."
msgstr ""

#: src/monad-transformers/reader-io.md:119
msgid ""
"Showing the names of files and directories is achieved with `showFileName` "
"and `showDirName`:"
msgstr ""

#: src/monad-transformers/reader-io.md:127
msgid ""
"Both of these helpers delegate to functions on `Config` that take the ASCII "
"vs Unicode setting into account:"
msgstr ""

#: src/monad-transformers/reader-io.md:128
msgid ""
"```lean\n"
"def Config.preFile (cfg : Config) :=\n"
"  if cfg.useASCII then \"|--\" else \"├──\"\n"
"\n"
"def Config.preDir (cfg : Config) :=\n"
"  if cfg.useASCII then \"|  \" else \"│  \"\n"
"\n"
"def Config.fileName (cfg : Config) (file : String) : String :=\n"
"  s!\"{cfg.currentPrefix}{cfg.preFile} {file}\"\n"
"\n"
"def Config.dirName (cfg : Config) (dir : String) : String :=\n"
"  s!\"{cfg.currentPrefix}{cfg.preFile} {dir}/\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:141
msgid ""
"Similarly, `Config.inDirectory` extends the prefix with a directory marker:"
msgstr ""

#: src/monad-transformers/reader-io.md:142
msgid ""
"```lean\n"
"def Config.inDirectory (cfg : Config) : Config :=\n"
"  {cfg with currentPrefix := cfg.preDir ++ \" \" ++ cfg.currentPrefix}\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:147
msgid ""
"Iterating an IO action over a list of directory contents is achieved using "
"`doList`. Because `doList` carries out all the actions in a list and does "
"not base control-flow decisions on the values returned by any of the "
"actions, the full power of `Monad` is not necessary, and it will work for "
"any `Applicative`:"
msgstr ""

#: src/monad-transformers/reader-io.md:158
msgid "Using a Custom Monad"
msgstr ""

#: src/monad-transformers/reader-io.md:160
msgid ""
"While this implementation of `doug` works, manually passing the "
"configuration around is verbose and error-prone. The type system will not "
"catch it if the wrong configuration is passed downwards, for instance. A "
"reader effect ensures that the same configuration is passed to all recursive "
"calls, unless it is manually overridden, and it helps make the code less "
"verbose."
msgstr ""

#: src/monad-transformers/reader-io.md:164
msgid ""
"To create a version of `IO` that is also a reader of `Config`, first define "
"the type and its `Monad` instance, following the recipe from [the evaluator "
"example](../monads/arithmetic.md#custom-environments):"
msgstr ""

#: src/monad-transformers/reader-io.md:175
msgid ""
"The difference between this `Monad` instance and the one for `Reader` is "
"that this one uses `do`\\-notation in the `IO` monad as the body of the "
"function that `bind` returns, rather than applying `next` directly to the "
"value returned from `result`. Any `IO` effects performed by `result` must "
"occur before `next` is invoked, which is ensured by the `IO` monad's `bind` "
"operator. `ConfigIO` is not universe polymorphic because the underlying `IO` "
"type is also not universe polymorphic."
msgstr ""

#: src/monad-transformers/reader-io.md:179
msgid ""
"Running a `ConfigIO` action involves transforming it into an `IO` action by "
"providing it with a configuration:"
msgstr ""

#: src/monad-transformers/reader-io.md:184
msgid ""
"This function is not really necessary, as a caller could simply provide the "
"configuration directly. However, naming the operation can make it easier to "
"see which parts of the code are intended to run in which monad."
msgstr ""

#: src/monad-transformers/reader-io.md:187
msgid ""
"The next step is to define a means of accessing the current configuration as "
"part of `ConfigIO`:"
msgstr ""

#: src/monad-transformers/reader-io.md:192
msgid ""
"This is just like `read` from [the evaluator "
"example](../monads/arithmetic.md#custom-environments), except it uses `IO`'s "
"`pure` to return its value rather than doing so directly. Because entering a "
"directory modifies the current configuration for the scope of a recursive "
"call, it will be necessary to have a way to override a configuration:"
msgstr ""

#: src/monad-transformers/reader-io.md:199
msgid ""
"Much of the code used in `doug` has no need for configurations, and `doug` "
"calls ordinary Lean `IO` actions from the standard library that certainly "
"don't need a `Config`. Ordinary `IO` actions can be run using `runIO`, which "
"ignores the configuration argument:"
msgstr ""

#: src/monad-transformers/reader-io.md:206
msgid ""
"With these components, `showFileName` and `showDirName` can be updated to "
"take their configuration arguments implicitly through the `ConfigIO` monad. "
"They use [nested actions](../hello-world/conveniences.md#nested-actions) to "
"retrieve the configuration, and `runIO` to actually execute the call to "
"`IO.println`:"
msgstr ""

#: src/monad-transformers/reader-io.md:216
msgid ""
"In the new version of `dirTree`, the calls to `toEntry` and "
"`System.FilePath.readDir` are wrapped in `runIO`. Additionally, instead of "
"building a new configuration and then requiring the programmer to keep track "
"of which one to pass to recursive calls, it uses `locally` to naturally "
"delimit the modified configuration to only a small region of the program, in "
"which it is the _only_ valid configuration:"
msgstr ""

#: src/monad-transformers/reader-io.md:231
msgid ""
"The new version of `main` uses `ConfigIO.run` to invoke `dirTree` with the "
"initial configuration:"
msgstr ""

#: src/monad-transformers/reader-io.md:232
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"    match configFromArgs args with\n"
"    | some config =>\n"
"      (dirTree (← IO.currentDir)).run config\n"
"      pure 0\n"
"    | none =>\n"
"      IO.eprintln s!\"Didn't understand argument(s) {\" \".separate args}\\n"
"\"\n"
"      IO.eprintln usage\n"
"      pure 1\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:244
msgid ""
"This custom monad has a number of advantages over passing configurations "
"manually:"
msgstr ""

#: src/monad-transformers/reader-io.md:246
msgid ""
"It is easier to ensure that configurations are passed down unchanged, except "
"when changes are desired"
msgstr ""

#: src/monad-transformers/reader-io.md:247
msgid ""
"The concern of passing the configuration onwards is more clearly separated "
"from the concern of printing directory contents"
msgstr ""

#: src/monad-transformers/reader-io.md:248
msgid ""
"As the program grows, there will be more and more intermediate layers that "
"do nothing with configurations except propagate them, and these layers don't "
"need to be rewritten as the configuration logic changes"
msgstr ""

#: src/monad-transformers/reader-io.md:250
msgid "However, there are also some clear downsides:"
msgstr ""

#: src/monad-transformers/reader-io.md:252
msgid ""
"As the program evolves and the monad requires more features, each of the "
"basic operators such as `locally` and `currentConfig` will need to be updated"
msgstr ""

#: src/monad-transformers/reader-io.md:253
msgid ""
"Wrapping ordinary `IO` actions in `runIO` is noisy and distracts from the "
"flow of the program"
msgstr ""

#: src/monad-transformers/reader-io.md:254
msgid ""
"Writing monads instances by hand is repetitive, and the technique for adding "
"a reader effect to another monad is a design pattern that requires "
"documentation and communication overhead"
msgstr ""

#: src/monad-transformers/reader-io.md:256
msgid ""
"Using a technique called _monad transformers_, all of these downsides can be "
"addressed. A monad transformer takes a monad as an argument and returns a "
"new monad. Monad transformers consist of:"
msgstr ""

#: src/monad-transformers/reader-io.md:259
msgid ""
"A definition of the transformer itself, which is typically a function from "
"types to types"
msgstr ""

#: src/monad-transformers/reader-io.md:260 src/monad-transformers/summary.md:12
msgid "A `Monad` instance that assumes the inner type is already a monad"
msgstr ""

#: src/monad-transformers/reader-io.md:261
msgid ""
"An operator to \"lift\" an action from the inner monad to the transformed "
"monad, akin to `runIO`"
msgstr ""

#: src/monad-transformers/reader-io.md:263
msgid "Adding a Reader to Any Monad"
msgstr ""

#: src/monad-transformers/reader-io.md:265
msgid ""
"Adding a reader effect to `IO` was accomplished in `ConfigIO` by wrapping "
"`IO α` in a function type. The Lean standard library contains a function "
"that can do this to _any_ polymorphic type, called `ReaderT`:"
msgstr ""

#: src/monad-transformers/reader-io.md:271
msgid "Its arguments are as follows:"
msgstr ""

#: src/monad-transformers/reader-io.md:272
msgid "`ρ` is the environment that is accessible to the reader"
msgstr ""

#: src/monad-transformers/reader-io.md:273
msgid "`m` is the monad that is being transformed, such as `IO`"
msgstr ""

#: src/monad-transformers/reader-io.md:274
msgid ""
"`α` is the type of values being returned by the monadic computation Both `α` "
"and `ρ` are in the same universe because the operator that retrieves the "
"environment in the monad will have type `m ρ`."
msgstr ""

#: src/monad-transformers/reader-io.md:277
msgid "With `ReaderT`, `ConfigIO` becomes:"
msgstr ""

#: src/monad-transformers/reader-io.md:281
msgid ""
"It is an `abbrev` because `ReaderT` has many useful features defined in the "
"standard library that a non-reducible definition would hide. Rather than "
"taking responsibility for making these work directly for `ConfigIO`, it's "
"easier to simply have `ConfigIO` behave identically to `ReaderT Config IO`."
msgstr ""

#: src/monad-transformers/reader-io.md:284
msgid ""
"The manually-written `currentConfig` obtained the environment out of the "
"reader. This effect can be defined in a generic form for all uses of "
"`ReaderT`, under the name `read`:"
msgstr ""

#: src/monad-transformers/reader-io.md:290
msgid ""
"However, not every monad that provides a reader effect is built with "
"`ReaderT`. The type class `MonadReader` allows any monad to provide a `read` "
"operator:"
msgstr ""

#: src/monad-transformers/reader-io.md:301
msgid ""
"The type `ρ` is an output parameter because any given monad typically only "
"provides a single type of environment through a reader, so automatically "
"selecting it when the monad is known makes programs more convenient to write."
msgstr ""

#: src/monad-transformers/reader-io.md:303
msgid ""
"The `Monad` instance for `ReaderT` is essentially the same as the `Monad` "
"instance for `ConfigIO`, except `IO` has been replaced by some arbitrary "
"monad argument `m`:"
msgstr ""

#: src/monad-transformers/reader-io.md:313
msgid ""
"The next step is to eliminate uses of `runIO`. When Lean encounters a "
"mismatch in monad types, it automatically attempts to use a type class "
"called `MonadLift` to transform the actual monad into the expected monad. "
"This process is similar to the use of coercions. `MonadLift` is defined as "
"follows:"
msgstr ""

#: src/monad-transformers/reader-io.md:321
msgid ""
"The method `monadLift` translates from the monad `m` to the monad `n`. The "
"process is called \"lifting\" because it takes an action in the embedded "
"monad and makes it into an action in the surrounding monad. In this case, it "
"will be used to \"lift\" from `IO` to `ReaderT Config IO`, though the "
"instance works for _any_ inner monad `m`:"
msgstr ""

#: src/monad-transformers/reader-io.md:328
msgid ""
"The implementation of `monadLift` is very similar to that of `runIO`. "
"Indeed, it is enough to define `showFileName` and `showDirName` without "
"using `runIO`:"
msgstr ""

#: src/monad-transformers/reader-io.md:330
msgid ""
"```lean\n"
"def showFileName (file : String) : ConfigIO Unit := do\n"
"  IO.println s!\"{(← read).currentPrefix} {file}\"\n"
"\n"
"def showDirName (dir : String) : ConfigIO Unit := do\n"
"  IO.println s!\"{(← read).currentPrefix} {dir}/\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:338
msgid ""
"One final operation from the original `ConfigIO` remains to be translated to "
"a use of `ReaderT`: `locally`. The definition can be translated directly to "
"`ReaderT`, but the Lean standard library provides a more general version. "
"The standard version is called `withReader`, and it is part of a type class "
"called `MonadWithReader`:"
msgstr ""

#: src/monad-transformers/reader-io.md:345
msgid ""
"Just as in `MonadReader`, the environment `ρ` is an `outParam`. The "
"`withReader` operation is exported, so that it doesn't need to be written "
"with the type class name before it:"
msgstr ""

#: src/monad-transformers/reader-io.md:350
msgid ""
"The instance for `ReaderT` is essentially the same as the definition of "
"`locally`:"
msgstr ""

#: src/monad-transformers/reader-io.md:357
msgid ""
"With these definitions in place, the new version of `dirTree` can be written:"
msgstr ""

#: src/monad-transformers/reader-io.md:370
msgid ""
"Aside from replacing `locally` with `withReader`, it is the same as before."
msgstr ""

#: src/monad-transformers/reader-io.md:373
msgid ""
"Replacing the custom `ConfigIO` type with `ReaderT` did not save a large "
"number of lines of code in this section. However, rewriting the code using "
"components from the standard library does have long-term benefits. First, "
"readers who know about `ReaderT` don't need to take time to understand the "
"`Monad` instance for `ConfigIO`, working backwards to the meaning of monad "
"itself. Instead, they can be confident in their initial understanding. Next, "
"adding further effects to the monad (such as a state effect to count the "
"files in each directory and display a count at the end) requires far fewer "
"changes to the code, because the monad transformers and `MonadLift` "
"instances provided in the library work well together. Finally, using a set "
"of type classes included in the standard library, polymorphic code can be "
"written in such a way that it can work with a variety of monads without "
"having to care about details like the order in which the monad transformers "
"were applied. Just as some functions work in any monad, others can work in "
"any monad that provides a certain type of state, or a certain type of "
"exceptions, without having to specifically describe the _way_ in which a "
"particular concrete monad provides the state or exceptions."
msgstr ""

#: src/monad-transformers/reader-io.md:383
msgid "Controlling the Display of Dotfiles"
msgstr ""

#: src/monad-transformers/reader-io.md:385
msgid ""
"Files whose names begin with a dot character (`'.'`) typically represent "
"files that should usually be hidden, such as source-control metadata and "
"configuration files. Modify `doug` with an option to show or hide filenames "
"that begin with a dot. This option should be controlled with a `-a` "
"command-line option."
msgstr ""

#: src/monad-transformers/reader-io.md:389
msgid "Starting Directory as Argument"
msgstr ""

#: src/monad-transformers/reader-io.md:391
msgid ""
"Modify `doug` so that it takes a starting directory as an additional "
"command-line argument."
msgstr ""

#: src/monad-transformers/transformers.md:3
msgid ""
"`ReaderT` is far from the only useful monad transformer. This section "
"describes a number of additional transformers. Each monad transformer "
"consists of the following:"
msgstr ""

#: src/monad-transformers/transformers.md:6
msgid ""
"A definition or datatype `T` that takes a monad as an argument. It should "
"have a type like `(Type u → Type v) → Type u → Type v`, though it may accept "
"additional arguments prior to the monad."
msgstr ""

#: src/monad-transformers/transformers.md:8
msgid ""
"A `Monad` instance for `T m` that relies on an instance of `Monad m`. This "
"enables the transformed monad to be used as a monad."
msgstr ""

#: src/monad-transformers/transformers.md:9
msgid ""
"A `MonadLift` instance that translates actions of type `m α` into actions of "
"type `T m α`, for arbitrary monads `m`. This enables actions from the "
"underlying monad to be used in the transformed monad."
msgstr ""

#: src/monad-transformers/transformers.md:11
msgid ""
"Furthermore, the `Monad` instance for the transformer should obey the "
"contract for `Monad`, at least if the underlying `Monad` instance does. In "
"addition, `monadLift (pure x)` should be equivalent to `pure x` in the "
"transformed monad, and `monadLift` should distribute over `bind` so that "
"`monadLift (x >>= f)` is the same as `monadLift x >>= fun y => monadLift (f "
"y)`."
msgstr ""

#: src/monad-transformers/transformers.md:14
msgid ""
"Many monad transformers additionally define type classes in the style of "
"`MonadReader` that describe the actual effects available in the monad. This "
"can provide more flexibility: it allows programs to be written that rely "
"only on an interface, and don't constrain the underlying monad to be "
"implemented by a given transformer. The type classes are a way for programs "
"to express their requirements, and monad transformers are a convenient way "
"to meet these requirements."
msgstr ""

#: src/monad-transformers/transformers.md:19
msgid "Failure with `OptionT`"
msgstr ""

#: src/monad-transformers/transformers.md:21
msgid ""
"Failure, represented by the `Option` monad, and exceptions, represented by "
"the `Except` monad, both have corresponding transformers. In the case of "
"`Option`, failure can be added to a monad by having it contain values of "
"type `Option α` where it would otherwise contain values of type `α`. For "
"example, `IO (Option α)` represents `IO` actions that don't always return a "
"value of type `α`. This suggests the definition of the monad transformer "
"`OptionT`:"
msgstr ""

#: src/monad-transformers/transformers.md:30
msgid ""
"As an example of `OptionT` in action, consider a program that asks the user "
"questions. The function `getSomeInput` asks for a line of input and removes "
"whitespace from both ends. If the resulting trimmed input is non-empty, then "
"it is returned, but the function fails if there are no non-whitespace "
"characters:"
msgstr ""

#: src/monad-transformers/transformers.md:33
msgid ""
"```lean\n"
"def getSomeInput : OptionT IO String := do\n"
"  let input ← (← IO.getStdin).getLine\n"
"  let trimmed := input.trim\n"
"  if trimmed == \"\" then\n"
"    failure\n"
"  else pure trimmed\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:41
msgid ""
"This particular application tracks users with their name and their favorite "
"species of beetle:"
msgstr ""

#: src/monad-transformers/transformers.md:47
msgid ""
"Asking the user for input is no more verbose than a function that uses only "
"`IO` would be:"
msgstr ""

#: src/monad-transformers/transformers.md:48
msgid ""
"```lean\n"
"def getUserInfo : OptionT IO UserInfo := do\n"
"  IO.println \"What is your name?\"\n"
"  let name ← getSomeInput\n"
"  IO.println \"What is your favorite species of beetle?\"\n"
"  let beetle ← getSomeInput\n"
"  pure ⟨name, beetle⟩\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:56
msgid ""
"However, because the function runs in an `OptionT IO` context rather than "
"just in `IO`, failure in the first call to `getSomeInput` causes the whole "
"`getUserInfo` to fail, with control never reaching the question about "
"beetles. The main function, `interact`, invokes `getUserInfo` in a purely "
"`IO` context, which allows it to check whether the call succeeded or failed "
"by matching on the inner `Option`:"
msgstr ""

#: src/monad-transformers/transformers.md:58
msgid ""
"```lean\n"
"def interact : IO Unit := do\n"
"  match ← getUserInfo with\n"
"  | none => IO.eprintln \"Missing info\"\n"
"  | some ⟨name, beetle⟩ => IO.println s!\"Hello {name}, whose favorite "
"beetle is {beetle}.\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:65
msgid "The Monad Instance"
msgstr ""

#: src/monad-transformers/transformers.md:67
msgid ""
"Writing the monad instance reveals a difficulty. Based on the types, `pure` "
"should use `pure` from the underlying monad `m` together with `some`. Just "
"as `bind` for `Option` branches on the first argument, propagating `none`, "
"`bind` for `OptionT` should run the monadic action that makes up the first "
"argument, branch on the result, and then propagate `none`. Following this "
"sketch yields the following definition, which Lean does not accept:"
msgstr ""

#: src/monad-transformers/transformers.md:79
msgid "The error message shows a cryptic type mismatch:"
msgstr ""

#: src/monad-transformers/transformers.md:90
msgid ""
"The problem here is that Lean is selecting the wrong `Monad` instance for "
"the surrounding use of `pure`. Similar errors occur for the definition of "
"`bind`. One solution is to use type annotations to guide Lean to the correct "
"`Monad` instance:"
msgstr ""

#: src/monad-transformers/transformers.md:101
msgid ""
"While this solution works, it is inelegant and the code becomes a bit noisy."
msgstr ""

#: src/monad-transformers/transformers.md:103
msgid ""
"An alternative solution is to define functions whose type signatures guide "
"Lean to the correct instances. In fact, `OptionT` could have been defined as "
"a structure:"
msgstr ""

#: src/monad-transformers/transformers.md:109
msgid ""
"This would solve the problem, because the constructor `OptionT.mk` and the "
"field accessor `OptionT.run` would guide type class inference to the correct "
"instances. The downside to doing this is that structure values would need to "
"be allocated and deallocated repeatedly when running code that uses it, "
"while the direct definition is a compile-time-only feature. The best of both "
"worlds can be achieved by defining functions that serve the same role as "
"`OptionT.mk` and `OptionT.run`, but that work with the direct definition:"
msgstr ""

#: src/monad-transformers/transformers.md:117
msgid ""
"Both functions return their inputs unchanged, but they indicate the boundary "
"between code that is intended to present the interface of `OptionT` and code "
"that is intended to present the interface of the underlying monad `m`. Using "
"these helpers, the `Monad` instance becomes more readable:"
msgstr ""

#: src/monad-transformers/transformers.md:127
msgid ""
"Here, the use of `OptionT.mk` indicates that its arguments should be "
"considered as code that uses the interface of `m`, which allows Lean to "
"select the correct `Monad` instances."
msgstr ""

#: src/monad-transformers/transformers.md:129
msgid ""
"After defining the monad instance, it's a good idea to check that the monad "
"contract is satisfied. The first step is to show that `bind (pure v) f` is "
"the same as `f v`. Here's the steps:"
msgstr ""

#: src/monad-transformers/transformers.md:189
msgid ""
"The second rule states that `bind w pure` is the same as `w`. To demonstrate "
"this, unfold the definitions of `bind` and `pure`, yielding:"
msgstr ""

#: src/monad-transformers/transformers.md:197
msgid ""
"In this pattern match, the result of both cases is the same as the pattern "
"being matched, just with `pure` around it. In other words, it is equivalent "
"to `w >>= fun y => pure y`, which is an instance of `m`'s second monad rule."
msgstr ""

#: src/monad-transformers/transformers.md:200
msgid ""
"The final rule states that `bind (bind v f) g`  is the same as `bind v (fun "
"x => bind (f x) g)`. It can be checked in the same way, by expanding the "
"definitions of `bind` and `pure` and then delegating to the underlying monad "
"`m`."
msgstr ""

#: src/monad-transformers/transformers.md:203
msgid "An `Alternative` Instance"
msgstr ""

#: src/monad-transformers/transformers.md:205
msgid ""
"One convenient way to use `OptionT` is through the `Alternative` type class. "
"Successful return is already indicated by `pure`, and the `failure` and "
"`orElse` methods of `Alternative` provide a way to write a program that "
"returns the first successful result from a number of subprograms:"
msgstr ""

#: src/monad-transformers/transformers.md:217
msgid "Lifting"
msgstr ""

#: src/monad-transformers/transformers.md:219
msgid ""
"Lifting an action from `m` to `OptionT m` only requires wrapping `some` "
"around the result of the computation:"
msgstr ""

#: src/monad-transformers/transformers.md:227
msgid "Exceptions"
msgstr ""

#: src/monad-transformers/transformers.md:229
msgid ""
"The monad transformer version of `Except` is very similar to the monad "
"transformer version of `Option`. Adding exceptions of type `ε` to some "
"monadic action of type `m α` can be accomplished by adding exceptions to "
"`α`, yielding type `m (Except ε α)`:"
msgstr ""

#: src/monad-transformers/transformers.md:235
msgid ""
"`OptionT` provides `mk` and `run` functions to guide the type checker "
"towards the correct `Monad` instances. This trick is also useful for "
"`ExceptT`:"
msgstr ""

#: src/monad-transformers/transformers.md:242
msgid ""
"The `Monad` instance for `ExceptT` is also very similar to the instance for "
"`OptionT`. The only difference is that it propagates a specific error value, "
"rather than `none`:"
msgstr ""

#: src/monad-transformers/transformers.md:253
msgid ""
"The type signatures of `ExceptT.mk` and `ExceptT.run` contain a subtle "
"detail: they annotate the universe levels of `α` and `ε` explicitly. If they "
"are not explicitly annotated, then Lean generates a more general type "
"signature in which they have distinct polymorphic universe variables. "
"However, the definition of `ExceptT` expects them to be in the same "
"universe, because they can both be provided as arguments to `m`. This can "
"lead to a problem in the `Monad` instance where the universe level solver "
"fails to find a working solution:"
msgstr ""

#: src/monad-transformers/transformers.md:275
msgid ""
"This kind of error message is typically caused by underconstrained universe "
"variables. Diagnosing it can be tricky, but a good first step is to look for "
"reused universe variables in some definitions that are not reused in others."
msgstr ""

#: src/monad-transformers/transformers.md:278
msgid ""
"Unlike `Option`, the `Except` datatype is typically not used as a data "
"structure. It is always used as a control structure with its `Monad` "
"instance. This means that it is reasonable to lift `Except ε` actions into "
"`ExceptT ε m`, as well as actions from the underlying monad `m`. Lifting "
"`Except` actions into `ExceptT` actions is done by wrapping them in `m`'s "
"`pure`, because an action that only has exception effects cannot have any "
"effects from the monad `m`:"
msgstr ""

#: src/monad-transformers/transformers.md:286
msgid ""
"Because actions from `m` do not have any exceptions in them, their value "
"should be wrapped in `Except.ok`. This can be accomplished using the fact "
"that `Functor` is a superclass of `Monad`, so applying a function to the "
"result of any monadic computation can be accomplished using `Functor.map`:"
msgstr ""

#: src/monad-transformers/transformers.md:293
msgid "Type Classes for Exceptions"
msgstr ""

#: src/monad-transformers/transformers.md:295
msgid ""
"Exception handling fundamentally consists of two operations: the ability to "
"throw exceptions, and the ability to recover from them. Thus far, this has "
"been accomplished using the constructors of `Except` and pattern matching, "
"respectively. However, this ties a program that uses exceptions to one "
"specific encoding of the exception handling effect. Using a type class to "
"capture these operations allows a program that uses exceptions to be used in "
"_any_ monad that supports throwing and catching."
msgstr ""

#: src/monad-transformers/transformers.md:300
msgid ""
"Throwing an exception should take an exception as an argument, and it should "
"be allowed in any context where a monadic action is requested. The \"any "
"context\" part of the specification can be written as a type by writing `m "
"α`—because there's no way to produce a value of any arbitrary type, the "
"`throw` operation must be doing something that causes control to leave that "
"part of the program. Catching an exception should accept any monadic action "
"together with a handler, and the handler should explain how to get back to "
"the action's type from an exception:"
msgstr ""

#: src/monad-transformers/transformers.md:309
msgid ""
"The universe levels on `MonadExcept` differ from those of `ExceptT`. In "
"`ExceptT`, both `ε` and `α` have the same level, while `MonadExcept` imposes "
"no such limitation. This is because `MonadExcept` never places an exception "
"value inside of `m`. The most general universe signature recognizes the fact "
"that `ε` and `α` are completely independent in this definition. Being more "
"general means that the type class can be instantiated for a wider variety of "
"types."
msgstr ""

#: src/monad-transformers/transformers.md:315
msgid ""
"An example program that uses `MonadExcept` is a simple division service. The "
"program is divided into two parts: a frontend that supplies a user interface "
"based on strings that handles errors, and a backend that actually does the "
"division. Both the frontend and the backend can throw exceptions, the former "
"for ill-formed input and the latter for division by zero errors. The "
"exceptions are an inductive type:"
msgstr ""

#: src/monad-transformers/transformers.md:324
msgid "The backend checks for zero, and divides if it can:"
msgstr ""

#: src/monad-transformers/transformers.md:331
msgid ""
"The frontend's helper `asNumber` throws an exception if the string it is "
"passed is not a number. The overall frontend converts its inputs to `Int`s "
"and calls the backend, handling exceptions by returning a friendly string "
"error:"
msgstr ""

#: src/monad-transformers/transformers.md:333
msgid ""
"```lean\n"
"def asNumber [Monad m] [MonadExcept Err m] (s : String) : m Int :=\n"
"  match s.toInt? with\n"
"  | none => throw (.notANumber s)\n"
"  | some i => pure i\n"
"\n"
"def divFrontend [Monad m] [MonadExcept Err m] (n k : String) : m String :=\n"
"  tryCatch (do pure (toString (← divBackend (← asNumber n) (← asNumber "
"k))))\n"
"    fun\n"
"      | .divByZero => pure \"Division by zero!\"\n"
"      | .notANumber s => pure s!\"Not a number: \\\"{s}\\\"\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:345
msgid ""
"Throwing and catching exceptions is common enough that Lean provides a "
"special syntax for using `MonadExcept`. Just as `+` is short for "
"`HAdd.hAdd`, `try` and `catch` can be used as shorthand for the `tryCatch` "
"method:"
msgstr ""

#: src/monad-transformers/transformers.md:347
msgid ""
"```lean\n"
"def divFrontend [Monad m] [MonadExcept Err m] (n k : String) : m String :=\n"
"  try\n"
"    pure (toString (← divBackend (← asNumber n) (← asNumber k)))\n"
"  catch\n"
"    | .divByZero => pure \"Division by zero!\"\n"
"    | .notANumber s => pure s!\"Not a number: \\\"{s}\\\"\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:356
msgid ""
"In addition to `Except` and `ExceptT`, there are useful `MonadExcept` "
"instances for other types that may not seem like exceptions at first glance. "
"For example, failure due to `Option` can be seen as throwing an exception "
"that contains no data whatsoever, so there is an instance of `MonadExcept "
"Unit Option` that allows `try ... catch ...` syntax to be used with `Option`."
msgstr ""

#: src/monad-transformers/transformers.md:359
msgid "State"
msgstr ""

#: src/monad-transformers/transformers.md:361
msgid ""
"A simulation of mutable state is added to a monad by having monadic actions "
"accept a starting state as an argument and return a final state together "
"with their result. The bind operator for a state monad provides the final "
"state of one action as an argument to the next action, threading the state "
"through the program. This pattern can also be expressed as a monad "
"transformer:"
msgstr ""

#: src/monad-transformers/transformers.md:370
msgid ""
"Once again, the monad instance is very similar to that for `State`. The only "
"difference is that the input and output states are passed around and "
"returned in the underlying monad, rather than with pure code:"
msgstr ""

#: src/monad-transformers/transformers.md:380
msgid ""
"The corresponding type class has `get` and `set` methods. One downside of "
"`get` and `set` is that it becomes too easy to `set` the wrong state when "
"updating it. This is because retrieving the state, updating it, and saving "
"the updated state is a natural way to write some programs. For example, the "
"following program counts the number of diacritic-free English vowels and "
"consonants in a string of letters:"
msgstr ""

#: src/monad-transformers/transformers.md:384
msgid ""
"```lean\n"
"structure LetterCounts where\n"
"  vowels : Nat\n"
"  consonants : Nat\n"
"deriving Repr\n"
"\n"
"inductive Err where\n"
"  | notALetter : Char → Err\n"
"deriving Repr\n"
"\n"
"def vowels :=\n"
"  let lowerVowels := \"aeiuoy\"\n"
"  lowerVowels ++ lowerVowels.map (·.toUpper)\n"
"\n"
"def consonants :=\n"
"  let lowerConsonants := \"bcdfghjklmnpqrstvwxz\"\n"
"  lowerConsonants ++ lowerConsonants.map (·.toUpper )\n"
"\n"
"def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=\n"
"  let rec loop (chars : List Char) := do\n"
"    match chars with\n"
"    | [] => pure ()\n"
"    | c :: cs =>\n"
"      let st ← get\n"
"      let st' ←\n"
"        if c.isAlpha then\n"
"          if vowels.contains c then\n"
"            pure {st with vowels := st.vowels + 1}\n"
"          else if consonants.contains c then\n"
"            pure {st with consonants := st.consonants + 1}\n"
"          else -- modified or non-English letter\n"
"            pure st\n"
"        else throw (.notALetter c)\n"
"      set st'\n"
"      loop cs\n"
"  loop str.toList\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:421
msgid ""
"It would be very easy to write `set st` instead of `set st'`. In a large "
"program, this kind of mistake can lead to difficult-to-diagnose bugs."
msgstr ""

#: src/monad-transformers/transformers.md:424
msgid ""
"While using a nested action for the call to `get` would solve this problem, "
"it can't solve all such problems. For example, a function might update a "
"field on a structure based on the values of two other fields. This would "
"require two separate nested-action calls to `get`. Because the Lean compiler "
"contains optimizations that are only effective when there is a single "
"reference to a value, duplicating the references to the state might lead to "
"code that is significantly slower. Both the potential performance problem "
"and the potential bug can be worked around by using `modify`, which "
"transforms the state using a function:"
msgstr ""

#: src/monad-transformers/transformers.md:446
msgid ""
"The type class contains a function akin to `modify` called `modifyGet`, "
"which allows the function to both compute a return value and transform an "
"old state in a single step. The function returns a pair in which the first "
"element is the return value, and the second element is the new state; "
"`modify` just adds the constructor of `Unit` to the pair used in `modifyGet`:"
msgstr ""

#: src/monad-transformers/transformers.md:453
msgid "The definition of `MonadState` is as follows:"
msgstr ""

#: src/monad-transformers/transformers.md:460
msgid ""
"`PUnit` is a version of the `Unit` type that is universe-polymorphic to "
"allow it to be in `Type u` instead of `Type`. While it would be possible to "
"provide a default implementation of `modifyGet` in terms of `get` and `set`, "
"it would not admit the optimizations that make `modifyGet` useful in the "
"first place, rendering the method useless."
msgstr ""

#: src/monad-transformers/transformers.md:463
msgid "`Of` Classes and `The` Functions"
msgstr ""

#: src/monad-transformers/transformers.md:465
msgid ""
"Thus far, each monad type class that takes extra information, like the type "
"of exceptions for `MonadExcept` or the type of the state for `MonadState`, "
"has this type of extra information as an output parameter. For simple "
"programs, this is generally convenient, because a monad that combines one "
"use each of `StateT`, `ReaderT`, and `ExceptT` has only a single state type, "
"environment type, and exception type. As monads grow in complexity, however, "
"they may involve multiple states or errors types. In this case, the use of "
"an output parameter makes it impossible to target both states in the same "
"`do`\\-block."
msgstr ""

#: src/monad-transformers/transformers.md:470
msgid ""
"For these cases, there are additional type classes in which the extra "
"information is not an output parameter. These versions of the type classes "
"use the word `Of` in the name. For example, `MonadStateOf` is like "
"`MonadState`, but without an `outParam` modifier."
msgstr ""

#: src/monad-transformers/transformers.md:474
msgid ""
"Similarly, there are versions of the type class methods that accept the type "
"of the extra information as an _explicit_, rather than implicit, argument. "
"For `MonadStateOf`, there are `getThe` with type"
msgstr ""

#: src/monad-transformers/transformers.md:479
msgid "and `modifyThe` with type"
msgstr ""

#: src/monad-transformers/transformers.md:483
msgid ""
"There is no `setThe` because the type of the new state is enough to decide "
"which surrounding state monad transformer to use."
msgstr ""

#: src/monad-transformers/transformers.md:485
msgid ""
"In the Lean standard library, there are instances of the non-`Of` versions "
"of the classes defined in terms of the instances of the versions with `Of`. "
"In other words, implementing the `Of` version yields implementations of "
"both. It's generally a good idea to implement the `Of` version, and then "
"start writing programs using the non-`Of` versions of the class, "
"transitioning to the `Of` version if the output parameter becomes "
"inconvenient."
msgstr ""

#: src/monad-transformers/transformers.md:489
msgid "Transformers and `Id`"
msgstr ""

#: src/monad-transformers/transformers.md:491
msgid ""
"The identity monad `Id` is the monad that has no effects whatsoever, to be "
"used in contexts that expect a monad for some reason but where none is "
"actually necessary. Another use of `Id` is to serve as the bottom of a stack "
"of monad transformers. For instance, `StateT σ Id` works just like `State σ`."
msgstr ""

#: src/monad-transformers/transformers.md:498
msgid "Monad Contract"
msgstr ""

#: src/monad-transformers/transformers.md:500
msgid ""
"Using pencil and paper, check that the rules of the monad transformer "
"contract are satisfied for each monad transformer in this section."
msgstr ""

#: src/monad-transformers/transformers.md:502
msgid "Logging Transformer"
msgstr ""

#: src/monad-transformers/transformers.md:504
msgid ""
"Define a monad transformer version of `WithLog`. Also define the "
"corresponding type class `MonadWithLog`, and write a program that combines "
"logging and exceptions."
msgstr ""

#: src/monad-transformers/transformers.md:507
msgid "Counting Files"
msgstr ""

#: src/monad-transformers/transformers.md:509
msgid ""
"Modify `doug`'s monad with `StateT` such that it counts the number of "
"directories and files seen. At the end of execution, it should display a "
"report like:"
msgstr ""

#: src/monad-transformers/order.md:3
msgid ""
"When composing a monad from a stack of monad transformers, it's important to "
"be aware that the order in which the monad transformers are layered matters. "
"Different orderings of the same set of transformers result in different "
"monads."
msgstr ""

#: src/monad-transformers/order.md:6
msgid ""
"This version of `countLetters` is just like the previous version, except it "
"uses type classes to describe the set of available effects instead of "
"providing a concrete monad:"
msgstr ""

#: src/monad-transformers/order.md:24
msgid ""
"The state and exception monad transformers can be combined in two different "
"orders, each resulting in a monad that has instances of both type classes:"
msgstr ""

#: src/monad-transformers/order.md:30
msgid ""
"When run on input for which the program does not throw an exception, both "
"monads yield similar results:"
msgstr ""

#: src/monad-transformers/order.md:31
msgid ""
"```lean\n"
"#eval countLetters (m := M1) \"hello\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:37
msgid ""
"```lean\n"
"#eval countLetters (m := M2) \"hello\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:43
msgid ""
"However, there is a subtle difference between these return values. In the "
"case of `M1`, the outermost constructor is `Except.ok`, and it contains a "
"pair of the unit constructor with the final state. In the case of `M2`, the "
"outermost constructor is the pair, which contains `Except.ok` applied only "
"to the unit constructor. The final state is outside of `Except.ok`. In both "
"cases, the program returns the counts of vowels and consonants."
msgstr ""

#: src/monad-transformers/order.md:49
msgid ""
"On the other hand, only one monad yields a count of vowels and consonants "
"when the string causes an exception to be thrown. Using `M1`, only an "
"exception value is returned:"
msgstr ""

#: src/monad-transformers/order.md:51
msgid ""
"```lean\n"
"#eval countLetters (m := M1) \"hello!\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:57
msgid ""
"Using `M2`, the exception value is paired with the state as it was at the "
"time that the exception was thrown:"
msgstr ""

#: src/monad-transformers/order.md:58
msgid ""
"```lean\n"
"#eval countLetters (m := M2) \"hello!\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:65
msgid ""
"It might be tempting to think that `M2` is superior to `M1` because it "
"provides more information that might be useful when debugging. The same "
"program might compute _different_ answers in `M1` than it does in `M2`, and "
"there's no principled reason to say that one of these answers is necessarily "
"better than the other. This can be seen by adding a step to the program that "
"handles exceptions:"
msgstr ""

#: src/monad-transformers/order.md:68
msgid ""
"```lean\n"
"def countWithFallback\n"
"    [Monad m] [MonadState LetterCounts m] [MonadExcept Err m]\n"
"    (str : String) : m Unit :=\n"
"  try\n"
"    countLetters str\n"
"  catch _ =>\n"
"    countLetters \"Fallback\"\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:77
msgid ""
"This program always succeeds, but it might succeed with different results. "
"If no exception is thrown, then the results are the same as `countLetters`:"
msgstr ""

#: src/monad-transformers/order.md:79
msgid ""
"```lean\n"
"#eval countWithFallback (m := M1) \"hello\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:85
msgid ""
"```lean\n"
"#eval countWithFallback (m := M2) \"hello\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:91
msgid ""
"However, if the exception is thrown and caught, then the final states are "
"very different. With `M1`, the final state contains only the letter counts "
"from `\"Fallback\"`:"
msgstr ""

#: src/monad-transformers/order.md:93
msgid ""
"```lean\n"
"#eval countWithFallback (m := M1) \"hello!\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:99
msgid ""
"With `M2`, the final state contains letter counts from both `\"hello\"` and "
"from `\"Fallback\"`, as one would expect in an imperative language:"
msgstr ""

#: src/monad-transformers/order.md:100
msgid ""
"```lean\n"
"#eval countWithFallback (m := M2) \"hello!\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:107
msgid ""
"In `M1`, throwing an exception \"rolls back\" the state to where the "
"exception was caught. In `M2`, modifications to the state persist across the "
"throwing and catching of exceptions. This difference can be seen by "
"unfolding the definitions of `M1` and `M2`. `M1 α` unfolds to `LetterCounts "
"→ Except Err (α × LetterCounts)`, and `M2 α` unfolds to `LetterCounts → "
"Except Err α × LetterCounts`. That is to say, `M1 α` describes functions "
"that take an initial letter count, returning either an error or an `α` "
"paired with updated counts. When an exception is thrown in `M1`, there is no "
"final state. `M2 α` describes functions that take an initial letter count "
"and return a new letter count paired with either an error or an `α`. When an "
"exception is thrown in `M2`, it is accompanied by a state."
msgstr ""

#: src/monad-transformers/order.md:116
msgid "Commuting Monads"
msgstr ""

#: src/monad-transformers/order.md:118
msgid ""
"In the jargon of functional programming, two monad transformers are said to "
"_commute_ if they can be re-ordered without the meaning of the program "
"changing. The fact that the result of the program can differ when `StateT` "
"and `ExceptT` are reordered means that state and exceptions do not commute. "
"In general, monad transformers should not be expected to commute."
msgstr ""

#: src/monad-transformers/order.md:122
msgid ""
"Even though not all monad transformers commute, some do. For example, two "
"uses of `StateT` can be re-ordered. Expanding the definitions in `StateT σ "
"(StateT σ' Id) α` yields the type `σ → σ' → ((α × σ) × σ')`, and `StateT σ' "
"(StateT σ Id) α` yields `σ' → σ → ((α × σ') × σ)`. In other words, the "
"differences between them are that they nest the `σ` and `σ'` types in "
"different places in the return type, and they accept their arguments in a "
"different order. Any client code will still need to provide the same inputs, "
"and it will still receive the same outputs."
msgstr ""

#: src/monad-transformers/order.md:128
msgid ""
"Most programming languages that have both mutable state and exceptions work "
"like `M2`. In those languages, state that _should_ be rolled back when an "
"exception is thrown is difficult to express, and it usually needs to be "
"simulated in a manner that looks much like the passing of explicit state "
"values in `M1`. Monad transformers grant the freedom to choose an "
"interpretation of effect ordering that works for the problem at hand, with "
"both choices being equally easy to program with. However, they also require "
"care to be taken in the choice of ordering of transformers. With great "
"expressive power comes the responsibility to check that what's being "
"expressed is what is intended, and the type signature of `countWithFallback` "
"is probably more polymorphic than it should be."
msgstr ""

#: src/monad-transformers/order.md:137
msgid ""
"Check that `ReaderT` and `StateT` commute by expanding their definitions and "
"reasoning about the resulting types."
msgstr ""

#: src/monad-transformers/order.md:138
msgid ""
"Do `ReaderT` and `ExceptT` commute? Check your answer by expanding their "
"definitions and reasoning about the resulting types."
msgstr ""

#: src/monad-transformers/order.md:139
msgid ""
"Construct a monad transformer `ManyT` based on the definition of `Many`, "
"with a suitable `Alternative` instance. Check that it satisfies the `Monad` "
"contract."
msgstr ""

#: src/monad-transformers/order.md:140
msgid ""
"Does `ManyT` commute with `StateT`? If so, check your answer by expanding "
"definitions and reasoning about the resulting types. If not, write a program "
"in `ManyT (StateT σ Id)` and a program in `StateT σ (ManyT Id)`. Each "
"program should be one that makes more sense for the given ordering of monad "
"transformers."
msgstr ""

#: src/monad-transformers/do.md:1
msgid "More do Features"
msgstr ""

#: src/monad-transformers/do.md:3
msgid ""
"Lean's `do`\\-notation provides a syntax for writing programs with monads "
"that resembles imperative programming languages. In addition to providing a "
"convenient syntax for programs with monads, `do`\\-notation provides syntax "
"for using certain monad transformers."
msgstr ""

#: src/monad-transformers/do.md:6
msgid "Single-Branched `if`"
msgstr ""

#: src/monad-transformers/do.md:8
msgid ""
"When working in a monad, a common pattern is to carry out a side effect only "
"if some condition is true. For instance, `countLetters` contains a check for "
"vowels or consonants, and letters that are neither have no effect on the "
"state. This is captured by having the `else` branch evaluate to `pure ()`, "
"which has no effects:"
msgstr ""

#: src/monad-transformers/do.md:29
msgid ""
"When an `if` is a statement in a `do`\\-block, rather than being an "
"expression, then `else pure ()` can simply be omitted, and Lean inserts it "
"automatically. The following definition of `countLetters` is completely "
"equivalent:"
msgstr ""

#: src/monad-transformers/do.md:46
msgid ""
"A program that uses a state monad to count the entries in a list that "
"satisfy some monadic check can be written as follows:"
msgstr ""

#: src/monad-transformers/do.md:56
msgid ""
"Similarly, `if not E1 then STMT...` can instead be written `unless E1 do "
"STMT...`. The converse of `count` that counts entries that don't satisfy the "
"monadic check can be written by replacing `if` with `unless`:"
msgstr ""

#: src/monad-transformers/do.md:67
msgid ""
"Understanding single-branched `if` and `unless` does not require thinking "
"about monad transformers. They simply replace the missing branch with `pure "
"()`. The remaining extensions in this section, however, require Lean to "
"automatically rewrite the `do`\\-block to add a local transformer on top of "
"the monad that the `do`\\-block is written in."
msgstr ""

#: src/monad-transformers/do.md:71
msgid "Early Return"
msgstr ""

#: src/monad-transformers/do.md:73
msgid ""
"The standard library contains a function `List.find?` that returns the first "
"entry in a list that satisfies some check. A simple implementation that "
"doesn't make use of the fact that `Option` is a monad loops over the list "
"using a recursive function, with an `if` to stop the loop when the desired "
"entry is found:"
msgstr ""

#: src/monad-transformers/do.md:85
msgid ""
"Imperative languages typically sport the `return` keyword that aborts the "
"execution of a function, immediately returning some value to the caller. In "
"Lean, this is available in `do`\\-notation, and `return` halts the execution "
"of a `do`\\-block, with `return`'s argument being the value returned from "
"the monad. In other words, `List.find?` could have been written like this:"
msgstr ""

#: src/monad-transformers/do.md:96
msgid ""
"Early return in imperative languages is a bit like an exception that can "
"only cause the current stack frame to be unwound. Both early return and "
"exceptions terminate execution of a block of code, effectively replacing the "
"surrounding code with the thrown value. Behind the scenes, early return in "
"Lean is implemented using a version of `ExceptT`. Each `do`\\-block that "
"uses early return is wrapped in an exception handler (in the sense of the "
"function `tryCatch`). Early returns are translated to throwing the value as "
"an exception, and the handlers catch the thrown value and return it "
"immediately. In other words, the `do`\\-block's original return value type "
"is also used as the exception type."
msgstr ""

#: src/monad-transformers/do.md:103
msgid ""
"Making this more concrete, the helper function `runCatch` strips a layer of "
"`ExceptT` from the top of a monad transformer stack when the exception type "
"and return type are the same:"
msgstr ""

#: src/monad-transformers/do.md:110
msgid ""
"The `do`\\-block in `List.find?` that uses early return is translated to a "
"`do`\\-block that does not use early return by wrapping it in a use of "
"`runCatch`, and replacing early returns with `throw`:"
msgstr ""

#: src/monad-transformers/do.md:120
msgid ""
"Another situation in which early return is useful is command-line "
"applications that terminate early if the arguments or input are incorrect. "
"Many programs begin with a section that validates arguments and inputs "
"before proceeding to the main body of the program. The following version of "
"[the greeting program `hello-name`](../hello-world/running-a-program.md) "
"checks that no command-line arguments were provided:"
msgstr ""

#: src/monad-transformers/do.md:123
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  let stderr ← IO.getStderr\n"
"\n"
"  unless argv == [] do\n"
"    stderr.putStrLn s!\"Expected no arguments, but got {argv.length}\"\n"
"    return 1\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  stdout.flush\n"
"\n"
"  let name := (← stdin.getLine).trim\n"
"  if name == \"\" then\n"
"    stderr.putStrLn s!\"No name provided\"\n"
"    return 1\n"
"\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"\n"
"  return 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:145
msgid ""
"Running it with no arguments and typing the name `David` yields the same "
"result as the previous version:"
msgstr ""

#: src/monad-transformers/do.md:153
msgid ""
"Providing the name as a command-line argument instead of an answer causes an "
"error:"
msgstr ""

#: src/monad-transformers/do.md:159
msgid "And providing no name causes the other error:"
msgstr ""

#: src/monad-transformers/do.md:167
msgid ""
"The program that uses early return avoids needing to nest the control flow, "
"as is done in this version that does not use early return:"
msgstr ""

#: src/monad-transformers/do.md:168
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  let stderr ← IO.getStderr\n"
"\n"
"  if argv != [] then\n"
"    stderr.putStrLn s!\"Expected no arguments, but got {argv.length}\"\n"
"    pure 1\n"
"  else\n"
"    stdout.putStrLn \"How would you like to be addressed?\"\n"
"    stdout.flush\n"
"\n"
"    let name := (← stdin.getLine).trim\n"
"    if name == \"\" then\n"
"      stderr.putStrLn s!\"No name provided\"\n"
"      pure 1\n"
"    else\n"
"      stdout.putStrLn s!\"Hello, {name}!\"\n"
"      pure 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:190
msgid ""
"One important difference between early return in Lean and early return in "
"imperative languages is that Lean's early return applies only to the current "
"`do`\\-block. When the entire definition of a function is in the same `do` "
"block, this difference doesn't matter. But if `do` occurs underneath some "
"other structures, then the difference becomes apparent. For example, given "
"the following definition of `greet`:"
msgstr ""

#: src/monad-transformers/do.md:194
msgid ""
"```lean\n"
"def greet (name : String) : String :=\n"
"  \"Hello, \" ++ Id.run do return name\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:198
msgid ""
"the expression `greet \"David\"` evaluates to `\"Hello, David\"`, not just "
"`\"David\"`."
msgstr ""

#: src/monad-transformers/do.md:200
msgid "Loops"
msgstr ""

#: src/monad-transformers/do.md:202
msgid ""
"Just as every program with mutable state can be rewritten to a program that "
"passes the state as arguments, every loop can be rewritten as a recursive "
"function. From one perspective, `List.find?` is most clear as a recursive "
"function. After all, its definition mirrors the structure of the list: if "
"the head passes the check, then it should be returned; otherwise look in the "
"tail. When no more entries remain, the answer is `none`. From another "
"perspective, `List.find?` is most clear as a loop. After all, the program "
"consults the entries in order until a satisfactory one is found, at which "
"point it terminates. If the loop terminates without having returned, the "
"answer is `none`."
msgstr ""

#: src/monad-transformers/do.md:210
msgid "Looping with ForM"
msgstr ""

#: src/monad-transformers/do.md:212
msgid ""
"Lean includes a type class that describes looping over a container type in "
"some monad. This class is called `ForM`:"
msgstr ""

#: src/monad-transformers/do.md:218
msgid ""
"This class is quite general. The parameter `m` is a monad with some desired "
"effects, `γ` is the collection to be looped over, and `α` is the type of "
"elements from the collection. Typically, `m` is allowed to be any monad, but "
"it is possible to have a data structure that e.g. only supports looping in "
"`IO`. The method `forM` takes a collection, a monadic action to be run for "
"its effects on each element from the collection, and is then responsible for "
"running the actions."
msgstr ""

#: src/monad-transformers/do.md:223
msgid ""
"The instance for `List` allows `m` to be any monad, it sets `γ` to be `List "
"α`, and sets the class's `α` to be the same `α` found in the list:"
msgstr ""

#: src/monad-transformers/do.md:234
msgid ""
"The [function `doList` from `doug`](reader-io.md#implementation) is `forM` "
"for lists. Because `forM` is intended to be used in `do`\\-blocks, it uses "
"`Monad` rather than `Applicative`. `forM` can be used to make `countLetters` "
"much shorter:"
msgstr ""

#: src/monad-transformers/do.md:249
msgid "The instance for `Many` is very similar:"
msgstr ""

#: src/monad-transformers/do.md:261
msgid ""
"Because `γ` can be any type at all, `ForM` can support non-polymorphic "
"collections. A very simple collection is one of the natural numbers less "
"than some given number, in reverse order:"
msgstr ""

#: src/monad-transformers/do.md:267
msgid "Its `forM` operator applies the provided action to each smaller `Nat`:"
msgstr ""

#: src/monad-transformers/do.md:280
msgid ""
"Running `IO.println` on each number less than five can be accomplished with "
"`forM`:"
msgstr ""

#: src/monad-transformers/do.md:292
msgid ""
"An example `ForM` instance that works only in a particular monad is one that "
"loops over the lines read from an IO stream, such as standard input:"
msgstr ""

#: src/monad-transformers/do.md:293
msgid ""
"```lean\n"
"structure LinesOf where\n"
"  stream : IO.FS.Stream\n"
"\n"
"partial def LinesOf.forM (readFrom : LinesOf) (action : String → IO Unit) : "
"IO Unit := do\n"
"  let line ← readFrom.stream.getLine\n"
"  if line == \"\" then return ()\n"
"  action line\n"
"  forM readFrom action\n"
"\n"
"instance : ForM IO LinesOf String where\n"
"  forM := LinesOf.forM\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:306
msgid ""
"The definition of `forM` is marked `partial` because there is no guarantee "
"that the stream is finite. In this case, `IO.FS.Stream.getLine` works only "
"in the `IO` monad, so no other monad can be used for looping."
msgstr ""

#: src/monad-transformers/do.md:309
msgid ""
"This example program uses this looping construct to filter out lines that "
"don't contain letters:"
msgstr ""

#: src/monad-transformers/do.md:310
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  if argv != [] then\n"
"    IO.eprintln \"Unexpected arguments\"\n"
"    return 1\n"
"\n"
"  forM (LinesOf.mk (← IO.getStdin)) fun line => do\n"
"    if line.any (·.isAlpha) then\n"
"      IO.print line\n"
"\n"
"  return 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:322
msgid "The file `test-data` contains:"
msgstr ""

#: src/monad-transformers/do.md:331
msgid ""
"Invoking this program, which is stored in `ForMIO.lean`, yields the "
"following output:"
msgstr ""

#: src/monad-transformers/do.md:339
msgid "Stopping Iteration"
msgstr ""

#: src/monad-transformers/do.md:341
msgid ""
"Terminating a loop early is difficult to do with `forM`. Writing a function "
"that iterates over the `Nat`s in an `AllLessThan` only until `3` is reached "
"requires a means of stopping the loop partway through. One way to achieve "
"this is to use `forM` with the `OptionT` monad transformer. The first step "
"is to define `OptionT.exec`, which discards information about both the "
"return value and whether or not the transformed computation succeeded:"
msgstr ""

#: src/monad-transformers/do.md:349
msgid ""
"Then, failure in the `OptionT` instance of `Alternative` can be used to "
"terminate looping early:"
msgstr ""

#: src/monad-transformers/do.md:356
msgid "A quick test demonstrates that this solution works:"
msgstr ""

#: src/monad-transformers/do.md:367
msgid ""
"However, this code is not so easy to read. Terminating a loop early is a "
"common task, and Lean provides more syntactic sugar to make this easier. "
"This same function can also be written as follows:"
msgstr ""

#: src/monad-transformers/do.md:377
msgid "Testing it reveals that it works just like the prior version:"
msgstr ""

#: src/monad-transformers/do.md:388
msgid ""
"At the time of writing, the `for ... in ... do ...` syntax desugars to the "
"use of a type class called `ForIn`, which is a somewhat more complicated "
"version of `ForM` that keeps track of state and early termination. However, "
"there is a plan to refactor `for` loops to use the simpler `ForM`, with "
"monad transformers inserted as necessary. In the meantime, an adapter is "
"provided that converts a `ForM` instance into a `ForIn` instance, called "
"`ForM.forIn`. To enable `for` loops based on a `ForM` instance, add "
"something like the following, with appropriate replacements for "
"`AllLessThan` and `Nat`:"
msgstr ""

#: src/monad-transformers/do.md:396
msgid ""
"Note, however, that this adapter only works for `ForM` instances that keep "
"the monad unconstrained, as most of them do. This is because the adapter "
"uses `StateT` and `ExceptT`, rather than the underlying monad."
msgstr ""

#: src/monad-transformers/do.md:399
msgid ""
"Early return is supported in `for` loops. The translation of `do` blocks "
"with early return into a use of an exception monad transformer applies "
"equally well underneath `forM` as the earlier use of `OptionT` to halt "
"iteration does. This version of `List.find?` makes use of both:"
msgstr ""

#: src/monad-transformers/do.md:409
msgid ""
"In addition to `break`, `for` loops support `continue` to skip the rest of "
"the loop body in an iteration. An alternative (but confusing) formulation of "
"`List.find?` skips elements that don't satisfy the check:"
msgstr ""

#: src/monad-transformers/do.md:419
msgid ""
"A `Range` is a structure that consists of a starting number, an ending "
"number, and a step. They represent a sequence of natural numbers, from the "
"starting number to the ending number, increasing by the step each time. Lean "
"has special syntax to construct ranges, consisting of square brackets, "
"numbers, and colons that comes in four varieties. The stopping point must "
"always be provided, while the start and the step are optional, defaulting to "
"`0` and `1`, respectively:"
msgstr ""

#: src/monad-transformers/do.md:424
msgid "Start"
msgstr ""

#: src/monad-transformers/do.md:424
msgid "Stop"
msgstr ""

#: src/monad-transformers/do.md:424
msgid "Step"
msgstr ""

#: src/monad-transformers/do.md:424
msgid "As List"
msgstr ""

#: src/monad-transformers/do.md:426
msgid "`[:10]`"
msgstr ""

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:428
msgid "`0`"
msgstr ""

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:427
#: src/monad-transformers/do.md:428 src/monad-transformers/do.md:429
msgid "`10`"
msgstr ""

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:427
msgid "`1`"
msgstr ""

#: src/monad-transformers/do.md:426
msgid "`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`"
msgstr ""

#: src/monad-transformers/do.md:427
msgid "`[2:10]`"
msgstr ""

#: src/monad-transformers/do.md:427 src/monad-transformers/do.md:429
msgid "`2`"
msgstr ""

#: src/monad-transformers/do.md:427
msgid "`[2, 3, 4, 5, 6, 7, 8, 9]`"
msgstr ""

#: src/monad-transformers/do.md:428
msgid "`[:10:3]`"
msgstr ""

#: src/monad-transformers/do.md:428 src/monad-transformers/do.md:429
msgid "`3`"
msgstr ""

#: src/monad-transformers/do.md:428
msgid "`[0, 3, 6, 9]`"
msgstr ""

#: src/monad-transformers/do.md:429
msgid "`[2:10:3]`"
msgstr ""

#: src/monad-transformers/do.md:429
msgid "`[2, 5, 8]`"
msgstr ""

#: src/monad-transformers/do.md:431
msgid ""
"Note that the starting number _is_ included in the range, while the stopping "
"numbers is not. All three arguments are `Nat`s, which means that ranges "
"cannot count down—a range where the starting number is greater than or equal "
"to the stopping number simply contains no numbers."
msgstr ""

#: src/monad-transformers/do.md:434
msgid ""
"Ranges can be used with `for` loops to draw numbers from the range. This "
"program counts even numbers from four to eight:"
msgstr ""

#: src/monad-transformers/do.md:441
msgid "Running it yields:"
msgstr ""

#: src/monad-transformers/do.md:449
msgid ""
"Finally, `for` loops support iterating over multiple collections in "
"parallel, by separating the `in` clauses with commas. Looping halts when the "
"first collection runs out of elements, so the declaration:"
msgstr ""

#: src/monad-transformers/do.md:451
msgid ""
"```lean\n"
"def parallelLoop := do\n"
"  for x in [\"currant\", \"gooseberry\", \"rowan\"], y in [4:8] do\n"
"    IO.println (x, y)\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:456
msgid "produces three lines of output:"
msgstr ""

#: src/monad-transformers/do.md:466
msgid "Mutable Variables"
msgstr ""

#: src/monad-transformers/do.md:468
msgid ""
"In addition to early `return`, `else`\\-less `if`, and `for` loops, Lean "
"supports local mutable variables within a `do` block. Behind the scenes, "
"these mutable variables desugar to a use of `StateT`, rather than being "
"implemented by true mutable variables. Once again, functional programming is "
"used to simulate imperative programming."
msgstr ""

#: src/monad-transformers/do.md:472
msgid ""
"A local mutable variable is introduced with `let mut` instead of plain "
"`let`. The definition `two`, which uses the identity monad `Id` to enable "
"`do`\\-syntax without introducing any effects, counts to `2`:"
msgstr ""

#: src/monad-transformers/do.md:481
msgid ""
"This code is equivalent to a definition that uses `StateT` to add `1` twice:"
msgstr ""

#: src/monad-transformers/do.md:492
msgid ""
"Local mutable variables work well with all the other features of "
"`do`\\-notation that provide convenient syntax for monad transformers. The "
"definition `three` counts the number of entries in a three-entry list:"
msgstr ""

#: src/monad-transformers/do.md:501
msgid "Similarly, `six` adds the entries in a list:"
msgstr ""

#: src/monad-transformers/do.md:510
msgid ""
"`List.count` counts the number of entries in a list that satisfy some check:"
msgstr ""

#: src/monad-transformers/do.md:519
msgid ""
"Local mutable variables can be more convenient to use and easier to read "
"than an explicit local use of `StateT`. However, they don't have the full "
"power of unrestricted mutable variables from imperative languages. In "
"particular, they can only be modified in the `do`\\-block in which they are "
"introduced. This means, for instance, that `for`\\-loops can't be replaced "
"by otherwise-equivalent recursive helper functions. This version of "
"`List.count`:"
msgstr ""

#: src/monad-transformers/do.md:534
msgid "yields the following error on the attempted mutation of `found`:"
msgstr ""

#: src/monad-transformers/do.md:538
msgid ""
"This is because the recursive function is written in the identity monad, and "
"only the monad of the `do`\\-block in which the variable is introduced is "
"transformed with `StateT`."
msgstr ""

#: src/monad-transformers/do.md:540
msgid "What counts as a `do` block?"
msgstr ""

#: src/monad-transformers/do.md:542
msgid ""
"Many features of `do`\\-notation apply only to a single `do`\\-block. Early "
"return terminates the current block, and mutable variables can only be "
"mutated in the block that they are defined in. To use them effectively, it's "
"important to know what counts as \"the same block\"."
msgstr ""

#: src/monad-transformers/do.md:546
msgid ""
"Generally speaking, the indented block following the `do` keyword counts as "
"a block, and the immediate sequence of statements underneath it are part of "
"that block. Statements in independent blocks that are nonetheless contained "
"in a block are not considered part of the block. However, the rules that "
"govern what exactly counts as the same block are slightly subtle, so some "
"examples are in order. The precise nature of the rules can be tested by "
"setting up a program with a mutable variable and seeing where the mutation "
"is allowed. This program has a mutation that is clearly in the same block as "
"the mutable variable:"
msgstr ""

#: src/monad-transformers/do.md:557
msgid ""
"When a mutation occurs in a `do`\\-block that is part of a `let`\\-statement "
"that defines a name using `:=`, then it is not considered to be part of the "
"block:"
msgstr ""

#: src/monad-transformers/do.md:568
msgid ""
"However, a `do`\\-block that occurs under a `let`\\-statement that defines a "
"name using `←` is considered part of the surrounding block. The following "
"program is accepted:"
msgstr ""

#: src/monad-transformers/do.md:578
msgid ""
"Similarly, `do`\\-blocks that occur as arguments to functions are "
"independent of their surrounding blocks. The following program is not "
"accepted:"
msgstr ""

#: src/monad-transformers/do.md:591
msgid ""
"If the `do` keyword is completely redundant, then it does not introduce a "
"new block. This program is accepted, and is equivalent to the first one in "
"this section:"
msgstr ""

#: src/monad-transformers/do.md:599
msgid ""
"The contents of branches under a `do` (such as those introduced by `match` "
"or `if`) are considered to be part of the surrounding block, whether or not "
"a redundant `do` is added. The following programs are all accepted:"
msgstr ""

#: src/monad-transformers/do.md:626
msgid ""
"Similarly, the `do` that occurs as part of the `for` and `unless` syntax is "
"just part of their syntax, and does not introduce a fresh `do`\\-block. "
"These programs are also accepted:"
msgstr ""

#: src/monad-transformers/do.md:641
msgid "Imperative or Functional Programming?"
msgstr ""

#: src/monad-transformers/do.md:643
msgid ""
"The imperative features provided by Lean's `do`\\-notation allow many "
"programs to very closely resemble their counterparts in languages like Rust, "
"Java, or C#. This resemblance is very convenient when translating an "
"imperative algorithm into Lean, and some tasks are just most naturally "
"thought of imperatively. The introduction of monads and monad transformers "
"enables imperative programs to be written in purely functional languages, "
"and `do`\\-notation as a specialized syntax for monads (potentially locally "
"transformed) allows functional programmers to have the best of both worlds: "
"the strong reasoning principles afforded by immutability and a tight control "
"over available effects through the type system are combined with syntax and "
"libraries that allow programs that use effects to look familiar and be easy "
"to read. Monads and monad transformers allow functional versus imperative "
"programming to be a matter of perspective."
msgstr ""

#: src/monad-transformers/do.md:651
msgid ""
"Rewrite `doug` to use `for` instead of the `doList` function. Are there "
"other opportunities to use the features introduced in this section to "
"improve the code? If so, use them!"
msgstr ""

#: src/monad-transformers/conveniences.md:3
msgid "Pipe Operators"
msgstr ""

#: src/monad-transformers/conveniences.md:5
msgid ""
"Functions are normally written before their arguments. When reading a "
"program from left to right, this promotes a view in which the function's "
"_output_ is paramount—the function has a goal to achieve (that is, a value "
"to compute), and it receives arguments to support it in this process. But "
"some programs are easier to understand in terms of an input that is "
"successively refined to produce the output. For these situations, Lean "
"provides a _pipeline_ operator which is similar to the that provided by F#. "
"Pipeline operators are useful in the same situations as Clojure's threading "
"macros."
msgstr ""

#: src/monad-transformers/conveniences.md:11
msgid "The pipeline `E1 |> E2` is short for `E2 E1`. For example, evaluating:"
msgstr ""

#: src/monad-transformers/conveniences.md:17
msgid ""
"```output info\n"
"\"(some 5)\"\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:20
msgid ""
"While this change of emphasis can make some programs more convenient to "
"read, pipelines really come into their own when they contain many components."
msgstr ""

#: src/monad-transformers/conveniences.md:22
msgid "With the definition:"
msgstr ""

#: src/monad-transformers/conveniences.md:26
msgid "the following pipeline:"
msgstr ""

#: src/monad-transformers/conveniences.md:27
msgid ""
"```lean\n"
"#eval 5 |> times3 |> toString |> (\"It is \" ++ ·)\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:30
msgid "yields:"
msgstr ""

#: src/monad-transformers/conveniences.md:31
msgid ""
"```output info\n"
"\"It is 15\"\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:34
msgid ""
"More generally, a series of pipelines `E1 |> E2 |> E3 |> E4` is short for "
"nested function applications `E4 (E3 (E2 E1))`."
msgstr ""

#: src/monad-transformers/conveniences.md:36
msgid ""
"Pipelines may also be written in reverse. In this case, they do not place "
"the subject of data transformation first; however, in cases where many "
"nested parentheses pose a challenge for readers, they can clarify the steps "
"of application. The prior example could be equivalently written as:"
msgstr ""

#: src/monad-transformers/conveniences.md:39
msgid ""
"```lean\n"
"#eval (\"It is \" ++ ·) <| toString <| times3 <| 5\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:42
msgid "which is short for:"
msgstr ""

#: src/monad-transformers/conveniences.md:43
msgid ""
"```lean\n"
"#eval (\"It is \" ++ ·) (toString (times3 5))\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:47
msgid ""
"Lean's method dot notation that uses the name of the type before the dot to "
"resolve the namespace of the operator after the dot serves a similar purpose "
"to pipelines. Even without the pipeline operator, it is possible to write "
"`[1, 2, 3].reverse` instead of `List.reverse [1, 2, 3]`. However, the "
"pipeline operator is also useful for dotted functions when using many of "
"them. `([1, 2, 3].reverse.drop 1).reverse` can also be written as `[1, 2, 3] "
"|> List.reverse |> List.drop 1 |> List.reverse`. This version avoids having "
"to parenthesize expressions simply because they accept arguments, and it "
"recovers the convenience of a chain of method calls in languages like Kotlin "
"or C#. However, it still requires the namespace to be provided by hand. As a "
"final convenience, Lean provides the \"pipeline dot\" operator, which groups "
"functions like the pipeline but uses the name of the type to resolve "
"namespaces. With \"pipeline dot\", the example can be rewritten to `[1, 2, "
"3] |>.reverse |>.drop 1 |>.reverse`."
msgstr ""

#: src/monad-transformers/conveniences.md:56
msgid "Infinite Loops"
msgstr ""

#: src/monad-transformers/conveniences.md:58
msgid ""
"Within a `do`\\-block, the `repeat` keyword introduces an infinite loop. For "
"example, a program that spams the string `\"Spam!\"` can use it:"
msgstr ""

#: src/monad-transformers/conveniences.md:60
msgid ""
"```lean\n"
"def spam : IO Unit := do\n"
"  repeat IO.println \"Spam!\"\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:64
msgid "A `repeat` loop supports `break` and `continue`, just like `for` loops."
msgstr ""

#: src/monad-transformers/conveniences.md:66
msgid ""
"The `dump` function from the [implementation of "
"`feline`](../hello-world/cat.md#streams) uses a recursive function to run "
"forever:"
msgstr ""

#: src/monad-transformers/conveniences.md:77
msgid "This function can be greatly shortened using `repeat`:"
msgstr ""

#: src/monad-transformers/conveniences.md:87
msgid ""
"Neither `spam` nor `dump` need to be declared as `partial` because they are "
"not themselves infinitely recursive. Instead, `repeat` makes use of a type "
"whose `ForM` instance is `partial`. Partiality does not \"infect\" calling "
"functions."
msgstr ""

#: src/monad-transformers/conveniences.md:91
msgid "While Loops"
msgstr ""

#: src/monad-transformers/conveniences.md:93
msgid ""
"When programming with local mutability, `while` loops can be a convenient "
"alternative to `repeat` with an `if`\\-guarded `break`:"
msgstr ""

#: src/monad-transformers/conveniences.md:102
msgid "Behind the scenes, `while` is just a simpler notation for `repeat`."
msgstr ""

#: src/monad-transformers/summary.md:3
msgid "Combining Monads"
msgstr ""

#: src/monad-transformers/summary.md:5
msgid ""
"When writing a monad from scratch, there are design patterns that tend to "
"describe the ways that each effect is added to the monad. Reader effects are "
"added by having the monad's type be a function from the reader's "
"environment, state effects are added by including a function from the "
"initial state to the value paired with the final state, failure or "
"exceptions are added by including a sum type in the return type, and logging "
"or other output is added by including a product type in the return type. "
"Existing monads can be made part of the return type as well, allowing their "
"effects to be included in the new monad."
msgstr ""

#: src/monad-transformers/summary.md:9
msgid ""
"These design patterns are made into a library of reusable software "
"components by defining _monad transformers_, which add an effect to some "
"base monad. Monad transformers take the simpler monad types as arguments, "
"returning the enhanced monad types. At a minimum, a monad transformer should "
"provide the following instances:"
msgstr ""

#: src/monad-transformers/summary.md:13
msgid ""
"A `MonadLift` instance to translate an action from the inner monad to the "
"transformed monad"
msgstr ""

#: src/monad-transformers/summary.md:15
msgid ""
"Monad transformers may be implemented as polymorphic structures or inductive "
"datatypes, but they are most often implemented as functions from the "
"underlying monad type to the enhanced monad type."
msgstr ""

#: src/monad-transformers/summary.md:17
msgid "Type Classes for Effects"
msgstr ""

#: src/monad-transformers/summary.md:19
msgid ""
"A common design pattern is to implement a particular effect by defining a "
"monad that has the effect, a monad transformer that adds it to another "
"monad, and a type class that provides a generic interface to the effect. "
"This allows programs to be written that merely specify which effects they "
"need, so the caller can provide any monad that has the right effects."
msgstr ""

#: src/monad-transformers/summary.md:22
msgid ""
"Sometimes, auxiliary type information (e.g. the state's type in a monad that "
"provides state, or the exception's type in a monad that provides exceptions) "
"is an output parameter, and sometimes it is not. The output parameter is "
"most useful for simple programs that use each kind of effect only once, but "
"it risks having the type checker commit to a the wrong type too early when "
"multiple instances of the same effect are used in a given program. Thus, "
"both versions are typically provided, with the ordinary-parameter version of "
"the type class having a name that ends in `-Of`."
msgstr ""

#: src/monad-transformers/summary.md:26
msgid "Monad Transformers Don't Commute"
msgstr ""

#: src/monad-transformers/summary.md:28
msgid ""
"It is important to note that changing the order of transformers in a monad "
"can change the meaning of programs that use the monad. For instance, "
"re-ordering `StateT` and `ExceptT` can result either in programs that lose "
"state modifications when exceptions are thrown or programs that keep "
"changes. While most imperative languages provide only the latter, the "
"increased flexibility provided by monad transformers demands thought and "
"attention to choose the correct variety for the task at hand."
msgstr ""

#: src/monad-transformers/summary.md:32
msgid "`do`\\-Notation for Monad Transformers"
msgstr ""

#: src/monad-transformers/summary.md:34
msgid ""
"Lean's `do`\\-blocks support early return, in which the block is terminated "
"with some value, locally mutable variables, `for`\\-loops with `break` and "
"`continue`, and single-branched `if`\\-statements. While this may seem to be "
"introducing imperative features that would get in the way of using Lean to "
"write proofs, it is in fact nothing more than a more convenient syntax for "
"certain common uses of monad transformers. Behind the scenes, whatever monad "
"the `do`\\-block is written in is transformed by appropriate uses of "
"`ExceptT` and `StateT` to support these additional effects."
msgstr ""

#: src/dependent-types.md:3
msgid ""
"In most statically-typed programming languages, there is a hermetic seal "
"between the world of types and the world of programs. Types and programs "
"have different grammars and they are used at different times. Types are "
"typically used at compile time, to check that a program obeys certain "
"invariants. Programs are used at run time, to actually perform computations. "
"When the two interact, it is usually in the form of a type-case operator "
"like an \"instance-of\" check or a casting operator that provides the type "
"checker with information that was otherwise unavailable, to be verified at "
"run time. In other words, the interaction consists of types being inserted "
"into the world of programs, gaining some limited run-time meaning."
msgstr ""

#: src/dependent-types.md:10
msgid ""
"Lean does not impose this strict separation. In Lean, programs may compute "
"types and types may contain programs. Placing programs in types allows their "
"full computation power to be used at compile time, and the ability to return "
"types from functions makes types into first-class participants in the "
"programming process."
msgstr ""

#: src/dependent-types.md:14
msgid ""
"_Dependent types_ are types that contain non-type expressions. A common "
"source of dependent types is a named argument to a function. For example, "
"the function `natOrStringThree` returns either a natural number or a string, "
"depending on which `Bool` it is passed:"
msgstr ""

#: src/dependent-types.md:17
msgid ""
"```lean\n"
"def natOrStringThree (b : Bool) : if b then Nat else String :=\n"
"  match b with\n"
"  | true => (3 : Nat)\n"
"  | false => \"three\"\n"
"```"
msgstr ""

#: src/dependent-types.md:24
msgid "Further examples of dependent types include:"
msgstr ""

#: src/dependent-types.md:25
msgid ""
"[The introductory section on polymorphism](getting-to-know/polymorphism.md) "
"contains `posOrNegThree`, in which the function's return type depends on the "
"value of the argument."
msgstr ""

#: src/dependent-types.md:26
msgid ""
"[The `OfNat` type class](type-classes/pos.md#literal-numbers) depends on the "
"specific natural number literal being used."
msgstr ""

#: src/dependent-types.md:27
msgid ""
"[The `CheckedInput` "
"structure](functor-applicative-monad/applicative.md#validated-input) used in "
"the example of validators depends on the year in which validation occurred."
msgstr ""

#: src/dependent-types.md:28
msgid ""
"[Subtypes](functor-applicative-monad/applicative.md#subtypes) contain "
"propositions that refer to particular values."
msgstr ""

#: src/dependent-types.md:29
msgid ""
"Essentially all interesting propositions, including those that determine the "
"validity of [array indexing notation](props-proofs-indexing.md), are types "
"that contain values and are thus dependent types."
msgstr ""

#: src/dependent-types.md:31
msgid ""
"Dependent types vastly increase the power of a type system. The flexibility "
"of return types that branch on argument values enables programs to be "
"written that cannot easily be given types in other type systems. At the same "
"time, dependent types allow a type signature to restrict which values may be "
"returned from a function, enabling strong invariants to be enforced at "
"compile time."
msgstr ""

#: src/dependent-types.md:35
msgid ""
"However, programming with dependent types can be quite complex, and it "
"requires a whole set of skills above and beyond functional programming. "
"Expressive specifications can be complicated to fulfill, and there is a real "
"risk of tying oneself in knots and being unable to complete the program. On "
"the other hand, this process can lead to new understanding, which can be "
"expressed in a refined type that can be fulfilled. While this chapter "
"scratches the surface of dependently typed programming, it is a deep topic "
"that deserves an entire book of its own."
msgstr ""

#: src/dependent-types/indexed-families.md:3
msgid ""
"Polymorphic inductive types take type arguments. For instance, `List` takes "
"an argument that determines the type of the entries in the list, and "
"`Except` takes arguments that determine the types of the exceptions or "
"values. These type arguments, which are the same in every constructor of the "
"datatype, are referred to as _parameters_."
msgstr ""

#: src/dependent-types/indexed-families.md:7
msgid ""
"Arguments to inductive types need not be the same in every constructor, "
"however. Inductive types in which the arguments to the type vary based on "
"the choice of constructor are called _indexed families_, and the arguments "
"that vary are referred to as _indices_. The \"hello world\" of indexed "
"families is a type of lists that contains the length of the list in addition "
"to the type of entries, conventionally referred to as \"vectors\":"
msgstr ""

#: src/dependent-types/indexed-families.md:16
msgid ""
"Function declarations may take some arguments before the colon, indicating "
"that they are available in the entire definition, and some arguments after, "
"indicating a desire to pattern-match on them and define the function case by "
"case. Inductive datatypes have a similar principle: the argument `α` is "
"named at the top of the datatype declaration, prior to the colon, which "
"indicates that it is a parameter that must be provided as the first argument "
"in all occurrences of `Vect` in the definition, while the `Nat` argument "
"occurs after the colon, indicating that it is an index that may vary. "
"Indeed, the three occurrences of `Vect` in the `nil` and `cons` constructor "
"declarations consistently provide `α` as the first argument, while the "
"second argument is different in each case."
msgstr ""

#: src/dependent-types/indexed-families.md:20
msgid ""
"The declaration of `nil` states that it is a constructor of type `Vect α 0`. "
"This means that using `Vect.nil` in a context expecting a `Vect String 3` is "
"a type error, just as `[1, 2, 3]` is a type error in a context that expects "
"a `List String`:"
msgstr ""

#: src/dependent-types/indexed-families.md:33
msgid ""
"The mismatch between `0` and `3` in this example plays exactly the same role "
"as any other type mismatch, even though `0` and `3` are not themselves types."
msgstr ""

#: src/dependent-types/indexed-families.md:35
msgid ""
"Indexed families are called _families_ of types because different index "
"values can make different constructors available for use. In some sense, an "
"indexed family is not a type; rather, it is a collection of related types, "
"and the choice of index values also chooses a type from the collection. "
"Choosing the index `5` for `Vect` means that only the constructor `cons` is "
"available, and choosing the index `0` means that only `nil` is available."
msgstr ""

#: src/dependent-types/indexed-families.md:39
msgid ""
"If the index is not yet known (e.g. because it is a variable), then no "
"constructor can be used until it becomes known. Using `n` for the length "
"allows neither `Vect.nil` nor `Vect.cons`, because there's no way to know "
"whether the variable `n` should stand for a `Nat` that matches `0` or `n + "
"1`:"
msgstr ""

#: src/dependent-types/indexed-families.md:52
msgid ""
"```lean\n"
"example : Vect String n := Vect.cons \"Hello\" (Vect.cons \"world\" "
"Vect.nil)\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:55
msgid ""
"```output error\n"
"type mismatch\n"
"  Vect.cons \"Hello\" (Vect.cons \"world\" Vect.nil)\n"
"has type\n"
"  Vect String (0 + 1 + 1) : Type\n"
"but is expected to have type\n"
"  Vect String n : Type\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:64
msgid ""
"Having the length of the list as part of its type means that the type "
"becomes more informative. For example, `Vect.replicate` is a function that "
"creates a `Vect` with a number of copies of a given value. The type that "
"says this precisely is:"
msgstr ""

#: src/dependent-types/indexed-families.md:70
msgid ""
"The argument `n` appears as the length of the result. The message associated "
"with the underscore placeholder describes the task at hand:"
msgstr ""

#: src/dependent-types/indexed-families.md:81
msgid ""
"When working with indexed families, constructors can only be applied when "
"Lean can see that the constructor's index matches the index in the expected "
"type. However, neither constructor has an index that matches `n`—`nil` "
"matches `Nat.zero`, and `cons` matches `Nat.succ`. Just as in the example "
"type errors, the variable `n` could stand for either, depending on which "
"`Nat` is provided to the function as an argument. The solution is to use "
"pattern matching to consider both of the possible cases:"
msgstr ""

#: src/dependent-types/indexed-families.md:91
msgid ""
"Because `n` occurs in the expected type, pattern matching on `n` _refines_ "
"the expected type in the two cases of the match. In the first underscore, "
"the expected type has become `Vect α 0`:"
msgstr ""

#: src/dependent-types/indexed-families.md:101
msgid "In the second underscore, it has become `Vect α (k + 1)`:"
msgstr ""

#: src/dependent-types/indexed-families.md:111
msgid ""
"When pattern matching refines the type of a program in addition to "
"discovering the structure of a value, it is called _dependent pattern "
"matching_."
msgstr ""

#: src/dependent-types/indexed-families.md:113
msgid ""
"The refined type makes it possible to apply the constructors. The first "
"underscore matches `Vect.nil`, and the second matches `Vect.cons`: "
msgstr ""

#: src/dependent-types/indexed-families.md:121
msgid ""
"The first underscore under the `.cons` should have type `α`. There is an `α` "
"available, namely `x`:"
msgstr ""

#: src/dependent-types/indexed-families.md:132
msgid ""
"The second underscore should be a `Vect α k`, which can be produced by a "
"recursive call to `replicate`:"
msgstr ""

#: src/dependent-types/indexed-families.md:142
msgid "Here is the final definition of `replicate`:"
msgstr ""

#: src/dependent-types/indexed-families.md:150
msgid ""
"In addition to providing assistance while writing the function, the "
"informative type of `Vect.replicate` also allows client code to rule out a "
"number of unexpected functions without having to read the source code. A "
"version of `replicate` for lists could produce a list of the wrong length:"
msgstr ""

#: src/dependent-types/indexed-families.md:158
msgid "However, making this mistake with `Vect.replicate` is a type error:"
msgstr ""

#: src/dependent-types/indexed-families.md:177
msgid ""
"The function `List.zip` combines two lists by pairing the first entry in the "
"first list with the first entry in the second list, the second entry in the "
"first list with the second entry in the second list, and so forth. "
"`List.zip` can be used to pair the three highest peaks in the US state of "
"Oregon with the three highest peaks in Denmark:"
msgstr ""

#: src/dependent-types/indexed-families.md:179
msgid ""
"```lean\n"
"[\"Mount Hood\",\n"
" \"Mount Jefferson\",\n"
" \"South Sister\"].zip [\"Møllehøj\", \"Yding Skovhøj\", \"Ejer Bavnehøj\"]\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:184
msgid "The result is a list of three pairs:"
msgstr ""

#: src/dependent-types/indexed-families.md:185
msgid ""
"```lean\n"
"[(\"Mount Hood\", \"Møllehøj\"),\n"
" (\"Mount Jefferson\", \"Yding Skovhøj\"),\n"
" (\"South Sister\", \"Ejer Bavnehøj\")]\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:190
msgid ""
"It's somewhat unclear what should happen when the lists have different "
"lengths. Like many languages, Lean chooses to ignore the extra entries in "
"one of the lists. For instance, combining the heights of the five highest "
"peaks in Oregon with those of the three highest peaks in Denmark yields "
"three pairs. In particular,"
msgstr ""

#: src/dependent-types/indexed-families.md:202
msgid ""
"While this approach is convenient because it always returns an answer, it "
"runs the risk of throwing away data when the lists unintentionally have "
"different lengths. F# takes a different approach: its version of `List.zip` "
"throws an exception when the lengths don't match, as can be seen in this "
"`fsi` session:"
msgstr ""

#: src/dependent-types/indexed-families.md:217
msgid ""
"This avoids accidentally discarding information, but crashing a program "
"comes with its own difficulties. The Lean equivalent, which would use the "
"`Option` or `Except` monads, would introduce a burden that may not be worth "
"the safety."
msgstr ""

#: src/dependent-types/indexed-families.md:220
msgid ""
"Using `Vect`, however, it is possible to write a version of `zip` with a "
"type that requires that both arguments have the same length:"
msgstr ""

#: src/dependent-types/indexed-families.md:226
msgid ""
"This definition only has patterns for the cases where either both arguments "
"are `Vect.nil` or both arguments are `Vect.cons`, and Lean accepts the "
"definition without a \"missing cases\" error like the one that results from "
"a similar definition for `List`:"
msgstr ""

#: src/dependent-types/indexed-families.md:237
msgid ""
"This is because the constructor used in the first pattern, `nil` or `cons`, "
"_refines_ the type checker's knowledge about the length `n`. When the first "
"pattern is `nil`, the type checker can additionally determine that the "
"length was `0`, so the only possible choice for the second pattern is `nil`. "
"Similarly, when the first pattern is `cons`, the type checker can determine "
"that the length was `k+1` for some `Nat` `k`, so the only possible choice "
"for the second pattern is `cons`. Indeed, adding a case that uses `nil` and "
"`cons` together is a type error, because the lengths don't match:"
msgstr ""

#: src/dependent-types/indexed-families.md:255
msgid ""
"The refinement of the length can be observed by making `n` into an explicit "
"argument:"
msgstr ""

#: src/dependent-types/indexed-families.md:264
msgid ""
"Getting a feel for programming with dependent types requires experience, and "
"the exercises in this section are very important. For each exercise, try to "
"see which mistakes the type checker can catch, and which ones it can't, by "
"experimenting with the code as you go. This is also a good way to develop a "
"feel for the error messages."
msgstr ""

#: src/dependent-types/indexed-families.md:268
msgid ""
"Double-check that `Vect.zip` gives the right answer when combining the three "
"highest peaks in Oregon with the three highest peaks in Denmark. Because "
"`Vect` doesn't have the syntactic sugar that `List` has, it can be helpful "
"to begin by defining `oregonianPeaks : Vect String 3` and `danishPeaks : "
"Vect String 3`."
msgstr ""

#: src/dependent-types/indexed-families.md:271
msgid "Define a function `Vect.map` with type `(α → β) → Vect α n → Vect β n`."
msgstr ""

#: src/dependent-types/indexed-families.md:273
msgid ""
"Define a function `Vect.zipWith` that combines the entries in a `Vect` one "
"at a time with a function. It should have the type `(α → β → γ) → Vect α n → "
"Vect β n → Vect γ n`."
msgstr ""

#: src/dependent-types/indexed-families.md:276
msgid ""
"Define a function `Vect.unzip` that splits a `Vect` of pairs into a pair of "
"`Vect`s. It should have the type `Vect (α × β) n → Vect α n × Vect β n`."
msgstr ""

#: src/dependent-types/indexed-families.md:278
msgid ""
"Define a function `Vect.snoc` that adds an entry to the _end_ of a `Vect`. "
"Its type should be `Vect α n → α → Vect α (n + 1)` and `#eval Vect.snoc "
"(.cons \"snowy\" .nil) \"peaks\"` should yield `Vect.cons \"snowy\" "
"(Vect.cons \"peaks\" (Vect.nil))`. The name `snoc` is a traditional "
"functional programming pun: it is `cons` backwards."
msgstr ""

#: src/dependent-types/indexed-families.md:280
msgid "Define a function `Vect.reverse` that reverses the order of a `Vect`."
msgstr ""

#: src/dependent-types/indexed-families.md:282
msgid ""
"Define a function `Vect.drop` with the following type: `(n : Nat) → Vect α "
"(k + n) → Vect α k`. Verify that it works by checking that `#eval "
"danishPeaks.drop 2` yields `Vect.cons \"Ejer Bavnehøj\" (Vect.nil)`."
msgstr ""

#: src/dependent-types/indexed-families.md:285
msgid ""
"Define a function `Vect.take` with type `(n : Nat) → Vect α (k + n) → Vect α "
"n` that returns the first `n` entries in the `Vect`. Check that it works on "
"an example."
msgstr ""

#: src/dependent-types/universe-pattern.md:3
msgid ""
"In Lean, types such as `Type`, `Type 3`, and `Prop` that classify other "
"types are known as universes. However, the term _universe_ is also used for "
"a design pattern in which a datatype is used to represent a subset of Lean's "
"types, and a function converts the datatype's constructors into actual "
"types. The values of this datatype are called _codes_ for their types."
msgstr ""

#: src/dependent-types/universe-pattern.md:7
msgid ""
"Just like Lean's built-in universes, the universes implemented with this "
"pattern are types that describe some collection of available types, even "
"though the mechanism by which it is done is different. In Lean, there are "
"types such as `Type`, `Type 3`, and `Prop` that directly describe other "
"types. This arrangement is referred to as _universes à la Russell_. The "
"user-defined universes described in this section represent all of their "
"types as _data_, and include an explicit function to interpret these codes "
"into actual honest-to-goodness types. This arrangement is referred to as "
"_universes à la Tarski_. While languages such as Lean that are based on "
"dependent type theory almost always use Russell-style universes, "
"Tarski-style universes are a useful pattern for defining APIs in these "
"languages."
msgstr ""

#: src/dependent-types/universe-pattern.md:14
msgid ""
"Defining a custom universe makes it possible to carve out a closed "
"collection of types that can be used with an API. Because the collection of "
"types is closed, recursion over the codes allows programs to work for _any_ "
"type in the universe. One example of a custom universe has the codes `nat`, "
"standing for `Nat`, and `bool`, standing for `Bool`:"
msgstr ""

#: src/dependent-types/universe-pattern.md:26
msgid ""
"Pattern matching on a code allows the type to be refined, just as pattern "
"matching on the constructors of `Vect` allows the expected length to be "
"refined. For instance, a program that deserializes the types in this "
"universe from a string can be written as follows:"
msgstr ""

#: src/dependent-types/universe-pattern.md:28
msgid ""
"```lean\n"
"def decode (t : NatOrBool) (input : String) : Option t.asType :=\n"
"  match t with\n"
"  | .nat => input.toNat?\n"
"  | .bool =>\n"
"    match input with\n"
"    | \"true\" => some true\n"
"    | \"false\" => some false\n"
"    | _ => none\n"
"```"
msgstr ""

#: src/dependent-types/universe-pattern.md:38
msgid ""
"Dependent pattern matching on `t` allows the expected result type `t.asType` "
"to be respectively refined to `NatOrBool.nat.asType` and "
"`NatOrBool.bool.asType`, and these compute to the actual types `Nat` and "
"`Bool`."
msgstr ""

#: src/dependent-types/universe-pattern.md:40
msgid ""
"Like any other data, codes may be recursive. The type `NestedPairs` codes "
"for any possible nesting of the pair and natural number types:"
msgstr ""

#: src/dependent-types/universe-pattern.md:51
msgid ""
"In this case, the interpretation function `NestedPairs.asType` is recursive. "
"This means that recursion over codes is required in order to implement `BEq` "
"for the universe:"
msgstr ""

#: src/dependent-types/universe-pattern.md:63
msgid ""
"Even though every type in the `NestedPairs` universe already has a `BEq` "
"instance, type class search does not automatically check every possible case "
"of a datatype in an instance declaration, because there might be infinitely "
"many such cases, as with `NestedPairs`. Attempting to appeal directly to the "
"`BEq` instances rather than explaining to Lean how to find them by recursion "
"on the codes results in an error:"
msgstr ""

#: src/dependent-types/universe-pattern.md:73
msgid ""
"The `t` in the error message stands for an unknown value of type "
"`NestedPairs`."
msgstr ""

#: src/dependent-types/universe-pattern.md:75
msgid "Type Classes vs Universes"
msgstr ""

#: src/dependent-types/universe-pattern.md:77
msgid ""
"Type classes allow an open-ended collection of types to be used with an API "
"as long as they have implementations of the necessary interfaces. In most "
"cases, this is preferable. It is hard to predict all use cases for an API "
"ahead of time, and type classes are a convenient way to allow library code "
"to be used with more types than the original author expected."
msgstr ""

#: src/dependent-types/universe-pattern.md:81
msgid ""
"A universe à la Tarski, on the other hand, restricts the API to be usable "
"only with a predetermined collection of types. This is useful in a few "
"situations:"
msgstr ""

#: src/dependent-types/universe-pattern.md:83
msgid ""
"When a function should act very differently depending on which type it is "
"passed—it is impossible to pattern match on types themselves, but pattern "
"matching on codes for types is allowed"
msgstr ""

#: src/dependent-types/universe-pattern.md:84
msgid ""
"When an external system inherently limits the types of data that may be "
"provided, and extra flexibility is not desired"
msgstr ""

#: src/dependent-types/universe-pattern.md:85
msgid ""
"When additional properties of a type are required over and above the "
"implementation of some operations"
msgstr ""

#: src/dependent-types/universe-pattern.md:87
msgid ""
"Type classes are useful in many of the same situations as interfaces in Java "
"or C#, while a universe à la Tarski can be useful in cases where a sealed "
"class might be used, but where an ordinary inductive datatype is not usable."
msgstr ""

#: src/dependent-types/universe-pattern.md:89
msgid "A Universe of Finite Types"
msgstr ""

#: src/dependent-types/universe-pattern.md:91
msgid ""
"Restricting the types that can be used with an API to a predetermined "
"collection can enable operations that would be impossible for an open-ended "
"API. For example, functions can't normally be compared for equality. "
"Functions should be considered equal when they map the same inputs to the "
"same outputs. Checking this could take infinite amounts of time, because "
"comparing two functions with type `Nat → Bool` would require checking that "
"the functions returned the same `Bool` for each and every `Nat`."
msgstr ""

#: src/dependent-types/universe-pattern.md:96
msgid ""
"In other words, a function from an infinite type is itself infinite. "
"Functions can be viewed as tables, and a function whose argument type is "
"infinite requires infinitely many rows to represent each case. But functions "
"from finite types require only finitely many rows in their tables, making "
"them finite. Two functions whose argument type is finite can be checked for "
"equality by enumerating all possible arguments, calling the functions on "
"each of them, and then comparing the results. Checking higher-order "
"functions for equality requires generating all possible functions of a given "
"type, which additionally requires that the return type is finite so that "
"each element of the argument type can be mapped to each element of the "
"return type. This is not a _fast_ method, but it does complete in finite "
"time."
msgstr ""

#: src/dependent-types/universe-pattern.md:103
msgid "One way to represent finite types is by a universe:"
msgstr ""

#: src/dependent-types/universe-pattern.md:117
msgid ""
"In this universe, the constructor `arr` stands for the function type, which "
"is written with an `arr`ow."
msgstr ""

#: src/dependent-types/universe-pattern.md:119
msgid ""
"Comparing two values from this universe for equality is almost the same as "
"in the `NestedPairs` universe. The only important difference is the addition "
"of the case for `arr`, which uses a helper called `Finite.enumerate` to "
"generate every value from the type coded for by `t1`, checking that the two "
"functions return equal results for every possible input:"
msgstr ""

#: src/dependent-types/universe-pattern.md:130
msgid ""
"The standard library function `List.all` checks that the provided function "
"returns `true` on every entry of a list. This function can be used to "
"compare functions on the Booleans for equality:"
msgstr ""

#: src/dependent-types/universe-pattern.md:138
msgid "It can also be used to compare functions from the standard library:"
msgstr ""

#: src/dependent-types/universe-pattern.md:145
msgid ""
"It can even compare functions built using tools such as function composition:"
msgstr ""

#: src/dependent-types/universe-pattern.md:152
msgid ""
"This is because the `Finite` universe codes for Lean's _actual_ function "
"type, not a special analogue created by the library."
msgstr ""

#: src/dependent-types/universe-pattern.md:154
msgid ""
"The implementation of `enumerate` is also by recursion on the codes from "
"`Finite`."
msgstr ""

#: src/dependent-types/universe-pattern.md:163
msgid ""
"In the case for `Unit`, there is only a single value. In the case for "
"`Bool`, there are two values to return (`true` and `false`). In the case for "
"pairs, the result should be the Cartesian product of the values for the type "
"coded for by `t1` and the values for the type coded for by `t2`. In other "
"words, every value from `t1` should be paired with every value from `t2`. "
"The helper function `List.product` can certainly be written with an ordinary "
"recursive function, but here it is defined using `for` in the identity monad:"
msgstr ""

#: src/dependent-types/universe-pattern.md:176
msgid ""
"Finally, the case of `Finite.enumerate` for functions delegates to a helper "
"called `Finite.functions` that takes a list of all of the return values to "
"target as an argument."
msgstr ""

#: src/dependent-types/universe-pattern.md:178
msgid ""
"Generally speaking, generating all of the functions from some finite type to "
"a collection of result values can be thought of as generating the functions' "
"tables. Each function assigns an output to each input, which means that a "
"given function has \\\\( k \\\\) rows in its table when there are \\\\( k "
"\\\\) possible arguments. Because each row of the table could select any of "
"\\\\( n \\\\) possible outputs, there are \\\\( n ^ k \\\\) potential "
"functions to generate."
msgstr ""

#: src/dependent-types/universe-pattern.md:182
msgid ""
"Once again, generating the functions from a finite type to some list of "
"values is recursive on the code that describes the finite type:"
msgstr ""

#: src/dependent-types/universe-pattern.md:188
msgid ""
"The table for functions from `Unit` contains one row, because the function "
"can't pick different results based on which input it is provided. This means "
"that one function is generated for each potential input."
msgstr ""

#: src/dependent-types/universe-pattern.md:195
msgid ""
"There are \\\\( n^2 \\\\) functions from `Bool` when there are \\\\( n \\\\) "
"result values, because each individual function of type `Bool → α` uses the "
"`Bool` to select between two particular `α`s:"
msgstr ""

#: src/dependent-types/universe-pattern.md:203
msgid ""
"Generating the functions from pairs can be achieved by taking advantage of "
"currying. A function from a pair can be transformed into a function that "
"takes the first element of the pair and returns a function that's waiting "
"for the second element of the pair. Doing this allows `Finite.functions` to "
"be used recursively in this case:"
msgstr ""

#: src/dependent-types/universe-pattern.md:214
msgid ""
"Generating higher-order functions is a bit of a brain bender. Each "
"higher-order function takes a function as its argument. This argument "
"function can be distinguished from other functions based on its input/output "
"behavior. In general, the higher-order function can apply the argument "
"function to every possible argument, and it can then carry out any possible "
"behavior based on the result of applying the argument function. This "
"suggests a means of constructing the higher-order functions:"
msgstr ""

#: src/dependent-types/universe-pattern.md:219
msgid ""
"Begin with a list of all possible arguments to the function that is itself "
"an argument."
msgstr ""

#: src/dependent-types/universe-pattern.md:220
msgid ""
"For each possible argument, construct all possible behaviors that can result "
"from the observation of applying the argument function to the possible "
"argument. This can be done using `Finite.functions` and recursion over the "
"rest of the possible arguments, because the result of the recursion "
"represents the functions based on the observations of the rest of the "
"possible arguments. `Finite.functions` constructs all the ways of achieving "
"these based on the observation for the current argument."
msgstr ""

#: src/dependent-types/universe-pattern.md:221
msgid ""
"For potential behavior in response to these observations, construct a "
"higher-order function that applies the argument function to the current "
"possible argument. The result of this is then passed to the observation "
"behavior."
msgstr ""

#: src/dependent-types/universe-pattern.md:222
msgid ""
"The base case of the recursion is a higher-order function that observes "
"nothing for each result value—it ignores the argument function and simply "
"returns the result value."
msgstr ""

#: src/dependent-types/universe-pattern.md:224
msgid ""
"Defining this recursive function directly causes Lean to be unable to prove "
"that the whole function terminates. However, using a simpler form of "
"recursion called a _right fold_ can be used to make it clear to the "
"termination checker that the function terminates. A right fold takes three "
"arguments: a step function that combines the head of the list with the "
"result of the recursion over the tail, a default value to return when the "
"list is empty, and the list being processed. It then analyzes the list, "
"essentially replacing each `::` in the list with a call to the step function "
"and replacing `[]` with the default value:"
msgstr ""

#: src/dependent-types/universe-pattern.md:233
msgid "Finding the sum of the `Nat`s in a list can be done with `foldr`:"
msgstr ""

#: src/dependent-types/universe-pattern.md:244
msgid "With `foldr`, the higher-order functions can be created as follows:"
msgstr ""

#: src/dependent-types/universe-pattern.md:257
msgid "The complete definition of `Finite.Functions` is:"
msgstr ""

#: src/dependent-types/universe-pattern.md:288
msgid ""
"Because `Finite.enumerate` and `Finite.functions` call each other, they must "
"be defined in a `mutual` block. In other words, right before the definition "
"of `Finite.enumerate` is the `mutual` keyword:"
msgstr ""

#: src/dependent-types/universe-pattern.md:295
msgid ""
"and right after the definition of `Finite.functions` is the `end` keyword:"
msgstr ""

#: src/dependent-types/universe-pattern.md:310
msgid ""
"This algorithm for comparing functions is not particularly practical. The "
"number of cases to check grows exponentially; even a simple type like "
"`((Bool × Bool) → Bool) → Bool` describes 65536 distinct functions. Why are "
"there so many? Based on the reasoning above, and using \\\\( \\\\left| T "
"\\\\right| \\\\) to represent the number of values described by the type "
"\\\\( T \\\\), we should expect that \\\\\\[ \\\\left| \\\\left( \\\\left( "
"\\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) \\\\rightarrow "
"\\\\mathtt{Bool} \\\\right) \\\\rightarrow \\\\mathtt{Bool} \\\\right| "
"\\\\\\] is  \\\\\\[ \\\\left|\\\\mathrm{Bool}\\\\right|^{\\\\left| \\\\left( "
"\\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) \\\\rightarrow "
"\\\\mathtt{Bool} \\\\right| }, \\\\\\] which is \\\\\\[ 2^{2^{\\\\left| "
"\\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right| }}, \\\\\\] which is "
"\\\\\\[ 2^{2^4} \\\\\\] or 65536. Nested exponentials grow quickly, and "
"there are many higher-order functions."
msgstr ""

#: src/dependent-types/universe-pattern.md:327
msgid ""
"Write a function that converts any value from a type coded for by `Finite` "
"into a string. Functions should be represented as their tables."
msgstr ""

#: src/dependent-types/universe-pattern.md:328
msgid "Add the empty type `Empty` to `Finite` and `Finite.beq`."
msgstr ""

#: src/dependent-types/universe-pattern.md:329
msgid "Add `Option` to `Finite` and `Finite.beq`."
msgstr ""

#: src/dependent-types/typed-queries.md:3
msgid ""
"Indexed families are very useful when building an API that is supposed to "
"resemble some other language. They can be used to write a library of HTML "
"constructors that don't permit generating invalid HTML, to encode the "
"specific rules of a configuration file format, or to model complicated "
"business constraints. This section describes an encoding of a subset of "
"relational algebra in Lean using indexed families, as a simpler "
"demonstration of techniques that can be used to build a more powerful "
"database query language."
msgstr ""

#: src/dependent-types/typed-queries.md:7
msgid ""
"This subset uses the type system to enforce requirements such as "
"disjointness of field names, and it uses type-level computation to reflect "
"the schema into the types of values that are returned from a query. It is "
"not a realistic system, however—databases are represented as linked lists of "
"linked lists, the type system is much simpler than that of SQL, and the "
"operators of relational algebra don't really match those of SQL. However, it "
"is large enough to demonstrate useful principles and techniques."
msgstr ""

#: src/dependent-types/typed-queries.md:11
msgid "A Universe of Data"
msgstr ""

#: src/dependent-types/typed-queries.md:12
msgid ""
"In this relational algebra, the base data that can be held in columns can "
"have types `Int`, `String`, and `Bool` and are described by the universe "
"`DBType`:"
msgstr ""

#: src/dependent-types/typed-queries.md:23
msgid "Using `asType` allows these codes to be used for types. For example:"
msgstr ""

#: src/dependent-types/typed-queries.md:25
msgid ""
"```lean\n"
"#eval (\"Mount Hood\" : DBType.string.asType)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:28
msgid ""
"```output info\n"
"\"Mount Hood\"\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:32
msgid ""
"It is possible to compare the values described by any of the three database "
"types for equality. Explaining this to Lean, however, requires a bit of "
"work. Simply using `BEq` directly fails:"
msgstr ""

#: src/dependent-types/typed-queries.md:43
msgid ""
"Just as in the nested pairs universe, type class search doesn't "
"automatically check each possibility for `t`'s value The solution is to use "
"pattern matching to refine the types of `x` and `y`:"
msgstr ""

#: src/dependent-types/typed-queries.md:52
msgid ""
"In this version of the function, `x` and `y` have types `Int`, `String`, and "
"`Bool` in the three respective cases, and these types all have `BEq` "
"instances. The definition of `dbEq` can be used to define a `BEq` instance "
"for the types that are coded for by `DBType`:"
msgstr ""

#: src/dependent-types/typed-queries.md:58
msgid "This is not the same as an instance for the codes themselves:"
msgstr ""

#: src/dependent-types/typed-queries.md:67
msgid ""
"The former instance allows comparison of values drawn from the types "
"described by the codes, while the latter allows comparison of the codes "
"themselves."
msgstr ""

#: src/dependent-types/typed-queries.md:69
msgid ""
"A `Repr` instance can be written using the same technique. The method of the "
"`Repr` class is called `reprPrec` because it is designed to take things like "
"operator precedence into account when displaying values. Refining the type "
"through dependent pattern matching allows the `reprPrec` methods from the "
"`Repr` instances for `Int`, `String`, and `Bool` to be used:"
msgstr ""

#: src/dependent-types/typed-queries.md:81
msgid "Schemas and Tables"
msgstr ""

#: src/dependent-types/typed-queries.md:83
msgid "A schema describes the name and type of each column in a database:"
msgstr ""

#: src/dependent-types/typed-queries.md:91
msgid ""
"In fact, a schema can be seen as a universe that describes rows in a table. "
"The empty schema describes the unit type, a schema with a single column "
"describes that value on its own, and a schema with at least two columns is "
"represented by a tuple:"
msgstr ""

#: src/dependent-types/typed-queries.md:100
msgid ""
"As described in [the initial section on product "
"types](../getting-to-know/polymorphism.md#prod), Lean's product type and "
"tuples are right-associative. This means that nested pairs are equivalent to "
"ordinary flat tuples."
msgstr ""

#: src/dependent-types/typed-queries.md:103
msgid "A table is a list of rows that share a schema:"
msgstr ""

#: src/dependent-types/typed-queries.md:107
msgid ""
"For example, a diary of visits to mountain peaks can be represented with the "
"schema `peak`:"
msgstr ""

#: src/dependent-types/typed-queries.md:108
msgid ""
"```lean\n"
"abbrev peak : Schema := [\n"
"  ⟨\"name\", DBType.string⟩,\n"
"  ⟨\"location\", DBType.string⟩,\n"
"  ⟨\"elevation\", DBType.int⟩,\n"
"  ⟨\"lastVisited\", .int⟩\n"
"]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:116
msgid ""
"A selection of peaks visited by the author of this book appears as an "
"ordinary list of tuples:"
msgstr ""

#: src/dependent-types/typed-queries.md:117
msgid ""
"```lean\n"
"def mountainDiary : Table peak := [\n"
"  (\"Mount Nebo\",       \"USA\",     3637, 2013),\n"
"  (\"Moscow Mountain\",  \"USA\",     1519, 2015),\n"
"  (\"Himmelbjerget\",    \"Denmark\",  147, 2004),\n"
"  (\"Mount St. Helens\", \"USA\",     2549, 2010)\n"
"]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:125
msgid "Another example consists of waterfalls and a diary of visits to them:"
msgstr ""

#: src/dependent-types/typed-queries.md:126
msgid ""
"```lean\n"
"abbrev waterfall : Schema := [\n"
"  ⟨\"name\", .string⟩,\n"
"  ⟨\"location\", .string⟩,\n"
"  ⟨\"lastVisited\", .int⟩\n"
"]\n"
"\n"
"def waterfallDiary : Table waterfall := [\n"
"  (\"Multnomah Falls\", \"USA\", 2018),\n"
"  (\"Shoshone Falls\",  \"USA\", 2014)\n"
"]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:139
msgid "Recursion and Universes, Revisited"
msgstr ""

#: src/dependent-types/typed-queries.md:141
msgid ""
"The convenient structuring of rows as tuples comes at a cost: the fact that "
"`Row` treats its two base cases separately means that functions that use "
"`Row` in their types and are defined recursively over the codes (that, is "
"the schema) need to make the same distinctions. One example of a case where "
"this matters is an equality check that uses recursion over the schema to "
"define a function that checks rows for equality. This example does not pass "
"Lean's type checker:"
msgstr ""

#: src/dependent-types/typed-queries.md:161
msgid ""
"The problem is that the pattern `col :: cols` does not sufficiently refine "
"the type of the rows. This is because Lean cannot yet tell whether the "
"singleton pattern `[col]` or the `col1 :: col2 :: cols` pattern in the "
"definition of `Row` was matched, so the call to `Row` does not compute down "
"to a pair type. The solution is to mirror the structure of `Row` in the "
"definition of `Row.bEq`:"
msgstr ""

#: src/dependent-types/typed-queries.md:178
msgid ""
"Unlike in other contexts, functions that occur in types cannot be considered "
"only in terms of their input/output behavior. Programs that use these types "
"will find themselves forced to mirror the algorithm used in the type-level "
"function so that their structure matches the pattern-matching and recursive "
"behavior of the type. A big part of the skill of programming with dependent "
"types is the selection of appropriate type-level functions with the right "
"computational behavior."
msgstr ""

#: src/dependent-types/typed-queries.md:182
msgid "Column Pointers"
msgstr ""

#: src/dependent-types/typed-queries.md:184
msgid ""
"Some queries only make sense if a schema contains a particular column. For "
"example, a query that returns mountains with an elevation greater than 1000 "
"meters only makes sense in the context of a schema with a `\"elevation\"` "
"column that contains integers. One way to indicate that a column is "
"contained in a schema is to provide a pointer directly to it, and defining "
"the pointer as an indexed family makes it possible to rule out invalid "
"pointers."
msgstr ""

#: src/dependent-types/typed-queries.md:188
msgid ""
"There are two ways that a column can be present in a schema: either it is at "
"the beginning of the schema, or it is somewhere later in the schema. "
"Eventually, if a column is later in a schema, then it will be the beginning "
"of some tail of the schema."
msgstr ""

#: src/dependent-types/typed-queries.md:191
msgid ""
"The indexed family `HasCol` is a translation of the specification into Lean "
"code:"
msgstr ""

#: src/dependent-types/typed-queries.md:197
msgid ""
"The family's three arguments are the schema, the column name, and its type. "
"All three are indices, but re-ordering the arguments to place the schema "
"after the column name and type would allow the name and type to be "
"parameters. The constructor `here` can be used when the schema begins with "
"the column `⟨name, t⟩`; it is thus a pointer to the first column in the "
"schema that can only be used when the first column has the desired name and "
"type. The constructor `there` transforms a pointer into a smaller schema "
"into a pointer into a schema with one more column on it."
msgstr ""

#: src/dependent-types/typed-queries.md:202
msgid ""
"Because `\"elevation\"` is the third column in `peak`, it can be found by "
"looking past the first two columns with `there`, after which it is the first "
"column. In other words, to satisfy the type `HasCol peak \"elevation\" "
".int`, use the expression `.there (.there .here)`. One way to think about "
"`HasCol` is as a kind of decorated `Nat`—`zero` corresponds to `here`, and "
"`succ` corresponds to `there`. The extra type information makes it "
"impossible to have off-by-one errors."
msgstr ""

#: src/dependent-types/typed-queries.md:207
msgid ""
"A pointer to a particular column in a schema can be used to extract that "
"column's value from a row:"
msgstr ""

#: src/dependent-types/typed-queries.md:215
msgid ""
"The first step is to pattern match on the schema, because this determines "
"whether the row is a tuple or a single value. No case is needed for the "
"empty schema because there is a `HasCol` available, and both constructors of "
"`HasCol` specify non-empty schemas. If the schema has just a single column, "
"then the pointer must point to it, so only the `here` constructor of "
"`HasCol` need be matched. If the schema has two or more columns, then there "
"must be a case for `here`, in which case the value is the first one in the "
"row, and one for `there`, in which case a recursive call is used. Because "
"the `HasCol` type guarantees that the column exists in the row, `Row.get` "
"does not need to return an `Option`."
msgstr ""

#: src/dependent-types/typed-queries.md:221
msgid "`HasCol` plays two roles:"
msgstr ""

#: src/dependent-types/typed-queries.md:222
msgid ""
"It serves as _evidence_ that a column with a particular name and type exists "
"in a schema."
msgstr ""

#: src/dependent-types/typed-queries.md:224
msgid ""
"It serves as _data_ that can be used to find the value associated with the "
"column in a row."
msgstr ""

#: src/dependent-types/typed-queries.md:226
msgid ""
"The first role, that of evidence, is similar to way that propositions are "
"used. The definition of the indexed family `HasCol` can be read as a "
"specification of what counts as evidence that a given column exists. Unlike "
"propositions, however, it matters which constructor of `HasCol` was used. In "
"the second role, the constructors are used like `Nat`s to find data in a "
"collection. Programming with indexed families often requires the ability to "
"switch fluently between both perspectives."
msgstr ""

#: src/dependent-types/typed-queries.md:232
msgid "Subschemas"
msgstr ""

#: src/dependent-types/typed-queries.md:234
msgid ""
"One important operation in relational algebra is to _project_ a table or row "
"into a smaller schema. Every column not present in the smaller schema is "
"forgotten. In order for projection to make sense, the smaller schema must be "
"a subschema of the larger schema, which means that every column in the "
"smaller schema must be present in the larger schema. Just as `HasCol` makes "
"it possible to write a single-column lookup in a row that cannot fail, a "
"representation of the subschema relationship as an indexed family makes it "
"possible to write a projection function that cannot fail."
msgstr ""

#: src/dependent-types/typed-queries.md:239
msgid ""
"The ways in which one schema can be a subschema of another can be defined as "
"an indexed family. The basic idea is that a smaller schema is a subschema of "
"a bigger schema if every column in the smaller schema occurs in the bigger "
"schema. If the smaller schema is empty, then it's certainly a subschema of "
"the bigger schema, represented by the constructor `nil`. If the smaller "
"schema has a column, then that column must be in the bigger schema, and all "
"the rest of the columns in the subschema must also be a subschema of the "
"bigger schema. This is represented by the constructor `cons`."
msgstr ""

#: src/dependent-types/typed-queries.md:252
msgid ""
"In other words, `Subschema` assigns each column of the smaller schema a "
"`HasCol` that points to its location in the larger schema."
msgstr ""

#: src/dependent-types/typed-queries.md:254
msgid ""
"The schema `travelDiary` represents the fields that are common to both "
"`peak` and `waterfall`:"
msgstr ""

#: src/dependent-types/typed-queries.md:255
msgid ""
"```lean\n"
"abbrev travelDiary : Schema :=\n"
"  [⟨\"name\", .string⟩, ⟨\"location\", .string⟩, ⟨\"lastVisited\", .int⟩]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:259
msgid "It is certainly a subschema of `peak`, as shown by this example:"
msgstr ""

#: src/dependent-types/typed-queries.md:266
msgid ""
"However, code like this is difficult to read and difficult to maintain. One "
"way to improve it is to instruct Lean to write the `Subschema` and `HasCol` "
"constructors automatically. This can be done using the tactic feature that "
"was introduced in [the Interlude on propositions and "
"proofs](../props-proofs-indexing.md). That interlude uses `by simp` to "
"provide evidence of various propositions."
msgstr ""

#: src/dependent-types/typed-queries.md:271
msgid "In this context, two tactics are useful:"
msgstr ""

#: src/dependent-types/typed-queries.md:272
msgid ""
"The `constructor` tactic instructs Lean to solve the problem using the "
"constructor of a datatype."
msgstr ""

#: src/dependent-types/typed-queries.md:273
msgid ""
"The `repeat` tactic instructs Lean to repeat a tactic over and over until it "
"either fails or the proof is finished."
msgstr ""

#: src/dependent-types/typed-queries.md:275
msgid ""
"In the next example, `by constructor` has the same effect as just writing "
"`.nil` would have:"
msgstr ""

#: src/dependent-types/typed-queries.md:279
msgid ""
"However, attempting that same tactic with a slightly more complicated type "
"fails:"
msgstr ""

#: src/dependent-types/typed-queries.md:280
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:283
msgid ""
"```output error\n"
"unsolved goals\n"
"case a\n"
"⊢ HasCol peak \"location\" DBType.string\n"
"\n"
"case a\n"
"⊢ Subschema [] peak\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:291
msgid ""
"Errors that begin with `unsolved goals` describe tactics that failed to "
"completely build the expressions that they were supposed to. In Lean's "
"tactic language, a _goal_ is a type that a tactic is to fulfill by "
"constructing an appropriate expression behind the scenes. In this case, "
"`constructor` caused `Subschema.cons` to be applied, and the two goals "
"represent the two arguments expected by `cons`. Adding another instance of "
"`constructor` causes the first goal (`HasCol peak \\\"location\\\" "
"DBType.string`) to be addressed with `HasCol.there`, because `peak`'s first "
"column is not `\"location\"`:"
msgstr ""

#: src/dependent-types/typed-queries.md:295
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by\n"
"  constructor\n"
"  constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:300
msgid ""
"```output error\n"
"unsolved goals\n"
"case a.a\n"
"⊢ HasCol\n"
"    [{ name := \"location\", contains := DBType.string }, { name := "
"\"elevation\", contains := DBType.int },\n"
"      { name := \"lastVisited\", contains := DBType.int }]\n"
"    \"location\" DBType.string\n"
"\n"
"case a\n"
"⊢ Subschema [] peak\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:311
msgid ""
"However, adding a third `constructor` results in the first goal being "
"solved, because `HasCol.here` is applicable:"
msgstr ""

#: src/dependent-types/typed-queries.md:312
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by\n"
"  constructor\n"
"  constructor\n"
"  constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:323
msgid "A fourth instance of `constructor` solves the `Subschema peak []` goal:"
msgstr ""

#: src/dependent-types/typed-queries.md:324
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by\n"
"  constructor\n"
"  constructor\n"
"  constructor\n"
"  constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:331
msgid ""
"Indeed, a version written without the use of tactics has four constructors:"
msgstr ""

#: src/dependent-types/typed-queries.md:332
msgid ""
"```lean\n"
"example : Subschema [⟨\"location\", .string⟩] peak :=\n"
"  .cons (.there .here) .nil\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:337
msgid ""
"Instead of experimenting to find the right number of times to write "
"`constructor`, the `repeat` tactic can be used to ask Lean to just keep "
"trying `constructor` as long as it keeps making progress:"
msgstr ""

#: src/dependent-types/typed-queries.md:338
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by repeat constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:341
msgid ""
"This more flexible version also works for more interesting `Subschema` "
"problems:"
msgstr ""

#: src/dependent-types/typed-queries.md:348
msgid ""
"The approach of blindly trying constructors until something works is not "
"very useful for types like `Nat` or `List Bool`. Just because an expression "
"has type `Nat` doesn't mean that it's the _correct_ `Nat`, after all. But "
"types like `HasCol` and `Subschema` are sufficiently constrained by their "
"indices that only one constructor will ever be applicable, which means that "
"the contents of the program itself are less interesting, and a computer can "
"pick the correct one."
msgstr ""

#: src/dependent-types/typed-queries.md:352
msgid ""
"If one schema is a subschema of another, then it is also a subschema of the "
"larger schema extended with an additional column. This fact can be captured "
"as a function definition. `Subschema.addColumn` takes evidence that "
"`smaller` is a subschema of `bigger`, and then returns evidence that "
"`smaller` is a subschema of `c :: bigger`, that is, `bigger` with one "
"additional column:"
msgstr ""

#: src/dependent-types/typed-queries.md:361
msgid ""
"A subschema describes where to find each column from the smaller schema in "
"the larger schema. `Subschema.addColumn` must translate these descriptions "
"from the original larger schema into the extended larger schema. In the "
"`nil` case, the smaller schema is `[]`, and `nil` is also evidence that `[]` "
"is a subschema of `c :: bigger`. In the `cons` case, which describes how to "
"place one column from `smaller` into `larger`, the placement of the column "
"needs to be adjusted with `there` to account for the new column `c`, and a "
"recursive call adjusts the rest of the columns."
msgstr ""

#: src/dependent-types/typed-queries.md:366
msgid ""
"Another way to think about `Subschema` is that it defines a _relation_ "
"between two schemas—the existence of an expression  with type `Subschema "
"bigger smaller` means that `(bigger, smaller)` is in the relation. This "
"relation is reflexive, meaning that every schema is a subschema of itself:"
msgstr ""

#: src/dependent-types/typed-queries.md:375
msgid "Projecting Rows"
msgstr ""

#: src/dependent-types/typed-queries.md:377
msgid ""
"Given evidence that `s'` is a subschema of `s`, a row in `s` can be "
"projected into a row in `s'`. This is done using the evidence that `s'` is a "
"subschema of `s`, which explains where each column of `s'` is found in `s`. "
"The new row in `s'` is built up one column at a time by retrieving the value "
"from the appropriate place in the old row."
msgstr ""

#: src/dependent-types/typed-queries.md:381
msgid ""
"The function that performs this projection, `Row.project`, has three cases, "
"one for each case of `Row` itself. It uses `Row.get` together with each "
"`HasCol` in the `Subschema` argument to construct the projected row:"
msgstr ""

#: src/dependent-types/typed-queries.md:391
msgid "Conditions and Selection"
msgstr ""

#: src/dependent-types/typed-queries.md:393
msgid ""
"Projection removes unwanted columns from a table, but queries must also be "
"able to remove unwanted rows. This operation is called _selection_. "
"Selection relies on having a means of expressing which rows are desired."
msgstr ""

#: src/dependent-types/typed-queries.md:397
msgid ""
"The example query language contains expressions, which are analogous to what "
"can be written in a `WHERE` clause in SQL. Expressions are represented by "
"the indexed family `DBExpr`. Because expressions can refer to columns from "
"the database, but different sub-expressions all have the same schema, "
"`DBExpr` takes the database schema as a parameter. Additionally, each "
"expression has a type, and these vary, making it an index:"
msgstr ""

#: src/dependent-types/typed-queries.md:409
msgid ""
"The `col` constructor represents a reference to a column in the database. "
"The `eq` constructor compares two expressions for equality, `lt` checks "
"whether one is less than the other, `and` is Boolean conjunction, and "
"`const` is a constant value of some type."
msgstr ""

#: src/dependent-types/typed-queries.md:412
msgid ""
"For example, an expression in `peak` that checks whether the `elevation` "
"column is greater than 1000 and the location is `\"Denmark\"` can be written:"
msgstr ""

#: src/dependent-types/typed-queries.md:413
msgid ""
"```leantac\n"
"def tallInDenmark : DBExpr peak .bool :=\n"
"  .and (.lt (.const 1000) (.col \"elevation\" (by repeat constructor)))\n"
"       (.eq (.col \"location\" (by repeat constructor)) (.const "
"\"Denmark\"))\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:418
msgid ""
"This is somewhat noisy. In particular, references to columns contain "
"boilerplate calls to `by repeat constructor`. A Lean feature called _macros_ "
"can help make expressions easier to read by eliminating this boilerplate:"
msgstr ""

#: src/dependent-types/typed-queries.md:421
msgid ""
"```leantac\n"
"macro \"c!\" n:term : term => `(DBExpr.col $n (by repeat constructor))\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:424
msgid ""
"This declaration adds the `c!` keyword to Lean, and instructs Lean to "
"replace any instance of `c!` followed by an expression with the "
"corresponding `DBExpr.col` construction. Here, `term` stands for Lean "
"expressions, rather than commands, tactics, or some other part of the "
"language. Lean macros are a bit like C preprocessor macros, except they are "
"better integrated into the language and they automatically avoid some of the "
"pitfalls of CPP. In fact, they are very closely related to macros in Scheme "
"and Racket."
msgstr ""

#: src/dependent-types/typed-queries.md:429
msgid "With this macro, the expression can be much easier to read:"
msgstr ""

#: src/dependent-types/typed-queries.md:430
msgid ""
"```lean\n"
"def tallInDenmark : DBExpr peak .bool :=\n"
"  .and (.lt (.const 1000) (c! \"elevation\"))\n"
"       (.eq (c! \"location\") (.const \"Denmark\"))\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:436
msgid ""
"Finding the value of an expression with respect to a given row uses "
"`Row.get` to extract column references, and it delegates to Lean's "
"operations on values for every other expression:"
msgstr ""

#: src/dependent-types/typed-queries.md:446
msgid ""
"Evaluating the expression for Valby Bakke, the tallest hill in the "
"Copenhagen area, yields `false` because Valby Bakke is much less than 1 km "
"over sea level:"
msgstr ""

#: src/dependent-types/typed-queries.md:447
msgid ""
"```lean\n"
"#eval tallInDenmark.evaluate (\"Valby Bakke\", \"Denmark\", 31, 2023)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:453
msgid "Evaluating it for a fictional mountain of 1230m elevation yields `true`:"
msgstr ""

#: src/dependent-types/typed-queries.md:454
msgid ""
"```lean\n"
"#eval tallInDenmark.evaluate (\"Fictional mountain\", \"Denmark\", 1230, "
"2023)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:460
msgid ""
"Evaluating it for the highest peak in the US state of Idaho yields `false`, "
"as Idaho is not part of Denmark:"
msgstr ""

#: src/dependent-types/typed-queries.md:461
msgid ""
"```lean\n"
"#eval tallInDenmark.evaluate (\"Mount Borah\", \"USA\", 3859, 1996)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:468
msgid "Queries"
msgstr ""

#: src/dependent-types/typed-queries.md:470
msgid ""
"The query language is based on relational algebra. In addition to tables, it "
"includes the following operators:"
msgstr ""

#: src/dependent-types/typed-queries.md:472
msgid ""
"The union of two expressions that have the same schema combines the rows "
"that result from two queries"
msgstr ""

#: src/dependent-types/typed-queries.md:473
msgid ""
"The difference of two expressions that have the same schema removes rows "
"found in the second result from the rows in the first result"
msgstr ""

#: src/dependent-types/typed-queries.md:474
msgid ""
"Selection by some criterion filters the result of a query according to an "
"expression"
msgstr ""

#: src/dependent-types/typed-queries.md:475
msgid "Projection into a subschema, removing columns from the result of a query"
msgstr ""

#: src/dependent-types/typed-queries.md:476
msgid ""
"Cartesian product, combining every row from one query with every row from "
"another"
msgstr ""

#: src/dependent-types/typed-queries.md:477
msgid "Renaming a column in the result of a query, which modifies its schema"
msgstr ""

#: src/dependent-types/typed-queries.md:478
msgid "Prefixing all columns in a query with a name"
msgstr ""

#: src/dependent-types/typed-queries.md:480
msgid ""
"The last operator is not strictly necessary, but it makes the language more "
"convenient to use."
msgstr ""

#: src/dependent-types/typed-queries.md:482
msgid "Once again, queries are represented by an indexed family:"
msgstr ""

#: src/dependent-types/typed-queries.md:483
msgid ""
"```lean\n"
"inductive Query : Schema → Type where\n"
"  | table : Table s → Query s\n"
"  | union : Query s → Query s → Query s\n"
"  | diff : Query s → Query s → Query s\n"
"  | select : Query s → DBExpr s .bool → Query s\n"
"  | project : Query s → (s' : Schema) → Subschema s' s → Query s'\n"
"  | product :\n"
"      Query s1 → Query s2 →\n"
"      disjoint (s1.map Column.name) (s2.map Column.name) →\n"
"      Query (s1 ++ s2)\n"
"  | renameColumn :\n"
"      Query s → (c : HasCol s n t) → (n' : String) → !((s.map "
"Column.name).contains n') →\n"
"      Query (s.renameColumn c n')\n"
"  | prefixWith :\n"
"      (n : String) → Query s →\n"
"      Query (s.map fun c => {c with name := n ++ \".\" ++ c.name})\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:501
msgid ""
"The `select` constructor requires that the expression used for selection "
"return a Boolean. The `product` constructor's type contains a call to "
"`disjoint`, which ensures that the two schemas don't share any names:"
msgstr ""

#: src/dependent-types/typed-queries.md:507
msgid ""
"The use of an expression of type `Bool` where a type is expected triggers a "
"coercion from `Bool` to `Prop`. Just as decidable propositions can be "
"considered to be Booleans, where evidence for the proposition is coerced to "
"`true` and refutations of the proposition are coerced to `false`, Booleans "
"are coerced into the proposition that states that the expression is equal to "
"`true`. Because all uses of the library are expected to occur in contexts "
"where the schemas are known ahead of time, this proposition can be proved "
"with `by simp`. Similarly, the `renameColumn` constructor checks that the "
"new name does not already exist in the schema. It uses the helper "
"`Schema.renameColumn` to change the name of the column pointed to by "
"`HasCol`:"
msgstr ""

#: src/dependent-types/typed-queries.md:518
msgid "Executing Queries"
msgstr ""

#: src/dependent-types/typed-queries.md:520
msgid ""
"Executing queries requires a number of helper functions. The result of a "
"query is a table; this means that each operation in the query language "
"requires a corresponding implementation that works with tables."
msgstr ""

#: src/dependent-types/typed-queries.md:523
msgid "Cartesian Product"
msgstr ""

#: src/dependent-types/typed-queries.md:525
msgid ""
"Taking the Cartesian product of two tables is done by appending each row "
"from the first table to each row from the second. First off, due to the "
"structure of `Row`, adding a single column to a row requires pattern "
"matching on its schema in order to determine whether the result will be a "
"bare value or a tuple. Because this is a common operation, factoring the "
"pattern matching out into a helper is convenient:"
msgstr ""

#: src/dependent-types/typed-queries.md:534
msgid ""
"Appending two rows is recursive on the structure of both the first schema "
"and the first row, because the structure of the row proceeds in lock-step "
"with the structure of the schema. When the first row is empty, appending "
"returns the second row. When the first row is a singleton, the value is "
"added to the second row. When the first row contains multiple columns, the "
"first column's value is added to the result of recursion on the remainder of "
"the row."
msgstr ""

#: src/dependent-types/typed-queries.md:546
msgid ""
"`List.flatMap` applies a function that itself returns a list to every entry "
"in an input list, returning the result of appending the resulting lists in "
"order:"
msgstr ""

#: src/dependent-types/typed-queries.md:552
msgid ""
"The type signature suggests that `List.flatMap` could be used to implement a "
"`Monad List` instance. Indeed, together with `pure x := [x]`, `List.flatMap` "
"does implement a monad. However, it's not a very useful `Monad` instance. "
"The `List` monad is basically a version of `Many` that explores _every_ "
"possible path through the search space in advance, before users have the "
"chance to request some number of values. Because of this performance trap, "
"it's usually not a good idea to define a `Monad` instance for `List`. Here, "
"however, the query language has no operator for restricting the number of "
"results to be returned, so combining all possibilities is exactly what is "
"desired:"
msgstr ""

#: src/dependent-types/typed-queries.md:563
msgid ""
"Just as with `List.product`, a loop with mutation in the identity monad can "
"be used as an alternative implementation technique:"
msgstr ""

#: src/dependent-types/typed-queries.md:574
msgid "Difference"
msgstr ""

#: src/dependent-types/typed-queries.md:576
msgid ""
"Removing undesired rows from a table can be done using `List.filter`, which "
"takes a list and a function that returns a `Bool`. A new list is returned "
"that contains only the entries for which the function returns `true`. For "
"instance,"
msgstr ""

#: src/dependent-types/typed-queries.md:579
msgid ""
"```lean\n"
"[\"Willamette\", \"Columbia\", \"Sandy\", \"Deschutes\"].filter (·.length > "
"8)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:583
msgid ""
"```lean\n"
"[\"Willamette\", \"Deschutes\"]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:586
msgid ""
"because `\"Columbia\"` and `\"Sandy\"` have lengths less than or equal to "
"`8`. Removing the entries of a table can be done using the helper "
"`List.without`:"
msgstr ""

#: src/dependent-types/typed-queries.md:592
msgid ""
"This will be used with the `BEq` instance for `Row` when interpreting "
"queries."
msgstr ""

#: src/dependent-types/typed-queries.md:594
msgid "Renaming Columns"
msgstr ""

#: src/dependent-types/typed-queries.md:595
msgid ""
"Renaming a column in a row is done with a recursive function that traverses "
"the row until the column in question is found, at which point the column "
"with the new name gets the same value as the column with the old name:"
msgstr ""

#: src/dependent-types/typed-queries.md:603
msgid ""
"While this function changes the _type_ of its argument, the actual return "
"value contains precisely the same data as the original argument. From a "
"run-time perspective, `renameRow` is nothing but a slow identity function. "
"One difficulty in programming with indexed families is that when performance "
"matters, this kind of operation can get in the way. It takes a very careful, "
"often brittle, design to eliminate these kinds of \"re-indexing\" functions."
msgstr ""

#: src/dependent-types/typed-queries.md:608
msgid "Prefixing Column Names"
msgstr ""

#: src/dependent-types/typed-queries.md:610
msgid ""
"Adding a prefix to column names is very similar to renaming a column. "
"Instead of proceeding to a desired column and then returning, `prefixRow` "
"must process all columns:"
msgstr ""

#: src/dependent-types/typed-queries.md:612
msgid ""
"```lean\n"
"def prefixRow (row : Row s) : Row (s.map fun c => {c with name := n ++ \".\" "
"++ c.name}) :=\n"
"  match s, row with\n"
"  | [], _ => ()\n"
"  | [_], v => v\n"
"  | _::_::_, (v, r) => (v, prefixRow r)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:619
msgid ""
"This can be used with `List.map` in order to add a prefix to all rows in a "
"table. Once again, this function only exists to change the type of a value."
msgstr ""

#: src/dependent-types/typed-queries.md:622
msgid "Putting the Pieces Together"
msgstr ""

#: src/dependent-types/typed-queries.md:624
msgid ""
"With all of these helpers defined, executing a query requires only a short "
"recursive function:"
msgstr ""

#: src/dependent-types/typed-queries.md:636
msgid ""
"Some arguments to the constructors are not used during execution. In "
"particular, both the constructor `project` and the function `Row.project` "
"take the smaller schema as explicit arguments, but the type of the "
"_evidence_ that this schema is a subschema of the larger schema contains "
"enough information for Lean to fill out the argument automatically. "
"Similarly, the fact that the two tables have disjoint column names that is "
"required by the `product` constructor is not needed by "
"`Table.cartesianProduct`. Generally speaking, dependent types provide many "
"opportunities to have Lean fill out arguments on behalf of the programmer."
msgstr ""

#: src/dependent-types/typed-queries.md:641
msgid ""
"Dot notation is used with the results of queries to call functions defined "
"both in the `Table` and `List` namespaces, such `List.map`, `List.filter`, "
"and `Table.cartesianProduct`. This works because `Table` is defined using "
"`abbrev`. Just like type class search, dot notation can see through "
"definitions created with `abbrev`. "
msgstr ""

#: src/dependent-types/typed-queries.md:645
msgid ""
"The implementation of `select` is also quite concise. After executing the "
"query `q`, `List.filter` is used to remove the rows that do not satisfy the "
"expression. Filter expects a function from `Row s` to `Bool`, but "
"`DBExpr.evaluate` has type `Row s → DBExpr s t → t.asType`. Because the type "
"of the `select` constructor requires that the expression have type `DBExpr s "
".bool`, `t.asType` is actually `Bool` in this context."
msgstr ""

#: src/dependent-types/typed-queries.md:650
msgid ""
"A query that finds the heights of all mountain peaks with an elevation "
"greater than 500 meters can be written:"
msgstr ""

#: src/dependent-types/typed-queries.md:651
msgid ""
"```leantac\n"
"open Query in\n"
"def example1 :=\n"
"  table mountainDiary |>.select\n"
"  (.lt (.const 500) (c! \"elevation\")) |>.project\n"
"  [⟨\"elevation\", .int⟩] (by repeat constructor)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:659
msgid "Executing it returns the expected list of integers:"
msgstr ""

#: src/dependent-types/typed-queries.md:667
msgid ""
"To plan a sightseeing tour, it may be relevant to match all pairs mountains "
"and waterfalls in the same location. This can be done by taking the "
"Cartesian product of both tables, selecting only the rows in which they are "
"equal, and then projecting out the names:"
msgstr ""

#: src/dependent-types/typed-queries.md:669
msgid ""
"```leantac\n"
"open Query in\n"
"def example2 :=\n"
"  let mountain := table mountainDiary |>.prefixWith \"mountain\"\n"
"  let waterfall := table waterfallDiary |>.prefixWith \"waterfall\"\n"
"  mountain.product waterfall (by simp)\n"
"    |>.select (.eq (c! \"mountain.location\") (c! \"waterfall.location\"))\n"
"    |>.project [⟨\"mountain.name\", .string⟩, ⟨\"waterfall.name\", .string⟩] "
"(by repeat constructor)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:678
msgid ""
"Because the example data includes only waterfalls in the USA, executing the "
"query returns pairs of mountains and waterfalls in the US:"
msgstr ""

#: src/dependent-types/typed-queries.md:682
msgid ""
"```output info\n"
"[(\"Mount Nebo\", \"Multnomah Falls\"),\n"
" (\"Mount Nebo\", \"Shoshone Falls\"),\n"
" (\"Moscow Mountain\", \"Multnomah Falls\"),\n"
" (\"Moscow Mountain\", \"Shoshone Falls\"),\n"
" (\"Mount St. Helens\", \"Multnomah Falls\"),\n"
" (\"Mount St. Helens\", \"Shoshone Falls\")]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:691
msgid "Errors You May Meet"
msgstr ""

#: src/dependent-types/typed-queries.md:693
msgid ""
"Many potential errors are ruled out by the definition of `Query`. For "
"instance, forgetting the added qualifier in `\"mountain.location\"` yields a "
"compile-time error that highlights the column reference `c! \"location\"`:"
msgstr ""

#: src/dependent-types/typed-queries.md:695
msgid ""
"```leantac\n"
"open Query in\n"
"def example2 :=\n"
"  let mountains := table mountainDiary |>.prefixWith \"mountain\"\n"
"  let waterfalls := table waterfallDiary |>.prefixWith \"waterfall\"\n"
"  mountains.product waterfalls (by simp)\n"
"    |>.select (.eq (c! \"location\") (c! \"waterfall.location\"))\n"
"    |>.project [⟨\"mountain.name\", .string⟩, ⟨\"waterfall.name\", .string⟩] "
"(by repeat constructor)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:704
msgid ""
"This is excellent feedback! On the other hand, the text of the error message "
"is quite difficult to act on:"
msgstr ""

#: src/dependent-types/typed-queries.md:706
msgid ""
"```output error\n"
"unsolved goals\n"
"case a.a.a.a.a.a.a\n"
"mountains : Query (List.map (fun c => { name := \"mountain\" ++ \".\" ++ "
"c.name, contains := c.contains }) peak) :=\n"
"  prefixWith \"mountain\" (table mountainDiary)\n"
"waterfalls : Query (List.map (fun c => { name := \"waterfall\" ++ \".\" ++ "
"c.name, contains := c.contains }) waterfall) :=\n"
"  prefixWith \"waterfall\" (table waterfallDiary)\n"
"⊢ HasCol (List.map (fun c => { name := \"waterfall\" ++ \".\" ++ c.name, "
"contains := c.contains }) []) \"location\" ?m.109970\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:716
msgid ""
"Similarly, forgetting to add prefixes to the names of the two tables results "
"in an error on `by simp`, which should provide evidence that the schemas are "
"in fact disjoint;"
msgstr ""

#: src/dependent-types/typed-queries.md:717
msgid ""
"```leantac\n"
"open Query in\n"
"def example2 :=\n"
"  let mountains := table mountainDiary\n"
"  let waterfalls := table waterfallDiary\n"
"  mountains.product waterfalls (by simp)\n"
"    |>.select (.eq (c! \"mountain.location\") (c! \"waterfall.location\"))\n"
"    |>.project [⟨\"mountain.name\", .string⟩, ⟨\"waterfall.name\", .string⟩] "
"(by repeat constructor)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:726
msgid "However, the error message is similarly unhelpful:"
msgstr ""

#: src/dependent-types/typed-queries.md:734
msgid ""
"Lean's macro system contains everything needed not only to provide a "
"convenient syntax for queries, but also to arrange for the error messages to "
"be helpful. Unfortunately, it is beyond the scope of this book to provide a "
"description of implementing languages with Lean macros. An indexed family "
"such as `Query` is probably best as the core of a typed database interaction "
"library, rather than its user interface."
msgstr ""

#: src/dependent-types/typed-queries.md:740
msgid "Dates"
msgstr ""

#: src/dependent-types/typed-queries.md:742
msgid ""
"Define a structure to represent dates. Add it to the `DBType` universe and "
"update the rest of the code accordingly. Provide the extra `DBExpr` "
"constructors that seem to be necessary."
msgstr ""

#: src/dependent-types/typed-queries.md:744
msgid "Nullable Types"
msgstr ""

#: src/dependent-types/typed-queries.md:746
msgid ""
"Add support for nullable columns to the query language by representing "
"database types with the following structure:"
msgstr ""

#: src/dependent-types/typed-queries.md:759
msgid ""
"Use this type in place of `DBType` in `Column` and `DBExpr`, and look up "
"SQL's rules for `NULL` and comparison operators to determine the types of "
"`DBExpr`'s constructors."
msgstr ""

#: src/dependent-types/typed-queries.md:761
msgid "Experimenting with Tactics"
msgstr ""

#: src/dependent-types/typed-queries.md:763
msgid ""
"What is the result of asking Lean to find values of the following types "
"using `by repeat constructor`? Explain why each gives the result that it "
"does."
msgstr ""

#: src/dependent-types/typed-queries.md:764
#: src/programs-proofs/special-types.md:42
msgid "`Nat`"
msgstr ""

#: src/dependent-types/typed-queries.md:765
msgid "`List Nat`"
msgstr ""

#: src/dependent-types/typed-queries.md:766
msgid "`Vect Nat 4`"
msgstr ""

#: src/dependent-types/typed-queries.md:767
msgid "`Row []`"
msgstr ""

#: src/dependent-types/typed-queries.md:768
msgid "`Row [⟨\"price\", .int⟩]`"
msgstr ""

#: src/dependent-types/typed-queries.md:769
msgid "`Row peak`"
msgstr ""

#: src/dependent-types/typed-queries.md:770
msgid "`HasCol [⟨\"price\", .int⟩, ⟨\"price\", .int⟩] \"price\" .int`"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:3
msgid ""
"The distinction between indices and parameters of an inductive type is more "
"than just a way to describe arguments to the type that either vary or do not "
"between the constructors. Whether an argument to an inductive type is a "
"parameter or an index also matters when it comes time to determine the "
"relationships between their universe levels. In particular, an inductive "
"type may have the same universe level as a parameter, but it must be in a "
"larger universe than its indices. This restriction is necessary to ensure "
"that Lean can be used as a theorem prover as well as a programming "
"language—without it, Lean's logic would be inconsistent. Experimenting with "
"error messages is a good way to illustrate these rules, as well as the "
"precise rules that determine whether an argument to a type is a parameter or "
"an index."
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:9
msgid ""
"Generally speaking, the definition of an inductive type takes its parameters "
"before a colon and its indices after the colon. Parameters are given names "
"like function arguments, whereas indices only have their types described. "
"This can be seen in the definition of `Vect`:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:17
msgid ""
"In this definition, `α` is a parameter and the `Nat` is an index. Parameters "
"may be referred to throughout the definition (for example, `Vect.cons` uses "
"`α` for the type of its first argument), but they must always be used "
"consistently. Because indices are expected to change, they are assigned "
"individual values at each constructor, rather than being provided as "
"arguments at the top of the datatype definition."
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:22
msgid "A very simple datatype with a parameter is `WithParameter`:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:27
msgid ""
"The universe level `u` can be used for both the parameter and for the "
"inductive type itself, illustrating that parameters do not increase the "
"universe level of a datatype. Similarly, when there are multiple parameters, "
"the inductive type receives whichever universe level is greater:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:33
msgid ""
"Because parameters do not increase the universe level of a datatype, they "
"can be more convenient to work with. Lean attempts to identify arguments "
"that are described like indices (after the colon), but used like parameters, "
"and turn them into parameters: Both of the following inductive datatypes "
"have their parameter written after the colon:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:45
msgid ""
"When a parameter is not named in the initial datatype declaration, different "
"names may be used for it in each constructor, so long as they are used "
"consistently. The following declaration is accepted:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:52
msgid ""
"However, this flexibility does not extend to datatypes that explicitly "
"declare the names of their parameters:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:64
msgid "Similarly, attempting to name an index results in an error:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:77
msgid ""
"Using an appropriate universe level and placing the index after the colon "
"results in a declaration that is acceptable:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:85
msgid ""
"Even though Lean can sometimes determine that an argument after the colon in "
"an inductive type declaration is a parameter when it is used consistently in "
"all constructors, all parameters are still required to come before all "
"indices. Attempting to place a parameter after an index results in the "
"argument being considered an index itself, which would require the universe "
"level of the datatype to increase:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:101
msgid ""
"Parameters need not be types. This example shows that ordinary datatypes "
"such as `Nat` may be used as parameters:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:113
msgid "Using the `n` as suggested causes the declaration to be accepted:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:122
msgid ""
"What can be concluded from these experiments? The rules of parameters and "
"indices are as follows:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:124
msgid "Parameters must be used identically in each constructor's type."
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:125
msgid "All parameters must come before all indices."
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:126
msgid ""
"The universe level of the datatype being defined must be at least as large "
"as the largest parameter, and strictly larger than the largest index."
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:127
msgid ""
"Named arguments written before the colon are always parameters, while "
"arguments after the colon are typically indices. Lean may determine that the "
"usage of arguments after the colon makes them into parameters if they are "
"used consistently in all constructors and don't come after any indices."
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:129
msgid ""
"When in doubt, the Lean command `#print` can be used to check how many of a "
"datatype's arguments are parameters. For example, for `Vect`, it points out "
"that the number of parameters is 1:"
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:142
msgid ""
"It is worth thinking about which arguments should be parameters and which "
"should be indices when choosing the order of arguments to a datatype. Having "
"as many arguments as possible be parameters helps keep universe levels under "
"control, which can make a complicated program easier to type check. One way "
"to make this possible is to ensure that all parameters come before all "
"indices in the argument list."
msgstr ""

#: src/dependent-types/indices-parameters-universes.md:146
msgid ""
"Additionally, even though Lean is capable of determining that arguments "
"after the colon are nonetheless parameters by their usage, it's a good idea "
"to write parameters with explicit names. This makes the intention clear to "
"readers, and it causes Lean to report an error if the argument is mistakenly "
"used inconsistently across the constructors."
msgstr ""

#: src/dependent-types/pitfalls.md:3
msgid ""
"The flexibility of dependent types allows more useful programs to be "
"accepted by a type checker, because the language of types is expressive "
"enough to describe variations that less-expressive type systems cannot. At "
"the same time, the ability of dependent types to express very fine-grained "
"specifications allows more buggy programs to be rejected by a type checker. "
"This power comes at a cost."
msgstr ""

#: src/dependent-types/pitfalls.md:7
msgid ""
"The close coupling between the internals of type-returning functions such as "
"`Row` and the types that they produce is an instance of a bigger difficulty: "
"the distinction between the interface and the implementation of functions "
"begins to break down when functions are used in types. Normally, all "
"refactorings are valid as long as they don't change the type signature or "
"input-output behavior of a function. Functions can be rewritten to use more "
"efficient algorithms and data structures, bugs can be fixed, and code "
"clarity can be improved without breaking client code. When the function is "
"used in a type, however, the internals of the function's implementation "
"become part of the type, and thus part of the _interface_ to another program."
msgstr ""

#: src/dependent-types/pitfalls.md:12
msgid ""
"As an example, take the following two implementations of addition on `Nat`. "
"`Nat.plusL` is recursive on its first argument:"
msgstr ""

#: src/dependent-types/pitfalls.md:19
msgid "`Nat.plusR`, on the other hand, is recursive on its second argument:"
msgstr ""

#: src/dependent-types/pitfalls.md:25
msgid ""
"Both implementations of addition are faithful to the underlying mathematical "
"concept, and they thus return the same result when given the same arguments."
msgstr ""

#: src/dependent-types/pitfalls.md:27
msgid ""
"However, these two implementations present quite different interfaces when "
"they are used in types. As an example, take a function that appends two "
"`Vect`s. This function should return a `Vect` whose length is the sum of the "
"length of the arguments. Because `Vect` is essentially a `List` with a more "
"informative type, it makes sense to write the function just as one would for "
"`List.append`, with pattern matching and recursion on the first argument. "
"Starting with a type signature and initial pattern match pointing at "
"placeholders yields two messages:"
msgstr ""

#: src/dependent-types/pitfalls.md:37
msgid ""
"The first message, in the `nil` case, states that the placeholder should be "
"replaced by a `Vect` with length `plusL 0 k`:"
msgstr ""

#: src/dependent-types/pitfalls.md:46
msgid ""
"The second message, in the `cons` case, states that the placeholder should "
"be replaced by a `Vect` with length `plusL (n✝ + 1) k`:"
msgstr ""

#: src/dependent-types/pitfalls.md:57
msgid ""
"The symbol after `n`, called a _dagger_, is used to indicate names that Lean "
"has internally invented. Behind the scenes, pattern matching on the first "
"`Vect` implicitly caused the value of the first `Nat` to be refined as well, "
"because the index on the constructor `cons` is `n + 1`, with the tail of the "
"`Vect` having length `n`. Here, `n✝` represents the `Nat` that is one less "
"than the argument `n`."
msgstr ""

#: src/dependent-types/pitfalls.md:61
msgid "Definitional Equality"
msgstr ""

#: src/dependent-types/pitfalls.md:63
msgid ""
"In the definition of `plusL`, there is a pattern case `0, k => k`. This "
"applies in the length used in the first placeholder, so another way to write "
"the underscore's type `Vect α (Nat.plusL 0 k)` is `Vect α k`. Similarly, "
"`plusL` contains a pattern case `n + 1, k => plusN n k + 1`. This means that "
"the type of the second underscore can be equivalently written `Vect α (plusL "
"n✝ k + 1)`."
msgstr ""

#: src/dependent-types/pitfalls.md:68
msgid ""
"To expose what is going on behind the scenes, the first step is to write the "
"`Nat` arguments explicitly, which also results in daggerless error messages "
"because the names are now written explicitly in the program:"
msgstr ""

#: src/dependent-types/pitfalls.md:92
msgid ""
"Annotating the underscores with the simplified versions of the types does "
"not introduce a type error, which means that the types as written in the "
"program are equivalent to the ones that Lean found on its own:"
msgstr ""

#: src/dependent-types/pitfalls.md:117
msgid ""
"The first case demands a `Vect α k`, and `ys` has that type. This is "
"parallel to the way that appending the empty list to any other list returns "
"that other list. Refining the definition with `ys` instead of the first "
"underscore yields a program with only one remaining underscore to be filled "
"out:"
msgstr ""

#: src/dependent-types/pitfalls.md:136
msgid ""
"Something very important has happened here. In a context where Lean expected "
"a `Vect α (Nat.plusL 0 k)`, it received a `Vect α k`. However, `Nat.plusL` "
"is not an `abbrev`, so it may seem like it shouldn't be running during type "
"checking. Something else is happening."
msgstr ""

#: src/dependent-types/pitfalls.md:141
msgid ""
"The key to understanding what's going on is that Lean doesn't just expand "
"`abbrev`s while type checking. It can also perform computation while "
"checking whether two types are equivalent to one another, such that any "
"expression of one type can be used in a context that expects the other type. "
"This property is called _definitional equality_, and it is subtle."
msgstr ""

#: src/dependent-types/pitfalls.md:145
msgid ""
"Certainly, two types that are written identically are considered to be "
"definitionally equal—`Nat` and `Nat` or `List String` and `List String` "
"should be considered equal. Any two concrete types built from different "
"datatypes are not equal, so `List Nat` is not equal to `Int`. Additionally, "
"types that differ only by renaming internal names are equal, so `(n : Nat) → "
"Vect String n` is the same as `(k : Nat) → Vect String k`. Because types can "
"contain ordinary data, definitional equality must also describe when data "
"are equal. Uses of the same constructors are equal, so `0` equals `0` and "
"`[5, 3, 1]` equals `[5, 3, 1]`."
msgstr ""

#: src/dependent-types/pitfalls.md:151
msgid ""
"Types contain more than just function arrows, datatypes, and constructors, "
"however. They also contain _variables_ and _functions_. Definitional "
"equality of variables is relatively simple: each variable is equal only to "
"itself, so `(n k : Nat) → Vect Int n` is not definitionally equal to `(n k : "
"Nat) → Vect Int k`. Functions, on the other hand, are more complicated. "
"While mathematics considers two functions to be equal if they have identical "
"input-output behavior, there is no efficient algorithm to check that, and "
"the whole point of definitional equality is for Lean to check whether two "
"types are interchangeable. Instead, Lean considers functions to be "
"definitionally equal either when they are both `fun`\\-expressions with "
"definitionally equal bodies. In other words, two functions must use _the "
"same algorithm_ that calls _the same helpers_ to be considered "
"definitionally equal. This is not typically very helpful, so definitional "
"equality of functions is mostly used when the exact same defined function "
"occurs in two types."
msgstr ""

#: src/dependent-types/pitfalls.md:160
msgid ""
"When functions are _called_ in a type, checking definitional equality may "
"involve reducing the function call. The type `Vect String (1 + 4)` is "
"definitionally equal to the type `Vect String (3 + 2)` because `1 + 4` is "
"definitionally equal to `3 + 2`. To check their equality, both are reduced "
"to `5`, and then the constructor rule can be used five times. Definitional "
"equality of functions applied to data can be checked first by seeing if "
"they're already the same—there's no need to reduce `[\"a\", \"b\"] ++ "
"[\"c\"]` to check that it's equal to `[\"a\", \"b\"] ++ [\"c\"]`, after all. "
"If not, the function is called and replaced with its value, and the value "
"can then be checked."
msgstr ""

#: src/dependent-types/pitfalls.md:166
msgid ""
"Not all function arguments are concrete data. For example, types may contain "
"`Nat`s that are not built from the `zero` and `succ` constructors. In the "
"type `(n : Nat) → Vect String n`, the variable `n` is a `Nat`, but it is "
"impossible to know _which_ `Nat` it is before the function is called. "
"Indeed, the function may be called first with `0`, and then later with `17`, "
"and then again with `33`. As seen in the definition of `appendL`, variables "
"with type `Nat` may also be passed to functions such as `plusL`. Indeed, the "
"type `(n : Nat) → Vect String n` is definitionally equal to the type `(n : "
"Nat) → Vect String (Nat.plusL 0 n)`."
msgstr ""

#: src/dependent-types/pitfalls.md:173
msgid ""
"The reason that `n` and `Nat.plusL 0 n` are definitionally equal is that "
"`plusL`'s pattern match examines its _first_ argument. This is problematic: "
"`(n : Nat) → Vect String n` is _not_ definitionally equal to `(n : Nat) → "
"Vect String (Nat.plusL n 0)`, even though zero should be both a left and a "
"right identity of addition. This happens because pattern matching gets stuck "
"when it encounters variables. Until the actual value of `n` becomes known, "
"there is no way to know which case of `Nat.plusL n 0` should be selected."
msgstr ""

#: src/dependent-types/pitfalls.md:178
msgid ""
"The same issue appears with the `Row` function in the query example. The "
"type `Row (c :: cs)` does not reduce to any datatype because the definition "
"of `Row` has separate cases for singleton lists and lists with at least two "
"entries. In other words, it gets stuck when trying to match the variable "
"`cs` against concrete `List` constructors. This is why almost every function "
"that takes apart or constructs a `Row` needs to match the same three cases "
"as `Row` itself: getting it unstuck reveals concrete types that can be used "
"for either pattern matching or constructors."
msgstr ""

#: src/dependent-types/pitfalls.md:183
msgid ""
"The missing case in `appendL` requires a `Vect α (Nat.plusL n k + 1)`. The "
"`+ 1` in the index suggests that the next step is to use `Vect.cons`:"
msgstr ""

#: src/dependent-types/pitfalls.md:200
msgid ""
"A recursive call to `appendL` can construct a `Vect` with the desired length:"
msgstr ""

#: src/dependent-types/pitfalls.md:206
msgid ""
"Now that the program is finished, removing the explicit matching on `n` and "
"`k` makes it easier to read and easier to call the function:"
msgstr ""

#: src/dependent-types/pitfalls.md:213
msgid ""
"Comparing types using definitional equality means that everything involved "
"in definitional equality, including the internals of function definitions, "
"becomes part of the _interface_ of programs that use dependent types and "
"indexed families. Exposing the internals of a function in a type means that "
"refactoring the exposed program may cause programs that use it to no longer "
"type check. In particular, the fact that `plusL` is used in the type of "
"`appendL` means that the definition of `plusL` cannot be replaced by the "
"otherwise-equivalent `plusR`."
msgstr ""

#: src/dependent-types/pitfalls.md:217
msgid "Getting Stuck on Addition"
msgstr ""

#: src/dependent-types/pitfalls.md:219
msgid ""
"What happens if append is defined with `plusR` instead? Beginning in the "
"same way, with explicit lengths and placeholder underscores in each case, "
"reveals the following useful error messages:"
msgstr ""

#: src/dependent-types/pitfalls.md:244
msgid ""
"However, attempting to place a `Vect α k` type annotation around the first "
"placeholder results in an type mismatch error:"
msgstr ""

#: src/dependent-types/pitfalls.md:258
msgid ""
"This error is pointing out that `plusR 0 k` and `k` are _not_ definitionally "
"equal."
msgstr ""

#: src/dependent-types/pitfalls.md:260
msgid "This is because `plusR` has the following definition:"
msgstr ""

#: src/dependent-types/pitfalls.md:266
msgid ""
"Its pattern matching occurs on the _second_ argument, not the first "
"argument, which means that the presence of the variable `k` in that position "
"prevents it from reducing. `Nat.add` in Lean's standard library is "
"equivalent to `plusR`, not `plusL`, so attempting to use it in this "
"definition results in precisely the same difficulties:"
msgstr ""

#: src/dependent-types/pitfalls.md:282
msgid ""
"Addition is getting _stuck_ on the variables. Getting it unstuck requires "
"[propositional "
"equality](../type-classes/standard-classes.md#equality-and-ordering)."
msgstr ""

#: src/dependent-types/pitfalls.md:285
msgid "Propositional Equality"
msgstr ""

#: src/dependent-types/pitfalls.md:287
msgid ""
"Propositional equality is the mathematical statement that two expressions "
"are equal. While definitional equality is a kind of ambient fact that Lean "
"automatically checks when required, statements of propositional equality "
"require explicit proofs. Once an equality proposition has been proved, it "
"can be used in a program to modify a type, replacing one side of the "
"equality with the other, which can unstick the type checker."
msgstr ""

#: src/dependent-types/pitfalls.md:291
msgid ""
"The reason why definitional equality is so limited is to enable it to be "
"checked by an algorithm. Propositional equality is much richer, but the "
"computer cannot in general check whether two expressions are propositionally "
"equal, though it can verify that a purported proof is in fact a proof. The "
"split between definitional and propositional equality represents a division "
"of labor between humans and machines: the most boring equalities are checked "
"automatically as part of definitional equality, freeing the human mind to "
"work on the interesting problems available in propositional equality. "
"Similarly, definitional equality is invoked automatically by the type "
"checker, while propositional equality must be specifically appealed to."
msgstr ""

#: src/dependent-types/pitfalls.md:297
msgid ""
"In [Propositions, Proofs, and Indexing](../props-proofs-indexing.md), some "
"equality statements are proved using `simp`. All of these equality "
"statements are ones in which the propositional equality is in fact already a "
"definitional equality. Typically, statements of propositional equality are "
"proved by first getting them into a form where they are either definitional "
"or close enough to existing proved equalities, and then using tools like "
"`simp` to take care of the simplified cases. The `simp` tactic is quite "
"powerful: behind the scenes, it uses a number of fast, automated tools to "
"construct a proof. A simpler tactic called `rfl` specifically uses "
"definitional equality to prove propositional equality. The name `rfl` is "
"short for _reflexivity_, which is the property of equality that states that "
"everything equals itself."
msgstr ""

#: src/dependent-types/pitfalls.md:304
msgid ""
"Unsticking `appendR` requires a proof that `k = Nat.plusR 0 k`, which is not "
"a definitional equality because `plusR` is stuck on the variable in its "
"second argument. To get it to compute, the `k` must become a concrete "
"constructor. This is a job for pattern matching."
msgstr ""

#: src/dependent-types/pitfalls.md:308
msgid ""
"In particular, because `k` could be _any_ `Nat`, this task requires a "
"function that can return evidence that `k = Nat.plusR 0 k` for _any_ `k` "
"whatsoever. This should be a function that returns a proof of equality, with "
"type `(k : Nat) → k = Nat.plusR 0 k`. Getting it started with initial "
"patterns and placeholders yields the following messages:"
msgstr ""

#: src/dependent-types/pitfalls.md:327
msgid ""
"Having refined `k` to `0` via pattern matching, the first placeholder stands "
"for evidence of a statement that does hold definitionally. The `rfl` tactic "
"takes care of it, leaving only the second placeholder:"
msgstr ""

#: src/dependent-types/pitfalls.md:335
msgid ""
"The second placeholder is a bit trickier. The expression `Nat.plusR 0 k + 1` "
"is definitionally equal to `Nat.plusR 0 (k + 1)`. This means that the goal "
"could also be written `k + 1 = Nat.plusR 0 k + 1`:"
msgstr ""

#: src/dependent-types/pitfalls.md:350
msgid ""
"Underneath the `+ 1` on each side of the equality statement is another "
"instance of what the function itself returns. In other words, a recursive "
"call on `k` would return evidence that `k = Nat.plusR 0 k`. Equality "
"wouldn't be equality if it didn't apply to function arguments.  In other "
"words, if `x = y`, then `f x = f y`. The standard library contains a "
"function `congrArg` that takes a function and an equality proof and returns "
"a new proof where the function has been applied to both sides of the "
"equality. In this case, the function is `(· + 1)`:"
msgstr ""

#: src/dependent-types/pitfalls.md:363
msgid ""
"Propositional equalities can be deployed in a program using the rightward "
"triangle operator `▸`. Given an equality proof as its first argument and "
"some other expression as its second, this operator replaces instances of the "
"left side of the equality with the right side of the equality in the second "
"argument's type. In other words, the following definition contains no type "
"errors:"
msgstr ""

#: src/dependent-types/pitfalls.md:371
msgid "The first placeholder has the expected type:"
msgstr ""

#: src/dependent-types/pitfalls.md:380
msgid "It can now be filled in with `ys`:"
msgstr ""

#: src/dependent-types/pitfalls.md:387
msgid ""
"Filling in the remaining placeholder requires unsticking another instance of "
"addition:"
msgstr ""

#: src/dependent-types/pitfalls.md:398
msgid ""
"Here, the statement to be proved is that `Nat.plusR (n + 1) k = Nat.plusR n "
"k + 1`, which can be used with `▸` to draw the `+ 1` out to the top of the "
"expression so that it matches the index of `cons`."
msgstr ""

#: src/dependent-types/pitfalls.md:400
msgid ""
"The proof is a recursive function that pattern matches on the second "
"argument to `plusR`, namely `k`. This is because `plusR` itself pattern "
"matches on its second argument, so the proof can \"unstick\" it through "
"pattern matching, exposing the computational behavior. The skeleton of the "
"proof is very similar to that of `plusR_zero_left`:"
msgstr ""

#: src/dependent-types/pitfalls.md:409
msgid ""
"The remaining case's type is definitionally equal to `Nat.plusR (n + 1) k + "
"1 = Nat.plusR n (k + 1) + 1`, so it can be solved with `congrArg`, just as "
"in `plusR_zero_left`:"
msgstr ""

#: src/dependent-types/pitfalls.md:416
msgid "This results in a finished proof:"
msgstr ""

#: src/dependent-types/pitfalls.md:423
msgid "The finished proof can be used to unstick the second case in `appendR`:"
msgstr ""

#: src/dependent-types/pitfalls.md:429
msgid ""
"When making the length arguments to `appendR` implicit again, they are no "
"longer explicitly named to be appealed to in the proofs. However, Lean's "
"type checker has enough information to fill them in automatically behind the "
"scenes, because no other values would allow the types to match:"
msgstr ""

#: src/dependent-types/pitfalls.md:437
msgid "Pros and Cons"
msgstr ""

#: src/dependent-types/pitfalls.md:439
msgid ""
"Indexed families have an important property: pattern matching on them "
"affects definitional equality. For example, in the `nil` case in a `match` "
"expression on a `Vect`, the length simply _becomes_ `0`. Definitional "
"equality can be very convenient, because it is always active and does not "
"need to be invoked explicitly."
msgstr ""

#: src/dependent-types/pitfalls.md:443
msgid ""
"However, the use of definitional equality with dependent types and pattern "
"matching has serious software engineering drawbacks. First off, functions "
"must be written especially to be used in types, and functions that are "
"convenient to use in types may not use the most efficient algorithms. Once a "
"function has been exposed through using it in a type, its implementation has "
"become part of the interface, leading to difficulties in future refactoring. "
"Secondly, definitional equality can be slow. When asked to check whether two "
"expressions are definitionally equal, Lean may need to run large amounts of "
"code if the functions in question are complicated and have many layers of "
"abstraction. Third, error messages that result from failures of definitional "
"equality are not always very easy to understand, because they may be phrased "
"in terms of the internals of functions. It is not always easy to understand "
"the provenance of the expressions in the error messages. Finally, encoding "
"non-trivial invariants in a collection of indexed families and "
"dependently-typed functions can often be brittle. It is often necessary to "
"change early definitions in a system when the exposed reduction behavior of "
"functions proves to not provide convenient definitional equalities. The "
"alternative is to litter the program with appeals to equality proofs, but "
"these can become quite unwieldy."
msgstr ""

#: src/dependent-types/pitfalls.md:454
msgid ""
"In idiomatic Lean code, indexed datatypes are not used very often. Instead, "
"subtypes and explicit propositions are typically used to enforce important "
"invariants. This approach involves many explicit proofs, and very few "
"appeals to definitional equality. As befits an interactive theorem prover, "
"Lean has been designed to make explicit proofs convenient. Generally "
"speaking, this approach should be preferred in most cases."
msgstr ""

#: src/dependent-types/pitfalls.md:460
msgid ""
"However, understanding indexed families of datatypes is important. Recursive "
"functions such as `plusR_zero_left` and `plusR_succ_left` are in fact "
"_proofs by mathematical induction_. The base case of the recursion "
"corresponds to the base case in induction, and the recursive call represents "
"an appeal to the induction hypothesis. More generally, new propositions in "
"Lean are often defined as inductive types of evidence, and these inductive "
"types usually have indices. The process of proving theorems is in fact "
"constructing expressions with these types behind the scenes, in a process "
"not unlike the proofs in this section. Also, indexed datatypes are sometimes "
"exactly the right tool for the job. Fluency in their use is an important "
"part of knowing when to use them."
msgstr ""

#: src/dependent-types/pitfalls.md:472
msgid ""
"Using a recursive function in the style of `plusR_succ_left`, prove that for "
"all `Nat`s `n` and `k`, `n.plusR k = n + k`."
msgstr ""

#: src/dependent-types/pitfalls.md:473
msgid ""
"Write a function on `Vect` for which `plusR` is more natural than `plusL`, "
"where `plusL` would require proofs to be used in the definition."
msgstr ""

#: src/dependent-types/summary.md:3
msgid "Dependent Types"
msgstr ""

#: src/dependent-types/summary.md:5
msgid ""
"Dependent types, where types contain non-type code such as function calls "
"and ordinary data constructors, lead to a massive increase in the expressive "
"power of a type system. The ability to _compute_ a type from the _value_ of "
"an argument means that the return type of a function can vary based on which "
"argument is provided. This can be used, for example, to have the result type "
"of a database query depend on the database's schema and the specific query "
"issued, without needing any potentially-failing cast operations on the "
"result of the query. When the query changes, so does the type that results "
"from running it, enabling immediate compile-time feedback."
msgstr ""

#: src/dependent-types/summary.md:10
msgid ""
"When a function's return type depends on a value, analyzing the value with "
"pattern matching can result in the type being _refined_, as a variable that "
"stands for a value is replaced by the constructors in the pattern. The type "
"signature of a function documents the way that the return type depends on "
"the argument value, and pattern matching then explains how the return type "
"can be fulfilled for each potential argument."
msgstr ""

#: src/dependent-types/summary.md:13
msgid ""
"Ordinary code that occurs in types is run during type checking, though "
"`partial` functions that might loop infinitely are not called. Mostly, this "
"computation follows the rules of ordinary evaluation that were introduced in "
"[the very beginning of this book](../getting-to-know/evaluating.md), with "
"expressions being progressively replaced by their values until a final value "
"is found. Computation during type checking has an important difference from "
"run-time computation: some values in types may be _variables_ whose values "
"are not yet known. In these cases, pattern-matching gets \"stuck\" and does "
"not proceed until or unless a particular constructor is selected, e.g. by "
"pattern matching. Type-level computation can be seen as a kind of partial "
"evaluation, where only the parts of the program that are sufficiently known "
"need to be evaluated and other parts are left alone."
msgstr ""

#: src/dependent-types/summary.md:19
msgid "The Universe Pattern"
msgstr ""

#: src/dependent-types/summary.md:21
msgid ""
"A common pattern when working with dependent types is to section off some "
"subset of the type system. For example, a database query library might be "
"able to return varying-length strings, fixed-length strings, or numbers in "
"certain ranges, but it will never return a function, a user-defined "
"datatype, or an `IO` action. A domain-specific subset of the type system can "
"be defined by first defining a datatype with constructors that match the "
"structure of the desired types, and then defining a function that interprets "
"values from this datatype into honest-to-goodness types. The constructors "
"are referred to as _codes_ for the types in question, and the entire pattern "
"is sometimes referred to as a _universe à la Tarski_, or just as a "
"_universe_ when context makes it clear that universes such as `Type 3` or "
"`Prop` are not what's meant."
msgstr ""

#: src/dependent-types/summary.md:26
msgid ""
"Custom universes are an alternative to defining a type class with instances "
"for each type of interest. Type classes are extensible, but extensibility is "
"not always desired. Defining a custom universe has a number of advantages "
"over using the types directly:"
msgstr ""

#: src/dependent-types/summary.md:29
msgid ""
"Generic operations that work for _any_ type in the universe, such as "
"equality testing and serialization, can be implemented by recursion on codes."
msgstr ""

#: src/dependent-types/summary.md:30
msgid ""
"The types accepted by external systems can be represented precisely, and the "
"definition of the code datatype serves to document what can be expected."
msgstr ""

#: src/dependent-types/summary.md:31
msgid ""
"Lean's pattern matching completeness checker ensures that no codes are "
"forgotten, while solutions based on type classes defer missing instance "
"errors to client code."
msgstr ""

#: src/dependent-types/summary.md:36
msgid ""
"Datatypes can take two separate kinds of arguments: _parameters_ are "
"identical in each constructor of the datatype, while _indices_ may vary "
"between constructors. For a given choice of index, only some constructors of "
"the datatype are available. As an example, `Vect.nil` is available only when "
"the length index is `0`, and `Vect.cons` is available only when the length "
"index is `n+1` for some `n`. While parameters are typically written as named "
"arguments before the colon in a datatype declaration, and indices as "
"arguments in a function type after the colon, Lean can infer when an "
"argument after the colon is used as a parameter."
msgstr ""

#: src/dependent-types/summary.md:41
msgid ""
"Indexed families allow the expression of complicated relationships between "
"data, all checked by the compiler. The datatype's invariants can be encoded "
"directly, and there is no way to violate them, not even temporarily. "
"Informing the compiler about the datatype's invariants brings a major "
"benefit: the compiler can now inform the programmer about what must be done "
"to satisfy them. The strategic use of compile-time errors, especially those "
"resulting from underscores, can make it possible to offload some of the "
"programming thought process to Lean, freeing up the programmer's mind to "
"worry about other things."
msgstr ""

#: src/dependent-types/summary.md:46
msgid ""
"Encoding invariants using indexed families can lead to difficulties. First "
"off, each invariant requires its own datatype, which then requires its own "
"support libraries. `List.append` and `Vect.append` are not interchangeable, "
"after all. This can lead to code duplication. Secondly, convenient use of "
"indexed families requires that the recursive structure of functions used in "
"types match the recursive structure of the programs being type checked. "
"Programming with indexed families is the art of arranging for the right "
"coincidences to occur. While it's possible to work around missing "
"coincidences with appeals to equality proofs, it is difficult, and it leads "
"to programs littered with cryptic justifications. Thirdly, running "
"complicated code on large values during type checking can lead to "
"compile-time slowdowns. Avoiding these slowdowns for complicated programs "
"can require specialized techniques."
msgstr ""

#: src/dependent-types/summary.md:56
msgid "Definitional and Propositional Equality"
msgstr ""

#: src/dependent-types/summary.md:58
msgid ""
"Lean's type checker must, from time to time, check whether two types should "
"be considered interchangeable. Because types can contain arbitrary programs, "
"it must therefore be able to check arbitrary programs for equality. However, "
"there is no efficient algorithm to check arbitrary programs for "
"fully-general mathematical equality. To work around this, Lean contains two "
"notions of equality:"
msgstr ""

#: src/dependent-types/summary.md:63
msgid ""
"_Definitional equality_ is an underapproximation of equality that "
"essentially checks for equality of syntactic representation modulo "
"computation and renaming of bound variables. Lean automatically checks for "
"definitional equality in situations where it is required."
msgstr ""

#: src/dependent-types/summary.md:65
msgid ""
"_Propositional equality_ must be explicitly proved and explicitly invoked by "
"the programmer. In return, Lean automatically checks that the proofs are "
"valid and that the invocations accomplish the right goal."
msgstr ""

#: src/dependent-types/summary.md:67
msgid ""
"The two notions of equality represent a division of labor between "
"programmers and Lean itself. Definitional equality is simple, but automatic, "
"while propositional equality is manual, but expressive. Propositional "
"equality can be used to unstick otherwise-stuck programs in types."
msgstr ""

#: src/dependent-types/summary.md:71
msgid ""
"However, the frequent use of propositional equality to unstick type-level "
"computation is typically a code smell. It typically means that coincidences "
"were not well-engineered, and it's usually a better idea to either redesign "
"the types and indices or to use a different technique to enforce the needed "
"invariants. When propositional equality is instead used to prove that a "
"program meets a specification, or as part of a subtype, there is less reason "
"to be suspicious."
msgstr ""

#: src/tactics-induction-proofs.md:3
msgid "A Note on Proofs and User Interfaces"
msgstr ""

#: src/tactics-induction-proofs.md:5
msgid ""
"This book presents the process of writing proofs as if they are written in "
"one go and submitted to Lean, which then replies with error messages that "
"describe what remains to be done. The actual process of interacting with "
"Lean is much more pleasant. Lean provides information about the proof as the "
"cursor is moved through it and there are a number of interactive features "
"that make proving easier. Please consult the documentation of your Lean "
"development environment for more information."
msgstr ""

#: src/tactics-induction-proofs.md:10
msgid ""
"The approach in this book that focuses on incrementally building a proof and "
"showing the messages that result demonstrates the kinds of interactive "
"feedback that Lean provides while writing a proof, even though it is much "
"slower than the process used by experts. At the same time, seeing incomplete "
"proofs evolve towards completeness is a useful perspective on proving. As "
"your skill in writing proofs increases, Lean's feedback will come to feel "
"less like errors and more like support for your own thought processes. "
"Learning the interactive approach is very important."
msgstr ""

#: src/tactics-induction-proofs.md:15
msgid "Recursion and Induction"
msgstr ""

#: src/tactics-induction-proofs.md:17
msgid ""
"The functions `plusR_succ_left` and `plusR_zero_left` from the preceding "
"chapter can be seen from two perspectives. On the one hand, they are "
"recursive functions that build up evidence for a proposition, just as other "
"recursive functions might construct a list, a string, or any other data "
"structure. On the other, they also correspond to proofs by _mathematical "
"induction_."
msgstr ""

#: src/tactics-induction-proofs.md:21
msgid ""
"Mathematical induction is a proof technique where a statement is proven for "
"_all_ natural numbers in two steps:"
msgstr ""

#: src/tactics-induction-proofs.md:22
msgid ""
"The statement is shown to hold for \\\\( 0 \\\\). This is called the _base "
"case_."
msgstr ""

#: src/tactics-induction-proofs.md:23
msgid ""
"Under the assumption that the statement holds for some arbitrarily chosen "
"number \\\\( n \\\\), it is shown to hold for \\\\( n + 1 \\\\). This is "
"called the _induction step_. The assumption that the statement holds for "
"\\\\( n \\\\) is called the _induction hypothesis_."
msgstr ""

#: src/tactics-induction-proofs.md:25
msgid ""
"Because it's impossible to check the statement for _every_ natural number, "
"induction provides a means of writing a proof that could, in principle, be "
"expanded to any particular natural number. For example, if a concrete proof "
"were desired for the number 3, then it could be constructed by using first "
"the base case and then the induction step three times, to show the statement "
"for 0, 1, 2, and finally 3. Thus, it proves the statement for all natural "
"numbers."
msgstr ""

#: src/tactics-induction-proofs.md:29
msgid "The Induction Tactic"
msgstr ""

#: src/tactics-induction-proofs.md:31
msgid ""
"Writing proofs by induction as recursive functions that use helpers such as "
"`congrArg` does not always do a good job of expressing the intentions behind "
"the proof. While recursive functions indeed have the structure of induction, "
"they should probably be viewed as an _encoding_ of a proof. Furthermore, "
"Lean's tactic system provides a number of opportunities to automate the "
"construction of a proof that are not available when writing the recursive "
"function explicitly. Lean provides an induction _tactic_ that can carry out "
"an entire proof by induction in a single tactic block. Behind the scenes, "
"Lean constructs the recursive function that corresponds the use of induction."
msgstr ""

#: src/tactics-induction-proofs.md:37
msgid ""
"To prove `plusR_zero_left` with the induction tactic, begin by writing its "
"signature (using `theorem`, because this really is a proof). Then, use `by "
"induction k` as the body of the definition:"
msgstr ""

#: src/tactics-induction-proofs.md:43
msgid "The resulting message states that there are two goals:"
msgstr ""

#: src/tactics-induction-proofs.md:54
msgid ""
"A tactic block is a program that is run while the Lean type checker "
"processes a file, somewhat like a much more powerful C preprocessor macro. "
"The tactics generate the actual program."
msgstr ""

#: src/tactics-induction-proofs.md:57
msgid ""
"In the tactic language, there can be a number of goals. Each goal consists "
"of a type together with some assumptions. These are analogous to using "
"underscores as placeholders—the type in the goal represents what is to be "
"proved, and the assumptions represent what is in-scope and can be used. In "
"the case of the goal `case zero`, there are no assumptions and the type is "
"`Nat.zero = Nat.plusR 0 Nat.zero`—this is the theorem statement with `0` "
"instead of `k`. In the goal `case succ`, there are two assumptions, named "
"`n✝` and `n_ih✝`. Behind the scenes, the `induction` tactic creates a "
"dependent pattern match that refines the overall type, and `n✝` represents "
"the argument to `Nat.succ` in the pattern. The assumption `n_ih✝` represents "
"the result of calling the generated function recursively on `n✝`. Its type "
"is the overall type of the theorem, just with `n✝` instead of `k`. The type "
"to be fulfilled as part of the goal `case succ` is the overall theorem "
"statement, with `Nat.succ n✝` instead of `k`."
msgstr ""

#: src/tactics-induction-proofs.md:67
msgid ""
"The two goals that result from the use of the `induction` tactic correspond "
"to the base case and the induction step in the description of mathematical "
"induction. The base case is `case zero`. In `case succ`, `n_ih✝` corresponds "
"to the induction hypothesis, while the whole of `case succ` is the induction "
"step."
msgstr ""

#: src/tactics-induction-proofs.md:71
msgid ""
"The next step in writing the proof is to focus on each of the two goals in "
"turn. Just as `pure ()` can be used in a `do` block to indicate \"do "
"nothing\", the tactic language has a statement `skip` that also does "
"nothing. This can be used when Lean's syntax requires a tactic, but it's not "
"yet clear which one should be used. Adding `with` to the end of the "
"`induction` statement provides a syntax that is similar to pattern matching:"
msgstr ""

#: src/tactics-induction-proofs.md:81
msgid ""
"Each of the two `skip` statements has a message associated with it. The "
"first shows the base case:"
msgstr ""

#: src/tactics-induction-proofs.md:88
msgid "The second shows the induction step:"
msgstr ""

#: src/tactics-induction-proofs.md:96
msgid ""
"In the induction step, the inaccessible names with daggers have been "
"replaced with the names provided after `succ`, namely `n` and `ih`."
msgstr ""

#: src/tactics-induction-proofs.md:98
msgid ""
"The cases after `induction ... with` are not patterns: they consist of the "
"name of a goal followed by zero or more names. The names are used for "
"assumptions introduced in the goal; it is an error to provide more names "
"than the goal introduces:"
msgstr ""

#: src/tactics-induction-proofs.md:110
msgid ""
"Focusing on the base case, the `rfl` tactic works just as well inside of the "
"`induction` tactic as it does in a recursive function:"
msgstr ""

#: src/tactics-induction-proofs.md:117
msgid ""
"In the recursive function version of the proof, a type annotation made the "
"expected type something that was easier to understand. In the tactic "
"language, there are a number of specific ways to transform a goal to make it "
"easier to solve. The `unfold` tactic replaces a defined name with its "
"definition:"
msgstr ""

#: src/tactics-induction-proofs.md:127
msgid ""
"Now, the right-hand side of the equality in the goal has become `Nat.plusR 0 "
"n + 1` instead of `Nat.plusR 0 (Nat.succ n)`:"
msgstr ""

#: src/tactics-induction-proofs.md:136
msgid ""
"Instead of appealing to functions like `congrArg` and operators like `▸`, "
"there are tactics that allow equality proofs to be used to transform proof "
"goals. One of the most important is `rw`, which takes a list of equality "
"proofs and replaces the left side with the right side in the goal. This "
"almost does the right thing in `plusR_zero_left`:"
msgstr ""

#: src/tactics-induction-proofs.md:147
msgid ""
"However, the direction of the rewrite was incorrect. Replacing `n` with "
"`Nat.plusR 0 n` made the goal more complicated rather than less complicated:"
msgstr ""

#: src/tactics-induction-proofs.md:156
msgid ""
"This can be remedied by placing a left arrow before `ih` in the call to "
"`rewrite`, which instructs it to replace the right-hand side of the equality "
"with the left-hand side:"
msgstr ""

#: src/tactics-induction-proofs.md:165
msgid ""
"This rewrite makes both sides of the equation identical, and Lean takes care "
"of the `rfl` on its own. The proof is complete."
msgstr ""

#: src/tactics-induction-proofs.md:168
msgid "Tactic Golf"
msgstr ""

#: src/tactics-induction-proofs.md:170
msgid ""
"So far, the tactic language has not shown its true value. The above proof is "
"no shorter than the recursive function; it's merely written in a "
"domain-specific language instead of the full Lean language. But proofs with "
"tactics can be shorter, easier, and more maintainable. Just as a lower score "
"is better in the game of golf, a shorter proof is better in the game of "
"tactic golf."
msgstr ""

#: src/tactics-induction-proofs.md:175
msgid ""
"The induction step of `plusR_zero_left` can be proved using the "
"simplification tactic `simp`. Using `simp` on its own does not help:"
msgstr ""

#: src/tactics-induction-proofs.md:187
msgid ""
"However, `simp` can be configured to make use of a set of definitions. Just "
"like `rw`, these arguments are provided in a list. Asking `simp` to take the "
"definition of `Nat.plusR` into account leads to a simpler goal:"
msgstr ""

#: src/tactics-induction-proofs.md:204
msgid ""
"In particular, the goal is now identical to the induction hypothesis. In "
"addition to automatically proving simple equality statements, the simplifier "
"automatically replaces goals like `Nat.succ A = Nat.succ B` with `A = B`. "
"Because the induction hypothesis `ih` has exactly the right type, the "
"`exact` tactic can indicate that it should be used:"
msgstr ""

#: src/tactics-induction-proofs.md:216
msgid ""
"However, the use of `exact` is somewhat fragile. Renaming the induction "
"hypothesis, which may happen while \"golfing\" the proof, would cause this "
"proof to stop working. The `assumption` tactic solves the current goal if "
"_any_ of the assumptions match it:"
msgstr ""

#: src/tactics-induction-proofs.md:228
msgid ""
"This proof is no shorter than the prior proof that used unfolding and "
"explicit rewriting. However, a series of transformations can make it much "
"shorter, taking advantage of the fact that `simp` can solve many kinds of "
"goals. The first step is to drop the `with` at the end of `induction`. For "
"structured, readable proofs, the `with` syntax is convenient. It complains "
"if any cases are missing, and it shows the structure of the induction "
"clearly. But shortening proofs can often require a more liberal approach."
msgstr ""

#: src/tactics-induction-proofs.md:235
msgid ""
"Using `induction` without `with` simply results in a proof state with two "
"goals. The `case` tactic can be used to select one of them, just as in the "
"branches of the `induction ... with` tactic. In other words, the following "
"proof is equivalent to the prior proof:"
msgstr ""

#: src/tactics-induction-proofs.md:247
msgid ""
"In a context with a single goal (namely, `k = Nat.plusR 0 k`), the "
"`induction k` tactic yields two goals. In general, a tactic will either fail "
"with an error or take a goal and transform it into zero or more new goals. "
"Each new goal represents what remains to be proved. If the result is zero "
"goals, then the tactic was a success, and that part of the proof is done."
msgstr ""

#: src/tactics-induction-proofs.md:252
msgid ""
"The `<;>` operator takes two tactics as arguments, resulting in a new "
"tactic. `T1 <;> T2` applies `T1` to the current goal, and then applies `T2` "
"in _all_ goals created by `T1`. In other words, `<;>` enables a general "
"tactic that can solve many kinds of goals to be used on multiple new goals "
"all at once. One such general tactic is `simp`."
msgstr ""

#: src/tactics-induction-proofs.md:257
msgid ""
"Because `simp` can both complete the proof of the base case and make "
"progress on the proof of the induction step, using it with `induction` and "
"`<;>` shortens the proof:"
msgstr ""

#: src/tactics-induction-proofs.md:262
msgid "This results in only a single goal, the transformed induction step:"
msgstr ""

#: src/tactics-induction-proofs.md:270
msgid "Running `assumption` in this goal completes the proof:"
msgstr ""

#: src/tactics-induction-proofs.md:275
msgid ""
"Here, `exact` would not have been possible, because `ih` was never "
"explicitly named."
msgstr ""

#: src/tactics-induction-proofs.md:277
msgid ""
"For beginners, this proof is not easier to read. However, a common pattern "
"for expert users is to take care of a number of simple cases with powerful "
"tactics like `simp`, allowing them to focus the text of the proof on the "
"interesting cases. Additionally, these proofs tend to be more robust in the "
"face of small changes to the functions and datatypes involved in the proof. "
"The game of tactic golf is a useful part of developing good taste and style "
"when writing proofs."
msgstr ""

#: src/tactics-induction-proofs.md:282
msgid "Induction on Other Datatypes"
msgstr ""

#: src/tactics-induction-proofs.md:284
msgid ""
"Mathematical induction proves a statement for natural numbers by providing a "
"base case for `Nat.zero` and an induction step for `Nat.succ`. The principle "
"of induction is also valid for other datatypes. Constructors without "
"recursive arguments form the base cases, while constructors with recursive "
"arguments form the induction steps. The ability to carry out proofs by "
"induction is the very reason why they are called _inductive_ datatypes."
msgstr ""

#: src/tactics-induction-proofs.md:289
msgid ""
"One example of this is induction on binary trees. Induction on binary trees "
"is a proof technique where a statement is proven for _all_ binary trees in "
"two steps:"
msgstr ""

#: src/tactics-induction-proofs.md:291
msgid ""
"The statement is shown to hold for `BinTree.leaf`. This is called the base "
"case."
msgstr ""

#: src/tactics-induction-proofs.md:292
msgid ""
"Under the assumption that the statement holds for some arbitrarily chosen "
"trees `l` and `r`, it is shown to hold for `BinTree.branch l x r`, where `x` "
"is an arbitrarily-chosen new data point. This is called the _induction "
"step_. The assumptions that the statement holds for `l` and `r` are called "
"the _induction hypotheses_."
msgstr ""

#: src/tactics-induction-proofs.md:294
msgid "`BinTree.count` counts the number of branches in a tree:"
msgstr ""

#: src/tactics-induction-proofs.md:301
msgid ""
"[Mirroring a tree](monads/conveniences.md#leading-dot-notation) does not "
"change the number of branches in it. This can be proven using induction on "
"trees. The first step is to state the theorem and invoke `induction`:"
msgstr ""

#: src/tactics-induction-proofs.md:310
msgid ""
"The base case states that counting the mirror of a leaf is the same as "
"counting the leaf:"
msgstr ""

#: src/tactics-induction-proofs.md:317
msgid ""
"The induction step allows the assumption that mirroring the left and right "
"subtrees won't affect their branch counts, and requests a proof that "
"mirroring a branch with these subtrees also preserves the overall branch "
"count:"
msgstr ""

#: src/tactics-induction-proofs.md:331
msgid ""
"The base case is true because mirroring `leaf` results in `leaf`, so the "
"left and right sides are definitionally equal. This can be expressed by "
"using `simp` with instructions to unfold `BinTree.mirror`:"
msgstr ""

#: src/tactics-induction-proofs.md:339
msgid ""
"In the induction step, nothing in the goal immediately matches the induction "
"hypotheses. Simplifying using the definitions of `BinTree.count` and "
"`BinTree.mirror` reveals the relationship:"
msgstr ""

#: src/tactics-induction-proofs.md:359
msgid ""
"Both induction hypotheses can be used to rewrite the left-hand side of the "
"goal into something almost like the right-hand side:"
msgstr ""

#: src/tactics-induction-proofs.md:380
msgid ""
"The `simp_arith` tactic, a version of `simp` that can use additional "
"arithmetic identities, is enough to prove this goal, yielding:"
msgstr ""

#: src/tactics-induction-proofs.md:391
msgid ""
"In addition to definitions to be unfolded, the simplifier can also be passed "
"names of equality proofs to use as rewrites while it simplifies proof goals. "
"`BinTree.mirror_count` can also be written:"
msgstr ""

#: src/tactics-induction-proofs.md:400
msgid ""
"As proofs grow more complicated, listing assumptions by hand can become "
"tedious. Furthermore, manually writing assumption names can make it more "
"difficult to re-use proof steps for multiple subgoals. The argument `*` to "
"`simp` or `simp_arith` instructs them to use _all_ assumptions while "
"simplifying or solving the goal. In other words, the proof could also be "
"written:"
msgstr ""

#: src/tactics-induction-proofs.md:411
msgid ""
"Because both branches are using the simplifier, the proof can be reduced to:"
msgstr ""

#: src/tactics-induction-proofs.md:420
msgid "Prove `plusR_succ_left` using the `induction ... with` tactic."
msgstr ""

#: src/tactics-induction-proofs.md:421
msgid "Rewrite the proof of `plus_succ_left` to use `<;>` in a single line."
msgstr ""

#: src/tactics-induction-proofs.md:422
msgid ""
"Prove that appending lists is associative using induction on lists: `theorem "
"List.append_assoc (xs ys zs : List α) : xs ++ (ys ++ zs) = (xs ++ ys) ++ zs`"
msgstr ""

#: src/programs-proofs.md:3
msgid ""
"This chapter is about programming. Programs need to compute the correct "
"result, but they also need to do so efficiently. To write efficient "
"functional programs, it's important to know both how to use data structures "
"appropriately and how to think about the time and space needed to run a "
"program."
msgstr ""

#: src/programs-proofs.md:7
msgid ""
"This chapter is also about proofs. One of the most important data structures "
"for efficient programming in Lean is the array, but safe use of arrays "
"requires proving that array indices are in bounds. Furthermore, most "
"interesting algorithms on arrays do not follow the pattern of structural "
"recursion—instead, they iterate over the array. While these algorithms "
"terminate, Lean will not necessarily be able to automatically check this. "
"Proofs can be used to demonstrate why a program terminates."
msgstr ""

#: src/programs-proofs.md:13
msgid ""
"Rewriting programs to make them faster often results in code that is more "
"difficult to understand. Proofs can also show that two programs always "
"compute the same answers, even if they do so with different algorithms or "
"implementation techniques. In this way, the slow, straightforward program "
"can serve as a specification for the fast, complicated version."
msgstr ""

#: src/programs-proofs.md:17
msgid ""
"Combining proofs and programming allows programs to be both safe and "
"efficient. Proofs allow elision of run-time bounds checks, they render many "
"tests unnecessary, and they provide an extremely high level of confidence in "
"a program without introducing any runtime performance overhead. However, "
"proving theorems about programs can be time consuming and expensive, so "
"other tools are often more economical."
msgstr ""

#: src/programs-proofs.md:21
msgid ""
"Interactive theorem proving is a deep topic. This chapter provides only a "
"taste, oriented towards the proofs that come up in practice while "
"programming in Lean. Most interesting theorems are not closely related to "
"programming. Please refer to [Next Steps](next-steps.md) for a list of "
"resources for learning more. Just as when learning programming, however, "
"there's no substitute for hands-on experience when learning to write "
"proofs—it's time to get started!"
msgstr ""

#: src/programs-proofs/tail-recursion.md:3
msgid ""
"While Lean's `do`\\-notation makes it possible to use traditional loop "
"syntax such as `for` and `while`, these constructs are translated behind the "
"scenes to invocations of recursive functions. In most programming languages, "
"recursive functions have a key disadvantage with respect to loops: loops "
"consume no space on the stack, while recursive functions consume stack space "
"proportional to the number of recursive calls. Stack space is typically "
"limited, and it is often necessary to take algorithms that are naturally "
"expressed as recursive functions and rewrite them as loops paired with an "
"explicit mutable heap-allocated stack."
msgstr ""

#: src/programs-proofs/tail-recursion.md:7
msgid ""
"In functional programming, the opposite is typically true. Programs that are "
"naturally expressed as mutable loops may consume stack space, while "
"rewriting them to recursive functions can cause them to run quickly. This is "
"due to a key aspect of functional programming languages: _tail-call "
"elimination_. A tail call is a call from one function to another that can be "
"compiled to an ordinary jump, replacing the current stack frame rather than "
"pushing a new one, and tail-call elimination is the process of implementing "
"this transformation."
msgstr ""

#: src/programs-proofs/tail-recursion.md:12
msgid ""
"Tail-call elimination is not just merely an optional optimization. Its "
"presence is a fundamental part of being able to write efficient functional "
"code. For it to be useful, it must be reliable. Programmers must be able to "
"reliably identify tail calls, and they must be able to trust that the "
"compiler will eliminate them."
msgstr ""

#: src/programs-proofs/tail-recursion.md:17
msgid "The function `NonTail.sum` adds the contents of a list of `Nat`s:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:23
msgid ""
"Applying this function to the list `[1, 2, 3]` results in the following "
"sequence of evaluation steps:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:41
msgid ""
"In the evaluation steps, parentheses indicate recursive calls to "
"`NonTail.sum`. In other words, to add the three numbers, the program must "
"first check that the list is non-empty. To add the head of the list (`1`) to "
"the sum of the tail of the list, it is first necessary to compute the sum of "
"the tail of the list:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:47
msgid ""
"But to compute the sum of the tail of the list, the program must check "
"whether it is empty. It is not - the tail is itself a list with `2` at its "
"head. The resulting step is waiting for the return of `NonTail.sum [3]`:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:53
msgid ""
"The whole point of the run-time call stack is to keep track of the values "
"`1`, `2`, and `3` along with the instruction to add them to the result of "
"the recursive call. As recursive calls are completed, control returns to the "
"stack frame that made the call, so each step of addition is performed. "
"Storing the heads of the list and the instructions to add them is not free; "
"it takes space proportional to the length of the list."
msgstr ""

#: src/programs-proofs/tail-recursion.md:57
msgid "The function `Tail.sum` also adds the contents of a list of `Nat`s:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:66
msgid ""
"Applying it to the list `[1, 2, 3]` results in the following sequence of "
"evaluation steps:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:86
msgid ""
"The internal helper function calls itself recursively, but it does so in a "
"way where nothing needs to be remembered in order to compute the final "
"result. When `Tail.sumHelper` reaches its base case, control can be returned "
"directly to `Tail.sum`, because the intermediate invocations of "
"`Tail.sumHelper` simply return the results of their recursive calls "
"unmodified. In other words, a single stack frame can be re-used for each "
"recursive invocation of `Tail.sumHelper`. Tail-call elimination is exactly "
"this re-use of the stack frame, and `Tail.sumHelper` is referred to as a "
"_tail-recursive function_."
msgstr ""

#: src/programs-proofs/tail-recursion.md:91
msgid ""
"The first argument to `Tail.sumHelper` contains all of the information that "
"would otherwise need to be tracked in the call stack—namely, the sum of the "
"numbers encountered so far. In each recursive call, this argument is updated "
"with new information, rather than adding new information to the call stack. "
"Arguments like `soFar` that replace the information from the call stack are "
"called _accumulators_."
msgstr ""

#: src/programs-proofs/tail-recursion.md:95
msgid ""
"At the time of writing and on the author's computer, `NonTail.sum` crashes "
"with a stack overflow when passed a list with 216,856 or more entries. "
"`Tail.sum`, on the other hand, can sum a list of 100,000,000 elements "
"without a stack overflow. Because no new stack frames need to be pushed "
"while running `Tail.sum`, it is completely equivalent to a `while` loop with "
"a mutable variable that holds the current list. At each recursive call, the "
"function argument on the stack is simply replaced with the next node of the "
"list."
msgstr ""

#: src/programs-proofs/tail-recursion.md:101
msgid "Tail and Non-Tail Positions"
msgstr ""

#: src/programs-proofs/tail-recursion.md:103
msgid ""
"The reason why `Tail.sumHelper` is tail recursive is that the recursive call "
"is in _tail position_. Informally speaking, a function call is in tail "
"position when the caller does not need to modify the returned value in any "
"way, but will just return it directly. More formally, tail position can be "
"defined explicitly for expressions."
msgstr ""

#: src/programs-proofs/tail-recursion.md:107
msgid ""
"If a `match`\\-expression is in tail position, then each of its branches is "
"also in tail position. Once a `match` has selected a branch, control "
"proceeds immediately to it. Similarly, both branches of an `if`\\-expression "
"are in tail position if the `if`\\-expression itself is in tail position. "
"Finally, if a `let`\\-expression is in tail position, then its body is as "
"well."
msgstr ""

#: src/programs-proofs/tail-recursion.md:112
msgid ""
"All other positions are not in tail position. The arguments to a function or "
"a constructor are not in tail position because evaluation must track the "
"function or constructor that will be applied to the argument's value. The "
"body of an inner function is not in tail position because control may not "
"even pass to it: function bodies are not evaluated until the function is "
"called. Similarly, the body of a function type is not in tail position. To "
"evaluate `E` in `(x : α) → E`, it is necessary to track that the resulting "
"type must have `(x : α) → ...` wrapped around it."
msgstr ""

#: src/programs-proofs/tail-recursion.md:118
msgid ""
"In `NonTail.sum`, the recursive call is not in tail position because it is "
"an argument to `+`. In `Tail.sumHelper`, the recursive call is in tail "
"position because it is immediately underneath a pattern match, which itself "
"is the body of the function."
msgstr ""

#: src/programs-proofs/tail-recursion.md:121
msgid ""
"At the time of writing, Lean only eliminates direct tail calls in recursive "
"functions. This means that tail calls to `f` in `f`'s definition will be "
"eliminated, but not tail calls to some other function `g`. While it is "
"certainly possible to eliminate a tail call to some other function, saving a "
"stack frame, this is not yet implemented in Lean."
msgstr ""

#: src/programs-proofs/tail-recursion.md:125
#: src/programs-proofs/tail-recursion-proofs.md:472
msgid "Reversing Lists"
msgstr ""

#: src/programs-proofs/tail-recursion.md:127
msgid ""
"The function `NonTail.reverse` reverses lists by appending the head of each "
"sub-list to the end of the result:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:133
msgid "Using it to reverse `[1, 2, 3]` yields the following sequence of steps:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:152
msgid ""
"The tail-recursive version uses `x :: ·` instead of `· ++ [x]` on the "
"accumulator at each step:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:161
msgid ""
"This is because the context saved in each stack frame while computing with "
"`NonTail.reverse` is applied beginning at the base case. Each \"remembered\" "
"piece of context is executed in last-in, first-out order. On the other hand, "
"the accumulator-passing version modifies the accumulator beginning from the "
"first entry in the list, rather than the original base case, as can be seen "
"in the series of reduction steps:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:177
msgid ""
"In other words, the non-tail-recursive version starts at the base case, "
"modifying the result of recursion from right to left through the list. The "
"entries in the list affect the accumulator in a first-in, first-out order. "
"The tail-recursive version with the accumulator starts at the head of the "
"list, modifying an initial accumulator value from left to right through the "
"list."
msgstr ""

#: src/programs-proofs/tail-recursion.md:181
msgid ""
"Because addition is commutative, nothing needed to be done to account for "
"this in `Tail.sum`. Appending lists is not commutative, so care must be "
"taken to find an operation that has the same effect when run in the opposite "
"direction. Appending `[x]` after the result of the recursion in "
"`NonTail.reverse` is analogous to adding `x` to the beginning of the list "
"when the result is built in the opposite order."
msgstr ""

#: src/programs-proofs/tail-recursion.md:185
msgid "Multiple Recursive Calls"
msgstr ""

#: src/programs-proofs/tail-recursion.md:187
msgid "In the definition of `BinTree.mirror`, there are two recursive calls:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:193
msgid ""
"Just as imperative languages would typically use a while loop for functions "
"like `reverse` and `sum`, they would typically use recursive functions for "
"this kind of traversal. This function cannot be straightforwardly rewritten "
"to be tail recursive using accumulator-passing style."
msgstr ""

#: src/programs-proofs/tail-recursion.md:196
msgid ""
"Typically, if more than one recursive call is required for each recursive "
"step, then it will be difficult to use accumulator-passing style. This "
"difficulty is similar to the difficulty of rewriting a recursive function to "
"use a loop and an explicit data structure, with the added complication of "
"convincing Lean that the function terminates. However, as in "
"`BinTree.mirror`, multiple recursive calls often indicate a data structure "
"that has a constructor with multiple recursive occurrences of itself. In "
"these cases, the depth of the structure is often logarithmic with respect to "
"its overall size, which makes the tradeoff between stack and heap less "
"stark. There are systematic techniques for making these functions "
"tail-recursive, such as using _continuation-passing style_, but they are "
"outside the scope of this chapter."
msgstr ""

#: src/programs-proofs/tail-recursion.md:204
msgid ""
"Translate each of the following non-tail-recursive functions into "
"accumulator-passing tail-recursive functions:"
msgstr ""

#: src/programs-proofs/tail-recursion.md:218
msgid ""
"The translation of `NonTail.filter` should result in a program that takes "
"constant stack space through tail recursion, and time linear in the length "
"of the input list. A constant factor overhead is acceptable relative to the "
"original:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:3
msgid ""
"Programs that have been rewritten to use tail recursion and an accumulator "
"can look quite different from the original program. The original recursive "
"function is often much easier to understand, but it runs the risk of "
"exhausting the stack at run time. After testing both versions of the program "
"on examples to rule out simple bugs, proofs can be used to show once and for "
"all that the programs are equivalent."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:7
msgid "Proving `sum` Equal"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:9
msgid ""
"To prove that both versions of `sum` are equal, begin by writing the theorem "
"statement with a stub proof:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:14
msgid "As expected, Lean describes an unsolved goal:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:20
msgid ""
"The `rfl` tactic cannot be applied here, because `NonTail.sum` and "
"`Tail.sum` are not definitionally equal. Functions can be equal in more ways "
"than just definitional equality, however. It is also possible to prove that "
"two functions are equal by proving that they produce equal outputs for the "
"same input. In other words, \\\\( f = g \\\\) can be proved by proving that "
"\\\\( f(x) = g(x) \\\\) for all possible inputs \\\\( x \\\\). This "
"principle is called _function extensionality_. Function extensionality is "
"exactly the reason why `NonTail.sum` equals `Tail.sum`: they both sum lists "
"of numbers."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:27
msgid ""
"In Lean's tactic language, function extensionality is invoked using "
"`funext`, followed by a name to be used for the arbitrary argument. The "
"arbitrary argument is added as an assumption to the context, and the goal "
"changes to require a proof that the functions applied to this argument are "
"equal:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:40
msgid ""
"This goal can be proved by induction on the argument `xs`. Both `sum` "
"functions return `0` when applied to the empty list, which serves as a base "
"case. Adding a number to the beginning of the input list causes both "
"functions to add that number to the result, which serves as an induction "
"step. Invoking the `induction` tactic results in two goals:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:65
msgid ""
"The base case for `nil` can be solved using `rfl`, because both functions "
"return `0` when passed the empty list:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:74
msgid ""
"The first step in solving the induction step is to simplify the goal, asking "
"`simp` to unfold `NonTail.sum` and `Tail.sum`:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:91
msgid ""
"Unfolding `Tail.sum` revealed that it immediately delegates to "
"`Tail.sumHelper`, which should also be simplified:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:100
msgid ""
"In the resulting goal, `sumHelper` has taken a step of computation and added "
"`y` to the accumulator:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:109
msgid ""
"Rewriting with the induction hypothesis removes all mentions of "
"`NonTail.sum` from the goal:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:127
msgid ""
"This new goal states that adding some number to the sum of a list is the "
"same as using that number as the initial accumulator in `sumHelper`. For the "
"sake of clarity, this new goal can be proved as a separate theorem:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:140
msgid "Once again, this is a proof by induction where the base case uses `rfl`:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:156
msgid ""
"Because this is an inductive step, the goal should be simplified until it "
"matches the induction hypothesis `ih`. Simplifying, using the definitions of "
"`Tail.sum` and `Tail.sumHelper`, results in the following:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:174
msgid ""
"Ideally, the induction hypothesis could be used to replace `Tail.sumHelper "
"(y + n) ys`, but they don't match. The induction hypothesis can be used for "
"`Tail.sumHelper n ys`, not `Tail.sumHelper (y + n) ys`. In other words, this "
"proof is stuck."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:178
msgid "A Second Attempt"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:180
msgid ""
"Rather than attempting to muddle through the proof, it's time to take a step "
"back and think. Why is it that the tail-recursive version of the function is "
"equal to the non-tail-recursive version? Fundamentally speaking, at each "
"entry in the list, the accumulator grows by the same amount as would be "
"added to the result of the recursion. This insight can be used to write an "
"elegant proof. Crucially, the proof by induction must be set up such that "
"the induction hypothesis can be applied to _any_ accumulator value."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:186
msgid ""
"Discarding the prior attempt, the insight can be encoded as the following "
"statement:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:192
msgid ""
"In this statement, it's very important that `n` is part of the type that's "
"after the colon. The resulting goal begins with `∀ (n : Nat)`, which is "
"short for \"For all `n`\":"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:199
msgid ""
"Using the induction tactic results in goals that include this \"for all\" "
"statement:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:207
msgid "In the `nil` case, the goal is:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:213
msgid ""
"For the induction step for `cons`, both the induction hypothesis and the "
"specific goal contain the \"for all `n`\":"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:222
msgid ""
"In other words, the goal has become more challenging to prove, but the "
"induction hypothesis is correspondingly more useful."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:224
msgid ""
"A mathematical proof for a statement that beings with \"for all \\\\( x "
"\\\\)\" should assume some arbitrary \\\\( x \\\\), and prove the statement. "
"\"Arbitrary\" means that no additional properties of \\\\( x \\\\) are "
"assumed, so the resulting statement will work for _any_ \\\\( x \\\\). In "
"Lean, a \"for all\" statement is a dependent function: no matter which "
"specific value it is applied to, it will return evidence of the proposition. "
"Similarly, the process of picking an arbitrary \\\\( x \\\\) is the same as "
"using `fun x => ...`. In the tactic language, this process of selecting an "
"arbitrary \\\\( x \\\\) is performed using the `intro` tactic, which "
"produces the function behind the scenes when the tactic script has "
"completed. The `intro` tactic should be provided with the name to be used "
"for this arbitrary value."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:231
msgid ""
"Using the `intro` tactic in the `nil` case removes the `∀ (n : Nat),` from "
"the goal, and adds an assumption `n : Nat`:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:245
msgid ""
"Both sides of this propositional equality are definitionally equal to `n`, "
"so `rfl` suffices:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:255
msgid "The `cons` goal also contains a \"for all\":"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:264
msgid "This suggests the use of `intro`."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:284
msgid ""
"The proof goal now contains both `NonTail.sum` and `Tail.sumHelper` applied "
"to `y :: ys`. The simplifier can make the next step more clear:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:306
msgid ""
"This goal is very close to matching the induction hypothesis. There are two "
"ways in which it does not match:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:308
msgid ""
"The left-hand side of the equation is `n + (y + NonTail.sum ys)`, but the "
"induction hypothesis needs the left-hand side to be a number added to "
"`NonTail.sum ys`. In other words, this goal should be rewritten to `(n + y) "
"+ NonTail.sum ys`, which is valid because addition of natural numbers is "
"associative."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:310
msgid ""
"When the left side has been rewritten to `(y + n) + NonTail.sum ys`, the "
"accumulator argument on the right side should be `n + y` rather than `y + n` "
"in order to match. This rewrite is valid because addition is also "
"commutative."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:313
msgid ""
"The associativity and commutativity of addition have already been proved in "
"Lean's standard library. The proof of associativity is named "
"`Nat.add_assoc`, and its type is `(n m k : Nat) → (n + m) + k = n + (m + "
"k)`, while the proof of commutativity is called `Nat.add_comm` and has type "
"`(n m : Nat) → n + m = m + n`. Normally, the `rw` tactic is provided with an "
"expression whose type is an equality. However, if the argument is instead a "
"dependent function whose return type is an equality, it attempts to find "
"arguments to the function that would allow the equality to match something "
"in the goal. There is only one opportunity to apply associativity, though "
"the direction of the rewrite must be reversed because the right side of the "
"equality in `Nat.add_assoc` is the one that matches the proof goal:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:339
msgid ""
"Rewriting directly with `Nat.add_comm`, however, leads to the wrong result. "
"The `rw` tactic guesses the wrong location for the rewrite, leading to an "
"unintended goal:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:363
msgid ""
"This can be fixed by explicitly providing `y` and `n` as arguments to "
"`Nat.add_comm`:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:386
msgid ""
"The goal now matches the induction hypothesis. In particular, the induction "
"hypothesis's type is a dependent function type. Applying `ih` to `n + y` "
"results in exactly the desired type. The `exact` tactic completes a proof "
"goal if its argument has exactly the desired type:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:403
msgid ""
"The actual proof requires only a little additional work to get the goal to "
"match the helper's type. The first step is still to invoke function "
"extensionality:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:415
msgid "The next step is unfold `Tail.sum`, exposing `Tail.sumHelper`:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:427
msgid ""
"Having done this, the types almost match. However, the helper has an "
"additional addend on the left side. In other words, the proof goal is "
"`NonTail.sum xs = Tail.sumHelper 0 xs`, but applying "
"`non_tail_sum_eq_helper_accum` to `xs` and `0` yields the type `0 + "
"NonTail.sum xs = Tail.sumHelper 0 xs`. Another standard library proof, "
"`Nat.zero_add`, has type `(n : Nat) → 0 + n = n`. Applying this function to "
"`NonTail.sum xs` results in an expression with type `0 + NonTail.sum xs = "
"NonTail.sum xs`, so rewriting from right to left results in the desired goal:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:444
msgid "Finally, the helper can be used to complete the proof:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:453
msgid ""
"This proof demonstrates a general pattern that can be used when proving that "
"an accumulator-passing tail-recursive function is equal to the "
"non-tail-recursive version. The first step is to discover the relationship "
"between the starting accumulator argument and the final result. For "
"instance, beginning `Tail.sumHelper` with an accumulator of `n` results in "
"the final sum being added to `n`, and beginning `Tail.reverseHelper` with an "
"accumulator of `ys` results in the final reversed list being prepended to "
"`ys`. The second step is to write down this relationship as a theorem "
"statement and prove it by induction. While the accumulator is always "
"initialized with some neutral value in practice, such as `0` or `[]`, this "
"more general statement that allows the starting accumulator to be any value "
"is what's needed to get a strong enough induction hypothesis. Finally, using "
"this helper theorem with the actual initial accumulator value results in the "
"desired proof. For example, in `non_tail_sum_eq_tail_sum`, the accumulator "
"is specified to be `0`. This may require rewriting the goal to make the "
"neutral initial accumulator values occur in the right place."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:466
msgid "Warming Up"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:468
msgid ""
"Write your own proofs for `Nat.zero_add`, `Nat.add_assoc`, and "
"`Nat.add_comm` using the `induction` tactic."
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:470
msgid "More Accumulator Proofs"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:474
msgid ""
"Adapt the proof for `sum` into a proof for `NonTail.reverse` and "
"`Tail.reverse`. The first step is to think about the relationship between "
"the accumulator value being passed to `Tail.reverseHelper` and the "
"non-tail-recursive reverse. Just as adding a number to the accumulator in "
"`Tail.sumHelper` is the same as adding it to the overall sum, using "
"`List.cons` to add a new entry to the accumulator in `Tail.reverseHelper` is "
"equivalent to some change to the overall result. Try three or four different "
"accumulator values with pencil and paper until the relationship becomes "
"clear. Use this relationship to prove a suitable helper theorem. Then, write "
"down the overall theorem. Because `NonTail.reverse` and `Tail.reverse` are "
"polymorphic, stating their equality requires the use of `@` to stop Lean "
"from trying to figure out which type to use for `α`. Once `α` is treated as "
"an ordinary argument, `funext` should be invoked with both `α` and `xs`:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:486
msgid "This results in a suitable goal:"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:496
msgid "Factorial"
msgstr ""

#: src/programs-proofs/tail-recursion-proofs.md:498
msgid ""
"Prove that `NonTail.factorial` from the exercises in the previous section is "
"equal to your tail-recursive solution by finding the relationship between "
"the accumulator and the result and proving a suitable helper theorem."
msgstr ""

#: src/programs-proofs/arrays-termination.md:3
msgid ""
"To write efficient code, it is important to select appropriate data "
"structures. Linked lists have their place: in some applications, the ability "
"to share the tails of lists is very important. However, most use cases for a "
"variable-length sequential collection of data are better served by arrays, "
"which have both less memory overhead and better locality."
msgstr ""

#: src/programs-proofs/arrays-termination.md:7
msgid "Arrays, however, have two drawbacks relative to lists:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:8
msgid ""
"Arrays are accessed through indexing, rather than by pattern matching, which "
"imposes [proof obligations](../props-proofs-indexing.md) in order to "
"maintain safety."
msgstr ""

#: src/programs-proofs/arrays-termination.md:9
msgid ""
"A loop that processes an entire array from left to right is a tail-recursive "
"function, but it does not have an argument that decreases on each call."
msgstr ""

#: src/programs-proofs/arrays-termination.md:11
msgid ""
"Making effective use of arrays requires knowing how to prove to Lean that an "
"array index is in bounds, and how to prove that an array index that "
"approaches the size of the array also causes the program to terminate. Both "
"of these are expressed using an inequality proposition, rather than "
"propositional equality."
msgstr ""

#: src/programs-proofs/arrays-termination.md:14
msgid "Inequality"
msgstr ""

#: src/programs-proofs/arrays-termination.md:16
msgid ""
"Because different types have different notions of ordering, inequality is "
"governed by two type classes, called `LE` and `LT`. The table in the section "
"on [standard type "
"classes](../type-classes/standard-classes.md#equality-and-ordering) "
"describes how these classes relate to the syntax:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:26
msgid ""
"In other words, a type may customize the meaning of the `<` and `≤` "
"operators, while `>` and `≥` derive their meanings from `<` and `≤`. The "
"classes `LT` and `LE` have methods that return propositions rather than "
"`Bool`s:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:36
msgid "The instance of `LE` for `Nat` delegates to `Nat.le`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:41
msgid ""
"Defining `Nat.le` requires a feature of Lean that has not yet been "
"presented: it is an inductively-defined relation."
msgstr ""

#: src/programs-proofs/arrays-termination.md:43
msgid "Inductively-Defined Propositions, Predicates, and Relations"
msgstr ""

#: src/programs-proofs/arrays-termination.md:45
msgid ""
"`Nat.le` is an _inductively-defined relation_. Just as `inductive` can be "
"used to create new datatypes, it can also be used to create new "
"propositions. When a proposition takes an argument, it is referred to as a "
"_predicate_ that may be true for some, but not all, potential arguments. "
"Propositions that take multiple arguments are called _relations_."
msgstr ""

#: src/programs-proofs/arrays-termination.md:50
msgid ""
"Each constructor of an inductively defined proposition is a way to prove it. "
"In other words, the declaration of the proposition describes the different "
"forms of evidence that it is true. A proposition with no arguments that has "
"a single constructor can be quite easy to prove:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:57
msgid "The proof consists of using its constructor:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:62
msgid ""
"In fact, the proposition `True`, which should always be easy to prove, is "
"defined just like `EasyToProve`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:68
msgid ""
"Inductively-defined propositions that don't take arguments are not nearly as "
"interesting as inductively-defined datatypes. This is because data is "
"interesting in its own right—the natural number `3` is different from the "
"number `35`, and someone who has ordered 3 pizzas will be upset if 35 arrive "
"at their door 30 minutes later. The constructors of a proposition describe "
"ways in which the proposition can be true, but once a proposition has been "
"proved, there is no need to know _which_ underlying constructors were used. "
"This is why most interesting inductively-defined types in the `Prop` "
"universe take arguments."
msgstr ""

#: src/programs-proofs/arrays-termination.md:73
msgid ""
"The inductively-defined predicate `IsThree` states that its argument is "
"three:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:78
msgid ""
"The mechanism used here is just like [indexed families such as "
"`HasCol`](../dependent-types/typed-queries.md#column-pointers), except the "
"resulting type is a proposition that can be proved rather than data that can "
"be used."
msgstr ""

#: src/programs-proofs/arrays-termination.md:80
msgid "Using this predicate, it is possible to prove that three is indeed three:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:85
msgid "Similarly, `IsFive` is a predicate that states that its argument is `5`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:91
msgid ""
"If a number is three, then the result of adding two to it should be five. "
"This can be expressed as a theorem statement:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:97
msgid "The resulting goal has a function type:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:103
msgid ""
"Thus, the `intro` tactic can be used to convert the argument into an "
"assumption:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:114
msgid ""
"Given the assumption that `n` is three, it should be possible to use the "
"constructor of `IsFive` to complete the proof:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:120
msgid "However, this results in an error:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:127
msgid ""
"This error occurs because `n + 2` is not definitionally equal to `5`. In an "
"ordinary function definition, dependent pattern matching on the assumption "
"`three` could be used to refine `n` to `3`. The tactic equivalent of "
"dependent pattern matching is `cases`, which has a syntax similar to that of "
"`induction`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:136
msgid "In the remaining case, `n` has been refined to `3`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:142
msgid ""
"Because `3 + 2` is definitionally equal to `5`, the constructor is now "
"applicable:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:150
msgid ""
"The standard false proposition `False` has no constructors, making it "
"impossible to provide direct evidence for. The only way to provide evidence "
"for `False` is if an assumption is itself impossible, similarly to how "
"`nomatch` can be used to mark code that the type system can see is "
"unreachable. As described in [the initial Interlude on "
"proofs](../props-proofs-indexing.md#connectives), the negation `Not A` is "
"short for `A → False`. `Not A` can also be written `¬A`."
msgstr ""

#: src/programs-proofs/arrays-termination.md:155
msgid "It is not the case that four is three:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:160
msgid "The initial proof goal contains `Not`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:165
msgid "The fact that it's actually a function type can be exposed using `simp`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:174
msgid ""
"Because the goal is a function type, `intro` can be used to convert the "
"argument into an assumption. There is no need to keep `simp`, as `intro` can "
"unfold the definition of `Not` itself:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:185
msgid "In this proof, the `cases` tactic solves the goal immediately:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:191
msgid ""
"Just as a pattern match on a `Vect String 2` doesn't need to include a case "
"for `Vect.nil`, a proof by cases over `IsThree 4` doesn't need to include a "
"case for `isThree`."
msgstr ""

#: src/programs-proofs/arrays-termination.md:193
msgid "Inequality of Natural Numbers"
msgstr ""

#: src/programs-proofs/arrays-termination.md:195
msgid "The definition of `Nat.le` has a parameter and an index:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:201
msgid ""
"The parameter `n` is the number that should be smaller, while the index is "
"the number that should be greater than or equal to `n`. The `refl` "
"constructor is used when both numbers are equal, while the `step` "
"constructor is used when the index is greater than `n`."
msgstr ""

#: src/programs-proofs/arrays-termination.md:204
msgid ""
"From the perspective of evidence, a proof that \\\\( n \\leq k \\\\) "
"consists of finding some number \\\\( d \\\\) such that \\\\( n + d = m "
"\\\\). In Lean, the proof then consists of a `Nat.le.refl` constructor "
"wrapped by \\\\( d \\\\) instances of `Nat.le.step`. Each `step` constructor "
"adds one to its index argument, so \\\\( d \\\\) `step` constructors adds "
"\\\\( d \\\\) to the larger number. For example, evidence that four is less "
"than or equal to seven consists of three `step`s around a `refl`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:214
msgid ""
"The strict less-than relation is defined by adding one to the number on the "
"left:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:222
msgid ""
"Evidence that four is strictly less than seven consists of two `step`'s "
"around a `refl`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:228
msgid "This is because `4 < 7` is equivalent to `5 ≤ 7`."
msgstr ""

#: src/programs-proofs/arrays-termination.md:230
#: src/programs-proofs/summary.md:72
msgid "Proving Termination"
msgstr ""

#: src/programs-proofs/arrays-termination.md:232
msgid ""
"The function `Array.map` transforms an array with a function, returning a "
"new array that contains the result of applying the function to each element "
"of the input array. Writing it as a tail-recursive function follows the "
"usual pattern of delegating to a function that passes the output array in an "
"accumulator. The accumulator is initialized with an empty array. The "
"accumulator-passing helper function also takes an argument that tracks the "
"current index into the array, which starts at `0`:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:241
msgid ""
"The helper should, at each iteration, check whether the index is still in "
"bounds. If so, it should loop again with the transformed element added to "
"the end of the accumulator and the index incremented by `1`. If not, then it "
"should terminate and return the accumulator. An initial implementation of "
"this code fails because Lean is unable to prove that the array index is "
"valid:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:265
msgid ""
"However, the conditional expression already checks the precise condition "
"that the array index's validity demands (namely, `i < arr.size`). Adding a "
"name to the `if` resolves the issue, because it adds an assumption that the "
"array indexing tactic can use:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:273
msgid ""
"Lean does not, however, accept the modified program, because the recursive "
"call is not made on an argument to one of the input constructors. In fact, "
"both the accumulator and the index grow, rather than shrinking:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:287
msgid ""
"Nevertheless, this function terminates, so simply marking it `partial` would "
"be unfortunate."
msgstr ""

#: src/programs-proofs/arrays-termination.md:289
msgid ""
"Why does `arrayMapHelper` terminate? Each iteration checks whether the index "
"`i` is still in bounds for the array `arr`. If so, `i` is incremented and "
"the loop repeats. If not, the program terminates. Because `arr.size` is a "
"finite number, `i` can be incremented only a finite number of times. Even "
"though no argument to the function decreases on each call, `arr.size - i` "
"decreases toward zero."
msgstr ""

#: src/programs-proofs/arrays-termination.md:296
msgid ""
"Lean can be instructed to use another expression for termination by "
"providing a `termination_by` clause at the end of a definition. The "
"`termination_by` clause has two components: names for the function's "
"arguments and an expression using those names that should decrease on each "
"call. For `arrayMapHelper`, the final definition looks like this:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:307
msgid ""
"A similar termination proof can be used to write `Array.find`, a function "
"that finds the first element in an array that satisfies a Boolean function "
"and returns both the element and its index:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:312
msgid ""
"Once again, the helper function terminates because `arr.size - i` decreases "
"as `i` increases:"
msgstr ""

#: src/programs-proofs/arrays-termination.md:324
msgid ""
"Not all termination arguments are as quite as simple as this one. However, "
"the basic structure of identifying some expression based on the function's "
"arguments that will decrease in each call occurs in all termination proofs. "
"Sometimes, creativity can be required in order to figure out just why a "
"function terminates, and sometimes Lean requires additional proofs in order "
"to accept the termination argument."
msgstr ""

#: src/programs-proofs/arrays-termination.md:332
msgid ""
"Implement a `ForM (Array α)` instance on arrays using a tail-recursive "
"accumulator-passing function and a `termination_by` clause."
msgstr ""

#: src/programs-proofs/arrays-termination.md:333
msgid ""
"Implement a function to reverse arrays using a tail-recursive "
"accumulator-passing function that _doesn't_ need a `termination_by` clause."
msgstr ""

#: src/programs-proofs/arrays-termination.md:334
msgid ""
"Reimplement `Array.map`, `Array.find`, and the `ForM` instance using `for "
"... in ...` loops in the identity monad and compare the resulting code."
msgstr ""

#: src/programs-proofs/arrays-termination.md:335
msgid ""
"Reimplement array reversal using a `for ... in ...` loop in the identity "
"monad. Compare it to the tail-recursive function."
msgstr ""

#: src/programs-proofs/inequalities.md:3
msgid ""
"Lean's built-in proof automation is sufficient to check that "
"`arrayMapHelper` and `findHelper` terminate. All that was needed was to "
"provide an expression whose value decreases with each recursive call. "
"However, Lean's built-in automation is not magic, and it often needs some "
"help."
msgstr ""

#: src/programs-proofs/inequalities.md:7
msgid "Merge Sort"
msgstr ""

#: src/programs-proofs/inequalities.md:9
msgid ""
"One example of a function whose termination proof is non-trivial is merge "
"sort on `List`. Merge sort consists of two phases: first, a list is split in "
"half. Each half is sorted using merge sort, and then the results are merged "
"using a function that combines two sorted lists into a larger sorted list. "
"The base cases are the empty list and the singleton list, both of which are "
"already considered to be sorted."
msgstr ""

#: src/programs-proofs/inequalities.md:14
msgid "To merge two sorted lists, there are two basic cases to consider:"
msgstr ""

#: src/programs-proofs/inequalities.md:15
msgid "If one of the input lists is empty, then the result is the other list."
msgstr ""

#: src/programs-proofs/inequalities.md:16
msgid ""
"If both lists are non-empty, then their heads should be compared. The result "
"of the function is the smaller of the two heads, followed by the result of "
"merging the remaining entries of both lists."
msgstr ""

#: src/programs-proofs/inequalities.md:18
msgid ""
"This is not structurally recursive on either list. The recursion terminates "
"because an entry is removed from one of the two lists in each recursive "
"call, but it could be either list. The `termination_by` clause uses the sum "
"of the length of both lists as a decreasing value:"
msgstr ""

#: src/programs-proofs/inequalities.md:33
msgid ""
"In addition to using the lengths of the lists, a pair that contains both "
"lists can also be provided:"
msgstr ""

#: src/programs-proofs/inequalities.md:45
msgid ""
"This works because Lean has a built-in notion of sizes of data, expressed "
"through a type class called `WellFoundedRelation`. The instance for pairs "
"automatically considers them to be smaller if either the first or the second "
"item in the pair shrinks."
msgstr ""

#: src/programs-proofs/inequalities.md:48
msgid ""
"A simple way to split a list is to add each entry in the input list to two "
"alternating output lists:"
msgstr ""

#: src/programs-proofs/inequalities.md:58
msgid ""
"Merge sort checks whether a base case has been reached. If so, it returns "
"the input list. If not, it splits the input, and merges the result of "
"sorting each half:"
msgstr ""

#: src/programs-proofs/inequalities.md:71
msgid ""
"Lean's pattern match compiler is able to tell that the assumption `h` "
"introduced by the `if` that tests whether `xs.length < 2` rules out lists "
"longer than one entry, so there is no \"missing cases\" error. However, even "
"though this program always terminates, it is not structurally recursive:"
msgstr ""

#: src/programs-proofs/inequalities.md:85
msgid ""
"The reason it terminates is that `splitList` always returns lists that are "
"shorter than its input. Thus, the length of `halves.fst` and `halves.snd` "
"are less than the length of `xs`. This can be expressed using a "
"`termination_by` clause:"
msgstr ""

#: src/programs-proofs/inequalities.md:99
msgid ""
"With this clause, the error message changes. Instead of complaining that the "
"function isn't structurally recursive, Lean instead points out that it was "
"unable to automatically prove that `(splitList xs).fst.length < xs.length`:"
msgstr ""

#: src/programs-proofs/inequalities.md:113
msgid "Splitting a List Makes it Shorter"
msgstr ""

#: src/programs-proofs/inequalities.md:115
msgid ""
"It will also be necessary to prove that `(splitList xs).snd.length < "
"xs.length`. Because `splitList` alternates between adding entries to the two "
"lists, it is easiest to prove both statements at once, so the structure of "
"the proof can follow the algorithm used to implement `splitList`. In other "
"words, it is easiest to prove that `∀(lst : List), (splitList "
"lst).fst.length < lst.length ∧ (splitList lst).snd.length < lst.length`."
msgstr ""

#: src/programs-proofs/inequalities.md:119
msgid ""
"Unfortunately, the statement is false. In particular, `splitList []` is "
"`([], [])`. Both output lists have length `0`, which is not less than `0`, "
"the length of the input list. Similarly, `splitList [\"basalt\"]` evaluates "
"to `([\"basalt\"], [])`, and `[\"basalt\"]` is not shorter than "
"`[\"basalt\"]`. However, `splitList [\"basalt\", \"granite\"]` evaluates to "
"`([\"basalt\"], [\"granite\"])`, and both of these output lists are shorter "
"than the input list."
msgstr ""

#: src/programs-proofs/inequalities.md:124
msgid ""
"It turns out that the lengths of the output lists are always less than or "
"equal to the length of the input list, but they are only strictly shorter "
"when the input list contains at least two entries. It turns out to be "
"easiest to prove the former statement, then extend it to the latter "
"statement. Begin with a theorem statement:"
msgstr ""

#: src/programs-proofs/inequalities.md:139
msgid ""
"Because `splitList` is structurally recursive on the list, the proof should "
"use induction. The structural recursion in `splitList` fits a proof by "
"induction perfectly: the base case of the induction matches the base case of "
"the recursion, and the inductive step matches the recursive call. The "
"`induction` tactic gives two goals:"
msgstr ""

#: src/programs-proofs/inequalities.md:167
msgid ""
"The goal for the `nil` case can be proved by invoking the simplifier and "
"instructing it to unfold the definition of `splitList`, because the length "
"of the empty list is less than or equal to the length of the empty list. "
"Similarly, simplifying with `splitList` in the `cons` case places `Nat.succ` "
"around the lengths in the goal:"
msgstr ""

#: src/programs-proofs/inequalities.md:188
msgid ""
"This is because the call to `List.length` consumes the head of the list `x "
":: xs`, converting it to a `Nat.succ`, in both the length of the input list "
"and the length of the first output list."
msgstr ""

#: src/programs-proofs/inequalities.md:190
msgid ""
"Writing `A ∧ B` in Lean is short for `And A B`. `And` is a structure type in "
"the `Prop` universe:"
msgstr ""

#: src/programs-proofs/inequalities.md:198
msgid ""
"In other words, a proof of `A ∧ B` consists of the `And.intro` constructor "
"applied to a proof of `A` in the `left` field and a proof of `B` in the "
"`right` field."
msgstr ""

#: src/programs-proofs/inequalities.md:200
msgid ""
"The `cases` tactic allows a proof to consider each constructor of a datatype "
"or each potential proof of a proposition in turn. It corresponds to a "
"`match` expression without recursion. Using `cases` on a structure results "
"in the structure being broken apart, with an assumption added for each field "
"of the structure, just as a pattern match expression extracts the field of a "
"structure for use in a program. Because structures have only one "
"constructor, using `cases` on a structure does not result in additional "
"goals."
msgstr ""

#: src/programs-proofs/inequalities.md:205
msgid ""
"Because `ih` is a proof of `List.length (splitList xs).fst ≤ List.length xs "
"∧ List.length (splitList xs).snd ≤ List.length xs`, using `cases ih` results "
"in an assumption that `List.length (splitList xs).fst ≤ List.length xs` and "
"an assumption that `List.length (splitList xs).snd ≤ List.length xs`:"
msgstr ""

#: src/programs-proofs/inequalities.md:228
msgid ""
"Because the goal of the proof is also an `And`, the `constructor` tactic can "
"be used to apply `And.intro`, resulting in a goal for each argument:"
msgstr ""

#: src/programs-proofs/inequalities.md:259
msgid ""
"The `left` goal is very similar to the `left✝` assumption, except the goal "
"wraps both sides of the inequality in `Nat.succ`. Likewise, the `right` goal "
"resembles the `right✝` assumption, except the goal adds a `Nat.succ` only to "
"the length of the input list. It's time to prove that these wrappings of "
"`Nat.succ` preserve the truth of the statement."
msgstr ""

#: src/programs-proofs/inequalities.md:263
msgid "Adding One to Both Sides"
msgstr ""

#: src/programs-proofs/inequalities.md:265
msgid ""
"For the `left` goal, the statement to prove is `Nat.succ_le_succ : n ≤ m → "
"Nat.succ n ≤ Nat.succ m`. In other words, if `n ≤ m`, then adding one to "
"both sides doesn't change this fact. Why is this true? The proof that `n ≤ "
"m` is a `Nat.le.refl` constructor with `m - n` instances of the "
"`Nat.le.step` constructor wrapped around it. Adding one to both sides simply "
"means that the `refl` applies to a number that's one larger than before, "
"with the same number of `step` constructors."
msgstr ""

#: src/programs-proofs/inequalities.md:271
msgid ""
"More formally, the proof is by induction on the evidence that `n ≤ m`. If "
"the evidence is `refl`, then `n = m`, so `Nat.succ n = Nat.succ m` and "
"`refl` can be used again. If the evidence is `step`, then the induction "
"hypothesis provides evidence that `Nat.succ n ≤ Nat.succ m`, and the goal is "
"to show that `Nat.succ n ≤ Nat.succ (Nat.succ m)`. This can be done by using "
"`step` together with the induction hypothesis."
msgstr ""

#: src/programs-proofs/inequalities.md:276
msgid "In Lean, the theorem statement is:"
msgstr ""

#: src/programs-proofs/inequalities.md:281
msgid "and the error message recapitulates it:"
msgstr ""

#: src/programs-proofs/inequalities.md:288
msgid ""
"The first step is to use the `intro` tactic, bringing the hypothesis that `n "
"≤ m` into scope and giving it a name:"
msgstr ""

#: src/programs-proofs/inequalities.md:300
msgid ""
"Because the proof is by induction on the evidence that `n ≤ m`, the next "
"tactic is `induction h`:"
msgstr ""

#: src/programs-proofs/inequalities.md:306
msgid "This results in two goals, once for each constructor of `Nat.le`:"
msgstr ""

#: src/programs-proofs/inequalities.md:319
msgid ""
"The goal for `refl` can itself be solved using `refl`, which the "
"`constructor` tactic selects. The goal for `step` will also require a use of "
"the `step` constructor:"
msgstr ""

#: src/programs-proofs/inequalities.md:336
msgid ""
"The goal is no longer shown using the `≤` operator, but it is equivalent to "
"the induction hypothesis `ih`. The `assumption` tactic automatically selects "
"an assumption that fulfills the goal, and the proof is complete:"
msgstr ""

#: src/programs-proofs/inequalities.md:348
msgid "Written as a recursive function, the proof is:"
msgstr ""

#: src/programs-proofs/inequalities.md:354
msgid ""
"It can be instructional to compare the tactic-based proof by induction with "
"this recursive function. Which proof steps correspond to which parts of the "
"definition?"
msgstr ""

#: src/programs-proofs/inequalities.md:357
msgid "Adding One to the Greater Side"
msgstr ""

#: src/programs-proofs/inequalities.md:359
msgid ""
"The second inequality needed to prove `splitList_shorter_le` is `∀(n m : "
"Nat), n ≤ m → n ≤ Nat.succ m`. This proof is almost identical to "
"`Nat.succ_le_succ`. Once again, the incoming assumption that `n ≤ m` "
"essentially tracks the difference between `n` and `m` in the number of "
"`Nat.le.step` constructors. Thus, the proof should add an extra "
"`Nat.le.step` in the base case. The proof can be written:"
msgstr ""

#: src/programs-proofs/inequalities.md:372
msgid ""
"To reveal what's going on behind the scenes, the `apply` and `exact` tactics "
"can be used to indicate exactly which constructor is being applied. The "
"`apply` tactic solves the current goal by applying a function or constructor "
"whose return type matches, creating new goals for each argument that was not "
"provided, while `exact` fails if any new goals would be needed:"
msgstr ""

#: src/programs-proofs/inequalities.md:382
msgid "The proof can be golfed:"
msgstr ""

#: src/programs-proofs/inequalities.md:387
msgid ""
"In this short tactic script, both goals introduced by `induction` are "
"addressed using `repeat (first | constructor | assumption)`. The tactic "
"`first | T1 | T2 | ... | Tn` means to use try `T1` through `Tn` in order, "
"using the first tactic that succeeds. In other words, `repeat (first | "
"constructor | assumption)` applies constructors as long as it can, and then "
"attempts to solve the goal using an assumption."
msgstr ""

#: src/programs-proofs/inequalities.md:391
msgid "Finally, the proof can be written as a recursive function:"
msgstr ""

#: src/programs-proofs/inequalities.md:398
msgid ""
"Each style of proof can be appropriate to different circumstances. The "
"detailed proof script is useful in cases where beginners may be reading the "
"code, or where the steps of the proof provide some kind of insight. The "
"short, highly-automated proof script is typically easier to maintain, "
"because automation is frequently both flexible and robust in the face of "
"small changes to definitions and datatypes. The recursive function is "
"typically both harder to understand from the perspective of mathematical "
"proofs and harder to maintain, but it can be a useful bridge for programmers "
"who are beginning to work with interactive theorem proving."
msgstr ""

#: src/programs-proofs/inequalities.md:403
msgid "Finishing the Proof"
msgstr ""

#: src/programs-proofs/inequalities.md:405
msgid ""
"Now that both helper theorems have been proved, the rest of "
"`splitList_shorter_le` will be completed quickly. The current proof state "
"has two goals, for the left and right sides of the `And`:"
msgstr ""

#: src/programs-proofs/inequalities.md:426
msgid ""
"The goals are named for the fields of the `And` structure. This means that "
"the `case` tactic (not to be confused with `cases`) can be used to focus on "
"each of them in turn:"
msgstr ""

#: src/programs-proofs/inequalities.md:439
msgid ""
"Instead of a single error that lists both unsolved goals, there are now two "
"messages, one on each `skip`. For the `left` goal, `Nat.succ_le_succ` can be "
"used:"
msgstr ""

#: src/programs-proofs/inequalities.md:450
msgid "In the right goal, `Nat.le_suc_of_le` fits:"
msgstr ""

#: src/programs-proofs/inequalities.md:460
msgid ""
"Both theorems include the precondition that `n ≤ m`. These can be found as "
"the `left✝` and `right✝` assumptions, which means that the `assumption` "
"tactic takes care of the final goals:"
msgstr ""

#: src/programs-proofs/inequalities.md:475
msgid ""
"The next step is to return to the actual theorem that is needed to prove "
"that merge sort terminates: that so long as a list has at least two entries, "
"both results of splitting it are strictly shorter."
msgstr ""

#: src/programs-proofs/inequalities.md:489
msgid ""
"Pattern matching works just as well in tactic scripts as it does in "
"programs. Because `lst` has at least two entries, they can be exposed with "
"`match`, which also refines the type through dependent pattern matching:"
msgstr ""

#: src/programs-proofs/inequalities.md:509
msgid ""
"Simplifying using `splitList` removes `x` and `y`, resulting in the computed "
"lengths of lists each gaining a `Nat.succ`:"
msgstr ""

#: src/programs-proofs/inequalities.md:528
msgid ""
"Replacing `simp` with `simp_arith` removes these `Nat.succ` constructors, "
"because `simp_arith` makes use of the fact that `n + 1 < m + 1` implies `n < "
"m`:"
msgstr ""

#: src/programs-proofs/inequalities.md:546
msgid ""
"This goal now matches `splitList_shorter_le`, which can be used to conclude "
"the proof:"
msgstr ""

#: src/programs-proofs/inequalities.md:557
msgid ""
"The facts needed to prove that `mergeSort` terminates can be pulled out of "
"the resulting `And`:"
msgstr ""

#: src/programs-proofs/inequalities.md:568
msgid "Merge Sort Terminates"
msgstr ""

#: src/programs-proofs/inequalities.md:570
msgid ""
"Merge sort has two recursive calls, one for each sub-list returned by "
"`splitList`. Each recursive call will require a proof that the length of the "
"list being passed to it is shorter than the length of the input list. It's "
"usually convenient to write a termination proof in two steps: first, write "
"down the propositions that will allow Lean to verify termination, and then "
"prove them. Otherwise, it's possible to put a lot of effort into proving the "
"propositions, only to find out that they aren't quite what's needed to "
"establish that the recursive calls are on smaller inputs."
msgstr ""

#: src/programs-proofs/inequalities.md:575
msgid ""
"The `sorry` tactic can prove any goal, even false ones. It isn't intended "
"for use in production code or final proofs, but it is a convenient way to "
"\"sketch out\" a proof or program ahead of time. Any definitions or theorems "
"that use `sorry` are annotated with a warning."
msgstr ""

#: src/programs-proofs/inequalities.md:579
msgid ""
"The initial sketch of `mergeSort`'s termination argument that uses `sorry` "
"can be written by copying the goals that Lean couldn't prove into "
"`have`\\-expressions. In Lean, `have` is similar to `let`. When using "
"`have`, the name is optional. Typically, `let` is used to define names that "
"refer to interesting values, while `have` is used to locally prove "
"propositions that can be found when Lean is searching for evidence that an "
"array lookup is in-bounds or that a function terminates."
msgstr ""

#: src/programs-proofs/inequalities.md:598
msgid "The warning is located on the name `mergeSort`:"
msgstr ""

#: src/programs-proofs/inequalities.md:602
msgid ""
"Because there are no errors, the proposed propositions are enough to "
"establish termination."
msgstr ""

#: src/programs-proofs/inequalities.md:604
msgid "The proofs begin by applying the helper theorems:"
msgstr ""

#: src/programs-proofs/inequalities.md:620
msgid ""
"Both proofs fail, because `splitList_shorter_fst` and "
"`splitList_shorter_snd` both require a proof that `xs.length ≥ 2`:"
msgstr ""

#: src/programs-proofs/inequalities.md:631
msgid ""
"To check that this will be enough to complete the proof, add it using "
"`sorry` and check for errors:"
msgstr ""

#: src/programs-proofs/inequalities.md:650
msgid "Once again, there is only a warning."
msgstr ""

#: src/programs-proofs/inequalities.md:655
msgid ""
"There is one promising assumption available: `h : ¬List.length xs < 2`, "
"which comes from the `if`. Clearly, if it is not the case that `xs.length < "
"2`, then `xs.length ≥ 2`. The Lean library provides this theorem under the "
"name `Nat.ge_of_not_lt`. The program is now complete:"
msgstr ""

#: src/programs-proofs/inequalities.md:680
msgid "The function can be tested on examples:"
msgstr ""

#: src/programs-proofs/inequalities.md:681
msgid ""
"```lean\n"
"#eval mergeSort [\"soapstone\", \"geode\", \"mica\", \"limestone\"]\n"
"```"
msgstr ""

#: src/programs-proofs/inequalities.md:684
msgid ""
"```output info\n"
"[\"geode\", \"limestone\", \"mica\", \"soapstone\"]\n"
"```"
msgstr ""

#: src/programs-proofs/inequalities.md:694
msgid "Division as Iterated Subtraction"
msgstr ""

#: src/programs-proofs/inequalities.md:696
msgid ""
"Just as multiplication is iterated addition and exponentiation is iterated "
"multiplication, division can be understood as iterated subtraction. The "
"[very first description of recursive functions in this "
"book](../getting-to-know/datatypes-and-patterns.md#recursive-functions) "
"presents a version of division that terminates when the divisor is not zero, "
"but that Lean does not accept. Proving that division terminates requires the "
"use of a fact about inequalities."
msgstr ""

#: src/programs-proofs/inequalities.md:700
msgid ""
"The first step is to refine the definition of division so that it requires "
"evidence that the divisor is not zero:"
msgstr ""

#: src/programs-proofs/inequalities.md:708
msgid ""
"The error message is somewhat longer, due to the additional argument, but it "
"contains essentially the same information:"
msgstr ""

#: src/programs-proofs/inequalities.md:736
msgid ""
"This definition of `div` terminates because the first argument `n` is "
"smaller on each recursive call. This can be expressed using a "
"`termination_by` clause:"
msgstr ""

#: src/programs-proofs/inequalities.md:746
msgid "Now, the error is confined to the recursive call:"
msgstr ""

#: src/programs-proofs/inequalities.md:758
msgid ""
"This can be proved using a theorem from the standard library, `Nat.sub_lt`. "
"This theorem states that `∀ {n k : Nat}, 0 < n → 0 < k → n - k < n` (the "
"curly braces indicate that `n` and `k` are implicit arguments). Using this "
"theorem requires demonstrating that both `n` and `k` are greater than zero. "
"Because `k > 0` is syntactic sugar for `0 < k`, the only necessary goal is "
"to show that `0 < n`. There are two possibilities: either `n` is `0`, or it "
"is `n' + 1` for some other `Nat` `n'`. But `n` cannot be `0`. The fact that "
"the `if` selected the second branch means that `¬ n < k`, but if `n = 0` and "
"`k > 0` then `n` must be less than `k`, which would be a contradiction. "
"This, `n = Nat.succ n'`, and `Nat.succ n'` is clearly greater than `0`."
msgstr ""

#: src/programs-proofs/inequalities.md:767
msgid "The full definition of `div`, including the termination proof, is:"
msgstr ""

#: src/programs-proofs/inequalities.md:786
msgid "Prove the following theorems:"
msgstr ""

#: src/programs-proofs/inequalities.md:788
msgid "For all natural numbers \\\\( n \\\\), \\\\( 0 \\< n + 1 \\\\)."
msgstr ""

#: src/programs-proofs/inequalities.md:789
msgid "For all natural numbers \\\\( n \\\\), \\\\( 0 \\\\leq n \\\\)."
msgstr ""

#: src/programs-proofs/inequalities.md:790
msgid ""
"For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), \\\\( (n + 1) - (k "
"+ 1) = n - k \\\\)"
msgstr ""

#: src/programs-proofs/inequalities.md:791
msgid ""
"For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), if \\\\( k \\< n "
"\\\\) then \\\\( n \\n"
"eq 0 \\\\)"
msgstr ""

#: src/programs-proofs/inequalities.md:792
msgid "For all natural numbers \\\\( n \\\\), \\\\( n - n = 0 \\\\)"
msgstr ""

#: src/programs-proofs/inequalities.md:793
msgid ""
"For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), if \\\\( n + 1 \\< "
"k \\\\) then \\\\( n \\< k \\\\)"
msgstr ""

#: src/programs-proofs/fin.md:3
msgid ""
"The `GetElem` instance for `Array` and `Nat` requires a proof that the "
"provided `Nat` is smaller than the array. In practice, these proofs often "
"end up being passed to functions along with the indices. Rather than passing "
"an index and a proof separately, a type called `Fin` can be used to bundle "
"up the index and the proof into a single value. This can make code easier to "
"read. Additionally, many of the built-in operations on arrays take their "
"index arguments as `Fin` rather than as `Nat`, so using these built-in "
"operations requires understanding how to use `Fin`."
msgstr ""

#: src/programs-proofs/fin.md:9
msgid ""
"The type `Fin n` represents numbers that are strictly less than `n`. In "
"other words, `Fin 3` describes `0`, `1`, and `2`, while `Fin 0` has no "
"values at all. The definition of `Fin` resembles `Subtype`, as a `Fin n` is "
"a structure that contains a `Nat` and a proof that it is less than `n`:"
msgstr ""

#: src/programs-proofs/fin.md:18
msgid ""
"Lean includes instances of `ToString` and `OfNat` that allow `Fin` values to "
"be conveniently used as numbers. In other words, the output of `#eval (5 : "
"Fin 8)` is `5`, rather than something like `{val := 5, isLt := _}`."
msgstr ""

#: src/programs-proofs/fin.md:21
msgid ""
"Instead of failing when the provided number is larger than the bound, the "
"`OfNat` instance for `Fin` returns a value modulo the bound. This means that "
"`#eval (45 : Fin 10)` results in `5` rather than a compile-time error."
msgstr ""

#: src/programs-proofs/fin.md:24
msgid ""
"In a return type, a `Fin` returned as a found index makes its connection to "
"the data structure in which it was found more clear. The `Array.find` in the "
"[previous section](./arrays-termination.md#proving-termination) returns an "
"index that the caller cannot immediately use to perform lookups into the "
"array, because the information about its validity has been lost. A more "
"specific type results in a value that can be used without making the program "
"significantly more complicated:"
msgstr ""

#: src/programs-proofs/fin.md:43
msgid ""
"Write a function `Fin.next? : Fin n → Option (Fin n)` that returns the next "
"largest `Fin` when it would be in bounds, or `none` if not. Check that"
msgstr ""

#: src/programs-proofs/fin.md:52
msgid "and that"
msgstr ""

#: src/programs-proofs/insertion-sort.md:3
msgid ""
"While insertion sort does not have the optimal worst-case time complexity "
"for a sorting algorithm, it still has a number of useful properties:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:4
msgid "It is simple and straightforward to implement and understand"
msgstr ""

#: src/programs-proofs/insertion-sort.md:5
msgid "It is an in-place algorithm, requiring no additional space to run"
msgstr ""

#: src/programs-proofs/insertion-sort.md:6
msgid "It is a stable sort"
msgstr ""

#: src/programs-proofs/insertion-sort.md:7
msgid "It is fast when the input is already almost sorted"
msgstr ""

#: src/programs-proofs/insertion-sort.md:9
msgid ""
"In-place algorithms are particularly useful in Lean due to the way it "
"manages memory. In some cases, operations that would normally copy an array "
"can be optimized into mutation. This includes swapping elements in an array."
msgstr ""

#: src/programs-proofs/insertion-sort.md:13
msgid ""
"Most languages and run-time systems with automatic memory management, "
"including JavaScript, the JVM, and .NET, use tracing garbage collection. "
"When memory needs to be reclaimed, the system starts at a number of _roots_ "
"(such as the call stack and global values) and then determines which values "
"can be reached by recursively chasing pointers. Any values that can't be "
"reached are deallocated, freeing memory."
msgstr ""

#: src/programs-proofs/insertion-sort.md:17
msgid ""
"Reference counting is an alternative to tracing garbage collection that is "
"used by a number of languages, including Python, Swift, and Lean. In a "
"system with reference counting, each object in memory has a field that "
"tracks how many references there are to it. When a new reference is "
"established, the counter is incremented. When a reference ceases to exist, "
"the counter is decremented. When the counter reaches zero, the object is "
"immediately deallocated."
msgstr ""

#: src/programs-proofs/insertion-sort.md:23
msgid ""
"Reference counting has one major disadvantage compared to a tracing garbage "
"collector: circular references can lead to memory leaks. If object \\\\( A "
"\\\\) references object \\\\( B \\\\) , and object \\\\( B \\\\) references "
"object \\\\( A \\\\), they will never be deallocated, even if nothing else "
"in the program references either \\\\( A \\\\) or \\\\( B \\\\). Circular "
"references result either from uncontrolled recursion or from mutable "
"references. Because Lean supports neither, it is impossible to construct "
"circular references."
msgstr ""

#: src/programs-proofs/insertion-sort.md:28
msgid ""
"Reference counting means that the Lean runtime system's primitives for "
"allocating and deallocating data structures can check whether a reference "
"count is about to fall to zero, and re-use an existing object instead of "
"allocating a new one. This is particularly important when working with large "
"arrays."
msgstr ""

#: src/programs-proofs/insertion-sort.md:32
msgid ""
"An implementation of insertion sort for Lean arrays should satisfy the "
"following criteria:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:33
msgid "Lean should accept the function without a `partial` annotation"
msgstr ""

#: src/programs-proofs/insertion-sort.md:34
msgid ""
"If passed an array to which there are no other references, it should modify "
"the array in-place rather than allocating a new one"
msgstr ""

#: src/programs-proofs/insertion-sort.md:36
msgid ""
"The first criterion is easy to check: if Lean accepts the definition, then "
"it is satisfied. The second, however, requires a means of testing it. Lean "
"provides a built-in function called `dbgTraceIfShared` with the following "
"signature:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:45
msgid ""
"It takes a string and a value as arguments, and prints a message that uses "
"the string to standard error if the value has more than one reference, "
"returning the value. This is not, strictly speaking, a pure function. "
"However, it is intended to be used only during development to check that a "
"function is in fact able to re-use memory rather than allocating and copying."
msgstr ""

#: src/programs-proofs/insertion-sort.md:49
msgid ""
"When learning to use `dbgTraceIfShared`, it's important to know that `#eval` "
"will report that many more values are shared than in compiled code. This can "
"be confusing. It's important to build an executable with `lake` rather than "
"experimenting in an editor."
msgstr ""

#: src/programs-proofs/insertion-sort.md:53
msgid ""
"Insertion sort consists of two loops. The outer loop moves a pointer from "
"left to right across the array to be sorted. After each iteration, the "
"region of the array to the left of the pointer is sorted, while the region "
"to the right may not yet be sorted. The inner loop takes the element pointed "
"to by the pointer and moves it to the left until the appropriate location "
"has been found and the loop invariant has been restored. In other words, "
"each iteration inserts the next element of the array into the appropriate "
"location in the sorted region."
msgstr ""

#: src/programs-proofs/insertion-sort.md:59
msgid "The Inner Loop"
msgstr ""

#: src/programs-proofs/insertion-sort.md:61
msgid ""
"The inner loop of insertion sort can be implemented as a tail-recursive "
"function that takes the array and the index of the element being inserted as "
"arguments. The element being inserted is repeatedly swapped with the element "
"to its left until either the element to the left is smaller or the beginning "
"of the array is reached. The inner loop is structurally recursive on the "
"`Nat` that is inside the `Fin` used to index into the array:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:76
msgid ""
"If the index `i` is `0`, then the element being inserted into the sorted "
"region has reached the beginning of the region and is the smallest. If the "
"index is `i' + 1`, then the element at `i'` should be compared to the "
"element at `i`. Note that while `i` is a `Fin arr.size`, `i'` is just a "
"`Nat` because it results from the `val` field of `i`. It is thus necessary "
"to prove that `i' < arr.size` before `i'` can be used to index into `arr`."
msgstr ""

#: src/programs-proofs/insertion-sort.md:81
msgid ""
"Omitting the `have`\\-expression with the proof that `i' < arr.size` reveals "
"the following goal:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:93
msgid ""
"The hint `Nat.lt_of_succ_lt` is a theorem from Lean's standard library. Its "
"signature, found by `#check Nat.lt_of_succ_lt`, is"
msgstr ""

#: src/programs-proofs/insertion-sort.md:98
msgid ""
"In other words, it states that if `n + 1 < m`, then `n < m`. The `*` passed "
"to `simp` causes it to combine `Nat.lt_of_succ_lt` with the `isLt` field "
"from `i` to get the final proof."
msgstr ""

#: src/programs-proofs/insertion-sort.md:101
msgid ""
"Having established that `i'` can be used to look up the element to the left "
"of the element being inserted, the two elements are looked up and compared.  "
"If the element to the left is less than or equal to the element being "
"inserted, then the loop is finished and the invariant has been restored. If "
"the element to the left is greater than the element being inserted, then the "
"elements are swapped and the inner loop begins again. `Array.swap` takes "
"both of its indices as `Fin`s, and the `by assumption` that establishes that "
"`i' < arr.size` makes use of the `have`. The index to be examined on the "
"next round through the inner loop is also `i'`, but `by assumption` is not "
"sufficient in this case. This is because the proof was written for the "
"original array `arr`, not the result of swapping two elements. The `simp` "
"tactic's database contains the fact that swapping two elements of an array "
"doesn't change its size, and the `[*]` argument instructs it to additionally "
"use the assumption introduced by `have`."
msgstr ""

#: src/programs-proofs/insertion-sort.md:109
msgid "The Outer Loop"
msgstr ""

#: src/programs-proofs/insertion-sort.md:111
msgid ""
"The outer loop of insertion sort moves the pointer from left to right, "
"invoking `insertSorted` at each iteration to insert the element at the "
"pointer into the correct position in the array. The basic form of the loop "
"resembles the implementation of `Array.map`:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:120
msgid ""
"The resulting error is also the same as the error that occurs without a "
"`termination_by` clause on `Array.map`, because there is no argument that "
"decreases at every recursive call:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:134
msgid ""
"Before constructing the termination proof, it can be convenient to test the "
"definition with a `partial` modifier to make sure that it returns the "
"expected answers:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:148
msgid ""
"```lean\n"
"#eval insertionSortLoop #[\"metamorphic\", \"igneous\", \"sedentary\"] 0\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:151
msgid ""
"```output info\n"
"#[\"igneous\", \"metamorphic\", \"sedentary\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:155
msgid "Termination"
msgstr ""

#: src/programs-proofs/insertion-sort.md:157
msgid ""
"Once again, the function terminates because the difference between the index "
"and the size of the array being processed decreases on each recursive call. "
"This time, however, Lean does not accept the `termination_by`:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:179
msgid ""
"The problem is that Lean has no way to know that `insertSorted` returns an "
"array that's the same size as the one it is passed. In order to prove that "
"`insertionSortLoop` terminates, it is necessary to first prove that "
"`insertSorted` doesn't change the size of the array. Copying the unproved "
"termination condition from the error message to the function and \"proving\" "
"it with `sorry` allows the function to be temporarily accepted:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:196
msgid ""
"Because `insertSorted` is structurally recursive on the index of the element "
"being inserted, the proof should be by induction on the index. In the base "
"case, the array is returned unchanged, so its length certainly does not "
"change. For the inductive step, the induction hypothesis is that a recursive "
"call on the next smaller index will not change the length of the array. "
"There are two cases two consider: either the element has been fully inserted "
"into the sorted region and the array is returned unchanged, in which case "
"the length is also unchanged, or the element is swapped with the next one "
"before the recursive call. However, swapping two elements in an array "
"doesn't change the size of it, and the induction hypothesis states that the "
"recursive call with the next index returns an array that's the same size as "
"its argument. Thus, the size remains unchanged."
msgstr ""

#: src/programs-proofs/insertion-sort.md:203
msgid ""
"Translating this English-language theorem statement to Lean and proceeding "
"using the techniques from this chapter is enough to prove the base case and "
"make progress in the inductive step:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:214
msgid ""
"The simplification using `insertSorted` in the inductive step revealed the "
"pattern match in `insertSorted`:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:241
msgid ""
"When faced with a goal that includes `if` or `match`, the `split` tactic "
"(not to be confused with the `split` function used in the definition of "
"merge sort) replaces the goal with one new goal for each path of control "
"flow:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:253
msgid ""
"Additionally, each new goal has an assumption that indicates which branch "
"led to that goal, named `heq✝` in this case:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:302
msgid ""
"Rather than write proofs for both simple cases, adding `<;> try rfl` after "
"`split` causes the two straightforward cases to disappear immediately, "
"leaving only a single goal:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:339
msgid ""
"Unfortunately, the induction hypothesis is not strong enough to prove this "
"goal. The induction hypothesis states that calling `insertSorted` on `arr` "
"leaves the size unchanged, but the proof goal is to show that the result of "
"the recursive call with the result of swapping leaves the size unchanged. "
"Successfully completing the proof requires an induction hypothesis that "
"works for _any_ array that is passed to `insertSorted` together with the "
"smaller index as an argument"
msgstr ""

#: src/programs-proofs/insertion-sort.md:343
msgid ""
"It is possible to get a strong induction hypothesis by using the "
"`generalizing` option to the `induction` tactic. This option brings "
"additional assumptions from the context into the statement that's used to "
"generate the base case, the induction hypothesis, and the goal to be shown "
"in the inductive step. Generalizing over `arr` leads to a stronger "
"hypothesis:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:357
msgid ""
"In the resulting goal, `arr` is now part of a \"for all\" statement in the "
"inductive hypothesis:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:386
msgid ""
"However, this whole proof is beginning to get unmanageable. The next step "
"would be to introduce a variable standing for the length of the result of "
"swapping, show that it is equal to `arr.size`, and then show that this "
"variable is also equal to the length of the array that results from the "
"recursive call. These equality statement can then be chained together to "
"prove the goal. It's much easier, however, to carefully reformulate the "
"theorem statement such that the induction hypothesis is automatically strong "
"enough and the variables are already introduced. The reformulated statement "
"reads:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:397
msgid ""
"This version of the theorem statement is easier to prove for a few reasons:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:398
msgid ""
"Rather than bundling up the index and the proof of its validity in a `Fin`, "
"the index comes before the array. This allows the induction hypothesis to "
"naturally generalize over the array and the proof that `i` is in bounds."
msgstr ""

#: src/programs-proofs/insertion-sort.md:400
msgid ""
"An abstract length `len` is introduced to stand for `array.size`. Proof "
"automation is often better at working with explicit statements of equality."
msgstr ""

#: src/programs-proofs/insertion-sort.md:403
msgid ""
"The resulting proof state shows the statement that will be used to generate "
"the induction hypothesis, as well as the base case and the goal of the "
"inductive step:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:413
msgid ""
"Compare the statement with the goals that result from the `induction` tactic:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:422
msgid ""
"In the base case, each occurrence of `i` has been replaced by `0`. Using "
"`intro` to introduce each assumption and then simplifying using "
"`insertSorted` will prove the goal, because `insertSorted` at index `zero` "
"returns its argument unchanged:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:433
msgid ""
"In the inductive step, the induction hypothesis has exactly the right "
"strength. It will be useful for _any_ array, so long as that array has "
"length `len`:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:448
msgid "In the base case, `simp` reduces the goal to `arr.size = len`:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:470
msgid ""
"This can be proved using the assumption `hLen`. Adding the `*` parameter to "
"`simp` instructs it to additionally use assumptions, which solves the goal:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:483
msgid ""
"In the inductive step, introducing assumptions and simplifying the goal "
"results once again in a goal that contains a pattern match:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:524
msgid ""
"Using the `split` tactic results in one goal for each pattern. Once again, "
"the first two goals result from branches without recursive calls, so the "
"induction hypothesis is not necessary:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:593
msgid ""
"Running `try assumption` in each goal that results from `split` eliminates "
"both of the non-recursive goals:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:634
msgid ""
"The new formulation of the proof goal, in which a constant `len` is used for "
"the lengths of all the arrays involved in the recursive function, falls "
"nicely within the kinds of problems that `simp` can solve. This final proof "
"goal can be solved by `simp [*]`, because the assumptions that relate the "
"array's length to `len` are important:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:651
msgid ""
"Finally, because `simp [*]` can use assumptions, the `try assumption` line "
"can be replaced by `simp [*]`, shortening the proof:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:666
msgid ""
"This proof can now be used to replace the `sorry` in `insertionSortLoop`. "
"Providing `arr.size` as the `len` argument to the theorem causes the final "
"conclusion to be `(insertSorted arr ⟨i, isLt⟩).size = arr.size`, so the "
"rewrite ends with a very manageable proof goal:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:687
msgid ""
"The proof `Nat.sub_succ_lt_self` is part of Lean's standard library. It's "
"type is `∀ (a i : Nat), i < a → a - (i + 1) < a - i`, which is exactly "
"what's needed:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:702
msgid "The Driver Function"
msgstr ""

#: src/programs-proofs/insertion-sort.md:704
msgid ""
"Insertion sort itself calls `insertionSortLoop`, initializing the index that "
"demarcates the sorted region of the array from the unsorted region to `0`:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:710
msgid "A few quick tests show the function is at least not blatantly wrong:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:717
msgid ""
"```lean\n"
"#eval insertionSort #[ \"quartz\", \"marble\", \"granite\", \"hematite\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:720
msgid ""
"```output info\n"
"#[\"granite\", \"hematite\", \"marble\", \"quartz\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:724
msgid "Is This Really Insertion Sort?"
msgstr ""

#: src/programs-proofs/insertion-sort.md:726
msgid ""
"Insertion sort is _defined_ to be an in-place sorting algorithm. What makes "
"it useful, despite its quadratic worst-case run time, is that it is a stable "
"sorting algorithm that doesn't allocate extra space and that handles "
"almost-sorted data efficiently. If each iteration of the inner loop "
"allocated a new array, then the algorithm wouldn't _really_ be insertion "
"sort."
msgstr ""

#: src/programs-proofs/insertion-sort.md:730
msgid ""
"Lean's array operations, such as `Array.set` and `Array.swap`, check whether "
"the array in question has a reference count that is greater than one. If so, "
"then the array is visible to multiple parts of the code, which means that it "
"must be copied. Otherwise, Lean would no longer be a pure functional "
"language. However, when the reference count is exactly one, there are no "
"other potential observers of the value. In these cases, the array primitives "
"mutate the array in place. What other parts of the program don't know can't "
"hurt them."
msgstr ""

#: src/programs-proofs/insertion-sort.md:737
msgid ""
"Lean's proof logic works at the level of pure functional programs, not the "
"underlying implementation. This means that the best way to discover whether "
"a program unnecessarily copies data is to test it. Adding calls to "
"`dbgTraceIfShared` at each point where mutation is desired causes the "
"provided message to be printed to `stderr` when the value in question has "
"more than one reference."
msgstr ""

#: src/programs-proofs/insertion-sort.md:741
msgid ""
"Insertion sort has precisely one place that is at risk of copying rather "
"than mutating: the call to `Array.swap`. Replacing `arr.swap ⟨i', by "
"assumption⟩ i` with `((dbgTraceIfShared \"array to swap\" arr).swap ⟨i', by "
"assumption⟩ i)` causes the program to emit `shared RC array to swap` "
"whenever it is unable to mutate the array. However, this change to the "
"program changes the proofs as well, because now there's a call to an "
"additional function. Because `dbgTraceIfShared` returns its second argument "
"directly, adding it to the calls to `simp` is enough to fix the proofs."
msgstr ""

#: src/programs-proofs/insertion-sort.md:746
msgid "The complete instrumented code for insertion sort is:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:747
msgid ""
"```leantacnorfl\n"
"def insertSorted [Ord α] (arr : Array α) (i : Fin arr.size) : Array α :=\n"
"  match i with\n"
"  | ⟨0, _⟩ => arr\n"
"  | ⟨i' + 1, _⟩ =>\n"
"    have : i' < arr.size := by\n"
"      simp [Nat.lt_of_succ_lt, *]\n"
"    match Ord.compare arr[i'] arr[i] with\n"
"    | .lt | .eq => arr\n"
"    | .gt =>\n"
"      insertSorted\n"
"        ((dbgTraceIfShared \"array to swap\" arr).swap ⟨i', by assumption⟩ "
"i)\n"
"        ⟨i', by simp [dbgTraceIfShared, *]⟩\n"
"\n"
"theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :\n"
"    (arr : Array α) → (isLt : i < arr.size) → (arr.size = len) →\n"
"    (insertSorted arr ⟨i, isLt⟩).size = len := by\n"
"  induction i with\n"
"  | zero =>\n"
"    intro arr isLt hLen\n"
"    simp [insertSorted, *]\n"
"  | succ i' ih =>\n"
"    intro arr isLt hLen\n"
"    simp [insertSorted, dbgTraceIfShared]\n"
"    split <;> simp [*]\n"
"\n"
"def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=\n"
"  if h : i < arr.size then\n"
"    have : (insertSorted arr ⟨i, h⟩).size - (i + 1) < arr.size - i := by\n"
"      rw [insert_sorted_size_eq arr.size i arr h rfl]\n"
"      simp [Nat.sub_succ_lt_self, *]\n"
"    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)\n"
"  else\n"
"    arr\n"
"termination_by insertionSortLoop arr i => arr.size - i\n"
"\n"
"def insertionSort [Ord α] (arr : Array α) : Array α :=\n"
"  insertionSortLoop arr 0\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:787
msgid ""
"A bit of cleverness is required to check whether the instrumentation "
"actually works. First off, the Lean compiler aggressively optimizes function "
"calls away when all their arguments are known at compile time. Simply "
"writing a program that applies `insertionSort` to a large array is not "
"sufficient, because the resulting compiled code may contain only the sorted "
"array as a constant. The easiest way to ensure that the compiler doesn't "
"optimize away the sorting routine is to read the array from `stdin`. "
"Secondly, the compiler performs dead code elimination. Adding extra `let`s "
"to the program won't necessarily result in more references in running code "
"if the `let`\\-bound variables are never used. To ensure that the extra "
"reference is not eliminated entirely, it's important to ensure that the "
"extra reference is somehow used."
msgstr ""

#: src/programs-proofs/insertion-sort.md:795
msgid ""
"The first step in testing the instrumentation is to write `getLines`, which "
"reads an array of lines from standard input:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:807
msgid ""
"`IO.FS.Stream.getLine` returns a complete line of text, including the "
"trailing newline. It returns `\"\"` when the end-of-file marker has been "
"reached."
msgstr ""

#: src/programs-proofs/insertion-sort.md:810
msgid ""
"Next, two separate `main` routines are needed. Both read the array to be "
"sorted from standard input, ensuring that the calls to `insertionSort` won't "
"be replaced by their return values at compile time. Both then print to the "
"console, ensuring that the calls to `insertionSort` won't be optimized away "
"entirely. One of them prints only the sorted array, while the other prints "
"both the sorted array and the original array. The second function should "
"trigger a warning that `Array.swap` had to allocate a new array:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:815
msgid ""
"```lean\n"
"def mainUnique : IO Unit := do\n"
"  let lines ← getLines\n"
"  for line in insertionSort lines do\n"
"    IO.println line\n"
"\n"
"def mainShared : IO Unit := do\n"
"  let lines ← getLines\n"
"  IO.println \"--- Sorted lines: ---\"\n"
"  for line in insertionSort lines do\n"
"    IO.println line\n"
"\n"
"  IO.println \"\"\n"
"  IO.println \"--- Original data: ---\"\n"
"  for line in lines do\n"
"    IO.println line\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:833
msgid ""
"The actual `main` simply selects one of the two main actions based on the "
"provided command-line arguments:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:834
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"  match args with\n"
"  | [\"--shared\"] => mainShared; pure 0\n"
"  | [\"--unique\"] => mainUnique; pure 0\n"
"  | _ =>\n"
"    IO.println \"Expected single argument, either \\\"--shared\\\" or "
"\\\"--unique\\\"\"\n"
"    pure 1\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:844
msgid "Running it with no arguments produces the expected usage information:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:845
msgid ""
"```\n"
"$ sort\n"
"Expected single argument, either \"--shared\" or \"--unique\"\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:850
msgid "The file `test-data` contains the following rocks:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:863
msgid ""
"Using the instrumented insertion sort on these rocks results them being "
"printed in alphabetical order:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:877
msgid ""
"However, the version in which a reference is retained to the original array "
"results in a notification on `stderr` (namely, `shared RC array to swap`) "
"from the first call to `Array.swap`:"
msgstr ""

#: src/programs-proofs/insertion-sort.md:903
msgid ""
"The fact that only a single `shared RC` notification appears means that the "
"array is copied only once. This is because the copy that results from the "
"call to `Array.swap` is itself unique, so no further copies need to be made. "
"In an imperative language, subtle bugs can result from forgetting to "
"explicitly copy an array before passing it by reference. When running `sort "
"--shared`, the array is copied as needed to preserve the pure functional "
"meaning of Lean programs, but no more."
msgstr ""

#: src/programs-proofs/insertion-sort.md:909
msgid "Other Opportunities for Mutation"
msgstr ""

#: src/programs-proofs/insertion-sort.md:911
msgid ""
"The use of mutation instead of copying when references are unique is not "
"limited to array update operators. Lean also attempts to \"recycle\" "
"constructors whose reference counts are about to fall to zero, reusing them "
"instead of allocating new data. This means, for instance, that `List.map` "
"will mutate a linked list in place, at least in cases when nobody could "
"possibly notice. One of the most important steps in optimizing hot loops in "
"Lean code is making sure that the data being modified is not referred to "
"from multiple locations."
msgstr ""

#: src/programs-proofs/insertion-sort.md:918
msgid ""
"Write a function that reverses arrays. Test that if the input array has a "
"reference count of one, then your function does not allocate a new array."
msgstr ""

#: src/programs-proofs/insertion-sort.md:920
msgid ""
"Implement either merge sort or quicksort for arrays. Prove that your "
"implementation terminates, and test that it doesn't allocate more arrays "
"than expected. This is a challenging exercise!"
msgstr ""

#: src/programs-proofs/special-types.md:3
msgid ""
"Understanding the representation of data in memory is very important. "
"Usually, the representation can be understood from the definition of a "
"datatype. Each constructor corresponds to an object in memory that has a "
"header that includes a tag and a reference count. The constructor's "
"arguments are each represented by a pointer to some other object. In other "
"words, `List` really is a linked list and extracting a field from a "
"`structure` really does just chase a pointer."
msgstr ""

#: src/programs-proofs/special-types.md:9
msgid ""
"There are, however, some important exceptions to this rule. A number of "
"types are treated specially by the compiler. For example, the type `UInt32` "
"is defined as `Fin (2 ^ 32)`, but it is replaced at run-time with an actual "
"native implementation based on machine words. Similarly, even though the "
"definition of `Nat` suggests an implementation similar to `List Unit`, the "
"actual run-time representation uses immediate machine words for "
"sufficiently-small numbers and an efficient arbitrary-precision arithmetic "
"library for larger numbers. The Lean compiler translates from definitions "
"that use pattern matching into the appropriate operations for this "
"representation, and calls to operations like addition and subtraction are "
"mapped to fast operations from the underlying arithmetic library. After all, "
"addition should not take time linear in the size of the addends."
msgstr ""

#: src/programs-proofs/special-types.md:16
msgid ""
"The fact that some types have special representations also means that care "
"is needed when working with them. Most of these types consist of a "
"`structure` that is treated specially by the compiler. With these "
"structures, using the constructor or the field accessors directly can "
"trigger an expensive conversion from an efficient representation to a slow "
"one that is convenient for proofs. For example, `String` is defined as a "
"structure that contains a list of characters, but the run-time "
"representation of strings uses UTF-8, not linked lists of pointers to "
"characters. Applying the constructor to a list of characters creates a byte "
"array that encodes them in UTF-8, and accessing the field of the structure "
"takes time linear in the length of the string to decode the UTF-8 "
"representation and allocate a linked list. Arrays are represented similarly. "
"From the logical perspective, arrays are structures that contain a list of "
"array elements, but the run-time representation is a dynamically-sized "
"array. At run time, the constructor translates the list into an array, and "
"the field accessor allocates a linked list from the array. The various array "
"operations are replaced with efficient versions by the compiler that mutate "
"the array when possible instead of allocating a new one."
msgstr ""

#: src/programs-proofs/special-types.md:26
msgid ""
"Both types themselves and proofs of propositions are completely erased from "
"compiled code. In other words, they take up no space, and any computations "
"that might have been performed as part of a proof are similarly erased. This "
"means that proofs can take advantage of the convenient interface to strings "
"and arrays as inductively-defined lists, including using induction to prove "
"things about them, without imposing slow conversion steps while the program "
"is running. For these built-in types, a convenient logical representation of "
"the data does not imply that the program must be slow."
msgstr ""

#: src/programs-proofs/special-types.md:31
msgid ""
"If a structure type has only a single non-type non-proof field, then the "
"constructor itself disappears at run time, being replaced with its single "
"argument. In other words, a subtype is represented identically to its "
"underlying type, rather than with an extra layer of indirection. Similarly, "
"`Fin` is just `Nat` in memory, and single-field structures can be created to "
"keep track of different uses of `Nat`s or `String`s without paying a "
"performance penalty. If a constructor has no non-type non-proof arguments, "
"then the constructor also disappears and is replaced with a constant value "
"where the pointer would otherwise be used. This means that `true`, `false`, "
"and `none` are constant values, rather than pointers to heap-allocated "
"objects."
msgstr ""

#: src/programs-proofs/special-types.md:38
msgid "The following types have special representations:"
msgstr ""

#: src/programs-proofs/special-types.md:40
msgid "Type"
msgstr ""

#: src/programs-proofs/special-types.md:40
msgid "Logical representation"
msgstr ""

#: src/programs-proofs/special-types.md:40
msgid "Run-time Representation"
msgstr ""

#: src/programs-proofs/special-types.md:42
msgid "Unary, with one pointer from each `Nat.succ`"
msgstr ""

#: src/programs-proofs/special-types.md:42
#: src/programs-proofs/special-types.md:43
msgid "Efficient arbitrary-precision integers"
msgstr ""

#: src/programs-proofs/special-types.md:43
msgid "`Int`"
msgstr ""

#: src/programs-proofs/special-types.md:43
msgid ""
"A sum type with constructors for positive or negative values, each "
"containing a `Nat`"
msgstr ""

#: src/programs-proofs/special-types.md:44
msgid "`UInt8`, `UInt16`, `UInt32`, `UInt64`"
msgstr ""

#: src/programs-proofs/special-types.md:44
msgid "A `Fin` with an appropriate bound"
msgstr ""

#: src/programs-proofs/special-types.md:44
msgid "Fixed-precision machine integers"
msgstr ""

#: src/programs-proofs/special-types.md:45
msgid "`Char`"
msgstr ""

#: src/programs-proofs/special-types.md:45
msgid "A `UInt32` paired with a proof that it's a valid code point"
msgstr ""

#: src/programs-proofs/special-types.md:45
msgid "Ordinary characters"
msgstr ""

#: src/programs-proofs/special-types.md:46
msgid "`String`"
msgstr ""

#: src/programs-proofs/special-types.md:46
msgid "A structure that contains a `List Char` in a field called `data`"
msgstr ""

#: src/programs-proofs/special-types.md:46
msgid "UTF-8-encoded string"
msgstr ""

#: src/programs-proofs/special-types.md:47
msgid "`Array α`"
msgstr ""

#: src/programs-proofs/special-types.md:47
msgid "A structure that contains a `List α` in a field called `data`"
msgstr ""

#: src/programs-proofs/special-types.md:47
msgid "Packed arrays of pointers to `α` values"
msgstr ""

#: src/programs-proofs/special-types.md:48
msgid "`Sort u`"
msgstr ""

#: src/programs-proofs/special-types.md:48
msgid "A type"
msgstr ""

#: src/programs-proofs/special-types.md:48
#: src/programs-proofs/special-types.md:49
msgid "Erased completely"
msgstr ""

#: src/programs-proofs/special-types.md:49
msgid "Proofs of propositions"
msgstr ""

#: src/programs-proofs/special-types.md:49
msgid ""
"Whatever data is suggested by the proposition when considered as a type of "
"evidence"
msgstr ""

#: src/programs-proofs/special-types.md:53
msgid ""
"The [definition of `Pos`](../type-classes/pos.html) does not take advantage "
"of Lean's compilation of `Nat` to an efficient type. At run time, it is "
"essentially a linked list. Alternatively, a subtype can be defined that "
"allows Lean's fast `Nat` type to be used internally, as described [in the "
"initial section on "
"subtypes](../functor-applicative-monad/applicative.md#subtypes). At run "
"time, the proof will be erased. Because the resulting structure has only a "
"single data field, it is represented as that field, which means that this "
"new representation of `Pos` is identical to that of `Nat`."
msgstr ""

#: src/programs-proofs/special-types.md:59
msgid ""
"After proving the theorem `∀ {n k : Nat}, n ≠ 0 → k ≠ 0 → n + k ≠ 0`, define "
"instances of `ToString`, and `Add` for this new representation of `Pos`. "
"Then, define an instance of `Mul`, proving any necessary theorems along the "
"way."
msgstr ""

#: src/programs-proofs/summary.md:5
msgid ""
"Tail recursion is recursion in which the results of recursive calls are "
"returned immediately, rather than being used in some other way. These "
"recursive calls are called _tail calls_. Tail calls are interesting because "
"they can be compiled to a jump instruction rather than a call instruction, "
"and the current stack frame can be re-used instead of pushing a new frame. "
"In other words, tail-recursive functions are actually loops."
msgstr ""

#: src/programs-proofs/summary.md:10
msgid ""
"A common way to make a recursive function faster is to rewrite it in "
"accumulator-passing style. Instead of using the call stack to remember what "
"is to be done with the result of a recursive call, an additional argument "
"called an _accumulator_ is used to collect this information. For example, an "
"accumulator for a tail-recursive function that reverses a list contains the "
"already-seen list entries, in reverse order."
msgstr ""

#: src/programs-proofs/summary.md:14
msgid ""
"In Lean, only self-tail-calls are optimized into loops. In other words, two "
"functions that each end with a tail call to the other will not be optimized."
msgstr ""

#: src/programs-proofs/summary.md:17
msgid "Reference Counting and In-Place Updates"
msgstr ""

#: src/programs-proofs/summary.md:19
msgid ""
"Rather than using a tracing garbage collector, as is done in Java, C#, and "
"most JavaScript implementations, Lean uses reference counting for memory "
"management. This means that each value in memory contains a field that "
"tracks how many other values refer to it, and the run-time system maintains "
"these counts as references appear or disappear. Reference counting is also "
"used in Python, PHP, and Swift."
msgstr ""

#: src/programs-proofs/summary.md:23
msgid ""
"When asked to allocate a fresh object, Lean's run-time system is able to "
"recycle existing objects whose reference counts are falling to zero. "
"Additionally, array operations such as `Array.set` and `Array.swap` will "
"mutate an array if its reference count is one, rather than allocating a "
"modified copy. If `Array.swap` holds the only reference to an array, then no "
"other part of the program can tell that it was mutated rather than copied."
msgstr ""

#: src/programs-proofs/summary.md:27
msgid ""
"Writing efficient code in Lean requires the use of tail recursion and being "
"careful to ensure that large arrays are used uniquely. While tail calls can "
"be identified by inspecting the function's definition, understanding whether "
"a value is referred to uniquely may require reading the whole program. The "
"debugging helper `dbgTraceIfShared` can be used at key locations in the "
"program to check that a value is not shared."
msgstr ""

#: src/programs-proofs/summary.md:31
msgid "Proving Programs Correct"
msgstr ""

#: src/programs-proofs/summary.md:33
msgid ""
"Rewriting a program in accumulator-passing style, or making other "
"transformations that make it run faster, can also make it more difficult to "
"understand. It can be useful to keep the original version of the program "
"that is more clearly correct, and then use it as an executable specification "
"for the optimized version. While techniques such as unit testing work just "
"as well in Lean as in any other language, Lean also enables the use of "
"mathematical proofs that completely ensure that both versions of the "
"function return the same result for _all possible_ inputs."
msgstr ""

#: src/programs-proofs/summary.md:37
msgid ""
"Typically, proving that two functions are equal is done using function "
"extensionality (the `funext` tactic), which is the principle that two "
"functions are equal if they return the same values for every input. If the "
"functions are recursive, then induction is usually a good way to prove that "
"their outputs are the same. Usually, the recursive definition of the "
"function will make recursive calls on one particular argument; this argument "
"is a good choice for induction. In some cases, the induction hypothesis is "
"not strong enough. Fixing this problem usually requires thought about how to "
"construct a more general version of the theorem statement that provides "
"induction hypotheses that are strong enough. In particular, to prove that a "
"function is equivalent to an accumulator-passing version, a theorem "
"statement that relates arbitrary initial accumulator values to the final "
"result of the original function is needed."
msgstr ""

#: src/programs-proofs/summary.md:46
msgid ""
"The type `Fin n` represents natural numbers that are strictly less than `n`. "
"`Fin` is short for \"finite\". As with subtypes, a `Fin n` is a structure "
"that contains a `Nat` and a proof that this `Nat` is less than `n`. There "
"are no values of type `Fin 0`."
msgstr ""

#: src/programs-proofs/summary.md:51
msgid ""
"If `arr` is an `Array α`, then `Fin arr.size` always contains a number that "
"is a suitable index into `arr`. Many of the built-in array operators, such "
"as `Array.swap`, take `Fin` values as arguments rather than separated proof "
"objects."
msgstr ""

#: src/programs-proofs/summary.md:54
msgid ""
"Lean provides instances of most of the useful numeric type classes for "
"`Fin`. The `OfNat` instances for `Fin` perform modular arithmetic rather "
"than failing at compile time if the number provided is larger than the `Fin` "
"can accept."
msgstr ""

#: src/programs-proofs/summary.md:57
msgid "Provisional Proofs"
msgstr ""

#: src/programs-proofs/summary.md:59
msgid ""
"Sometimes, it can be useful to pretend that a statement is proved without "
"actually doing the work of proving it. This can be useful when making sure "
"that a proof of a statement would be suitable for some task, such as a "
"rewrite in another proof, determining that an array access is safe, or "
"showing that a recursive call is made on a smaller value than the original "
"argument. It's very frustrating to spend time proving something, only to "
"discover that some other proof would have been more useful."
msgstr ""

#: src/programs-proofs/summary.md:63
msgid ""
"The `sorry` tactic causes Lean to provisionally accept a statement as if it "
"were a real proof. It can be seen as analogous to a stub method that throws "
"a `NotImplementedException` in C#. Any proof that relies on `sorry` includes "
"a warning in Lean."
msgstr ""

#: src/programs-proofs/summary.md:67
msgid ""
"Be careful! The `sorry` tactic can prove _any_ statement, even false "
"statements. Proving that `3 < 2` can cause an out-of-bounds array access to "
"persist to runtime, unexpectedly crashing a program. Using `sorry` is "
"convenient during development, but keeping it in the code is dangerous."
msgstr ""

#: src/programs-proofs/summary.md:74
msgid ""
"When a recursive function does not use structural recursion, Lean cannot "
"automatically determine that it terminates. In these situations, the "
"function could just be marked `partial`. However, it is also possible to "
"provide a proof that the function terminates."
msgstr ""

#: src/programs-proofs/summary.md:78
msgid ""
"Partial functions have a key downside: they can't be unfolded during type "
"checking or in proofs. This means that Lean's value as an interactive "
"theorem prover can't be applied to them. Additionally, showing that a "
"function that is expected to terminate actually always does terminate "
"removes one more potential source of bugs."
msgstr ""

#: src/programs-proofs/summary.md:82
msgid ""
"The `termination_by` clause that's allowed at the end of a function can be "
"used to specify the reason why a recursive function terminates. The clause "
"maps the function's arguments to an expression that is expected to be "
"smaller for each recursive call. Some examples of expressions that might "
"decrease are the difference between a growing index into an array and the "
"array's size, the length of a list that's cut in half at each recursive "
"call, or a pair of lists, exactly one of which shrinks on each recursive "
"call."
msgstr ""

#: src/programs-proofs/summary.md:86
msgid ""
"Lean contains proof automation that can automatically determine that some "
"expressions shrink with each call, but many interesting programs will "
"require manual proofs. These proofs can be provided with `have`, a version "
"of `let` that's intended for locally providing proofs rather than values."
msgstr ""

#: src/programs-proofs/summary.md:89
msgid ""
"A good way to write recursive functions is to begin by declaring them "
"`partial` and debugging them with testing until they return the right "
"answers. Then, `partial` can be removed and replaced with a `termination_by` "
"clause. Lean will place error highlights on each recursive call for which a "
"proof is needed that contains the statement that needs to be proved. Each of "
"these statements can be placed in a `have`, with the proof being `sorry`. If "
"Lean accepts the program and it still passes its tests, the final step is to "
"actually prove the theorems that enable Lean to accept it. This approach can "
"prevent wasting time on proving that a buggy program terminates."
msgstr ""

#: src/next-steps.md:3
msgid ""
"This book introduces the very basics of functional programming in Lean, "
"including a tiny amount of interactive theorem proving. Using "
"dependently-typed functional languages like Lean is a deep topic, and much "
"can be said. Depending on your interests, the following resources might be "
"useful for learning Lean 4."
msgstr ""

#: src/next-steps.md:7
msgid "Learning Lean"
msgstr ""

#: src/next-steps.md:9
msgid "Lean 4 itself is described in the following resources:"
msgstr ""

#: src/next-steps.md:11
msgid ""
"[Theorem Proving in Lean 4](https://lean-lang.org/theorem_proving_in_lean4/) "
"is a tutorial on writing proofs using Lean."
msgstr ""

#: src/next-steps.md:12
msgid ""
"[The Lean 4 Manual](https://lean-lang.org/lean4/doc/) provides a reference "
"for the language and its features. At the time of writing, it is still "
"incomplete, but it describes many aspects of Lean in greater detail than "
"this book."
msgstr ""

#: src/next-steps.md:13
msgid ""
"[How To Prove It With Lean](https://djvelleman.github.io/HTPIwL/) is a "
"Lean-based accompaniment to the well-regarded textbook [_How To Prove "
"It_](https://www.cambridge.org/highereducation/books/how-to-prove-it/6D2965D625C6836CD4A785A2C843B3DA) "
"that provides an introduction to writing paper-and-pencil mathematical "
"proofs."
msgstr ""

#: src/next-steps.md:14
msgid ""
"[Metaprogramming in Lean "
"4](https://github.com/arthurpaulino/lean4-metaprogramming-book) provides an "
"overview of Lean's extension mechanisms, from infix operators and notations "
"to macros, custom tactics, and full-on custom embedded languages."
msgstr ""

#: src/next-steps.md:15
msgid ""
"[Functional Programming in "
"Lean](https://lean-lang.org/functional_programming_in_lean/) may be "
"interesting to readers who enjoy jokes about recursion."
msgstr ""

#: src/next-steps.md:17
msgid ""
"However, the best way to continue learning Lean is to start reading and "
"writing code, consulting the documentation when you get stuck. Additionally, "
"the [Lean Zulip](https://leanprover.zulipchat.com/) is an excellent place to "
"meet other Lean users, ask for help, and help others."
msgstr ""

#: src/next-steps.md:20
msgid "The Standard Library"
msgstr ""

#: src/next-steps.md:22
msgid ""
"Out of the box, Lean itself includes a fairly minimal library. Lean is "
"self-hosted, and the included code is just enough to implement Lean itself. "
"For many applications, a larger standard library is needed."
msgstr ""

#: src/next-steps.md:26
msgid ""
"[std4](https://github.com/leanprover/std4) is an in-progress standard "
"library that includes many data structures, tactics, type class instances, "
"and functions that are out of scope for the Lean compiler itself. To use "
"`std4`, the first step is to find a commit in its history that's compatible "
"with the version of Lean 4 that you're using (that is, one in which the "
"`lean-toolchain` file matches the one in your project). Then, add the "
"following to the top level of your `lakefile.lean`, where `COMMIT_HASH` is "
"the appropriate version:"
msgstr ""

#: src/next-steps.md:29
msgid ""
"```lean\n"
"require std from git\n"
"  \"https://github.com/leanprover/std4/\" @ \"COMMIT_HASH\"\n"
"```"
msgstr ""

#: src/next-steps.md:35
msgid "Mathematics in Lean"
msgstr ""

#: src/next-steps.md:37
msgid ""
"Most resources for mathematicians are written for Lean 3. A wide selection "
"are available at [the community "
"site](https://leanprover-community.github.io/learn.html). To get started "
"doing mathematics in Lean 4, it is probably easiest to participate in the "
"process of porting the mathematics library `mathlib` from Lean 3 to Lean 4. "
"Please see the [`mathlib4` "
"README](https://github.com/leanprover-community/mathlib4) for further "
"information."
msgstr ""

#: src/next-steps.md:42
msgid "Using Dependent Types in Computer Science"
msgstr ""

#: src/next-steps.md:44
msgid ""
"Coq is a language that has a lot in common with Lean. For computer "
"scientists, the [Software "
"Foundations](https://softwarefoundations.cis.upenn.edu/) series of "
"interactive textbooks provides an excellent introduction to applications of "
"Coq in computer science. The fundamental ideas of Lean and Coq are very "
"similar, and skills are readily transferable between the systems."
msgstr ""

#: src/next-steps.md:50
msgid ""
"For programmers who are interested in learning to use indexed families and "
"dependent types to structure programs, Edwin Brady's [_Type Driven "
"Development with "
"Idris_](https://www.manning.com/books/type-driven-development-with-idris) "
"provides an excellent introduction. Like Coq, Idris is a close cousin of "
"Lean, though it lacks tactics."
msgstr ""

#: src/next-steps.md:53
msgid "Understanding Dependent Types"
msgstr ""

#: src/next-steps.md:55
msgid ""
"[_The Little Typer_](https://thelittletyper.com/) is a book for programmers "
"who haven't formally studied logic or the theory of programming languages, "
"but who want to build an understanding of the core ideas of dependent type "
"theory. While all of the above resources aim to be as practical as possible, "
"_The Little Typer_ presents an approach to dependent type theory where the "
"very basics are built up from scratch, using only concepts from programming. "
"Disclaimer: the author of _Functional Programming in Lean_ is also an author "
"of _The Little Typer_."
msgstr ""

