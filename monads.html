<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>单子 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">
        <link rel="stylesheet" href="pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">致谢</a></li><li class="chapter-item expanded "><a href="getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="monads.html" class="active"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机</a></li><li class="chapter-item expanded "><a href="programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="next-steps.html">接下来做什么</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="monads"><a class="header" href="#monads">Monads</a></h1>
<!--
In C# and Kotlin, the `?.` operator is a way to look up a property or call a method on a potentially-null value.
If the receiver is `null`, the whole expression is null.
Otherwise, the underlying non-`null` value receives the call.
Uses of `?.` can be chained, in which case the first `null` result terminates the chain of lookups.
Chaining null-checks like this is much more convenient than writing and maintaining deeply nested `if`s.
-->
<p>在C#和Kotlin中，<code>?.</code>运算符是一种在可能为null的值上查找属性或调用方法的方式。如果<code>?.</code>前的值为<code>null</code>，则整个表达式为null。否则，该非<code>null</code>值会被用于调用。多个<code>?.</code>可以链接起来，在这种情况下，第一个 <code>null</code> 
结果将终止查找链。像这样链接null检查比编写和维护深层嵌套的 <code>if</code> 方便得多。</p>
<!--
Similarly, exceptions are significantly more convenient than manually checking and propagating error codes.
At the same time, logging is easiest to accomplish by having a dedicated logging framework, rather than having each function return both its log results and its return value.
Chained null checks and exceptions typically require language designers to anticipate this use case, while logging frameworks typically make use of side effects to decouple code that logs from the accumulation of the logs.
-->
<p>类似地，异常机制比手动检查和传递错误码方便得多。同时，通过使用专用日志记录框架（而不是让每个函数同时返回其日志结果和返回值）可以轻松地完成日志记录。链接的空检查和异常通常要求语言设计者预料到这种用法，而日志记录框架通常利用副作用将记录日志的代码与日志的累积解耦。</p>
<!--
All these features and more can be implemented in library code as instances of a common API called `Monad`.
Lean provides dedicated syntax that makes this API convenient to use, but can also get in the way of understanding what is going on behind the scenes.
This chapter begins with the nitty-gritty presentation of manually nesting null checks, and builds from there to the convenient, general API.
Please suspend your disbelief in the meantime.
-->
<p>所有这些功能以及更多功能都可以作为通用 API —— <code>Monad</code> 的实例在库代码中实现。Lean 提供了专门的语法，使此 API 
易于使用，但也会妨碍理解幕后发生的事情。本章从手动嵌套空检查的细节介绍开始，并由此构建到方便、通用的 API。在此期间，请暂时搁置你的怀疑。</p>
<!--
## Checking for `none`: Don't Repeat Yourself
-->
<h2 id="检查none避免重复代码"><a class="header" href="#检查none避免重复代码">检查<code>none</code>：避免重复代码</a></h2>
<!--
In Lean, pattern matching can be used to chain checks for null.
Getting the first entry from a list can just use the optional indexing notation:
-->
<p>在Lean中，模式匹配可用于链接空检查。从列表中获取第一个项可通过可选的索引记号：```lean
def first (xs : List α) : Option α :=
xs[0]?</p>
<pre><code>&lt;!--
The result must be an `Option` because empty lists have no first entry.
Extracting the first and third entries requires a check that each is not `none`:
--&gt;

&quot;结果必须是`Option`，因为空列表没有第一个项。提取第一个和第三个项需要检查每个项都不为 `none`：```lean
def firstThird (xs : List α) : Option (α × α) :=
  match xs[0]? with
  | none =&gt; none
  | some first =&gt;
    match xs[2]? with
    | none =&gt; none
    | some third =&gt;
      some (first, third)
</code></pre>
<!--
Similarly, extracting the first, third, and fifth entries requires more checks that the values are not `none`:
-->
<p>类似地，提取第一个、第三个和第五个项需要更多检查，以确保这些值不是 <code>none</code>：```lean
def firstThirdFifth (xs : List α) : Option (α × α × α) :=
match xs[0]? with
| none =&gt; none
| some first =&gt;
match xs[2]? with
| none =&gt; none
| some third =&gt;
match xs[4]? with
| none =&gt; none
| some fifth =&gt;
some (first, third, fifth)</p>
<pre><code>&lt;!--
And adding the seventh entry to this sequence begins to become quite unmanageable:
--&gt;

而将第七个项添加到此序列中则开始变得相当难以管理：```lean
def firstThirdFifthSeventh (xs : List α) : Option (α × α × α × α) :=
  match xs[0]? with
  | none =&gt; none
  | some first =&gt;
    match xs[2]? with
    | none =&gt; none
    | some third =&gt;
      match xs[4]? with
      | none =&gt; none
      | some fifth =&gt;
        match xs[6]? with
        | none =&gt; none
        | some seventh =&gt;
          some (first, third, fifth, seventh)
</code></pre>
<!--
The fundamental problem with this code is that it addresses two concerns: extracting the numbers and checking that all of them are present, but the second concern is addressed by copying and pasting the code that handles the `none` case.
It is often good style to lift a repetitive segment into a helper function:
-->
<p>这段代码有两个问题：提取数字和检查它们是否全部存在，但第二个问题是通过复制粘贴处理<code>none</code>情况的代码来解决的。通常鼓励将重复的片段提取到辅助函数中：```lean
def andThen (opt : Option α) (next : α → Option β) : Option β :=
match opt with
| none =&gt; none
| some x =&gt; next x</p>
<pre><code>&lt;!--
This helper, which is used similarly to `?.` in C# and Kotlin, takes care of propagating `none` values.
It takes two arguments: an optional value and a function to apply when the value is not `none`.
If the first argument is `none`, then the helper returns `none`.
If the first argument is not `none`, then the function is applied to the contents of the `some` constructor.
--&gt;

该辅助函数类似于C#和Kotlin中的`?.`，用于处理`none`值。它接受两个参数：一个可选值和一个在该值非`none`时应用的函数。如果第一个参数是`none`，则辅助函数返回`none`。如果第一个参数不是`none`，则该函数将应用于`some` 构造器的内容。

&lt;!--
Now, `firstThird` can be rewritten to use `andThen` instead of pattern matching:
--&gt;

现在，`firstThird` 可以使用`andThen`重写：```lean
def firstThird (xs : List α) : Option (α × α) :=
  andThen xs[0]? fun first =&gt;
  andThen xs[2]? fun third =&gt;
  some (first, third)
</code></pre>
<!--
In Lean, functions don't need to be enclosed in parentheses when passed as arguments.
The following equivalent definition uses more parentheses and indents the bodies of functions:
-->
<p>在Lean中，作为参数传递时，函数不需要用括号括起来。以下等价定义使用了更多括号并缩进了函数体：```lean
def firstThird (xs : List α) : Option (α × α) :=
andThen xs[0]? (fun first =&gt;
andThen xs[2]? (fun third =&gt;
some (first, third)))</p>
<pre><code>&lt;!--
The `andThen` helper provides a sort of &quot;pipeline&quot; through which values flow, and the version with the somewhat unusual indentation is more suggestive of this fact.
Improving the syntax used to write `andThen` can make these computations even easier to understand.
--&gt;

`andThen`辅助函数提供了一种让值流过的“管道”，具有特殊缩进的版本更能说明这一事实。改进 `andThen`的语法可以使其更容易阅读和理解。

&lt;!--
### Infix Operators
--&gt;

### 中缀运算符

&lt;!--
In Lean, infix operators can be declared using the `infix`, `infixl`, and `infixr` commands, which create (respectively) non-associative, left-associative, and right-associative operators.
When used multiple times in a row, a _left associative_ operator stacks up the opening parentheses on the left side of the expression.
The addition operator `+` is left associative, so `w + x + y + z` is equivalent to `(((w + x) + y) + z)`.
The exponentiation operator `^` is right associative, so `w ^ x ^ y ^ z` is equivalent to `(w ^ (x ^ (y ^ z)))`.
Comparison operators such as `&lt;` are non-associative, so `x &lt; y &lt; z` is a syntax error and requires manual parentheses.
--&gt;

在 Lean 中，可以使用 `infix`、`infixl` 和 `infixr`命令声明中缀运算符，分别用于非结合、左结合和右结合的情况。当连续多次使用时，**左结合**运算符会将（开）括号堆叠在表达式的左侧。加法运算符`+` 是左结合的，因此 `w + x + y + z` 等价于 `(((w + x) + y) + z)`。指数运算符 `^` 是右结合的，因此 `w ^ x ^ y ^ z` 等价于 `(w ^ (x ^ (y ^ z)))`。比较运算符（如 `&lt;`）是非结合的，因此 `x &lt; y &lt; z`是一个语法错误，需要手动添加括号。

&lt;!--
The following declaration makes `andThen` into an infix operator:
--&gt;

以下声明将`andThen`声明为中缀运算符：```lean
infixl:55 &quot; ~~&gt; &quot; =&gt; andThen
</code></pre>
<!--
The number following the colon declares the _precedence_ of the new infix operator.
In ordinary mathematical notation, `x + y * z` is equivalent to `x + (y * z)` even though both `+` and `*` are left associative.
In Lean, `+` has precedence 65 and `*` has precedence 70.
Higher-precedence operators are applied before lower-precedence operators.
According to the declaration of `~~>`, both `+` and `*` have higher precedence, and thus apply first.
Typically, figuring out the most convenient precedences for a group of operators requires some experimentation and a large collection of examples.
-->
<p>冒号后面的数字声明了新中缀运算符的<strong>优先级</strong>。在一般的数学记号中，<code>x + y * z</code> 等价于 <code>x + (y * z)</code>，即使 <code>+</code> 和 <code>*</code> 都是左结合的。在 Lean 中，<code>+</code> 的优先级为 65，<code>*</code> 的优先级为 70。优先级更高的运算符应用于优先级较低的运算符之前。根据<code>~~&gt;</code>的声明，<code>+</code>和<code>*</code>都具有更高的优先级，因此会被首先计算。通常来说，找出最适合一组运算符的优先级需要一些实验和大量的示例。</p>
<!--
Following the new infix operator is a double arrow `=>`, which specifies the named function to be used for the infix operator.
Lean's standard library uses this feature to define `+` and `*` as infix operators that point at `HAdd.hAdd` and `HMul.hMul`, respectively, allowing type classes to be used to overload the infix operators.
Here, however, `andThen` is just an ordinary function.
-->
<p>在新的中缀运算符后面是一个双箭头 <code>=&gt;</code>，指定中缀运算符使用的命名的函数。
Lean的标准库使用此功能将<code>+</code>和<code>*</code>定义为指向<code>HAdd.hAdd</code>和<code>HMul.hMul</code>的中缀运算符，从而允许将类型类用于重载中缀运算符。不过这里的<code>andThen</code>只是一个普通函数。</p>
<!--
Having defined an infix operator for `andThen`, `firstThird` can be rewritten in a way that brings the "pipeline" feeling of `none`-checks front and center:
-->
<p>通过为<code>andThen</code>定义一个中缀运算符，<code>firstThird</code>可以被改写成一种，显化<code>none</code>检查的“管道”风格的方式：```lean
def firstThirdInfix (xs : List α) : Option (α × α) :=
xs[0]? ~~&gt; fun first =&gt;
xs[2]? ~~&gt; fun third =&gt;
some (first, third)</p>
<pre><code>&lt;!--
This style is much more concise when writing larger functions:
--&gt;

这种风格在编写较长的函数时更加精炼：```lean
def firstThirdFifthSeventh (xs : List α) : Option (α × α × α × α) :=
  xs[0]? ~~&gt; fun first =&gt;
  xs[2]? ~~&gt; fun third =&gt;
  xs[4]? ~~&gt; fun fifth =&gt;
  xs[6]? ~~&gt; fun seventh =&gt;
  some (first, third, fifth, seventh)
</code></pre>
<!--
## Propagating Error Messages
-->
<h2 id="错误消息的传递"><a class="header" href="#错误消息的传递">错误消息的传递</a></h2>
<!--
Pure functional languages such as Lean have no built-in exception mechanism for error handling, because throwing or catching an exception is outside of the step-by-step evaluation model for expressions.
However, functional programs certainly need to handle errors.
In the case of `firstThirdFifthSeventh`, it is likely relevant for a user to know just how long the list was and where the lookup failed.
-->
<p>像Lean这样的纯函数式语言并没有用于错误处理的内置异常机制，因为抛出或捕获异常超出了表达式逐步求值模型考虑的范围。然而函数式程序肯定需要处理错误。在<code>firstThirdFifthSeventh</code>的情况下，用户很可能需要知道列表有多长以及查找失败发生的位置。&quot;</p>
<!--
This is typically accomplished by defining a datatype that can be either an error or a result, and translating functions with exceptions into functions that return this datatype:
-->
<p>这通常通过定义一个——错误或结果——的数据类型，并让带有异常的函数返回此类型来实现：```lean
inductive Except (ε : Type) (α : Type) where
| error : ε → Except ε α
| ok : α → Except ε α
deriving BEq, Hashable, Repr</p>
<pre><code>&lt;!--
The type variable `ε` stands for the type of errors that can be produced by the function.
Callers are expected to handle both errors and successes, which makes the type variable `ε` play a role that is a bit like that of a list of checked exceptions in Java.
--&gt;

类型变量`ε`表示函数可能产生的错误类型。调用者需要处理错误和成功两种情况，因此类型变量`ε`有点类似Java中需要检查的异常列表。

&lt;!--
Similarly to `Option`, `Except` can be used to indicate a failure to find an entry in a list.
In this case, the error type is a `String`:
--&gt;

类似于 `Option`，`Except`可用于指示在列表中找不到项的情况。此时，错误的类型为 `String`：```lean
def get (xs : List α) (i : Nat) : Except String α :=
  match xs[i]? with
  | none =&gt; Except.error s!&quot;Index {i} not found (maximum is {xs.length - 1})&quot;
  | some x =&gt; Except.ok x
</code></pre>
<!--
Looking up an in-bounds value yields an `Except.ok`:
-->
<p>查找没有越界的值会得到<code>Except.ok</code>：```lean
def ediblePlants : List String :=
[&quot;ramsons&quot;, &quot;sea plantain&quot;, &quot;sea buckthorn&quot;, &quot;garden nasturtium&quot;]</p>
<p>#eval get ediblePlants 2</p>
<pre><code>```output info
Except.ok &quot;sea buckthorn&quot;
</code></pre>
<!--
Looking up an out-of-bounds value yields an `Except.error`:
-->
<p>查找越界的值将产生<code>Except.error</code>：```lean
#eval get ediblePlants 4</p>
<pre><code>```output info
Except.error &quot;Index 4 not found (maximum is 3)&quot;
</code></pre>
<!--
A single list lookup can conveniently return a value or an error:
-->
<p>单个列表查找可以方便地返回一个值或错误：```lean
def first (xs : List α) : Except String α :=
get xs 0</p>
<pre><code>&lt;!--
However, performing two list lookups requires handling potential failures:
--&gt;

然而，连续的两个列表查找则需要处理可能发生的失败情况：```lean
def firstThird (xs : List α) : Except String (α × α) :=
  match get xs 0 with
  | Except.error msg =&gt; Except.error msg
  | Except.ok first =&gt;
    match get xs 2 with
    | Except.error msg =&gt; Except.error msg
    | Except.ok third =&gt;
      Except.ok (first, third)
</code></pre>
<!--
Adding another list lookup to the function requires still more error handling:
-->
<p>向函数中添加另一个列表查找需要额外的错误处理：```lean
def firstThirdFifth (xs : List α) : Except String (α × α × α) :=
match get xs 0 with
| Except.error msg =&gt; Except.error msg
| Except.ok first =&gt;
match get xs 2 with
| Except.error msg =&gt; Except.error msg
| Except.ok third =&gt;
match get xs 4 with
| Except.error msg =&gt; Except.error msg
| Except.ok fifth =&gt;
Except.ok (first, third, fifth)</p>
<pre><code>&lt;!--
And one more list lookup begins to become quite unmanageable:
--&gt;

再继续添加一个列表查找则开始变得相当难以管理：```lean
def firstThirdFifthSeventh (xs : List α) : Except String (α × α × α × α) :=
  match get xs 0 with
  | Except.error msg =&gt; Except.error msg
  | Except.ok first =&gt;
    match get xs 2 with
    | Except.error msg =&gt; Except.error msg
    | Except.ok third =&gt;
      match get xs 4 with
      | Except.error msg =&gt; Except.error msg
      | Except.ok fifth =&gt;
        match get xs 6 with
        | Except.error msg =&gt; Except.error msg
        | Except.ok seventh =&gt;
          Except.ok (first, third, fifth, seventh)
</code></pre>
<!--
Once again, a common pattern can be factored out into a helper.
Each step through the function checks for an error, and only proceeds with the rest of the computation if the result was a success.
A new version of `andThen` can be defined for `Except`:
-->
<p>同样，一个通用的模式可以提取为一个辅助函数。函数中的每一步都会检查错误，并只有在成功的情况下才进行之后的计算。可以为<code>Except</code>定义<code>andThen</code>的新版本：```lean
def andThen (attempt : Except e α) (next : α → Except e β) : Except e β :=
match attempt with
| Except.error msg =&gt; Except.error msg
| Except.ok x =&gt; next x</p>
<pre><code>&lt;!--
Just as with `Option`, this version of `andThen` allows a more concise definition of `firstThird`:
--&gt;

与`Option`一样，该`andThen`允许更简洁地定义`firstThird`：```lean
def firstThird' (xs : List α) : Except String (α × α) :=
  andThen (get xs 0) fun first  =&gt;
  andThen (get xs 2) fun third =&gt;
  Except.ok (first, third)
</code></pre>
<!--
In both the `Option` and `Except` case, there are two repeating patterns: there is the checking of intermediate results at each step, which has been factored out into `andThen`, and there is the final successful result, which is `some` or `Except.ok`, respectively.
For the sake of convenience, success can be factored out into a helper called `ok`:
-->
<p>在<code>Option</code>和<code>Except</code>情况下，都有两个重复的模式：每一步都有对中间结果的检查，并已提取为<code>andThen</code>；有最终的成功结果，分别是<code>some</code> 或<code>Except.ok</code>。为了方便起见，成功的情况可提取为辅助函数<code>ok</code>：```lean
def ok (x : α) : Except ε α := Except.ok x</p>
<pre><code>&lt;!--
Similarly, failure can be factored out into a helper called `fail`:
--&gt;

类似地，失败的情况可提取为辅助函数`fail` ：```lean
def fail (err : ε) : Except ε α := Except.error err
</code></pre>
<!--
Using `ok` and `fail` makes `get` a little more readable:
-->
<p><code>ok</code>和<code>fail</code>使得<code>get</code>可读性更好：```lean
def get (xs : List α) (i : Nat) : Except String α :=
match xs[i]? with
| none =&gt; fail s!&quot;Index {i} not found (maximum is {xs.length - 1})&quot;
| some x =&gt; ok x</p>
<pre><code>

&lt;!--
After adding the infix declaration for `andThen`, `firstThird` can be just as concise as the version that returns an `Option`:
--&gt;

在为`andThen`添加中缀运算符后，`firstThird`可以和返回`Option`的版本一样简洁：```lean
infixl:55 &quot; ~~&gt; &quot; =&gt; andThen

def firstThird (xs : List α) : Except String (α × α) :=
  get xs 0 ~~&gt; fun first =&gt;
  get xs 2 ~~&gt; fun third =&gt;
  ok (first, third)
</code></pre>
<!--
The technique scales similarly to larger functions:
-->
<p>该技术同样适用于更长的函数：```lean
def firstThirdFifthSeventh (xs : List α) : Except String (α × α × α × α) :=
get xs 0 ~~&gt; fun first =&gt;
get xs 2 ~~&gt; fun third =&gt;
get xs 4 ~~&gt; fun fifth =&gt;
get xs 6 ~~&gt; fun seventh =&gt;
ok (first, third, fifth, seventh)</p>
<pre><code>
## 日志记录

&lt;!--
A number is even if dividing it by 2 leaves no remainder:
--&gt;

当一个数字除以2时没有余数则称它为偶数：```lean
def isEven (i : Int) : Bool :=
  i % 2 == 0
</code></pre>
<!--
The function `sumAndFindEvens` computes the sum of a list while remembering the even numbers encountered along the way:
-->
<p>函数<code>sumAndFindEvens</code>计算列表所有元素的加和，同时记录沿途遇到的偶数：```lean
def sumAndFindEvens : List Int → List Int × Int
| [] =&gt; ([], 0)
| i :: is =&gt;
let (moreEven, sum) := sumAndFindEvens is
(if isEven i then i :: moreEven else moreEven, sum + i)</p>
<pre><code>&lt;!--
This function is a simplified example of a common pattern.
Many programs need to traverse a data structure once, while both computing a main result and accumulating some kind of tertiary extra result.
One example of this is logging: a program that is an `IO` action can always log to a file on disk, but because the disk is outside of the mathematical world of Lean functions, it becomes much more difficult to prove things about logs based on `IO`.
Another example is a function that computes the sum of all the nodes in a tree with an inorder traversal, while simultaneously recording each nodes visited:
--&gt;

此函数是一个常见模式的简化示例。许多程序需要遍历一次数据结构，计算一个主要结果的同时累积某种额外的结果。一个例子是日志记录：一个类型为`IO`的程序会将日志输出到磁盘上的文件中，但是由于磁盘在 Lean 函数的数学世界之外，因此对基于`IO`的日志相关的证明变得十分困难。另一个例子是同时计算树的中序遍历和所有节点的加和的函数，它必须记录每个访问的节点：```lean
def inorderSum : BinTree Int → List Int × Int
  | BinTree.leaf =&gt; ([], 0)
  | BinTree.branch l x r =&gt;
    let (leftVisited, leftSum) := inorderSum l
    let (hereVisited, hereSum) := ([x], x)
    let (rightVisited, rightSum) := inorderSum r
    (leftVisited ++ hereVisited ++ rightVisited, leftSum + hereSum + rightSum)
</code></pre>
<!--
Both `sumAndFindEvens` and `inorderSum` have a common repetitive structure.
Each step of computation returns a pair that consists of a list of data that have been saved along with the primary result.
The lists are then appended, and the primary result is computed and paired with the appended lists.
The common structure becomes more apparent with a small rewrite of `sumAndFindEvens` that more cleanly separates the concerns of saving even numbers and computing the sum:
-->
<p><code>sumAndFindEvens</code>和<code>inorderSum</code>都具有共同的重复结构。计算的每一步都返回一个对(pair)，由由数据列表和主要结果组成。在下一步中列表会被附加新的元素，计算新的主要结果并与附加的列表再次配对。通过对<code>sumAndFindEvens</code>稍微改写，保存偶数和计算加和的关注点则更加清晰地分离，共同的结构变得更加明显：```lean
def sumAndFindEvens : List Int → List Int × Int
| [] =&gt; ([], 0)
| i :: is =&gt;
let (moreEven, sum) := sumAndFindEvens is
let (evenHere, ()) := (if isEven i then [i] else [], ())
(evenHere ++ moreEven, sum + i)</p>
<pre><code>
&lt;!--
For the sake of clarity, a pair that consists of an accumulated result together with a value can be given its own name:
--&gt;

为了清晰起见，可以给由累积结果和值组成的对(pair)起一个专有的名字：```lean
structure WithLog (logged : Type) (α : Type) where
  log : List logged
  val : α
</code></pre>
<!--
Similarly, the process of saving a list of accumulated results while passing a value on to the next step of a computation can be factored out into a helper, once again named `andThen`:
-->
<p>同样，保存累积结果列表的同时传递一个值到下一步的过程，可以提取为一个辅助函数，再次命名为 <code>andThen</code>：```lean
def andThen (result : WithLog α β) (next : β → WithLog α γ) : WithLog α γ :=
let {log := thisOut, val := thisRes} := result
let {log := nextOut, val := nextRes} := next thisRes
{log := thisOut ++ nextOut, val := nextRes}</p>
<pre><code>&lt;!--
In the case of errors, `ok` represents an operation that always succeeds.
Here, however, it is an operation that simply returns a value without logging anything:
--&gt;

在可能发生错误的语境下，`ok`表示一个总是成功的操作。然而在这里，它仅简单地返回一个值而不产生任何日志：```lean
def ok (x : β) : WithLog α β := {log := [], val := x}
</code></pre>
<!--
Just as `Except` provides `fail` as a possibility, `WithLog` should allow items to be added to a log.
This has no interesting return value associated with it, so it returns `Unit`:
-->
<p>正如<code>Except</code>提供<code>fail</code>作为一种可能性，<code>WithLog</code>应该允许将项添加到日志中。它不需要返回任何有意义的结果，所以返回类型为<code>Unit</code>：```lean
def save (data : α) : WithLog α Unit :=
{log := [data], val := ()}</p>
<pre><code>
&lt;!--
`WithLog`, `andThen`, `ok`, and `save` can be used to separate the logging concern from the summing concern in both programs:
--&gt;

`WithLog`、`andThen`、`ok`和`save`可以将两个程序中的，日志记录与求和问题分开：```lean
def sumAndFindEvens : List Int → WithLog Int Int
  | [] =&gt; ok 0
  | i :: is =&gt;
    andThen (if isEven i then save i else ok ()) fun () =&gt;
    andThen (sumAndFindEvens is) fun sum =&gt;
    ok (i + sum)

def inorderSum : BinTree Int → WithLog Int Int
  | BinTree.leaf =&gt; ok 0
  | BinTree.branch l x r =&gt;
    andThen (inorderSum l) fun leftSum =&gt;
    andThen (save x) fun () =&gt;
    andThen (inorderSum r) fun rightSum =&gt;
    ok (leftSum + x + rightSum)
</code></pre>
<!--
And, once again, the infix operator helps put focus on the correct steps:
-->
<p>同样地，中缀运算符有助于专注于正确的过程：```lean
infixl:55 &quot; ~~&gt; &quot; =&gt; andThen</p>
<p>def sumAndFindEvens : List Int → WithLog Int Int
| [] =&gt; ok 0
| i :: is =&gt;
(if isEven i then save i else ok ()) ~~&gt; fun () =&gt;
sumAndFindEvens is ~~&gt; fun sum =&gt;
ok (i + sum)</p>
<p>def inorderSum : BinTree Int → WithLog Int Int
| BinTree.leaf =&gt; ok 0
| BinTree.branch l x r =&gt;
inorderSum l ~~&gt; fun leftSum =&gt;
save x ~~&gt; fun () =&gt;
inorderSum r ~~&gt; fun rightSum =&gt;
ok (leftSum + x + rightSum)</p>
<pre><code>
&lt;!--
## Numbering Tree Nodes
--&gt;

## 对树节点编号

&lt;!--
An _inorder numbering_ of a tree associates each data point in the tree with the step it would be visited at in an inorder traversal of the tree.
For example, consider `aTree`:
--&gt;

树的每个节点的**中序编号**指的是：在中序遍历中被访问的次序。例如，考虑如下`aTree`：```lean
open BinTree in
def aTree :=
  branch
    (branch
       (branch leaf &quot;a&quot; (branch leaf &quot;b&quot; leaf))
       &quot;c&quot;
       leaf)
    &quot;d&quot;
    (branch leaf &quot;e&quot; leaf)
</code></pre>
<!--
Its inorder numbering is:
-->
<p>它的中序编号为：```output info
BinTree.branch
(BinTree.branch
(BinTree.branch (BinTree.leaf) (0, &quot;a&quot;) (BinTree.branch (BinTree.leaf) (1, &quot;b&quot;) (BinTree.leaf)))
(2, &quot;c&quot;)
(BinTree.leaf))
(3, &quot;d&quot;)
(BinTree.branch (BinTree.leaf) (4, &quot;e&quot;) (BinTree.leaf))</p>
<pre><code>
&lt;!--
Trees are most naturally processed with recursive functions, but the usual pattern of recursion on trees makes it difficult to compute an inorder numbering.
This is because the highest number assigned anywhere in the left subtree is used to determine the numbering of a node's data value, and then again to determine the starting point for numbering the right subtree.
In an imperative language, this issue can be worked around by using a mutable variable that contains the next number to be assigned.
The following Python program computes an inorder numbering using a mutable variable:
--&gt;

树用递归函数来处理最为自然，但树的常见的递归模式并不适合计算中序编号。这是因为左子树中分配的最大编号将用于确定当前节点的编号，然后用于确定右子树编号的起点。在命令式语言中，可以使用持有下一个被分配编号的可变变量来解决此问题。以下Python程序使用可变变量计算中序编号：```python
class Branch:
    def __init__(self, value, left=None, right=None):
        self.left = left
        self.value = value
        self.right = right
    def __repr__(self):
        return f'Branch({self.value!r}, left={self.left!r}, right={self.right!r})'

def number(tree):
    num = 0
    def helper(t):
        nonlocal num
        if t is None:
            return None
        else:
            new_left = helper(t.left)
            new_value = (num, t.value)
            num += 1
            new_right = helper(t.right)
            return Branch(left=new_left, value=new_value, right=new_right)

    return helper(tree)```
&lt;!--
The numbering of the Python equivalent of `aTree` is:
--&gt;

`aTree`在Python中等价定义是：```python
a_tree = Branch(&quot;d&quot;,
                left=Branch(&quot;c&quot;,
                            left=Branch(&quot;a&quot;, left=None, right=Branch(&quot;b&quot;)),
                            right=None),
                right=Branch(&quot;e&quot;))```
&lt;!--
and its numbering is:
--&gt;

并且它的编号是：```
&gt;&gt;&gt; number(a_tree)
Branch((3, 'd'), left=Branch((2, 'c'), left=Branch((0, 'a'), left=None, right=Branch((1, 'b'), left=None, right=None)), right=None), right=Branch((4, 'e'), left=None, right=None))
</code></pre>
<!--
Even though Lean does not have mutable variables, a workaround exists.
From the point of view of the rest of the world, the mutable variable can be thought of as having two relevant aspects: its value when the function is called, and its value when the function returns.
In other words, a function that uses a mutable variable can be seen as a function that takes the mutable variable's starting value as an argument, returning a pair of the variable's final value and the function's result.
This final value can then be passed as an argument to the next step.
-->
<p>尽管Lean没有可变变量，但有另外一种解决方法。可变变量可以认为具有两个相关方面：函数调用时的值和函数返回时的值。换句话说，使用可变变量的函数可以看作：将变量的起始值作为参数、返回变量的最终值和结果构成的元组的函数。然后可以将此最终值作为参数传递给下一步。</p>
<!--
Just as the Python example uses an outer function that establishes a mutable variable and an inner helper function that changes the variable, a Lean version of the function uses an outer function that provides the variable's starting value and explicitly returns the function's result along with an inner helper function that threads the variable's value while computing the numbered tree:
-->
<p>正如Python示例中定义可变变量的外部函数和更改变量的内部辅助函数一样，Lean版本使用：提供变量初值并明确返回结果的外部函数，以及计算编号树的同时传递变量值的内部辅助函数：```lean
def number (t : BinTree α) : BinTree (Nat × α) :=
let rec helper (n : Nat) : BinTree α → (Nat × BinTree (Nat × α))
| BinTree.leaf =&gt; (n, BinTree.leaf)
| BinTree.branch left x right =&gt;
let (k, numberedLeft) := helper n left
let (i, numberedRight) := helper (k + 1) right
(i, BinTree.branch numberedLeft (k, x) numberedRight)
(helper 0 t).snd</p>
<pre><code>&lt;!--
This code, like the `none`-propagating `Option` code, the `error`-propagating `Except` code, and the log-accumulating `WithLog` code, commingles two concerns: propagating the value of the counter, and actually traversing the tree to find the result.
Just as in those cases, an `andThen` helper can be defined to propagate state from one step of a computation to another.
The first step is to give a name to the pattern of taking an input state as an argument and returning an output state together with a value:
--&gt;

此代码与传递`none`的`Option`代码、传递`error`的`Except`代码、以及累积日志的`WithLog`代码一样，混杂了两个问题：传递计数器的值，以及实际遍历树以查找结果。与那些情况一样，可以定义一个`andThen`辅助函数，将状态在计算的步骤之间传递。第一步是为以下模式命名：将输入状态作为参数并返回输出状态和值：```lean
def State (σ : Type) (α : Type) : Type :=
  σ → (σ × α)
</code></pre>
<!--
In the case of `State`, `ok` is a function that returns the input state unchanged, along with the provided value:
-->
<p>在<code>State</code>的情况下，<code>ok</code>函数原封不动地传递输入状态、以及输入的值：```lean
def ok (x : α) : State σ α :=
fun s =&gt; (s, x)</p>
<pre><code>&lt;!--
When working with a mutable variable, there are two fundamental operations: reading the value and replacing it with a new one.
Reading the current value is accomplished with a function that places the input state unmodified into the output state, and also places it into the value field:
--&gt;

在使用可变变量时，有两个基本操作：读取和新值替换旧值。读取当前值意味着——记录输入状态、将其放入输出状态，然后直接返回记录的输入状态：```lean
def get : State σ σ :=
  fun s =&gt; (s, s)
</code></pre>
<!--
Writing a new value consists of ignoring the input state, and placing the provided new value into the output state:
-->
<p>写入新值意味着——忽略输入状态，并将提供的新值直接放入输出状态：```lean
def set (s : σ) : State σ Unit :=
fun _ =&gt; (s, ())</p>
<pre><code>&lt;!--
Finally, two computations that use state can be sequenced by finding both the output state and return value of the first function, then passing them both into the next function:
--&gt;

最后，可以将`first`函数的输出状态和返回值传递到`next`函数中，以此实现这两个函数的先后调用：```lean
def andThen (first : State σ α) (next : α → State σ β) : State σ β :=
  fun s =&gt;
    let (s', x) := first s
    next x s'

infixl:55 &quot; ~~&gt; &quot; =&gt; andThen
</code></pre>
<!--
Using `State` and its helpers, local mutable state can be simulated:
-->
<p>通过<code>State</code>和它的辅助函数，可以模拟局部可变状态：```lean
def number (t : BinTree α) : BinTree (Nat × α) :=
let rec helper : BinTree α → State Nat (BinTree (Nat × α))
| BinTree.leaf =&gt; ok BinTree.leaf
| BinTree.branch left x right =&gt;
helper left ~~&gt; fun numberedLeft =&gt;
get ~~&gt; fun n =&gt;
set (n + 1) ~~&gt; fun () =&gt;
helper right ~~&gt; fun numberedRight =&gt;
ok (BinTree.branch numberedLeft (n, x) numberedRight)
(helper t 0).snd</p>
<pre><code>&lt;!--
Because `State` simulates only a single local variable, `get` and `set` don't need to refer to any particular variable name.
--&gt;

因为`State`只模拟一个局部变量，所以`get`和`set`不需要任何特定的变量名。

&lt;!--
## Monads: A Functional Design Pattern
--&gt;

## 单子：一种函数式设计模式

&lt;!--
Each of these examples has consisted of:
 * A polymorphic type, such as `Option`, `Except ε`, `WithLog logged`, or `State σ`
 * An operator `andThen` that takes care of some repetitive aspect of sequencing programs that have this type
 * An operator `ok` that is (in some sense) the most boring way to use the type
 * A collection of other operations, such as `none`, `fail`, `save`, and `get`, that name ways of using the type
--&gt;

以上的每个示例都包含下述结构：
 * 一个多态类型，例如`Option`、`Except ε`、`WithLog logged`或`State σ`
 * 一个运算符`andThen`，用来处理连续、重复、具有此类型的程序序列
 * 一个运算符`ok`，它（在某种意义上）是使用该类型最无聊的方式
 * 一系列其他操作，例如`none`、`fail`、`save`和`get`，指出了使用对应类型的方式

&lt;!--
This style of API is called a _monad_.
While the idea of monads is derived from a branch of mathematics called category theory, no understanding of category theory is needed in order to use them for programming.
The key idea of monads is that each monad encodes a particular kind of side effect using the tools provided by the pure functional language Lean.
For example, `Option` represents programs that can fail by returning `none`, `Except` represents programs that can throw exceptions, `WithLog` represents programs that accumulate a log while running, and `State` represents programs with a single mutable variable.
--&gt;

这种风格的API统称为**单子**(Monad)。虽然单子的思想源自于一门称为范畴论的数学分支，但为了将它们用于编程，并不需要理解范畴论。单子的关键思想是，每个单子都使用纯函数式语言Lean提供的工具对特定类型的副作用进行编码。例如`Option`表示可能通过返回`none`而失败的程序，`Except`表示可能抛出异常的程序，`WithLog`表示在运行过程中累积日志的程序，`State`表示具有单个可变变量的程序。

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="type-classes/summary.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="monads/class.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="type-classes/summary.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="monads/class.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
