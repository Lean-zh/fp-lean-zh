<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>结构体 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">致谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html" class="active"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利的功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步运行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 启动项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利的功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利的功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利的功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 全类</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利的功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 全类设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与全类层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">接下来做什么</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Structures
-->
<h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<!--
The first step in writing a program is usually to identify the problem domain's concepts, and then find suitable representations for them in code.
Sometimes, a domain concept is a collection of other, simpler, concepts.
In that case, it can be convenient to group these simpler components together into a single "package", which can then be given a meaningful name.
In Lean, this is done using _structures_, which are analogous to `struct`s in C or Rust and `record`s in C#.
-->
<p>编写程序的第一步通常是找出问题域中的概念，然后用合适的代码表示它们。
有时，一个域概念是其他更简单概念的集合。此时，将这些更简单的组件分组到一个「包」中会很方便，
然后可以给它取一个有意义的名称。在 Lean 中，这是使用**结构体（Structure）**完成的，
它类似于 C 或 Rust 中的 <code>struct</code> 和 C# 中的 <code>record</code>。</p>
<!--
Defining a structure introduces a completely new type to Lean that can't be reduced to any other type.
This is useful because multiple structures might represent different concepts that nonetheless contain the same data.
For instance, a point might be represented using either Cartesian or polar coordinates, each being a pair of floating-point numbers.
Defining separate structures prevents API clients from confusing one for another.
-->
<p>定义一个结构体会向 Lean 引入一个全新的类型，该类型不能化简为任何其他类型。
这很有用，因为多个结构体可能表示不同的概念，但它们包含相同的数据。
例如，一个点可以用笛卡尔坐标或极坐标表示，每个都是一对浮点数。
分别定义不同的结构体可以防止 API 的用户将一个与另一个混淆。</p>
<!--
Lean's floating-point number type is called `Float`, and floating-point numbers are written in the usual notation.
-->
<p>Lean 的浮点数类型称为 <code>Float</code>，浮点数采用通常的表示法。</p>
<pre><code class="language-lean">#check 1.2
</code></pre>
<pre><code class="language-output info">1.2 : Float
</code></pre>
<pre><code class="language-lean">#check -454.2123215
</code></pre>
<pre><code class="language-output info">-454.2123215 : Float
</code></pre>
<pre><code class="language-lean">#check 0.0
</code></pre>
<pre><code class="language-output info">0.0 : Float
</code></pre>
<!--
When floating point numbers are written with the decimal point, Lean will infer the type `Float`. If they are written without it, then a type annotation may be necessary.
-->
<p>当浮点数使用小数点书写时，Lean 会推断其类型为 <code>Float</code>。
如果不使用小数点书写，则可能需要类型标注。</p>
<pre><code class="language-lean">#check 0
</code></pre>
<pre><code class="language-output info">0 : Nat
</code></pre>
<pre><code class="language-lean">#check (0 : Float)
</code></pre>
<pre><code class="language-output info">0 : Float
</code></pre>
<!--
A Cartesian point is a structure with two `Float` fields, called `x` and `y`.
This is declared using the `structure` keyword.
-->
<p>笛卡尔点是一个结构体，它有两个 <code>Float</code> 字段，称为 <code>x</code> 和 <code>y</code>。
它使用 <code>structure</code> 关键字声明。</p>
<pre><code class="language-lean">structure Point where
  x : Float
  y : Float
deriving Repr
</code></pre>
<!--
After this declaration, `Point` is a new structure type.
The final line, which says `deriving Repr`, asks Lean to generate code to display values of type `Point`.
This code is used by `#eval` to render the result of evaluation for consumption by programmers, analogous to the `repr` function in Python.
It is also possible to override the compiler's generated display code.
-->
<p>声明之后，<code>Point</code> 就是一个新的结构体类型了。最后一行写着 <code>deriving Repr</code>，
它要求 Lean 生成代码以显示类型为 <code>Point</code> 的值。此代码用于 <code>#eval</code>
显示求值结果以供程序员使用，类似于 Python 中的 <code>repr</code> 函数。
编译器生成的显示代码也可以被覆盖。</p>
<!--
The typical way to create a value of a structure type is to provide values for all of its fields inside of curly braces.
The origin of a Cartesian plane is where `x` and `y` are both zero:
-->
<p>创建结构体类型值通常的方法是在大括号内为其所有字段提供值。
笛卡尔平面的原点是 <code>x</code> 和 <code>y</code> 均为零的点：</p>
<pre><code class="language-lean">def origin : Point := { x := 0.0, y := 0.0 }
</code></pre>
<!--
If the `deriving Repr` line in `Point`'s definition were omitted, then attempting `#eval origin` would yield an error similar to that which occurs when omitting a function's argument:
-->
<p>如果 <code>Point</code> 定义中的 <code>deriving Repr</code> 行被省略，则尝试
<code>#eval origin</code>
会产生类似于省略函数参数时产生的错误：&quot;</p>
<pre><code class="language-output error">expression
  origin
has type
  Point
but instance
  Lean.MetaEval Point
failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class
</code></pre>
<!--
That message is saying that the evaluation machinery doesn't know how to communicate the result of evaluation back to the user.
-->
<p>该消息表明求值机制不知道如何将求值结果传达给用户。</p>
<!--
Happily, with `deriving Repr`, the result of `#eval origin` looks very much like the definition of `origin`.
-->
<p>幸运的是，使用 <code>deriving Repr</code>，<code>#eval origin</code>
的结果看起来非常像 <code>origin</code> 的定义。</p>
<pre><code class="language-output info">{ x := 0.000000, y := 0.000000 }
</code></pre>
<!--
Because structures exist to "bundle up" a collection of data, naming it and treating it as a single unit, it is also important to be able to extract the individual fields of a structure.
This is done using dot notation, as in C, Python, or Rust.
-->
<p>由于结构体是用来「打包」一组数据，并将其命名并后作为单个单元进行处理的，
因此能够提取结构体的各个字段也很重要。这可以使用点记法，就像在 C、Python 或 Rust 中一样。</p>
<pre><code class="language-lean">#eval origin.x
</code></pre>
<pre><code class="language-output info">0.000000
</code></pre>
<pre><code class="language-lean">#eval origin.y
</code></pre>
<pre><code class="language-output info">0.000000
</code></pre>
<!--
This can be used to define functions that take structures as arguments.
For instance, addition of points is performed by adding the underlying coordinate values.
It should be the case that `#eval addPoints { x := 1.5, y := 32 } { x := -8, y := 0.2 }` yields
-->
<p>可以定义以结构体作为参数的函数。例如，点的加法可通过底层坐标值相加来执行。
<code>#eval addPoints { x := 1.5, y := 32 } { x := -8, y := 0.2 }</code> 会产生</p>
<pre><code class="language-output info">{ x := -6.500000, y := 32.200000 }
</code></pre>
<!--
The function itself takes two `Points` as arguments, called `p1` and `p2`.
The resulting point is based on the `x` and `y` fields of both `p1` and `p2`:
-->
<p>该函数本身以两个 <code>Points</code> 作为参数，分别为 <code>p1</code> 和 <code>p2</code>。
结果点基于 <code>p1</code> 和 <code>p2</code> 的 <code>x</code> 和 <code>y</code> 字段：&quot;</p>
<pre><code class="language-lean">def addPoints (p1 : Point) (p2 : Point) : Point :=
  { x := p1.x + p2.x, y := p1.y + p2.y }
</code></pre>
<!--
Similarly, the distance between two points, which is the square root of the sum of the squares of the differences in their `x` and `y` components, can be written:
-->
<p>类似地，两点之间的距离（即其 <code>x</code> 和 <code>y</code> 分量之差的平方和的平方根）可以写成：</p>
<pre><code class="language-lean">def distance (p1 : Point) (p2 : Point) : Float :=
  Float.sqrt (((p2.x - p1.x) ^ 2.0) + ((p2.y - p1.y) ^ 2.0))
</code></pre>
<!--
For example, the distance between (1, 2) and (5, -1) is 5:
-->
<p>例如，(1, 2) 和 (5, -1) 之间的距离为 5：</p>
<pre><code class="language-lean">#eval distance { x := 1.0, y := 2.0 } { x := 5.0, y := -1.0 }
</code></pre>
<pre><code class="language-output info">5.000000
</code></pre>
<!--
Multiple structures may have fields with the same names.
For instance, a three-dimensional point datatype may share the fields `x` and `y`, and be instantiated with the same field names:
-->
<p>不同结构体可能具有同名的字段。例如，三维点数据类型可能共享字段 <code>x</code> 和 <code>y</code>，
并使用相同的字段名实例化：</p>
<pre><code class="language-lean">structure Point3D where
  x : Float
  y : Float
  z : Float
deriving Repr

def origin3D : Point3D := { x := 0.0, y := 0.0, z := 0.0 }
</code></pre>
<p>这意味着必须知道结构体的预期类型才能使用大括号语法。
如果类型未知，Lean 将无法实例化结构体。例如，</p>
<pre><code class="language-lean">#check { x := 0.0, y := 0.0 }
</code></pre>
<!--
leads to the error
-->
<p>会导致错误</p>
<pre><code class="language-output error">invalid {...} notation, expected type is not known
</code></pre>
<!--
As usual, the situation can be remedied by providing a type annotation.
-->
<p>通常，可以通过提供类型标注来补救这种情况。</p>
<pre><code class="language-lean">#check ({ x := 0.0, y := 0.0 } : Point)
</code></pre>
<pre><code class="language-output info">{ x := 0.0, y := 0.0 } : Point
</code></pre>
<!--
To make programs more concise, Lean also allows the structure type annotation inside the curly braces.
-->
<p>为了使程序更加简洁，Lean 还允许在大括号内标注结构体类型。</p>
<pre><code class="language-lean">#check { x := 0.0, y := 0.0 : Point}
</code></pre>
<pre><code class="language-output info">{ x := 0.0, y := 0.0 } : Point
</code></pre>
<!--
## Updating Structures
-->
<h2 id="更新结构体"><a class="header" href="#更新结构体">更新结构体</a></h2>
<!--
Imagine a function `zeroX` that replaces the `x` field of a `Point` with `0.0`.
In most programming language communities, this sentence would mean that the memory location pointed to by `x` was to be overwritten with a new value.
However, Lean does not have mutable state.
In functional programming communities, what is almost always meant by this kind of statement is that a fresh `Point` is allocated with the `x` field pointing to the new value, and all other fields pointing to the original values from the input.
One way to write `zeroX` is to follow this description literally, filling out the new value for `x` and manually transferring `y`:
-->
<p>设想一个函数 <code>zeroX</code>，它将 <code>Point</code> 的 <code>x</code> 字段置为 <code>0.0</code>。
在大多数编程语言社区中，这句话意味着指向 <code>x</code> 的内存位置将被新值覆盖。
但是，Lean 没有可变状态。在函数式编程社区中，这种说法几乎总是意味着分配一个新的 <code>Point</code>，
其 <code>x</code> 字段指向新值，而其他字段指向输入中的原始值。
编写 <code>zeroX</code> 的一种方法是逐字遵循此描述，填写 <code>x</code> 的新值并手动传入 <code>y</code>：</p>
<pre><code class="language-lean">def zeroX (p : Point) : Point :=
  { x := 0, y := p.y }
</code></pre>
<!--
This style of programming has drawbacks, however.
First off, if a new field is added to a structure, then every site that updates any field at all must be updated, causing maintenance difficulties.
Secondly, if the structure contains multiple fields with the same type, then there is a real risk of copy-paste coding leading to field contents being duplicated or switched.
Finally, the program becomes long and bureaucratic.
-->
<p>然而，这种编程风格也存在一些缺点。首先，如果向结构体中添加了一个新字段，
那么所有更新任何字段的代码都需要更新，这会导致维护困难。
其次，如果结构体中包含多个具有相同类型的字段，那么存在真正的风险，
即复制粘贴代码会导致字段内容被复制或交换。最后，程序会变得冗长且呆板。</p>
<!--
Lean provides a convenient syntax for replacing some fields in a structure while leaving the others alone.
This is done by using the `with` keyword in a structure initialization.
The source of unchanged fields occurs before the `with`, and the new fields occur after.
For instance, `zeroX` can be written with only the new `x` value:
-->
<p>Lean 提供了一种便捷的语法，用于替换结构体中的一些字段，同时保留其他字段。
这是通过在结构体初始化中使用 <code>with</code> 关键字来完成的。未更改字段的源代码写在 <code>with</code> 之前，
而新字段写在 <code>with</code> 之后。例如，<code>zeroX</code> 可以仅使用新的 <code>x</code> 值编写：</p>
<pre><code class="language-lean">def zeroX (p : Point) : Point :=
  { p with x := 0 }
</code></pre>
<!--
Remember that this structure update syntax does not modify existing values—it creates new values that share some fields with old values.
For instance, given the point `fourAndThree`:
-->
<p>请记住，此结构体更新语法不会修改现有值，它会创建一些与旧值共享某些字段的新值。
例如，给定点 <code>fourAndThree</code>：</p>
<pre><code class="language-lean">def fourAndThree : Point :=
  { x := 4.3, y := 3.4 }
</code></pre>
<!--
evaluating it, then evaluating an update of it using `zeroX`, then evaluating it again yields the original value:
-->
<p>对其进行求值，然后使用 <code>zeroX</code> 对其进行更新，然后再次对其进行求值，将产生原始值：</p>
<pre><code class="language-lean">#eval fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 4.300000, y := 3.400000 }
</code></pre>
<pre><code class="language-lean">#eval zeroX fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 0.000000, y := 3.400000 }
</code></pre>
<pre><code class="language-lean">#eval fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 4.300000, y := 3.400000 }
</code></pre>
<!--
One consequence of the fact that structure updates do not modify the original structure is that it becomes easier to reason about cases where the new value is computed from the old one.
All references to the old structure continue to refer to the same field values in all of the new values provided.
-->
<p>结构体更新不会修改原始结构体，这样更容易推理新值是从旧值计算得出的。
对旧结构体的所有引用会在所有提供的新值中继续引用相同的字段值。</p>
<!--
## Behind the Scenes
-->
<h2 id="behind-the-scenes"><a class="header" href="#behind-the-scenes">Behind the Scenes</a></h2>
<!--
Every structure has a _constructor_.
Here, the term "constructor" may be a source of confusion.
Unlike constructors in languages such as Java or Python, constructors in Lean are not arbitrary code to be run when a datatype is initialized.
Instead, constructors simply gather the data to be stored in the newly-allocated data structure.
It is not possible to provide a custom constructor that pre-processes data or rejects invalid arguments.
This is really a case of the word "constructor" having different, but related, meanings in the two contexts.
-->
<p>每个结构体都有一个<strong>构造子（Constructor）</strong>。「Constructor」一词在英文中可能会引起混淆。
与 Java 或 Python 等语言中的构造函数不同，Lean 中的构造子不是在初始化数据类型时运行的任意代码。
相反，构造子只会收集要存储在新分配的数据结构中的数据。
不可能提供一个预处理数据或拒绝无效参数的自定义构造子。
这实际上是「Constructor」一词在两种情况下具有不同但相关的含义的情况。</p>
<!--
By default, the constructor for a structure named `S` is named `S.mk`.
Here, `S` is a namespace qualifier, and `mk` is the name of the constructor itself.
Instead of using curly-brace initialization syntax, the constructor can also be applied directly.
-->
<p>默认情况下，名为 <code>S</code> 的结构体的构造子命名为 <code>S.mk</code>。其中，<code>S</code> 是命名空间限定符，
<code>mk</code> 是构造子本身的名称。除了使用大括号初始化语法外，还可以直接应用构造子。</p>
<pre><code class="language-lean">#check Point.mk 1.5 2.8
</code></pre>
<!--
However, this is not generally considered to be good Lean style, and Lean even returns its feedback using the standard structure initializer syntax.
-->
<p>然而，这通常不被认为是良好的 Lean 风格，Lean 甚至使用标准结构体初始化语法返回其结果。</p>
<pre><code class="language-output info">{ x := 1.5, y := 2.8 } : Point
</code></pre>
<!--
Constructors have function types, which means they can be used anywhere that a function is expected.
For instance, `Point.mk` is a function that accepts two `Float`s (respectively `x` and `y`) and returns a new `Point`.
-->
<p>构造子具有函数类型，这意味着它们可以在需要函数的任何地方使用。
例如，<code>Point.mk</code> 是一个接受两个 <code>Float</code>（分别是 <code>x</code> 和 <code>y</code>），并返回一个新 <code>Point</code> 的函数。</p>
<pre><code class="language-lean">#check (Point.mk)
</code></pre>
<pre><code class="language-output info">Point.mk : Float → Float → Point
</code></pre>
<!--
To override a structure's constructor name, write it with two colons at the beginning.
For instance, to use `Point.point` instead of `Point.mk`, write:
-->
<p>要覆盖结构体的构造子名称，请在开头写出新的名称后跟两个冒号。
例如，要使用 <code>Point.point</code> 而非 <code>Point.mk</code>，请编写：</p>
<pre><code class="language-lean">structure Point where
  point ::
  x : Float
  y : Float
deriving Repr
</code></pre>
<!--
In addition to the constructor, an accessor function is defined for each field of a structure.
These have the same name as the field, in the structure's namespace.
For `Point`, accessor functions `Point.x` and `Point.y` are generated.
-->
<p>除了构造子，结构体的每个字段还定义了一个访问器函数。
它们在结构体的命名空间中与字段具有相同的名称。对于 <code>Point</code>，
会生成访问器函数 <code>Point.x</code> 和 <code>Point.y</code>。</p>
<pre><code class="language-lean">#check (Point.x)
</code></pre>
<pre><code class="language-output info">Point.x : Point → Float
</code></pre>
<pre><code class="language-lean">#check (Point.y)
</code></pre>
<pre><code class="language-output info">Point.y : Point → Float
</code></pre>
<!--
In fact, just as the curly-braced structure construction syntax is converted to a call to the structure's constructor behind the scenes, the syntax `p1.x` in the prior definition of `addPoints` is converted into a call to the `Point.x` accessor.
That is, `#eval origin.x` and `#eval Point.x origin` both yield
-->
<p>实际上，就像大括号结构体构造语法会在幕后转换为对结构体构造函数的调用一样，
<code>addPoints</code> 中先前定义中的语法 <code>p1.x</code> 会被转换为对 <code>Point.x</code> 访问器的调用。
也就是说，<code>#eval origin.x</code>
和 <code>#eval Point.x origin</code> 都会产生</p>
<pre><code class="language-output info">0.000000
</code></pre>
<!--
Accessor dot notation is usable with more than just structure fields.
It can also be used for functions that take any number of arguments.
More generally, accessor notation has the form `TARGET.f ARG1 ARG2 ...`.
If `TARGET` has type `T`, the function named `T.f` is called.
`TARGET` becomes its leftmost argument of type `T`, which is often but not always the first one, and `ARG1 ARG2 ...` are provided in order as the remaining arguments.
For instance, `String.append` can be invoked from a string with accessor notation, even though `String` is not a structure with an `append` field.
-->
<p>访问器的点记法不仅可以与结构字段一起使用。它还可以用于接受任意数量参数的函数。
更一般地说，访问器记法具有以下形式：<code>TARGET.f ARG1 ARG2 ...</code>。如果
<code>TARGET</code> 的类型为 <code>T</code>，则调用名为 <code>T.f</code> 的函数。
<code>TARGET</code> 是其类型为 <code>T</code> 的最左边的参数，它通常但并非总是第一个参数，并且
<code>ARG1 ARG2 ...</code> 按顺序作为其余参数提供。例如，即使 <code>String</code> 不是具有
<code>append</code> 字段的结构，也可以使用访问器记法从字符串中调用 <code>String.append</code>。</p>
<pre><code class="language-lean">#eval &quot;one string&quot;.append &quot; and another&quot;
</code></pre>
<pre><code class="language-output info">&quot;one string and another&quot;
</code></pre>
<!--
In that example, `TARGET` represents `"one string"` and `ARG1` represents `" and another"`.
-->
<p>在该示例中，<code>TARGET</code> 表示 <code>&quot;one string&quot;</code>，<code>ARG1</code> 表示 <code>&quot; and another&quot;</code>。</p>
<!--
The function `Point.modifyBoth` (that is, `modifyBoth` defined in the `Point` namespace) applies a function to both fields in a `Point`:
-->
<p><code>Point.modifyBoth</code> 函数（即在 <code>Point</code> 命名空间中定义的 <code>modifyBoth</code>）
将一个函数应用于 <code>Point</code> 中的两个字段：</p>
<pre><code class="language-lean">def Point.modifyBoth (f : Float → Float) (p : Point) : Point :=
  { x := f p.x, y := f p.y }
</code></pre>
<!--
Even though the `Point` argument comes after the function argument, it can be used with dot notation as well:
-->
<p>即使 <code>Point</code> 参数位于函数参数之后，也可以使用点记法：</p>
<pre><code class="language-lean">#eval fourAndThree.modifyBoth Float.floor
</code></pre>
<pre><code class="language-output info">{ x := 4.000000, y := 3.000000 }
</code></pre>
<!--
In this case, `TARGET` represents `fourAndThree`, while `ARG1` is `Float.floor`.
This is because the target of the accessor notation is used as the first argument in which the type matches, not necessarily the first argument.
-->
<p>在这种情况下，<code>TARGET</code> 表示 <code>fourAndThree</code>，而 <code>ARG1</code> 是 <code>Float.floor</code>。
这是因为访问器记法的目标用作第一个类型匹配的参数，而不一定是第一个参数。</p>
<!--
## Exercises
-->
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<!--
 * Define a structure named `RectangularPrism` that contains the height, width, and depth of a rectangular prism, each as a `Float`.
 * Define a function named `volume : RectangularPrism → Float` that computes the volume of a rectangular prism.
 * Define a structure named `Segment` that represents a line segment by its endpoints, and define a function `length : Segment → Float` that computes the length of a line segment. `Segment` should have at most two fields.
 * Which names are introduced by the declaration of `RectangularPrism`?
 * Which names are introduced by the following declarations of `Hamster` and `Book`? What are their types?
-->
<ul>
<li>定义一个名为 <code>RectangularPrism</code> 的结构，其中包含一个矩形棱柱的高度、宽度和深度，每个都是 <code>Float</code>。</li>
<li>定义一个名为 <code>volume : RectangularPrism → Float</code> 的函数，用于计算矩形棱柱的体积。</li>
<li>定义一个名为 <code>Segment</code> 的结构，它通过其端点表示线段，并定义一个函数
<code>length : Segment → Float</code>，用于计算线段的长度。<code>Segment</code> 最多应有两个字段。</li>
<li>RectangularPrism` 的声明引入了哪些名称？</li>
<li>以下 <code>Hamster</code> 和 <code>Book</code> 的声明引入了哪些名称？它们的类型是什么？</li>
</ul>
<pre><code class="language-lean">structure Hamster where
  name : String
  fluffy : Bool
</code></pre>
<pre><code class="language-lean">structure Book where
  makeBook ::
  title : String
  author : String
  price : Float
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-to-know/functions-and-definitions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../getting-to-know/datatypes-and-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-to-know/functions-and-definitions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../getting-to-know/datatypes-and-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
