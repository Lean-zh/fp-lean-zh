<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>更多不等式 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html" class="active"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/programs-proofs/inequalities.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# More Inequalities
-->
<h1 id="更多不等式"><a class="header" href="#更多不等式">更多不等式</a></h1>
<!--
Lean's built-in proof automation is sufficient to check that `arrayMapHelper` and `findHelper` terminate.
All that was needed was to provide an expression whose value decreases with each recursive call.
However, Lean's built-in automation is not magic, and it often needs some help.
-->
<p>Lean 的内置证明自动化足以检查 <code>arrayMapHelper</code> 和 <code>findHelper</code> 是否停机。
所需要做的就是提供一个值随着每次递归调用而减小的表达式。
但是，Lean 的内置自动化不是万能的，它通常需要一些帮助。</p>
<!--
## Merge Sort
-->
<h2 id="归并排序"><a class="header" href="#归并排序">归并排序</a></h2>
<p>一个停机证明非平凡的函数示例是 <code>List</code> 上的归并排序。归并排序包含两个阶段：
首先，将列表分成两半。使用归并排序对每一半进行排序，
然后使用一个将两个已排序列表合并为一个更大的已排序列表的函数合并结果。
基本情况是空列表和单元素列表，它们都被认为已经排序。</p>
<!--
To merge two sorted lists, there are two basic cases to consider:

 1. If one of the input lists is empty, then the result is the other list.
 2. If both lists are non-empty, then their heads should be compared. The result of the function is the smaller of the two heads, followed by the result of merging the remaining entries of both lists.
-->
<p>要合并两个已排序列表，需要考虑两个基本情况：</p>
<ol>
<li>如果一个输入列表为空，则结果是另一个列表。</li>
<li>如果两个列表都不为空，则应比较它们的头部。该函数的结果是两个头部中较小的一个，
后面是合并两个列表的剩余项的结果。</li>
</ol>
<!--
This is not structurally recursive on either list.
The recursion terminates because an entry is removed from one of the two lists in each recursive call, but it could be either list.
The `termination_by` clause uses the sum of the length of both lists as a decreasing value:
-->
<p>这在任何列表上都不是结构化递归。递归停机是因为在每次递归调用中都会从两个列表中的一个中删除一个项，
但它可能是任何一个列表。<code>termination_by</code> 子句使用两个列表长度的和作为递减值：</p>
<pre><code class="language-lean">def merge [Ord α] (xs : List α) (ys : List α) : List α :=
  match xs, ys with
  | [], _ =&gt; ys
  | _, [] =&gt; xs
  | x'::xs', y'::ys' =&gt;
    match Ord.compare x' y' with
    | .lt | .eq =&gt; x' :: merge xs' (y' :: ys')
    | .gt =&gt; y' :: merge (x'::xs') ys'
termination_by merge xs ys =&gt; xs.length + ys.length
</code></pre>
<!--
In addition to using the lengths of the lists, a pair that contains both lists can also be provided:
-->
<p>除了使用列表的长度外，还可以提供一个包含两个列表的偶对：</p>
<pre><code class="language-lean">def merge [Ord α] (xs : List α) (ys : List α) : List α :=
  match xs, ys with
  | [], _ =&gt; ys
  | _, [] =&gt; xs
  | x'::xs', y'::ys' =&gt;
    match Ord.compare x' y' with
    | .lt | .eq =&gt; x' :: merge xs' (y' :: ys')
    | .gt =&gt; y' :: merge (x'::xs') ys'
termination_by merge xs ys =&gt; (xs, ys)
</code></pre>
<!--
This works because Lean has a built-in notion of sizes of data, expressed through a type class called `WellFoundedRelation`.
The instance for pairs automatically considers them to be smaller if either the first or the second item in the pair shrinks.
-->
<p>它有效是因为 Lean 有一个内置的数据大小概念，通过一个称为 <code>WellFoundedRelation</code>
的类型类来表示。如果偶对中的第一个或第二个项缩小，偶对的实例会自动认为它们会变小。</p>
<!--
A simple way to split a list is to add each entry in the input list to two alternating output lists:
-->
<p>分割列表的一个简单方法是将输入列表中的每个项添加到两个交替的输出列表中：</p>
<pre><code class="language-lean">def splitList (lst : List α) : (List α × List α) :=
  match lst with
  | [] =&gt; ([], [])
  | x :: xs =&gt;
    let (a, b) := splitList xs
    (x :: b, a)
</code></pre>
<!--
Merge sort checks whether a base case has been reached.
If so, it returns the input list.
If not, it splits the input, and merges the result of sorting each half:
-->
<p>归并排序检查是否已达到基本情况。如果是，则返回输入列表。
如果不是，则分割输入，并合并对每一半排序的结果：</p>
<pre><code class="language-lean">def mergeSort [Ord α] (xs : List α) : List α :=
  if h : xs.length &lt; 2 then
    match xs with
    | [] =&gt; []
    | [x] =&gt; [x]
  else
    let halves := splitList xs
    merge (mergeSort halves.fst) (mergeSort halves.snd)
</code></pre>
<!--
Lean's pattern match compiler is able to tell that the assumption `h` introduced by the `if` that tests whether `xs.length < 2` rules out lists longer than one entry, so there is no "missing cases" error.
However, even though this program always terminates, it is not structurally recursive:
-->
<p>Lean 的模式匹配编译器能够判断由测试 <code>xs.length &lt; 2</code> 的 <code>if</code> 引入的前提 <code>h</code>
排除了长度超过一个条目的列表，因此没有「缺少情况」的错误。
然而，即使此程序总是停机，它也不是结构化递归的：</p>
<pre><code class="language-output error">fail to show termination for
  mergeSort
with errors
argument #3 was not used for structural recursion
  failed to eliminate recursive application
    mergeSort halves.fst

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<!--
The reason it terminates is that `splitList` always returns lists that are shorter than its input.
Thus, the length of `halves.fst` and `halves.snd` are less than the length of `xs`.
This can be expressed using a `termination_by` clause:
-->
<p>它能停机的原因是 <code>splitList</code> 总是返回比其输入更短的列表。
因此，<code>halves.fst</code> 和 <code>halves.snd</code> 的长度小于 <code>xs</code> 的长度。
这可以使用 <code>termination_by</code> 子句来表示：</p>
<pre><code class="language-lean">def mergeSort [Ord α] (xs : List α) : List α :=
  if h : xs.length &lt; 2 then
    match xs with
    | [] =&gt; []
    | [x] =&gt; [x]
  else
    let halves := splitList xs
    merge (mergeSort halves.fst) (mergeSort halves.snd)
termination_by mergeSort xs =&gt; xs.length
</code></pre>
<!--
With this clause, the error message changes.
Instead of complaining that the function isn't structurally recursive, Lean instead points out that it was unable to automatically prove that `(splitList xs).fst.length < xs.length`:
-->
<p>有了这个子句，错误信息就变了。Lean 不会抱怨函数不是结构化递归的，
而是指出它无法自动证明 <code>(splitList xs).fst.length &lt; xs.length</code>：</p>
<pre><code class="language-output error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
α : Type u_1
xs : List α
h : ¬List.length xs &lt; 2
halves : List α × List α := splitList xs
⊢ List.length (splitList xs).fst &lt; List.length xs
</code></pre>
<!--
## Splitting a List Makes it Shorter
-->
<h2 id="分割列表使其变短"><a class="header" href="#分割列表使其变短">分割列表使其变短</a></h2>
<!--
It will also be necessary to prove that `(splitList xs).snd.length < xs.length`.
Because `splitList` alternates between adding entries to the two lists, it is easiest to prove both statements at once, so the structure of the proof can follow the algorithm used to implement `splitList`.
In other words, it is easiest to prove that `∀(lst : List), (splitList lst).fst.length < lst.length ∧ (splitList lst).snd.length < lst.length`.
-->
<p>还需要证明 <code>(splitList xs).snd.length &lt; xs.length</code>。由于 <code>splitList</code>
在向两个列表添加条目之间交替进行，因此最简单的方法是同时证明这两个语句，
这样证明的结构就可以遵循用于实现 <code>splitList</code> 的算法。换句话说，最简单的方法是证明
<code>∀(lst : List), (splitList lst).fst.length &lt; lst.length ∧ (splitList lst).snd.length &lt; lst.length</code>。</p>
<!--
Unfortunately, the statement is false.
In particular, `splitList []` is `([], [])`. Both output lists have length `0`, which is not less than `0`, the length of the input list.
Similarly, `splitList ["basalt"]` evaluates to `(["basalt"], [])`, and `["basalt"]` is not shorter than `["basalt"]`.
However, `splitList ["basalt", "granite"]` evaluates to `(["basalt"], ["granite"])`, and both of these output lists are shorter than the input list.
-->
<p>不幸的是，这个陈述是错误的。特别是，
<code>splitList []</code> 是
<code>([], [])</code>。
两个输出列表的长度都是 <code>0</code>，这并不小于输入列表的长度 <code>0</code>。类似地，
<code>splitList [&quot;basalt&quot;]</code> 求值为
<code>([\&quot;basalt\&quot;], [])</code>，而 <code>[&quot;basalt&quot;]</code> 并不比 <code>[&quot;basalt&quot;]</code> 短。然而，
<code>splitList [&quot;basalt&quot;, &quot;granite&quot;]</code> 求值为
<code>([&quot;basalt&quot;], [&quot;granite&quot;])</code>，
这两个输出列表都比输入列表短。</p>
<!--
It turns out that the lengths of the output lists are always less than or equal to the length of the input list, but they are only strictly shorter when the input list contains at least two entries.
It turns out to be easiest to prove the former statement, then extend it to the latter statement.
Begin with a theorem statement:
-->
<p>输出列表的长度始终小于或等于输入列表的长度，但仅当输入列表至少包含两个条目时，
它们才严格更短。事实证明，最容易证明前一个陈述，然后将其扩展到后一个陈述。
从定理的陈述开始：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  skip
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
⊢ List.length (splitList lst).fst ≤ List.length lst ∧ List.length (splitList lst).snd ≤ List.length lst
</code></pre>
<!--
Because `splitList` is structurally recursive on the list, the proof should use induction.
The structural recursion in `splitList` fits a proof by induction perfectly: the base case of the induction matches the base case of the recursion, and the inductive step matches the recursive call.
The `induction` tactic gives two goals:
-->
<p>由于 <code>splitList</code> 在列表上是结构化递归的，因此证明应使用归纳法。
<code>splitList</code> 中的结构化递归非常适合归纳证明：归纳法的基本情况与递归的基本情况匹配，
归纳步骤与递归调用匹配。<code>induction</code> 策略给出了两个目标：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; skip
  | cons x xs ih =&gt; skip
</code></pre>
<pre><code class="language-output error">unsolved goals
case nil
α : Type u_1
⊢ List.length (splitList []).fst ≤ List.length [] ∧ List.length (splitList []).snd ≤ List.length []
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
α : Type u_1
x : α
xs : List α
ih : List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs
⊢ List.length (splitList (x :: xs)).fst ≤ List.length (x :: xs) ∧
    List.length (splitList (x :: xs)).snd ≤ List.length (x :: xs)
</code></pre>
<!--
The goal for the `nil` case can be proved by invoking the simplifier and instructing it to unfold the definition of `splitList`, because the length of the empty list is less than or equal to the length of the empty list.
Similarly, simplifying with `splitList` in the `cons` case places `Nat.succ` around the lengths in the goal:
-->
<p>可以通过调用简化器并指示它展开 <code>splitList</code> 的定义来证明 <code>nil</code> 情况的目标，
因为空列表的长度小于或等于空列表的长度。类似地，在 <code>cons</code> 情况下使用 <code>splitList</code>
简化会在目标中的长度周围放置 <code>Nat.succ</code>：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
α : Type u_1
x : α
xs : List α
ih : List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs) ∧
    List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<!--
This is because the call to `List.length` consumes the head of the list `x :: xs`, converting it to a `Nat.succ`, in both the length of the input list and the length of the first output list.
-->
<p>这是因为对 <code>List.length</code> 的调用消耗了列表 <code>x :: xs</code> 的头部，将其转换为 <code>Nat.succ</code>，
既在输入列表的长度中，也在第一个输出列表的长度中。</p>
<!--
Writing `A ∧ B` in Lean is short for `And A B`.
`And` is a structure type in the `Prop` universe:
-->
<p>在 Lean 中编写 <code>A ∧ B</code> 是 <code>And A B</code> 的缩写。
<code>And</code> 是 <code>Prop</code> 宇宙中的一个结构体类型：</p>
<pre><code class="language-lean">structure And (a b : Prop) : Prop where
  intro ::
  left : a
  right : b
</code></pre>
<!--
In other words, a proof of `A ∧ B` consists of the `And.intro` constructor applied to a proof of `A` in the `left` field and a proof of `B` in the `right` field.
-->
<p>换句话说，<code>A ∧ B</code> 的证明包括应用于 <code>left</code> 字段中 <code>A</code> 的证明和应用于 <code>right</code>
字段中 <code>B</code> 的证明的 <code>And.intro</code> 构造子。</p>
<!--
The `cases` tactic allows a proof to consider each constructor of a datatype or each potential proof of a proposition in turn.
It corresponds to a `match` expression without recursion.
Using `cases` on a structure results in the structure being broken apart, with an assumption added for each field of the structure, just as a pattern match expression extracts the field of a structure for use in a program.
Because structures have only one constructor, using `cases` on a structure does not result in additional goals.
-->
<p><code>cases</code> 策略允许证明依次考虑数据类型的每个构造子或命题的每个潜在证明。
它对应于没有递归的 <code>match</code> 表达式。对结构体使用 <code>cases</code> 会导致结构体被分解，
并为结构体的每个字段添加一个假设，就像模式匹配表达式提取结构体的字段以用于程序中一样。
由于结构体只有一个构造子，因此对结构体使用 <code>cases</code> 不会产生额外的目标。</p>
<!--
Because `ih` is a proof of `List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs`, using `cases ih` results in an assumption that `List.length (splitList xs).fst ≤ List.length xs` and an assumption that `List.length (splitList xs).snd ≤ List.length xs`:
-->
<p>由于 <code>ih</code> 是
<code>List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs</code>
的一个证明，使用 <code>cases ih</code> 会产生一个 <code>List.length (splitList xs).fst ≤ List.length xs</code> 的假设
和一个 <code>List.length (splitList xs).snd ≤ List.length xs</code> 的假设:</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons.intro
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs) ∧
    List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<!--
Because the goal of the proof is also an `And`, the `constructor` tactic can be used to apply `And.intro`, resulting in a goal for each argument:
-->
<p>由于证明的目标也是一个 <code>And</code>，因此可以使用 <code>constructor</code> 策略应用 <code>And.intro</code>，
从而为每个参数生成一个目标：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
    constructor
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons.intro.left
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs)

case cons.intro.right
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<!--
The `left` goal is very similar to the `left✝` assumption, except the goal wraps both sides of the inequality in `Nat.succ`.
Likewise, the `right` goal resembles the `right✝` assumption, except the goal adds a `Nat.succ` only to the length of the input list.
It's time to prove that these wrappings of `Nat.succ` preserve the truth of the statement.
-->
<p><code>left</code> 目标与 <code>left✝</code> 假设非常相似，除了目标用 <code>Nat.succ</code> 包装不等式的两侧。
同样，<code>right</code> 目标类似于 <code>right✝</code> 假设，除了目标仅将 <code>Nat.succ</code> 添加到输入列表的长度。
现在是时候证明 <code>Nat.succ</code> 的这些包装保留了陈述的真值了。</p>
<!--
### Adding One to Both Sides
-->
<h3 id="两边同时加一"><a class="header" href="#两边同时加一">两边同时加一</a></h3>
<!--
For the `left` goal, the statement to prove is `Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m`.
In other words, if `n ≤ m`, then adding one to both sides doesn't change this fact.
Why is this true?
The proof that `n ≤ m` is a `Nat.le.refl` constructor with `m - n` instances of the `Nat.le.step` constructor wrapped around it.
Adding one to both sides simply means that the `refl` applies to a number that's one larger than before, with the same number of `step` constructors.
-->
<p>对于 <code>left</code> 目标，要证明的语句是 <code>Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m</code>。
换句话说，如果 <code>n ≤ m</code>，那么在两边都加一并不会改变这一事实。为什么这是真的？
证明 <code>n ≤ m</code> 是一个 <code>Nat.le.refl</code> 构造子，周围有 <code>m - n</code> 个 <code>Nat.le.step</code> 构造子的实例。
在两边都加一只是意味着 <code>refl</code> 应用于比之前大一的数，并且具有相同数量的 <code>step</code> 构造子。</p>
<!--
More formally, the proof is by induction on the evidence that `n ≤ m`.
If the evidence is `refl`, then `n = m`, so `Nat.succ n = Nat.succ m` and `refl` can be used again.
If the evidence is `step`, then the induction hypothesis provides evidence that `Nat.succ n ≤ Nat.succ m`, and the goal is to show that `Nat.succ n ≤ Nat.succ (Nat.succ m)`.
This can be done by using `step` together with the induction hypothesis.
-->
<p>更形式化地说，证明是通过归纳法来证明 <code>n ≤ m</code> 的证据。如果证据是 <code>refl</code>，则 <code>n = m</code>，
因此 <code>Nat.succ n = Nat.succ m</code>，并且可以再次使用 <code>refl</code>。
如果证据是 <code>step</code>，则归纳假设提供了 <code>Nat.succ n ≤ Nat.succ m</code> 的证据，
并且目标是证明 <code>Nat.succ n ≤ Nat.succ (Nat.succ m)</code>。
这可以通过将 <code>step</code> 与归纳假设一起使用来完成。</p>
<!--
In Lean, the theorem statement is:
-->
<p>在 Lean 中，该定理陈述为：</p>
<pre><code class="language-leantac">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m := by
  skip
</code></pre>
<!--
and the error message recapitulates it:
-->
<p>错误信息对其进行了概括：</p>
<pre><code class="language-output error">unsolved goals
n m : Nat
⊢ n ≤ m → Nat.succ n ≤ Nat.succ m
</code></pre>
<!--
The first step is to use the `intro` tactic, bringing the hypothesis that `n ≤ m` into scope and giving it a name:
-->
<p>第一步是使用 <code>intro</code> 策略，将假设 <code>n ≤ m</code> 引入作用域并为其命名：</p>
<pre><code class="language-leantac">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m := by
  intro h
</code></pre>
<pre><code class="language-output error">unsolved goals
n m : Nat
h : n ≤ m
⊢ Nat.succ n ≤ Nat.succ m
</code></pre>
<!--
Because the proof is by induction on the evidence that `n ≤ m`, the next tactic is `induction h`:
-->
<p>由于证明是通过归纳法对证据 <code>n ≤ m</code> 进行的，因此下一个策略是 <code>induction h</code>：</p>
<pre><code class="language-leantac">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m := by
  intro h
  induction h
</code></pre>
<!--
This results in two goals, once for each constructor of `Nat.le`:
-->
<p>这会产生两个目标，每个目标对应于 <code>Nat.le</code> 的一个构造子：</p>
<pre><code class="language-output error">unsolved goals
case refl
n m : Nat
⊢ Nat.succ n ≤ Nat.succ n

case step
n m m✝ : Nat
a✝ : Nat.le n m✝
a_ih✝ : Nat.succ n ≤ Nat.succ m✝
⊢ Nat.succ n ≤ Nat.succ (Nat.succ m✝)
</code></pre>
<!--
The goal for `refl` can itself be solved using `refl`, which the `constructor` tactic selects.
The goal for `step` will also require a use of the `step` constructor:
-->
<p><code>refl</code> 的目标可以使用 <code>refl</code> 本身来解决，<code>constructor</code> 策略会选择它。
<code>step</code> 的目标还需要使用 <code>step</code> 构造子：</p>
<pre><code class="language-leantac">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m := by
  intro h
  induction h with
  | refl =&gt; constructor
  | step h' ih =&gt; constructor
</code></pre>
<pre><code class="language-output error">unsolved goals
case step.a
n m m✝ : Nat
h' : Nat.le n m✝
ih : Nat.succ n ≤ Nat.succ m✝
⊢ Nat.le (Nat.succ n) (m✝ + 1)
</code></pre>
<!--
The goal is no longer shown using the `≤` operator, but it is equivalent to the induction hypothesis `ih`.
The `assumption` tactic automatically selects an assumption that fulfills the goal, and the proof is complete:
-->
<p>该目标不再使用 <code>≤</code> 运算符显示，但它等价于归纳假设 <code>ih</code>。
<code>assumption</code> 策略会自动选择一个满足目标的假设，证明完毕：</p>
<pre><code class="language-leantac">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m := by
  intro h
  induction h with
  | refl =&gt; constructor
  | step h' ih =&gt;
    constructor
    assumption
</code></pre>
<!--
Written as a recursive function, the proof is:
-->
<p>写成递归函数，证明如下：</p>
<pre><code class="language-lean">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m
  | .refl =&gt; .refl
  | .step h' =&gt; .step (Nat.succ_le_succ h')
</code></pre>
<!--
It can be instructional to compare the tactic-based proof by induction with this recursive function.
Which proof steps correspond to which parts of the definition?
-->
<p>将基于策略的归纳证明与这个递归函数进行比较是有指导意义的。哪些证明步骤对应于定义的哪些部分？</p>
<!--
### Adding One to the Greater Side
-->
<h3 id="在较大的一侧加一"><a class="header" href="#在较大的一侧加一">在较大的一侧加一</a></h3>
<!--
The second inequality needed to prove `splitList_shorter_le` is `∀(n m : Nat), n ≤ m → n ≤ Nat.succ m`.
This proof is almost identical to `Nat.succ_le_succ`.
Once again, the incoming assumption that `n ≤ m` essentially tracks the difference between `n` and `m` in the number of `Nat.le.step` constructors.
Thus, the proof should add an extra `Nat.le.step` in the base case.
The proof can be written:
-->
<p>证明 <code>splitList_shorter_le</code> 所需的第二个不等式是 <code>∀(n m : Nat), n ≤ m → n ≤ Nat.succ m</code>。
这个证明几乎与 <code>Nat.succ_le_succ</code> 相同。同样，传入的假设 <code>n ≤ m</code> 基本上跟踪了 <code>n</code> 和 <code>m</code>
在 <code>Nat.le.step</code> 构造子数量上的差异。因此，证明应该在基本情况下添加一个额外的 <code>Nat.le.step</code>。
证明可以写成：</p>
<pre><code class="language-leantac">theorem Nat.le_succ_of_le : n ≤ m → n ≤ Nat.succ m := by
  intro h
  induction h with
  | refl =&gt; constructor; constructor
  | step =&gt; constructor; assumption
</code></pre>
<!--
To reveal what's going on behind the scenes, the `apply` and `exact` tactics can be used to indicate exactly which constructor is being applied.
The `apply` tactic solves the current goal by applying a function or constructor whose return type matches, creating new goals for each argument that was not provided, while `exact` fails if any new goals would be needed:
-->
<p>为了揭示幕后发生的事情，<code>apply</code> 和 <code>exact</code> 策略可用于准确指示正在应用哪个构造子。
<code>apply</code> 策略通过应用一个返回类型匹配的函数或构造子来解决当前目标，
为每个未提供的参数创建新的目标，而如果需要任何新目标，<code>exact</code> 就会失败：</p>
<pre><code class="language-leantac">theorem Nat.le_succ_of_le : n ≤ m → n ≤ Nat.succ m := by
  intro h
  induction h with
  | refl =&gt; apply Nat.le.step; exact Nat.le.refl
  | step _ ih =&gt; apply Nat.le.step; exact ih
</code></pre>
<!--
The proof can be golfed:
-->
<p>证明可以简化：</p>
<pre><code class="language-leantac">theorem Nat.le_succ_of_le (h : n ≤ m) : n ≤ Nat.succ m := by
  induction h &lt;;&gt; repeat (first | constructor | assumption)
</code></pre>
<!--
In this short tactic script, both goals introduced by `induction` are addressed using `repeat (first | constructor | assumption)`.
The tactic `first | T1 | T2 | ... | Tn` means to use try `T1` through `Tn` in order, using the first tactic that succeeds.
In other words, `repeat (first | constructor | assumption)` applies constructors as long as it can, and then attempts to solve the goal using an assumption.
-->
<p>在这个简短的策略脚本中，由 <code>induction</code> 引入的两个目标都使用
<code>repeat (first | constructor | assumption)</code> 来解决。策略 <code>first | T1 | T2 | ... | Tn</code>
表示按顺序尝试 <code>T1</code> 到 <code>Tn</code>，然后使用第一个成功的策略。
换句话说，<code>repeat (first | constructor | assumption)</code> 会尽可能地应用构造子，
然后尝试使用假设来解决目标。</p>
<!--
Finally, the proof can be written as a recursive function:
-->
<p>最后，证明可以写成一个递归函数：</p>
<pre><code class="language-lean">theorem Nat.le_succ_of_le : n ≤ m → n ≤ Nat.succ m
  | .refl =&gt; .step .refl
  | .step h =&gt; .step (Nat.le_succ_of_le h)
</code></pre>
<!--
Each style of proof can be appropriate to different circumstances.
The detailed proof script is useful in cases where beginners may be reading the code, or where the steps of the proof provide some kind of insight.
The short, highly-automated proof script is typically easier to maintain, because automation is frequently both flexible and robust in the face of small changes to definitions and datatypes.
The recursive function is typically both harder to understand from the perspective of mathematical proofs and harder to maintain, but it can be a useful bridge for programmers who are beginning to work with interactive theorem proving.
-->
<p>每种证明风格都适用于不同的情况。详细的证明脚本在初学者阅读代码或证明步骤提供某种见解的情况下很有用。
简短、高度自动化的证明脚本通常更容易维护，因为自动化通常在面对定义和数据类型的细微更改时既灵活又健壮。
递归函数通常从数学证明的角度来看更难理解，也更难维护，但对于开始使用交互式定理证明的程序员来说，
它可能是一个有用的桥梁。</p>
<!--
### Finishing the Proof
-->
<h3 id="完成证明"><a class="header" href="#完成证明">完成证明</a></h3>
<!--
Now that both helper theorems have been proved, the rest of `splitList_shorter_le` will be completed quickly.
The current proof state has two goals, for the left and right sides of the `And`:
-->
<p>现在已经证明了两个辅助定理，<code>splitList_shorter_le</code> 的其余部分将很快完成。
当前的证明状态有两个目标，用于 <code>And</code> 的左侧和右侧：</p>
<pre><code class="language-output error">unsolved goals
case cons.intro.left
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs)

case cons.intro.right
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<!--
The goals are named for the fields of the `And` structure. This means that the `case` tactic (not to be confused with `cases`) can be used to focus on each of them in turn:
-->
<p>目标以 <code>And</code> 结构体的字段命名。这意味着 <code>case</code> 策略（不要与 <code>cases</code> 混淆）可以依次关注于每个目标：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧ (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
    constructor
    case left =&gt; skip
    case right =&gt; skip
</code></pre>
<!--
Instead of a single error that lists both unsolved goals, there are now two messages, one on each `skip`.
For the `left` goal, `Nat.succ_le_succ` can be used:
-->
<p>现在不再是一个错误列出两个未解决的目标，而是有两个错误信息，
每个 <code>skip</code> 上一个。对于<code>left</code>目标，可以使用<code>Nat.succ_le_succ</code>：</p>
<pre><code class="language-output error">unsolved goals
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs)
</code></pre>
<!--
In the right goal, `Nat.le_suc_of_le` fits:
-->
<p>在右侧目标中，<code>Nat.le_suc_of_le</code> 适合：</p>
<pre><code class="language-output error">unsolved goals
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<!--
Both theorems include the precondition that `n ≤ m`.
These can be found as the `left✝` and `right✝` assumptions, which means that the `assumption` tactic takes care of the final goals:
-->
<p>这两个定理都包含前提条件 <code>n ≤ m</code>。它们可以作为 <code>left✝</code> 和 <code>right✝</code> 假设找到，
这意味着 <code>assumption</code> 策略可以处理最终目标：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧ (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
    constructor
    case left =&gt; apply Nat.succ_le_succ; assumption
    case right =&gt; apply Nat.le_succ_of_le; assumption
</code></pre>
<!--
The next step is to return to the actual theorem that is needed to prove that merge sort terminates: that so long as a list has at least two entries, both results of splitting it are strictly shorter.
-->
<p>下一步是返回到证明归并排序停机所需的实际定理：只要一个列表至少有两个条目，
则分割它的两个结果都严格短于它。</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  skip
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
x✝ : List.length lst ≥ 2
⊢ List.length (splitList lst).fst &lt; List.length lst ∧ List.length (splitList lst).snd &lt; List.length lst
</code></pre>
<!--
Pattern matching works just as well in tactic scripts as it does in programs.
Because `lst` has at least two entries, they can be exposed with `match`, which also refines the type through dependent pattern matching:
-->
<p>模式匹配在策略脚本中与在程序中一样有效。因为 <code>lst</code> 至少有两个条目，
所以它们可以用 <code>match</code> 暴露出来，它还通过依值模式匹配来细化类型：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  match lst with
  | x :: y :: xs =&gt;
    skip
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
x y : α
xs : List α
x✝ : List.length (x :: y :: xs) ≥ 2
⊢ List.length (splitList (x :: y :: xs)).fst &lt; List.length (x :: y :: xs) ∧
    List.length (splitList (x :: y :: xs)).snd &lt; List.length (x :: y :: xs)
</code></pre>
<!--
Simplifying using `splitList` removes `x` and `y`, resulting in the computed lengths of lists each gaining a `Nat.succ`:
-->
<p>使用 <code>splitList</code> 简化会删除 <code>x</code> 和 <code>y</code>，导致列表的计算长度每个都获得 <code>Nat.succ</code>：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  match lst with
  | x :: y :: xs =&gt;
    simp [splitList]
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
x y : α
xs : List α
x✝ : List.length (x :: y :: xs) ≥ 2
⊢ Nat.succ (List.length (splitList xs).fst) &lt; Nat.succ (Nat.succ (List.length xs)) ∧
    Nat.succ (List.length (splitList xs).snd) &lt; Nat.succ (Nat.succ (List.length xs))
</code></pre>
<!--
Replacing `simp` with `simp_arith` removes these `Nat.succ` constructors, because `simp_arith` makes use of the fact that `n + 1 < m + 1` implies `n < m`:
-->
<p>用 <code>simp_arith</code> 替换 <code>simp</code> 会删除这些 <code>Nat.succ</code> 构造子，
因为 <code>simp_arith</code> 利用了 <code>n + 1 &lt; m + 1</code> 意味着 <code>n &lt; m</code> 的事实：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  match lst with
  | x :: y :: xs =&gt;
    simp_arith [splitList]
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
x y : α
xs : List α
x✝ : List.length (x :: y :: xs) ≥ 2
⊢ List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs
</code></pre>
<!--
This goal now matches `splitList_shorter_le`, which can be used to conclude the proof:
-->
<p>此目标现在匹配 <code>splitList_shorter_le</code>，可用于结束证明：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  match lst with
  | x :: y :: xs =&gt;
    simp_arith [splitList]
    apply splitList_shorter_le
</code></pre>
<!--
The facts needed to prove that `mergeSort` terminates can be pulled out of the resulting `And`:
-->
<p>证明 <code>mergeSort</code> 停机所需的事实可以从结果 <code>And</code> 中提取出来：</p>
<pre><code class="language-leantac">theorem splitList_shorter_fst (lst : List α) (h : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length :=
  splitList_shorter lst h |&gt;.left

theorem splitList_shorter_snd (lst : List α) (h : lst.length ≥ 2) :
    (splitList lst).snd.length &lt; lst.length :=
  splitList_shorter lst h |&gt;.right
</code></pre>
<!--
## Merge Sort Terminates
-->
<h2 id="归并排序停机证明"><a class="header" href="#归并排序停机证明">归并排序停机证明</a></h2>
<!--
Merge sort has two recursive calls, one for each sub-list returned by `splitList`.
Each recursive call will require a proof that the length of the list being passed to it is shorter than the length of the input list.
It's usually convenient to write a termination proof in two steps: first, write down the propositions that will allow Lean to verify termination, and then prove them.
Otherwise, it's possible to put a lot of effort into proving the propositions, only to find out that they aren't quite what's needed to establish that the recursive calls are on smaller inputs.
-->
<p>归并排序有两个递归调用，一个用于 <code>splitList</code> 返回的每个子列表。
每个递归调用都需要证明传递给它的列表的长度短于输入列表的长度。
通常分两步编写停机证明会更方便：首先，写下允许 Lean 验证停机的命题，然后证明它们。
否则，可能会投入大量精力来证明命题，却发现它们并不是所需的在更小的输入上建立递归调用的内容。</p>
<!--
The `sorry` tactic can prove any goal, even false ones.
It isn't intended for use in production code or final proofs, but it is a convenient way to "sketch out" a proof or program ahead of time.
Any definitions or theorems that use `sorry` are annotated with a warning.
-->
<p><code>sorry</code> 策略可以证明任何目标，即使是错误的目标。它不适用于生产代码或最终证明，
但它是一种便捷的方法，可以提前「勾勒出」证明或程序。任何使用 <code>sorry</code> 的定义或定理都会附有警告。</p>
<!--
The initial sketch of `mergeSort`'s termination argument that uses `sorry` can be written by copying the goals that Lean couldn't prove into `have`-expressions.
In Lean, `have` is similar to `let`.
When using `have`, the name is optional.
Typically, `let` is used to define names that refer to interesting values, while `have` is used to locally prove propositions that can be found when Lean is searching for evidence that an array lookup is in-bounds or that a function terminates.
-->
<p>使用 <code>sorry</code> 的 <code>mergeSort</code> 停机论证的初始草图可以通过将 Lean 无法证明的目标复制到
<code>have</code> 表达式中来编写。在 Lean 中，<code>have</code> 类似于 <code>let</code>。使用 <code>have</code> 时，名称是可选的。
通常，<code>let</code> 用于定义引用关键值的名称，而 <code>have</code> 用于局部证明命题，
当 Lean 在寻找「数组查找是否在范围内」或「函数是否停机」的证据时，可以找到这些命题。</p>
<pre><code class="language-leantac">def mergeSort [Ord α] (xs : List α) : List α :=
  if h : xs.length &lt; 2 then
    match xs with
    | [] =&gt; []
    | [x] =&gt; [x]
  else
    let halves := splitList xs
    have : halves.fst.length &lt; xs.length := by
      sorry
    have : halves.snd.length &lt; xs.length := by
      sorry
    merge (mergeSort halves.fst) (mergeSort halves.snd)
termination_by mergeSort xs =&gt; xs.length
</code></pre>
<!--
The warning is located on the name `mergeSort`:
-->
<p>警告位于名称 <code>mergeSort</code> 上：</p>
<pre><code class="language-output warning">declaration uses 'sorry'
</code></pre>
<!--
Because there are no errors, the proposed propositions are enough to establish termination.
-->
<p>因为没有错误，所以建议的命题足以建立停机证明。</p>
<!--
The proofs begin by applying the helper theorems:
-->
<p>证明从应用辅助定理开始：</p>
<pre><code class="language-leantac">def mergeSort [Ord α] (xs : List α) : List α :=
  if h : xs.length &lt; 2 then
    match xs with
    | [] =&gt; []
    | [x] =&gt; [x]
  else
    let halves := splitList xs
    have : halves.fst.length &lt; xs.length := by
      apply splitList_shorter_fst
    have : halves.snd.length &lt; xs.length := by
      apply splitList_shorter_snd
    merge (mergeSort halves.fst) (mergeSort halves.snd)
termination_by mergeSort xs =&gt; xs.length
</code></pre>
<!--
Both proofs fail, because `splitList_shorter_fst` and `splitList_shorter_snd` both require a proof that `xs.length ≥ 2`:
-->
<p>两个证明都失败了，因为 <code>splitList_shorter_fst</code> 和 <code>splitList_shorter_snd</code>
都需要证明 <code>xs.length ≥ 2</code>：</p>
<pre><code class="language-output error">unsolved goals
case h
α : Type ?u.37732
inst✝ : Ord α
xs : List α
h : ¬List.length xs &lt; 2
halves : List α × List α := splitList xs
⊢ List.length xs ≥ 2
</code></pre>
<!--
To check that this will be enough to complete the proof, add it using `sorry` and check for errors:
-->
<p>要检查这是否足以完成证明，请使用 <code>sorry</code> 添加它并检查错误：</p>
<pre><code class="language-leantac">def mergeSort [Ord α] (xs : List α) : List α :=
  if h : xs.length &lt; 2 then
    match xs with
    | [] =&gt; []
    | [x] =&gt; [x]
  else
    let halves := splitList xs
    have : xs.length ≥ 2 := by sorry
    have : halves.fst.length &lt; xs.length := by
      apply splitList_shorter_fst
      assumption
    have : halves.snd.length &lt; xs.length := by
      apply splitList_shorter_snd
      assumption
    merge (mergeSort halves.fst) (mergeSort halves.snd)
termination_by mergeSort xs =&gt; xs.length
</code></pre>
<!--
Once again, there is only a warning.
-->
<p>同样，只会有一个警告。</p>
<pre><code class="language-output warning">declaration uses 'sorry'
</code></pre>
<!--
There is one promising assumption available: `h : ¬List.length xs < 2`, which comes from the `if`.
Clearly, if it is not the case that `xs.length < 2`, then `xs.length ≥ 2`.
The Lean library provides this theorem under the name `Nat.ge_of_not_lt`.
The program is now complete:
-->
<p>有一个有希望的假设可用：<code>h : ¬List.length xs &lt; 2</code>，它来自 <code>if</code>。
显然，如果不是 <code>xs.length &lt; 2</code>，那么 <code>xs.length ≥ 2</code>。
Lean 库以 <code>Nat.ge_of_not_lt</code> 的名称提供了此定理。程序现在已完成：</p>
<pre><code class="language-leantac">def mergeSort [Ord α] (xs : List α) : List α :=
  if h : xs.length &lt; 2 then
    match xs with
    | [] =&gt; []
    | [x] =&gt; [x]
  else
    let halves := splitList xs
    have : xs.length ≥ 2 := by
      apply Nat.ge_of_not_lt
      assumption
    have : halves.fst.length &lt; xs.length := by
      apply splitList_shorter_fst
      assumption
    have : halves.snd.length &lt; xs.length := by
      apply splitList_shorter_snd
      assumption
    merge (mergeSort halves.fst) (mergeSort halves.snd)
termination_by mergeSort xs =&gt; xs.length
</code></pre>
<!--
The function can be tested on examples:
-->
<p>该函数可以在示例上进行测试：</p>
<pre><code class="language-lean">#eval mergeSort [&quot;soapstone&quot;, &quot;geode&quot;, &quot;mica&quot;, &quot;limestone&quot;]
</code></pre>
<pre><code class="language-output info">[&quot;geode&quot;, &quot;limestone&quot;, &quot;mica&quot;, &quot;soapstone&quot;]
</code></pre>
<pre><code class="language-lean">#eval mergeSort [5, 3, 22, 15]
</code></pre>
<pre><code class="language-output info">[3, 5, 15, 22]
</code></pre>
<!--
## Division as Iterated Subtraction
-->
<h2 id="用减法迭代表示除法"><a class="header" href="#用减法迭代表示除法">用减法迭代表示除法</a></h2>
<!--
Just as multiplication is iterated addition and exponentiation is iterated multiplication, division can be understood as iterated subtraction.
The [very first description of recursive functions in this book](../getting-to-know/datatypes-and-patterns.md#recursive-functions) presents a version of division that terminates when the divisor is not zero, but that Lean does not accept.
Proving that division terminates requires the use of a fact about inequalities.
-->
<p>正如乘法是迭代的加法，指数是迭代的乘法，除法可以理解为迭代的减法。
<a href="../getting-to-know/datatypes-and-patterns.html#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">本书中对递归函数的第一个描述</a>
给出了除法的一个版本，当除数不为零时停机，但 Lean 并不接受。证明除法终止需要使用关于不等式的事实。</p>
<!--
The first step is to refine the definition of division so that it requires evidence that the divisor is not zero:
-->
<p>第一步是细化除法的定义，使其需要证据证明除数不为零：</p>
<pre><code class="language-lean">def div (n k : Nat) (ok : k &gt; 0) : Nat :=
  if n &lt; k then
    0
  else
    1 + div (n - k) k ok
</code></pre>
<!--
The error message is somewhat longer, due to the additional argument, but it contains essentially the same information:
-->
<p>由于增加了参数，错误信息会稍长一些，但它包含基本相同的信息：</p>
<pre><code class="language-output error">fail to show termination for
  div
with errors
argument #1 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k ok

argument #2 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k ok

argument #3 was not used for structural recursion
  application type mismatch
    @Nat.le.brecOn (Nat.succ 0) fun k ok =&gt; Nat → Nat
  argument
    fun k ok =&gt; Nat → Nat
  has type
    (k : Nat) → k &gt; 0 → Type : Type 1
  but is expected to have type
    (a : Nat) → Nat.le (Nat.succ 0) a → Prop : Type

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<!--
This definition of `div` terminates because the first argument `n` is smaller on each recursive call.
This can be expressed using a `termination_by` clause:
-->
<p><code>div</code> 的这个定义会停机，因为第一个参数 <code>n</code> 在每次递归调用时都更小。
这可以使用 <code>termination_by</code> 子句来表示：</p>
<pre><code class="language-lean">def div (n k : Nat) (ok : k &gt; 0) : Nat :=
  if h : n &lt; k then
    0
  else
    1 + div (n - k) k ok
termination_by div n k ok =&gt; n
</code></pre>
<!--
Now, the error is confined to the recursive call:
-->
<p>现在，错误仅限于递归调用：</p>
<pre><code class="language-output error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
n k : Nat
ok : k &gt; 0
h : ¬n &lt; k
⊢ n - k &lt; n
</code></pre>
<!--
This can be proved using a theorem from the standard library, `Nat.sub_lt`.
This theorem states that `∀ {n k : Nat}, 0 < n → 0 < k → n - k < n` (the curly braces indicate that `n` and `k` are implicit arguments).
Using this theorem requires demonstrating that both `n` and `k` are greater than zero.
Because `k > 0` is syntactic sugar for `0 < k`, the only necessary goal is to show that `0 < n`.
There are two possibilities: either `n` is `0`, or it is `n' + 1` for some other `Nat` `n'`.
But `n` cannot be `0`.
The fact that the `if` selected the second branch means that `¬ n < k`, but if `n = 0` and `k > 0` then `n` must be less than `k`, which would be a contradiction.
This, `n = Nat.succ n'`, and `Nat.succ n'` is clearly greater than `0`.
-->
<p>This can be proved using a theorem from the standard library, <code>Nat.sub_lt</code>.
This theorem states that  (the curly braces indicate that <code>n</code> and <code>k</code> are implicit arguments).
Using this theorem requires demonstrating that both <code>n</code> and <code>k</code> are greater than zero.
Because <code>k &gt; 0</code> is syntactic sugar for <code>0 &lt; k</code>, the only necessary goal is to show that <code>0 &lt; n</code>.
There are two possibilities: either <code>n</code> is <code>0</code>, or it is <code>n' + 1</code> for some other <code>Nat</code> <code>n'</code>.
But <code>n</code> cannot be <code>0</code>.
The fact that the <code>if</code> selected the second branch means that <code>¬ n &lt; k</code>, but if <code>n = 0</code> and <code>k &gt; 0</code> then <code>n</code> must be less than <code>k</code>, which would be a contradiction.
This, <code>n = Nat.succ n'</code>, and <code>Nat.succ n'</code> is clearly greater than <code>0</code>.
这可以使用标准库中的定理 <code>Nat.sub_lt</code> 来证明。该定理指出
<code>∀ {n k : Nat}, 0 &lt; n → 0 &lt; k → n - k &lt; n</code>
（花括号表示 <code>n</code> 和 <code>k</code> 是隐式参数）。使用此定理需要证明 <code>n</code> 和 <code>k</code> 都大于零。
因为 <code>k &gt; 0</code> 是 <code>0 &lt; k</code> 的语法糖，所以唯一必要的目标是证明 <code>0 &lt; n</code>。
有两种可能性：<code>n</code> 为 <code>0</code>，或它为某个其他 <code>Nat n'</code> 的 <code>n' + 1</code>。
但 <code>n</code> 不能为 <code>0</code>。<code>if</code> 选择第二个分支的事实意味着 <code>¬ n &lt; k</code>，
但如果 <code>n = 0</code> 且 <code>k &gt; 0</code>，则 <code>n</code> 必须小于 <code>k</code>，这将会产生矛盾。
在这里，<code>n = Nat.succ n'</code>，而 <code>Nat.succ n'</code> 明显大于 <code>0</code>。</p>
<!--
The full definition of `div`, including the termination proof, is:
-->
<p><code>div</code> 的完整定义，包括停机证明：</p>
<pre><code class="language-leantac">def div (n k : Nat) (ok : k &gt; 0) : Nat :=
  if h : n &lt; k then
    0
  else
    have : 0 &lt; n := by
      cases n with
      | zero =&gt; contradiction
      | succ n' =&gt; simp_arith
    have : n - k &lt; n := by
      apply Nat.sub_lt &lt;;&gt; assumption
    1 + div (n - k) k ok
termination_by div n k ok =&gt; n
</code></pre>
<!--
## Exercises
-->
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<!--
Prove the following theorems:

 * For all natural numbers \\( n \\), \\( 0 < n + 1 \\).
 * For all natural numbers \\( n \\), \\( 0 \\leq n \\).
 * For all natural numbers \\( n \\) and \\( k \\), \\( (n + 1) - (k + 1) = n - k \\)
 * For all natural numbers \\( n \\) and \\( k \\), if \\( k < n \\) then \\( n \neq 0 \\)
 * For all natural numbers \\( n \\), \\( n - n = 0 \\)
 * For all natural numbers \\( n \\) and \\( k \\), if \\( n + 1 < k \\) then \\( n < k \\)
-->
<p>证明以下定理：</p>
<ul>
<li>对于所有的自然数 \( n \)，\( 0 &lt; n + 1 \)。</li>
<li>对于所有的自然数 \( n \)，\( 0 \leq n \)。</li>
<li>对于所有的自然数 \( n \) 和 \( k \)，\( (n + 1) - (k + 1) = n - k \)</li>
<li>对于所有的自然数 \( n \) 和 \( k \), 若 \( k &lt; n \) 则 \( n \neq 0 \)</li>
<li>对于所有的自然数 \( n \)，\( n - n = 0 \)</li>
<li>对于所有的自然数 \( n \) 和 \( k \)，若 \( n + 1 &lt; k \) 则 \( n &lt; k \)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../programs-proofs/arrays-termination.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../programs-proofs/fin.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../programs-proofs/arrays-termination.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../programs-proofs/fin.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
