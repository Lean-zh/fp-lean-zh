<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>逐步执行 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html" class="active"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构体和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的契约</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/hello-world/step-by-step.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Step By Step
-->
<h1 id="逐步执行"><a class="header" href="#逐步执行">逐步执行</a></h1>
<!--
A `do` block can be executed one line at a time.
Start with the program from the prior section:
-->
<p><code>do</code> 块可以逐行执行。从上一节的程序开始：</p>
<pre><code class="language-lean">  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<!--
## Standard IO
-->
<h2 id="标准-io"><a class="header" href="#标准-io">标准 IO</a></h2>
<!--
The first line is `  let stdin ← IO.getStdin`, while the remainder is:
-->
<p>第一行是 <code>  let stdin ← IO.getStdin</code>，其余部分是：</p>
<pre><code class="language-lean">  let stdout ← IO.getStdout
  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<!--
To execute a `let` statement that uses a `←`, start by evaluating the expression to the right of the arrow (in this case, `IO.getStdIn`).
Because this expression is just a variable, its value is looked up.
The resulting value is a built-in primitive `IO` action.
The next step is to execute this `IO` action, resulting in a value that represents the standard input stream, which has type `IO.FS.Stream`.
Standard input is then associated with the name to the left of the arrow (here `stdin`) for the remainder of the `do` block.
-->
<p>要执行使用 <code>←</code> 的 <code>let</code> 语句，首先求值箭头右侧的表达式（在本例中为 <code>IO.getStdIn</code>）。
因为该表达式只是一个变量，所以查找它的值。结果值是一个内置的 <code>IO</code> 原语活动。
下一步是执行此 <code>IO</code> 活动，结果是一个表示标准输入流的值，其类型为 <code>IO.FS.Stream</code>。
然后将标准输入与箭头左侧的名称（此处为 <code>stdin</code>）关联，以用于 <code>do</code> 块的其余部分。&quot;</p>
<!--
Executing the second line, `  let stdout ← IO.getStdout`, proceeds similarly.
First, the expression `IO.getStdout` is evaluated, yielding an `IO` action that will return the standard output.
Next, this action is executed, actually returning the standard output.
Finally, this value is associated with the name `stdout` for the remainder of the `do` block.
-->
<p>执行第二行 <code>  let stdout ← IO.getStdout</code> 的过程类似。
首先，求值表达式 <code>IO.getStdout</code>，得到一个 <code>IO</code> 活动，该活动将返回标准输出。
接下来，执行此活动，实际返回标准输出。最后，将此值与 <code>do</code> 块的其余部分关联起来，并命名为 <code>stdout</code>。&quot;</p>
<!--
## Asking a Question
-->
<h2 id="提问"><a class="header" href="#提问">提问</a></h2>
<!--
Now that `stdin` and `stdout` have been found, the remainder of the block consists of a question and an answer:
-->
<p>现在已经有了 <code>stdin</code> 和 <code>stdout</code>，该代码块的其余部分包括一个问题和一个答案：</p>
<pre><code class="language-lean">  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<!--
The first statement in the block, `  stdout.putStrLn "How would you like to be addressed?"`, consists of an expression.
To execute an expression, it is first evaluated.
In this case, `IO.FS.Stream.putStrLn` has type `IO.FS.Stream → String → IO Unit`.
This means that it is a function that accepts a stream and a string, returning an `IO` action.
The expression uses [accessor notation](../getting-to-know/structures.md#behind-the-scenes) for a function call.
This function is applied to two arguments: the standard output stream and a string.
The value of the expression is an `IO` action that will write the string and a newline character to the output stream.
Having found this value, the next step is to execute it, which causes the string and newline to actually be written to `stdout`.
Statements that consist only of expressions do not introduce any new variables.
-->
<p>该代码块中的第一个语句 <code>  stdout.putStrLn &quot;How would you like to be addressed?&quot;</code>
由一个表达式组成。要执行一个表达式，首先要对其进行求值。在这种情况下，<code>IO.FS.Stream.putStrLn</code>
的类型为 <code>IO.FS.Stream → String → IO Unit</code>。这意味着它是一个接受流和字符串并返回 <code>IO</code> 活动的函数。
该表达式使用<a href="../getting-to-know/structures.html#%E5%B9%95%E5%90%8E">访问器记法</a>进行函数调用。
此函数应用于两个参数：标准输出流和字符串。表达式的值为一个 <code>IO</code> 活动，
该活动将字符串和换行符写入输出流。得到此值后，下一步是执行它，这会导致字符串和换行符写入到
<code>stdout</code>。仅由表达式组成的语句不会引入任何新变量。</p>
<!--
The next statement in the block is `  let input ← stdin.getLine`.
`IO.FS.Stream.getLine` has type `IO.FS.Stream → IO String`, which means that it is a function from a stream to an `IO` action that will return a string.
Once again, this is an example of accessor notation.
This `IO` action is executed, and the program waits until the user has typed a complete line of input.
Assume the user writes "`David`".
The resulting line (`"David\n"`) is associated with `input`, where the escape sequence `\n` denotes the newline character.
-->
<p>下一条语句是 <code>  let input ← stdin.getLine</code>。
<code>IO.FS.Stream.getLine</code> 的类型为 <code>IO.FS.Stream → IO String</code>，
这意味着它是一个从流到 <code>IO</code> 活动的函数，该函数将返回一个字符串。
同样，这也是访问器表示法的示例。此 <code>IO</code> 活动被执行时，程序会等待用户键入一行完整的输入。
假设用户输入了「<code>David</code>」，则结果行（「<code>David\n</code>」）会与 <code>input</code> 关联，其中转义序列 <code>\n</code> 表示换行符。</p>
<pre><code class="language-lean">  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<!--
The next line, `  let name := input.dropRightWhile Char.isWhitespace`, is a `let` statement.
Unlike the other `let` statements in this program, it uses `:=` instead of `←`.
This means that the expression will be evaluated, but the resulting value need not be an `IO` action and will not be executed.
In this case, `String.dropRightWhile` takes a string and a predicate over characters and returns a new string from which all the characters at the end of the string that satisfy the predicate have been removed.
For example,
-->
<p>下一行 <code>let name := input.dropRightWhile Char.isWhitespace</code> 是一个 <code>let</code> 语句。
与本程序中的其他 <code>let</code> 语句不同，它使用 <code>:=</code> 而不是 <code>←</code>。这意味着将计算表达式，
但结果值不必是 <code>IO</code> 活动，并且不会执行。在这种情况下，<code>String.dropRightWhile</code>
接受一个字符串和一个字符的谓词，并返回一个新字符串，其中字符串末尾满足谓词的所有字符都会被删除。例如，</p>
<pre><code class="language-lean">#eval &quot;Hello!!!&quot;.dropRightWhile (· == '!')
</code></pre>
<!--
yields
-->
<p>会产生</p>
<pre><code class="language-output info">&quot;Hello&quot;
</code></pre>
<!--
and
-->
<p>而</p>
<pre><code class="language-lean">#eval &quot;Hello...   &quot;.dropRightWhile (fun c =&gt; not (c.isAlphanum))
</code></pre>
<!--
yields
-->
<p>会产生</p>
<pre><code class="language-output info">&quot;Hello&quot;
</code></pre>
<!--
in which all non-alphanumeric characters have been removed from the right side of the string.
In the current line of the program, whitespace characters (including the newline) are removed from the right side of the input string, resulting in `"David"`, which is associated with `name` for the remainder of the block.
-->
<p>其中所有非字母数字的字符均已从字符串的右侧删除。在程序的当前行中，
空格符（包括换行符）从输入字符串的右侧删除，得到 「<code>David</code>」，
它在代码块的剩余部分与 <code>name</code> 关联。</p>
<!--
## Greeting the User
-->
<h2 id="向用户问好"><a class="header" href="#向用户问好">向用户问好</a></h2>
<!--
All that remains to be executed in the `do` block is a single statement:
-->
<p><code>do</code> 块中剩余要执行的只有一条语句：</p>
<pre><code class="language-lean">  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<!--
The string argument to `putStrLn` is constructed via string interpolation, yielding the string `"Hello, David!"`.
Because this statement is an expression, it is evaluated to yield an `IO` action that will print this string with a newline to standard output.
Once the expression has been evaluated, the resulting `IO` action is executed, resulting in the greeting.
-->
<p>传递给 <code>putStrLn</code> 的字符串参数通过字符串插值构建，生成字符串 <code>&quot;Hello, David!&quot;</code>。
由于此语句是一个表达式，因此它被求值以生成一个 <code>IO</code> 活动，
该活动会将此字符串后加上换行符打印到标准输出。表达式求值后，将执行生成的 <code>IO</code> 活动，从而生成问候语。</p>
<!--
## `IO` Actions as Values
-->
<!--
## `IO` Actions as Values
-->
<h2 id="io-活动作为值"><a class="header" href="#io-活动作为值"><code>IO</code> 活动作为值</a></h2>
<!--
In the above description, it can be difficult to see why the distinction between evaluating expressions and executing `IO` actions is necessary.
After all, each action is executed immediately after it is produced.
Why not simply carry out the effects during evaluation, as is done in other languages?
-->
<p>在上面的描述中，可能很难看出为什么需要区分求值表达式和执行 <code>IO</code> 活动。
毕竟，每个活动在生成后都会立即执行。为什么不干脆在求值期间执行副作用，
就像在其他语言中所做的那样呢？</p>
<!--
The answer is twofold.
First off, separating evaluation from execution means that programs must be explicit about which functions can have side effects.
Because the parts of the program that do not have effects are much more amenable to mathematical reasoning, whether in the heads of programmers or using Lean's facilities for formal proof, this separation can make it easier to avoid bugs.
Secondly, not all `IO` actions need be executed at the time that they come into existence.
The ability to mention an action without carrying it out allows ordinary functions to be used as control structures.
-->
<p>答案有两个。首先，将求值与执行分开意味着程序必须明确说明哪些函数可以产生副作用。
由于没有副作用的程序部分更适合数学推理，无论是在程序员的头脑中还是使用 Lean 的形式化证明工具，
这种分离可以更容易地避免错误。其次，并非所有 <code>IO</code> 活动都需要在它们产生时执行。
在不执行活动的情况下提及活动的能力能够将普通函数用作控制结构。</p>
<!--
For instance, the function `twice` takes an `IO` action as its argument, returning a new action that will execute the first one twice.
-->
<p>例如，函数 <code>twice</code> 将 <code>IO</code> 活动作为其参数，返回一个新的活动，该活动将第一个活动执行两次。</p>
<pre><code class="language-lean">def twice (action : IO Unit) : IO Unit := do
  action
  action
</code></pre>
<!--
For instance, executing
-->
<p>例如，执行</p>
<pre><code class="language-lean">twice (IO.println &quot;shy&quot;)
</code></pre>
<!--
results in
-->
<p>会打印</p>
<pre><code class="language-output info">shy
shy
</code></pre>
<!--
being printed.
This can be generalized to a version that runs the underlying action any number of times:
-->
<p>这可以推广为一个通用函数，它可以运行底层活动任意次：</p>
<pre><code class="language-lean">def nTimes (action : IO Unit) : Nat → IO Unit
  | 0 =&gt; pure ()
  | n + 1 =&gt; do
    action
    nTimes action n
</code></pre>
<!--
In the base case for `Nat.zero`, the result is `pure ()`.
The function `pure` creates an `IO` action that has no side effects, but returns `pure`'s argument, which in this case is the constructor for `Unit`.
As an action that does nothing and returns nothing interesting, `pure ()` is at the same time utterly boring and very useful.
In the recursive step, a `do` block is used to create an action that first executes `action` and then executes the result of the recursive call.
Executing `nTimes (IO.println "Hello") 3` causes the following output:
-->
<p>在 <code>Nat.zero</code> 的基本情况下，结果是 <code>pure ()</code>。函数 <code>pure</code> 创建一个没有副作用的 <code>IO</code> 活动，
但返回 <code>pure</code> 的参数，在本例中是 <code>Unit</code> 的构造子。作为不执行任何活动且不返回任何有趣内容的活动，
<code>pure ()</code> 既非常无聊又非常有用。在递归步骤中，<code>do</code> 块用于创建一个活动，该活动首先执行 <code>action</code>，
然后执行递归调用的结果。执行 <code>nTimes (IO.println &quot;Hello&quot;) 3</code> 会输出以下内容：</p>
<pre><code class="language-output info">Hello
Hello
Hello
</code></pre>
<!--
In addition to using functions as control structures, the fact that `IO` actions are first-class values means that they can be saved in data structures for later execution.
For instance, the function `countdown` takes a `Nat` and returns a list of unexecuted `IO` actions, one for each `Nat`:
-->
<p>除了将函数用作控制结构体之外，<code>IO</code> 活动是一等值的事实意味着它们可以保存在数据结构中供以后执行。
例如，函数 <code>countdown</code> 接受一个 <code>Nat</code> 并返回一个未执行的 <code>IO</code> 活动列表，每个 <code>Nat</code> 对应一个：</p>
<pre><code class="language-lean">def countdown : Nat → List (IO Unit)
  | 0 =&gt; [IO.println &quot;Blast off!&quot;]
  | n + 1 =&gt; IO.println s!&quot;{n + 1}&quot; :: countdown n
</code></pre>
<!--
This function has no side effects, and does not print anything.
For example, it can be applied to an argument, and the length of the resulting list of actions can be checked:
-->
<p>此函数没有副作用，并且不打印任何内容。例如，它可以应用于一个参数，并且可以检查结果活动列表的长度：</p>
<pre><code class="language-lean">def from5 : List (IO Unit) := countdown 5
</code></pre>
<!--
This list contains six elements (one for each number, plus a `"Blast off!"` action for zero):
-->
<p>此列表包含六个元素（每个数字一个，外加一个对应零的 <code>&quot;Blast off!&quot;</code> 活动）：</p>
<pre><code class="language-lean">#eval from5.length
</code></pre>
<pre><code class="language-output info">6
</code></pre>
<!--
The function `runActions` takes a list of actions and constructs a single action that runs them all in order:
-->
<p>函数 <code>runActions</code> 接受一个活动列表，并构造一个按顺序运行所有活动的单个活动：</p>
<pre><code class="language-lean">def runActions : List (IO Unit) → IO Unit
  | [] =&gt; pure ()
  | act :: actions =&gt; do
    act
    runActions actions
</code></pre>
<!--
Its structure is essentially the same as that of `nTimes`, except instead of having one action that is executed for each `Nat.succ`, the action under each `List.cons` is to be executed.
Similarly, `runActions` does not itself run the actions.
It creates a new action that will run them, and that action must be placed in a position where it will be executed as a part of `main`:
-->
<p>其结构本质上与 <code>nTimes</code> 相同，只是没有一个对每个 <code>Nat.succ</code> 执行的活动，
而是在每个 <code>List.cons</code> 下的活动将被执行。类似地，<code>runActions</code> 本身不会运行这些活动。
而是创建一个将要运行这些活动的新活动，并且该活动必须放置在将作为 <code>main</code> 的一部分执行的位置：</p>
<pre><code class="language-lean">def main : IO Unit := runActions from5
</code></pre>
<!--
Running this program results in the following output:
-->
<p>运行此程序会产生以下输出：</p>
<pre><code class="language-output info">5
4
3
2
1
Blast off!
</code></pre>
<!--
What happens when this program is run?
The first step is to evaluate `main`. That occurs as follows:
-->
<p>当运行此程序时会发生什么？第一步是求值 <code>main</code>，它产生如下输出：</p>
<pre><code class="language-lean">main
===&gt;
runActions from5
===&gt;
runActions (countdown 5)
===&gt;
runActions
  [IO.println &quot;5&quot;,
   IO.println &quot;4&quot;,
   IO.println &quot;3&quot;,
   IO.println &quot;2&quot;,
   IO.println &quot;1&quot;,
   IO.println &quot;Blast off!&quot;]
===&gt;
do IO.println &quot;5&quot;
   IO.println &quot;4&quot;
   IO.println &quot;3&quot;
   IO.println &quot;2&quot;
   IO.println &quot;1&quot;
   IO.println &quot;Blast off!&quot;
   pure ()
</code></pre>
<!--
The resulting `IO` action is a `do` block.
Each step of the `do` block is then executed, one at a time, yielding the expected output.
The final step, `pure ()`, does not have any effects, and it is only present because the definition of `runActions` needs a base case.
-->
<p>产生的 <code>IO</code> 活动是一个 <code>do</code> 块。然后逐个执行 <code>do</code> 块的每个步骤，产生预期的输出。
最后一步 <code>pure ()</code> 没有产生任何作用，它的存在只是因为 <code>runActions</code> 的定义需要一个基本情况。</p>
<!--
## Exercise
-->
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<!--
Step through the execution of the following program on a piece of paper:
-->
<p>在纸上逐步执行以下程序：</p>
<pre><code class="language-lean">def main : IO Unit := do
  let englishGreeting := IO.println &quot;Hello!&quot;
  IO.println &quot;Bonjour!&quot;
  englishGreeting
</code></pre>
<!--
While stepping through the program's execution, identify when an expression is being evaluated and when an `IO` action is being executed.
When executing an `IO` action results in a side effect, write it down.
After doing this, run the program with Lean and double-check that your predictions about the side effects were correct.
-->
<p>在逐步执行程序时，要察觉到何时正在求值表达式，以及何时正在执行 <code>IO</code> 活动。
当执行 <code>IO</code> 活动产生副作用时，请将其写下来。在纸上执行完毕后，使用 Lean 运行程序，
并仔细检查你对副作用的预测是否正确。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../hello-world/running-a-program.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../hello-world/starting-a-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../hello-world/running-a-program.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../hello-world/starting-a-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
