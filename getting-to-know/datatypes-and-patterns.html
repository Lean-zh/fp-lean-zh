<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数据类型、模式匹配与递归 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">致谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html" class="active"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步运行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建一个项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">接下来做什么</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Datatypes and Patterns
-->
<h1 id="数据类型与模式匹配"><a class="header" href="#数据类型与模式匹配">数据类型与模式匹配</a></h1>
<!--
Structures enable multiple independent pieces of data to be combined into a coherent whole that is represented by a brand new type.
Types such as structures that group together a collection of values are called _product types_.
Many domain concepts, however, can't be naturally represented as structures.
For instance, an application might need to track user permissions, where some users are document owners, some may edit documents, and others may only read them.
A calculator has a number of binary operators, such as addition, subtraction, and multiplication.
Structures do not provide an easy way to encode multiple choices.
-->
<p>结构体使多个独立的数据块可以组合成一个连贯的整体，该整体由一个全新的类型表示。
将一组值组合在一起的类型（如结构体）称为 <strong>积类型（Product Type）</strong>。
然而，许多领域概念不能自然地表示为结构体。例如，应用程序可能需要跟踪用户权限，
其中一些用户是文档所有者，一些用户可以编辑文档，而另一些用户只能阅读文档。
计算器具有许多二元运算符，例如加法、减法和乘法。结构体无法提供一种简单的方法来编码多项选择。</p>
<!--
Similarly, while a structure is an excellent way to keep track of a fixed set of fields, many applications require data that may contain an arbitrary number of elements.
Most classic data structures, such as trees and lists, have a recursive structure, where the tail of a list is itself a list, or where the left and right branches of a binary tree are themselves binary trees.
In the aforementioned calculator, the structure of expressions themselves is recursive.
The summands in an addition expression may themselves be multiplication expressions, for instance.
-->
<p>同样，尽管结构体是跟踪固定字段集的绝佳方式，但许多应用程序需要可能包含任意数量元素的数据。
大多数经典数据结构体（例如树和列表）具有递归结构体，其中列表的尾部本身是一个列表，
或者二叉树的左右分支本身是二叉树。在上述计算器中，表达式本身的结构体是递归的。
例如，加法表达式中的加数本身可能是乘法表达式。</p>
<!--
Datatypes that allow choices are called _sum types_ and datatypes that can include instances of themselves are called _recursive datatypes_.
Recursive sum types are called _inductive datatypes_, because mathematical induction may be used to prove statements about them.
When programming, inductive datatypes are consumed through pattern matching and recursive functions.
-->
<p>允许选择的类型称为<strong>和类型（Sum Type）</strong>，而可以包含自身实例的类型称为
<strong>递归类型（Recursive Datatype）</strong>。递归和类型称<strong>归纳类型（Inductive Datatype）</strong>，
因为可以用数学归纳法来证明有关它们的陈述。在编程时，归纳类型通过模式匹配和递归函数来消耗。</p>
<!--
Many of the built-in types are actually inductive datatypes in the standard library.
For instance, `Bool` is an inductive datatype:
-->
<p>许多内置类型实际上是标准库中的归纳类型。例如，<code>Bool</code> 就是一个归纳类型：</p>
<pre><code class="language-lean">inductive Bool where
  | false : Bool
  | true : Bool
</code></pre>
<!--
This definition has two main parts.
The first line provides the name of the new type (`Bool`), while the remaining lines each describe a constructor.
As with constructors of structures, constructors of inductive datatypes are mere inert receivers of and containers for other data, rather than places to insert arbitrary initialization and validation code.
Unlike structures, inductive datatypes may have multiple constructors.
Here, there are two constructors, `true` and `false`, and neither takes any arguments.
Just as a structure declaration places its names in a namespace named after the declared type, an inductive datatype places the names of its constructors in a namespace.
In the Lean standard library, `true` and `false` are re-exported from this namespace so that they can be written alone, rather than as `Bool.true` and `Bool.false`, respectively.
-->
<p>此定义有两个主要部分。第一行提供了新类型（<code>Bool</code>）的名称，而其余各行分别描述了一个构造函数。
与结构体的构造函数一样，归纳类型的构造函数只是其他数据的接收器和容器，
而不是插入任意初始化代码和验证代码的地方。与结构体不同，归纳类型可以有多个构造函数。
这里有两个构造函数，<code>true</code> 和 <code>false</code>，并且都不接受任何参数。
就像结构体声明将其名称放在以声明类型命名的命名空间中一样，归纳类型将构造函数的名称放在命名空间中。
在 Lean 标准库中，<code>true</code> 和 <code>false</code> 从此命名空间重新导出，以便可以单独编写它们，
而不是分别作为 <code>Bool.true</code> 和 <code>Bool.false</code>。</p>
<!--
From a data modeling perspective, inductive datatypes are used in many of the same contexts where a sealed abstract class might be used in other languages.
In languages like C# or Java, one might write a similar definition of `Bool`:
-->
<p>从数据建模的角度来看，归纳数据类型在许多与其他语言中可能使用密封抽象类相同的上下文中使用。
在 C# 或 Java 等语言中，人们可能会编写类似的 <code>Bool</code> 定义：</p>
<pre><code class="language-C#">abstract class Bool {}
class True : Bool {}
class False : Bool {}
</code></pre>
<!--
However, the specifics of these representations are fairly different. In particular, each non-abstract class creates both a new type and new ways of allocating data. In the object-oriented example, `True` and `False` are both types that are more specific than `Bool`, while the Lean definition introduces only the new type `Bool`.
-->
<p>然而，这些表示的具体内容有很大不同。特别是，每个非抽象类都会创建一种新类型和分配数据的新方式。
在面向对象示例中，<code>True</code> 和 <code>False</code> 都是比 <code>Bool</code> 更具体的类型，而 Lean 定义仅引入了新类型 <code>Bool</code>。</p>
<!--
The type `Nat` of non-negative integers is an inductive datatype:
-->
<p>非负整数的类型 <code>Nat</code> 是一个归纳数据类型：</p>
<pre><code class="language-lean">inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat
</code></pre>
<!--
Here, `zero` represents 0, while `succ` represents the successor of some other number.
The `Nat` mentioned in `succ`'s declaration is the very type `Nat` that is in the process of being defined.
_Successor_ means "one greater than", so the successor of five is six and the successor of 32,185 is 32,186.
Using this definition, `4` is represented as `Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))`.
This definition is almost like the definition of `Bool` with slightly different names.
The only real difference is that `succ` is followed by `(n : Nat)`, which specifies that the constructor `succ` takes an argument of type `Nat` which happens to be named `n`.
The names `zero` and `succ` are in a namespace named after their type, so they must be referred to as `Nat.zero` and `Nat.succ`, respectively.
-->
<p>在这里，<code>zero</code> 表示 0，而 <code>succ</code> 表示errt数字的后继。<code>succ</code> 声明中提到的 <code>Nat</code>
正是我们正在定义的类型 <code>Nat</code>。**后继（Successor）**表示「比...大一」，因此 5 的后继是 6，
32,185 的后继是 32,186。使用此定义，<code>4</code> 表示为 <code>Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))</code>。
这个定义与 <code>Bool</code> 的定义非常类似，只是名称略有不同。唯一真正的区别是 <code>succ</code> 后面跟着
<code>(n : Nat)</code>，它指定构造函数 <code>succ</code> 接受类型为 <code>Nat</code> 的参数，该参数恰好命名为 <code>n</code>。
名称 <code>zero</code> 和 <code>succ</code> 位于以其类型命名的命名空间中，因此它们分别必须称为 <code>Nat.zero</code> 和 <code>Nat.succ</code>。</p>
<!--
Argument names, such as `n`, may occur in Lean's error messages and in feedback provided when writing mathematical proofs.
Lean also has an optional syntax for providing arguments by name.
Generally, however, the choice of argument name is less important than the choice of a structure field name, as it does not form as large a part of the API.
-->
<p>参数名称（如 <code>n</code>）可能出现在 Lean 的错误消息以及编写数学证明时提供的反馈中。
Lean 还具有按名称提供参数的可选语法。然而，通常情况下，
参数名的选择不如结构体字段名的选择重要，因为它不构成 API 的主要部分。</p>
<!--
In C# or Java, `Nat` could be defined as follows:
-->
<p>在 C# 或 Java 中，<code>Nat</code> 的定义如下：</p>
<pre><code class="language-C#">abstract class Nat {}
class Zero : Nat {}
class Succ : Nat {
  public Nat n;
  public Succ(Nat pred) {
    n = pred;
  }
}
</code></pre>
<!--
Just as in the `Bool` example above, this defines more types than the Lean equivalent.
Additionally, this example highlights how Lean datatype constructors are much more like subclasses of an abstract class than they are like constructors in C# or Java, as the constructor shown here contains initialization code to be executed.
-->
<p>与上面 <code>Bool</code> 的示例类似，这样会定义比 Lean 中等价的项更多的类型。
此外，该示例突出显示了 Lean 数据类型构造子更像是抽象类的子类，而不是像
C# 或 Java 中的构造子，因为此处显示的构造子包含要执行的初始化代码。</p>
<!--
Sum types are also similar to using a string tag to encode discriminated unions in TypeScript.
In TypeScript, `Nat` could be defined as follows:
-->
<p>和类型也类似于使用字符串标签来对 TypeScript 中的不交并进行编码。
在 TypeScript 中，<code>Nat</code> 可以定义如下：</p>
<pre><code class="language-typescript">interface Zero {
    tag: &quot;zero&quot;;
}

interface Succ {
    tag: &quot;succ&quot;;
    predecessor: Nat;
}

type Nat = Zero | Succ;
</code></pre>
<!--
Just like C# and Java, this encoding ends up with more types than in Lean, because `Zero` and `Succ` are each a type on their own.
It also illustrates that Lean constructors correspond to objects in JavaScript or TypeScript that include a tag that identifies the contents.
-->
<p>与 C# 和 Java 一样，这种编码最终会产生比 Lean 中更多的类型，因为 <code>Zero</code> 和 <code>Succ</code>
都是它们自己的类型。它还说明了 Lean 构造函数对应于 JavaScript 或 TypeScript 中的对象，
这些对象包含一个标识内容的标记。</p>
<!--
## Pattern Matching
-->
<h2 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h2>
<!--
In many languages, these kinds of data are consumed by first using an instance-of operator to check which subclass has been received and then reading the values of the fields that are available in the given subclass.
The instance-of check determines which code to run, ensuring that the data needed by this code is available, while the fields themselves provide the data.
In Lean, both of these purposes are simultaneously served by _pattern matching_.
-->
<p>在很多语言中，这类数据首先使用 instance-of 运算符来检查接收了哪个子类，
然后读取给定子类中可用的字段值。instance-of 会检查确定要运行哪个代码，
以确保此代码所需的数据可用，而数据由字段本身提供。
在 Lean 中，这两个目的均由**模式匹配（Pattern Matching）**实现。</p>
<!--
An example of a function that uses pattern matching is `isZero`, which is a function that returns `true` when its argument is `Nat.zero`, or false otherwise.
-->
<p>使用模式匹配的函数示例是 <code>isZero</code>，这是一个当其参数为 <code>Nat.zero</code>
时返回 <code>true</code> 的函数，否则返回 <code>false</code>。</p>
<pre><code class="language-lean">def isZero (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; false
</code></pre>
<!--
The `match` expression is provided the function's argument `n` for destructuring.
If `n` was constructed by `Nat.zero`, then the first branch of the pattern match is taken, and the result is `true`.
If `n` was constructed by `Nat.succ`, then the second branch is taken, and the result is `false`.
-->
<p><code>match</code> 表达式为函数参数 <code>n</code> 提供了解构。若 <code>n</code> 由 <code>Nat.zero</code> 构建，
则采用模式匹配的第一分支，结果为 <code>true</code>。若 <code>n</code> 由 <code>Nat.succ</code> 构建，
则采用第二分支，结果为 <code>false</code>。</p>
<!--
Step-by-step, evaluation of `isZero Nat.zero` proceeds as follows:
-->
<p><code>isZero Nat.zero</code> 的逐步求值过程如下：</p>
<pre><code class="language-lean">isZero Nat.zero
===&gt;
match Nat.zero with
| Nat.zero =&gt; true
| Nat.succ k =&gt; false
===&gt;
true
</code></pre>
<!--
Evaluation of `isZero 5` proceeds similarly:
-->
<p><code>isZero 5</code> 的求值过程类似：</p>
<pre><code class="language-lean">isZero 5
===&gt;
isZero (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))
===&gt;
match Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))) with
| Nat.zero =&gt; true
| Nat.succ k =&gt; false
===&gt;
false
</code></pre>
<!--
The `k` in the second branch of the pattern in `isZero` is not decorative.
It makes the `Nat` that is the argument to `succ` visible, with the provided name.
That smaller number can then be used to compute the final result of the expression.
-->
<p><code>isZero</code> 中模式的第二分支中的 <code>k</code> 并非装饰性符号。它使 <code>succ</code> 的参数 <code>Nat</code>
可见，并提供了名称。然后可以使用该较小的数字计算表达式的最终结果。</p>
<!--
Just as the successor of some number \\( n \\) is one greater than \\( n \\) (that is, \\( n + 1\\)), the predecessor of a number is one less than it.
If `pred` is a function that finds the predecessor of a `Nat`, then it should be the case that the following examples find the expected result:
-->
<p>正如某个数字 \( n \) 的后继比 \( n \) 大 1（即 \( n + 1\)），
某个数字的前驱比它小 1。如果 <code>pred</code> 是一个查找 <code>Nat</code> 前驱的函数，
那么以下示例应该找到预期的结果：</p>
<pre><code class="language-lean">#eval pred 5
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<pre><code class="language-lean">#eval pred 839
</code></pre>
<pre><code class="language-output info">838
</code></pre>
<!--
Because `Nat` cannot represent negative numbers, `0` is a bit of a conundrum.
Usually, when working with `Nat`, operators that would ordinarily produce a negative number are redefined to produce `0` itself:
-->
<p>由于 <code>Nat</code> 无法表示负数，因此 <code>0</code> 有点令人费解。在使用 <code>Nat</code> 时，
会产生负数的运算符通常会被重新定义为产生 <code>0</code> 本身：</p>
<pre><code class="language-lean">#eval pred 0
</code></pre>
<pre><code class="language-output info">0
</code></pre>
<!--
To find the predecessor of a `Nat`, the first step is to check which constructor was used to create it.
If it was `Nat.zero`, then the result is `Nat.zero`.
If it was `Nat.succ`, then the name `k` is used to refer to the `Nat` underneath it.
And this `Nat` is the desired predecessor, so the result of the `Nat.succ` branch is `k`.
-->
<p>要查找 <code>Nat</code> 的前驱，第一步是检查使用哪个构造子创建它。如果是 <code>Nat.zero</code>，则结果为 <code>Nat.zero</code>。
如果是 <code>Nat.succ</code>，则使用名称 <code>k</code> 引用其下的 <code>Nat</code>。而这个 <code>Nat</code> 是所需的前驱，因此
<code>Nat.succ</code> 分支的结果是 <code>k</code>。</p>
<pre><code class="language-lean">def pred (n : Nat) : Nat :=
  match n with
  | Nat.zero =&gt; Nat.zero
  | Nat.succ k =&gt; k
</code></pre>
<!--
Applying this function to `5` yields the following steps:
-->
<p>将此函数应用于 <code>5</code> 会产生以下步骤：</p>
<pre><code class="language-lean">pred 5
===&gt;
pred (Nat.succ 4)
===&gt;
match Nat.succ 4 with
| Nat.zero =&gt; Nat.zero
| Nat.succ k =&gt; k
===&gt;
4
</code></pre>
<!--
Pattern matching can be used with structures as well as with sum types.
For instance, a function that extracts the third dimension from a `Point3D` can be written as follows:
-->
<p>模式匹配不仅可用于和类型，还可用于结构体。
例如，一个从 <code>Point3D</code> 中提取第三维度的函数可以写成如下：</p>
<pre><code class="language-lean">def depth (p : Point3D) : Float :=
  match p with
  | { x:= h, y := w, z := d } =&gt; d
</code></pre>
<!--
In this case, it would have been much simpler to just use the `z` accessor, but structure patterns are occasionally the simplest way to write a function.
-->
<p>在这种情况下，直接使用 <code>z</code> 访问器会简单得多，但结构体模式有时是编写函数的最简单方法。</p>
<!--
## Recursive Functions
-->
<h2 id="递归函数"><a class="header" href="#递归函数">递归函数</a></h2>
<!--
Definitions that refer to the name being defined are called _recursive definitions_.
Inductive datatypes are allowed to be recursive; indeed, `Nat` is an example of such a datatype because `succ` demands another `Nat`.
Recursive datatypes can represent arbitrarily large data, limited only by technical factors like available memory.
Just as it would be impossible to write down one constructor for each natural number in the datatype definition, it is also impossible to write down a pattern match case for each possibility.
-->
<p>引用正在定义的名称的定义称为<strong>递归定义（Recursive Definition）</strong>。
归纳数据类型允许是递归的；事实上，<code>Nat</code> 就是这样的数据类型的一个例子，
因为 <code>succ</code> 需要另一个 <code>Nat</code>。递归数据类型可以表示任意大的数据，仅受可用内存等技术因素限制。
就像不可能在数据类型定义中为每个自然数编写一个构造器一样，也不可能为每个可能性编写一个模式匹配用例。</p>
<!--
Recursive datatypes are nicely complemented by recursive functions.
A simple recursive function over `Nat` checks whether its argument is even.
In this case, `zero` is even.
Non-recursive branches of the code like this one are called _base cases_.
The successor of an odd number is even, and the successor of an even number is odd.
This means that a number built with `succ` is even if and only if its argument is not even.
-->
<p>递归数据类型与递归函数很好地互补。一个简单的 <code>Nat</code> 递归函数检查其参数是否是偶数。
在这种情况下，<code>zero</code> 是偶数。像这样的代码的非递归分支称为<strong>基本情况（Base Case）</strong>。
奇数的后继是偶数，偶数的后继是奇数。这意味着使用 <code>succ</code> 构建的数字当且仅当其参数不是偶数时才是偶数。</p>
<pre><code class="language-lean">def even (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (even k)
</code></pre>
<!--
This pattern of thought is typical for writing recursive functions on `Nat`.
First, identify what to do for `zero`.
Then, determine how to transform a result for an arbitrary `Nat` into a result for its successor, and apply this transformation to the result of the recursive call.
This pattern is called _structural recursion_.
-->
<p>这种思维模式对于在 <code>Nat</code> 上编写递归函数是典型的。首先，确定对 <code>zero</code> 做什么。
然后，确定如何将任意 <code>Nat</code> 的结果转换为其后继的结果，并将此转换应用于递归调用的结果。
此模式称为<strong>结构化递归（Structural Recursion）</strong>。</p>
<!--
Unlike many languages, Lean ensures by default that every recursive function will eventually reach a base case.
From a programming perspective, this rules out accidental infinite loops.
But this feature is especially important when proving theorems, where infinite loops cause major difficulties.
A consequence of this is that Lean will not accept a version of `even` that attempts to invoke itself recursively on the original number:
-->
<p>不同于许多语言，Lean 默认确保每个递归函数最终都会到达基本情况。
从编程角度来看，这排除了意外的无限循环。但此特性在证明定理时尤为重要，
而无限循环会产生主要困难。由此产生的一个后果是，
Lean 不会接受尝试对原始数字递归调用自身的 <code>even</code> 版本：</p>
<pre><code class="language-lean">def evenLoops (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (evenLoops n)
</code></pre>
<!--
The important part of the error message is that Lean could not determine that the recursive function always reaches a base case (because it doesn't).
-->
<p>错误消息的主要部分是 Lean 无法确定递归函数是否最终会到达基本情况（因为它不会）。</p>
<pre><code class="language-output error">fail to show termination for
  evenLoops
with errors
structural recursion cannot be used

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments
</code></pre>
<!--
Even though addition takes two arguments, only one of them needs to be inspected.
To add zero to a number \\( n \\), just return \\( n \\).
To add the successor of \\( k \\) to \\( n \\), take the successor of the result of adding \\( k \\) to \\( n \\).
-->
<p>尽管加法需要两个参数，但只需要检查其中一个参数。要将零加到数字 \( n \) 上，
只需返回 \( n \)。要将 \( k \) 的后继加到 \( n \) 上，则需要得到将 \( k \)
加到 \( n \) 的结果的后继。</p>
<pre><code class="language-lean">def plus (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; n
  | Nat.succ k' =&gt; Nat.succ (plus n k')
</code></pre>
<!--
In the definition of `plus`, the name `k'` is chosen to indicate that it is connected to, but not identical with, the argument `k`.
For instance, walking through the evaluation of `plus 3 2` yields the following steps:
-->
<p>在 <code>plus</code> 的定义中，选择名称 <code>k'</code> 表示它与参数 <code>k</code> 相关联，但并不相同。
例如，展开 <code>plus 3 2</code> 的求值过程会产生以下步骤：</p>
<pre><code class="language-lean">plus 3 2
===&gt;
plus 3 (Nat.succ (Nat.succ Nat.zero))
===&gt;
match Nat.succ (Nat.succ Nat.zero) with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k')
===&gt;
Nat.succ (plus 3 (Nat.succ Nat.zero))
===&gt;
Nat.succ (match Nat.succ Nat.zero with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k'))
===&gt;
Nat.succ (Nat.succ (plus 3 Nat.zero))
===&gt;
Nat.succ (Nat.succ (match Nat.zero with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k')))
===&gt;
Nat.succ (Nat.succ 3)
===&gt;
5
</code></pre>
<!--
One way to think about addition is that \\( n + k \\) applies `Nat.succ` \\( k \\) times to \\( n \\).
Similarly, multiplication \\( n × k \\) adds \\( n \\) to itself \\( k \\) times and subtraction \\( n - k \\) takes \\( n \\)'s predecessor \\( k \\) times.
-->
<p>考虑加法的一种方法是 \( n + k \) 将 <code>Nat.succ</code> 应用于 \( n \) \( k \) 次。
类似地，乘法 \( n × k \) 将 \( n \) 加到自身 \( k \) 次，而减法
\( n - k \) 将 \( n \) 的前驱减去 \( k \) 次。</p>
<pre><code class="language-lean">def times (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; Nat.zero
  | Nat.succ k' =&gt; plus n (times n k')

def minus (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; n
  | Nat.succ k' =&gt; pred (minus n k')
</code></pre>
<!--
Not every function can be easily written using structural recursion.
The understanding of addition as iterated `Nat.succ`, multiplication as iterated addition, and subtraction as iterated predecessor suggests an implementation of division as iterated subtraction.
In this case, if the numerator is less than the divisor, the result is zero.
Otherwise, the result is the successor of dividing the numerator minus the divisor by the divisor.
-->
<p>并非每个函数都可以轻松地使用结构体递归来编写。将加法理解为迭代的 <code>Nat.succ</code>，
将乘法理解为迭代的加法，将减法理解为迭代的前驱，这表明除法可以实现为迭代的减法。
在这种情况下，如果分子小于分母，则结果为零。否则，结果是将分子减去分母除以分母的后继。</p>
<pre><code class="language-lean">def div (n : Nat) (k : Nat) : Nat :=
  if n &lt; k then
    0
  else Nat.succ (div (n - k) k)
</code></pre>
<!--
As long as the second argument is not `0`, this program terminates, as it always makes progress towards the base case.
However, it is not structurally recursive, because it doesn't follow the pattern of finding a result for zero and transforming a result for a smaller `Nat` into a result for its successor.
In particular, the recursive invocation of the function is applied to the result of another function call, rather than to an input constructor's argument.
Thus, Lean rejects it with the following message:
-->
<p>只要第二个参数不为 <code>0</code>，这个程序就会终止，因为它始终朝着基本情况前进。然而，它不是结构化递归，
因为它不遵循「为零找到一个结果，然后将较小的 <code>Nat</code> 的结果转换为其后继的结果」的模式。
特别是，该函数的递归调用，应用于另一个函数调用的结果，而非输入构造子的参数。
因此，Lean 会拒绝它，并显示以下消息：</p>
<pre><code class="language-output error">fail to show termination for
  div
with errors
argument #1 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k

argument #2 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<!--
This message means that `div` requires a manual proof of termination.
This topic is explored in [the final chapter](../programs-proofs/inequalities.md#division-as-iterated-subtraction).
-->
<p>此消息表示 <code>div</code> 需要手动证明停机。这个主题在
<a href="../programs-proofs/inequalities.html#division-as-iterated-subtraction">最后一章</a>
中进行了探讨。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-to-know/structures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../getting-to-know/polymorphism.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-to-know/structures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../getting-to-know/polymorphism.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
