<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>宇宙 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构体和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的契约</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html" class="active"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/functor-applicative-monad/universes.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Universes
-->
<h1 id="宇宙"><a class="header" href="#宇宙">宇宙</a></h1>
<!--
In the interests of simplicity, this book has thus far papered over an important feature of Lean: _universes_.
A universe is a type that classifies other types.
Two of them are familiar: `Type` and `Prop`.
`Type` classifies ordinary types, such as `Nat`, `String`, `Int → String × Char`, and `IO Unit`.
`Prop` classifies propositions that may be true or false, such as `"nisse" = "elf"` or `3 > 2`.
The type of `Prop` is `Type`:
```lean
#check Prop
```
```output info
Prop : Type
```
-->
<p>为了简化，本书到目前为止略去了 Lean 的一个重要特性：<strong>宇宙 (Universes)</strong>。
宇宙是一种对其他类型进行分类的类型。
其中两个是我们熟悉的：<code>Type</code> 和 <code>Prop</code>。
<code>Type</code> 分类了普通类型，例如 <code>Nat</code>、<code>String</code>、<code>Int → String × Char</code> 和 <code>IO Unit</code>。
<code>Prop</code> 分类了可能为真或假的命题，例如 <code>&quot;nisse&quot; = &quot;elf&quot;</code> 或 <code>3 &gt; 2</code>。
<code>Prop</code> 的类型是 <code>Type</code>：</p>
<pre><code class="language-lean">#check Prop
</code></pre>
<pre><code class="language-output info">Prop : Type
</code></pre>
<!--
For technical reasons, more universes than these two are needed.
In particular, `Type` cannot itself be a `Type`.
This would allow a logical paradox to be constructed and undermine Lean's usefulness as a theorem prover.
-->
<p>出于技术原因，我们需要比这两个更多的宇宙。
具体而言，<code>Type</code> 本身不能是一个 <code>Type</code>。
这会导致逻辑悖论的产生，并削弱 Lean 作为定理证明器的实用性。</p>
<!--
The formal argument for this is known as _Girard's Paradox_.
It related to a better-known paradox known as _Russell's Paradox_, which was used to show that early versions of set theory were inconsistent.
In these set theories, a set can be defined by a property.
For example, one might have the set of all red things, the set of all fruit, the set of all natural numbers, or even the set of all sets.
Given a set, one can ask whether a given element is contained in it.
For instance, a bluebird is not contained in the set of all red things, but the set of all red things is contained in the set of all sets.
Indeed, the set of all sets even contains itself.
-->
<p>对此的正式论证被称为 <strong>吉拉德悖论 (Girard's Paradox)</strong>。
它与一个更著名的悖论有关，称为 <strong>罗素悖论 (Russell's Paradox)</strong>，该悖论用于展示早期版本的集合论是不一致的。
在这些集合论中，一个集合可以通过一个属性来定义。
例如，所有红色事物的集合，所有水果的集合，所有自然数的集合，甚至所有集合的集合。
给定一个集合，可以询问一个给定的元素是否被包含在其中。
例如，一只蓝色的鸟不会被包含在所有红色事物的集合中，但所有红色事物的集合被包含在所有集合的集合中。
实际上，所有集合的集合甚至包含其自身。</p>
<!--
What about the set of all sets that do not contain themselves?
It contains the set of all red things, as the set of all red things is not itself red.
It does not contain the set of all sets, because the set of all sets contains itself.
But does it contain itself?
If it does contain itself, then it cannot contain itself.
But if it does not, then it must.
-->
<p>那么，所有不包含自身的集合的集合呢？
它包含所有红色事物的集合，因为所有红色事物的集合本身并不是红色的。
它不包含所有集合的集合，因为所有集合的集合包含自身。
但它是否包含自身呢？
如果它包含自身，那么它就不能包含自身。
但如果它不包含自身，那么它就必须包含自身。</p>
<!--
This is a contradiction, which demonstrates that something was wrong with the initial assumptions.
In particular, allowing sets to be constructed by providing an arbitrary property is too powerful.
Later versions of set theory restrict the formation of sets to remove the paradox.
-->
<p>这是一个矛盾，表明了初始的假设存在问题。
具体而言，允许通过提供任意属性来构造集合的做法过于强大。
集合论的后续版本限制了集合的构造以消除这种悖论。</p>
<!--
A related paradox can be constructed in versions of dependent type theory that assign the type `Type` to `Type`.
To ensure that Lean has consistent logical foundations and can be used as a tool for mathematics, `Type` needs to have some other type.
This type is called `Type 1`:
```lean
#check Type
```
```output info
Type : Type 1
```
Similarly, `Type 1` is a `Type 2`,
`Type 2` is a `Type 3`,
`Type 3` is a `Type 4`, and so forth.
-->
<p>在那些可以将类型 <code>Type</code> 分配给 <code>Type</code>的 <strong>依赖类型理论 (Dependent Type Theory)</strong> 的版本中，可以构建一个相关的悖论。
为了确保 Lean 具有自洽的逻辑基础并且能够被用作数学工具，<code>Type</code> 需要有其他类型。
这个类型称为 <code>Type 1</code>：</p>
<pre><code class="language-lean">#check Type
</code></pre>
<pre><code class="language-output info">Type : Type 1
</code></pre>
<p>类似地，<code>Type 1</code> 是一个 <code>Type 2</code>，
<code>Type 2</code> 是一个 <code>Type 3</code>，
<code>Type 3</code> 是一个 <code>Type 4</code>，等等。</p>
<!--
Function types occupy the smallest universe that can contain both the argument type and the return type.
This means that `Nat → Nat` is a `Type`, `Type → Type` is a `Type 1`, and `Type 1 → Type 2` is a `Type 3`.
-->
<p>函数类型占据了可以同时包含参数类型和返回类型的最小宇宙。
这意味着 <code>Nat → Nat</code> 是一个 <code>Type</code>，<code>Type → Type</code> 是一个 <code>Type 1</code>，而 <code>Type 1 → Type 2</code> 是一个 <code>Type 3</code>。</p>
<!--
There is one exception to this rule.
If the return type of a function is a `Prop`, then the whole function type is in `Prop`, even if the argument is in a larger universe such as `Type` or even `Type 1`.
In particular, this means that predicates over values that have ordinary types are in `Prop`.
For example, the type `(n : Nat) → n = n + 0` represents a function from a `Nat` to evidence that it is equal to itself plus zero.
Even though `Nat` is in `Type`, this function type is in `Prop` due to this rule.
Similarly, even though `Type` is in `Type 1`, the function type `Type → 2 + 2 = 4` is still in `Prop`.
-->
<p>这个规则有一个例外。
如果一个函数的返回类型是 <code>Prop</code>，那么即使参数在更大的宇宙中，例如 <code>Type</code> 或甚至 <code>Type 1</code>，整个函数类型也在 <code>Prop</code> 中。
具体而言，这意味着具有普通类型的值的谓词在 <code>Prop</code> 中。
例如，类型 <code>(n : Nat) → n = n + 0</code> 表示了从一个 <code>Nat</code> 到它等于自身加零的证据的函数。
尽管 <code>Nat</code> 在 <code>Type</code> 中，根据这个规则，这个函数类型在 <code>Prop</code> 中。
同样，尽管 <code>Type</code> 在 <code>Type 1</code> 中，函数类型 <code>Type → 2 + 2 = 4</code> 仍在 <code>Prop</code> 中。</p>
<!--
## User Defined Types
-->
<h2 id="用户定义类型"><a class="header" href="#用户定义类型">用户定义类型</a></h2>
<!--
Structures and inductive datatypes can be declared to inhabit particular universes.
Lean then checks whether each datatype avoids paradoxes by being in a universe that's large enough to prevent it from containing its own type.
For instance, in the following declaration, `MyList` is declared to reside in `Type`, and so is its type argument `α`:
```lean
inductive MyList (α : Type) : Type where
  | nil : MyList α
  | cons : α → MyList α → MyList α
```
`MyList` itself is a `Type → Type`.
This means that it cannot be used to contain actual types, because then its argument would be `Type`, which is a `Type 1`:
```lean
def myListOfNat : MyList Type :=
  .cons Nat .nil
```
```output error
application type mismatch
  MyList Type
argument
  Type
has type
  Type 1 : Type 2
but is expected to have type
  Type : Type 1
```
-->
<p>结构体和归纳数据类型可以声明为存在于特定的宇宙中。
Lean 随后会检查每个数据类型是否通过位于足够大的宇宙中来避免悖论，从而防止它包含其自身的类型。
例如，在以下声明中，<code>MyList</code> 被声明为驻留在 <code>Type</code> 中，而它的类型参数 <code>α</code> 也是如此：</p>
<pre><code class="language-lean">inductive MyList (α : Type) : Type where
  | nil : MyList α
  | cons : α → MyList α → MyList α
</code></pre>
<p><code>MyList</code> 本身是一个 <code>Type → Type</code>。
这意味着它不能用于包含实际类型，因为那样的话它的参数将会是 <code>Type</code>，也就是一个 <code>Type 1</code>。</p>
<pre><code class="language-lean">def myListOfNat : MyList Type :=
  .cons Nat .nil
</code></pre>
<pre><code class="language-output error">application type mismatch
  MyList Type
argument
  Type
has type
  Type 1 : Type 2
but is expected to have type
  Type : Type 1
</code></pre>
<!--
Updating `MyList` so that its argument is a `Type 1` results in a definition rejected by Lean:
```lean
inductive MyList (α : Type 1) : Type where
  | nil : MyList α
  | cons : α → MyList α → MyList α
```
```output error
invalid universe level in constructor 'MyList.cons', parameter has type
  α
at universe level
  2
it must be smaller than or equal to the inductive datatype universe level
  1
```
This error occurs because the argument to `cons` with type `α` is from a larger universe than `MyList`.
Placing `MyList` itself in `Type 1` solves this issue, but at the cost of `MyList` now being itself inconvenient to use in contexts that expect a `Type`.
-->
<p>更新 <code>MyList</code> 使其参数为一个 <code>Type 1</code>，这会导致该定义被 Lean 拒绝：</p>
<pre><code class="language-lean">inductive MyList (α : Type 1) : Type where
  | nil : MyList α
  | cons : α → MyList α → MyList α
</code></pre>
<pre><code class="language-output error">invalid universe level in constructor 'MyList.cons', parameter has type
  α
at universe level
  2
it must be smaller than or equal to the inductive datatype universe level
  1
</code></pre>
<p>发生此错误的原因是，类型为 <code>α</code> 的 <code>cons</code> 的参数来自一个比 <code>MyList</code> 更大的宇宙。
将 <code>MyList</code> 本身置于 <code>Type 1</code> 中可以解决这个问题，但代价是 <code>MyList</code> 本身在需要 <code>Type</code> 的内容中变得不便使用。</p>
<!--
The specific rules that govern whether a datatype is allowed are somewhat complicated.
Generally speaking, it's easiest to start with the datatype in the same universe as the largest of its arguments.
Then, if Lean rejects the definition, increase its level by one, which will usually go through.
-->
<p>决定某种数据类型是否被允许的具体规则有些复杂。
通常来说，最简单的方法是，从其最大的参数所属的宇宙与自身所属的宇宙相同的数据类型开始。
然后，如果 Lean 拒绝了该定义，那就将其层级增加一级，这通常会奏效。</p>
<!--
## Universe Polymorphism
-->
<h2 id="宇宙多态"><a class="header" href="#宇宙多态">宇宙多态</a></h2>
<!--
Defining a datatype in a specific universe can lead to code duplication.
Placing `MyList` in `Type → Type` means that it can't be used for an actual list of types.
Placing it in `Type 1 → Type 1` means that it can't be used for a list of lists of types.
Rather than copy-pasting the datatype to create versions in `Type`, `Type 1`, `Type 2`, and so on, a feature called _universe polymorphism_ can be used to write a single definition that can be instantiated in any of these universes.
-->
<p>在特定的宇宙中定义一个数据类型可能会导致代码重复。
将 <code>MyList</code> 置于 <code>Type → Type</code> 中意味着它不能被用于实际的类型列表。
将它放在 <code>Type 1 → Type 1</code> 内意味着它不能用于类型列表的列表。
与其复制粘贴数据类型以在 <code>Type</code>、<code>Type 1</code>、<code>Type 2</code> 等中创建不同版本，不如使用一种称为 <strong>宇宙多态</strong> 的特性来编写单个可以在任意这些宇宙中实例化的定义。</p>
<!--
Ordinary polymorphic types use variables to stand for types in a definition.
This allows Lean to fill in the variables differently, which enables these definitions to be used with a variety of types.
Similarly, universe polymorphism allows variables to stand for universes in a definition, enabling Lean to fill them in differently so that they can be used with a variety of universes.
Just as type arguments are conventionally named with Greek letters, universe arguments are conventionally named `u`, `v`, and `w`.
-->
<p>普通的多态类型在定义中使用变量来表示类型。
这使得 Lean 可以以不同的方式填充这些变量，从而使这些定义可以与各种类型一起使用。
同样，宇宙多态性允许变量在定义中表示宇宙，使得 Lean 可以以不同的方式去填充它们，以便可以用于各种宇宙。
正如类型参数通常用希腊字母命名一样，宇宙参数通常命名为 <code>u</code>、<code>v</code> 和 <code>w</code>。</p>
<!--
This definition of `MyList` doesn't specify a particular universe level, but instead uses a variable `u` to stand for any level.
If the resulting datatype is used with `Type`, then `u` is `0`, and if it's used with `Type 3`, then `u` is `3`:
```lean
inductive MyList (α : Type u) : Type u where
  | nil : MyList α
  | cons : α → MyList α → MyList α
```
-->
<p><code>MyList</code> 的这个定义没有指定特定的宇宙层级，而是使用变量 <code>u</code> 来表示任意层级。
如果最终的数据类型与 <code>Type</code> 一起使用，那么 <code>u</code> 是 <code>0</code>；如果与 <code>Type 3</code> 一起使用，那么 <code>u</code> 是 <code>3</code>：</p>
<pre><code class="language-lean">inductive MyList (α : Type u) : Type u where
  | nil : MyList α
  | cons : α → MyList α → MyList α
</code></pre>
<!--
With this definition, the same definition of `MyList` can be used to contain both actual natural numbers and the natural number type itself:
```lean
def myListOfNumbers : MyList Nat :=
  .cons 0 (.cons 1 .nil)

def myListOfNat : MyList Type :=
  .cons Nat .nil
```
It can even contain itself:
```lean
def myListOfList : MyList (Type → Type) :=
  .cons MyList .nil
```
-->
<p>通过这个定义，<code>MyList</code> 的相同定义可以用于包含实际的自然数以及自然数类型本身：</p>
<pre><code class="language-lean">def myListOfNumbers : MyList Nat :=
  .cons 0 (.cons 1 .nil)

def myListOfNat : MyList Type :=
  .cons Nat .nil
</code></pre>
<p>它甚至可以包含其自身：</p>
<pre><code class="language-lean">def myListOfList : MyList (Type → Type) :=
  .cons MyList .nil
</code></pre>
<!--
It would seem that this would make it possible to write a logical paradox.
After all, the whole point of the universe system is to rule out self-referential types.
Behind the scenes, however, each occurrence of `MyList` is provided with a universe level argument.
In essence, the universe-polymorphic definition of `MyList` created a _copy_ of the datatype at each level, and the level argument selects which copy is to be used.
These level arguments are written with a dot and curly braces, so `MyList.{0} : Type → Type`, `MyList.{1} : Type 1 → Type 1`, and `MyList.{2} : Type 2 → Type 2`.
-->
<p>这似乎使得写出一个逻辑悖论成为可能。
毕竟，宇宙系统的全部意义在于排除自指类型。
然而，在幕后，每次出现 <code>MyList</code> 时都会提供一个宇宙层级的参数。
本质上，<code>MyList</code> 的宇宙多态定义在每个层级创建了数据类型的一个 <strong>副本</strong>，层级参数选择要使用哪个副本。
这些层级参数使用一个点和大括号书写，例如 <code>MyList.{0} : Type → Type</code>，<code>MyList.{1} : Type 1 → Type 1</code>，和 <code>MyList.{2} : Type 2 → Type 2</code>。</p>
<!--
Writing the levels explicitly, the prior example becomes:
```lean
def myListOfNumbers : MyList.{0} Nat :=
  .cons 0 (.cons 1 .nil)

def myListOfNat : MyList.{1} Type :=
  .cons Nat .nil

def myListOfList : MyList.{1} (Type → Type) :=
  .cons MyList.{0} .nil
```
-->
<p>明确地写出所有层次，之前的例子变成了：</p>
<pre><code class="language-lean">def myListOfNumbers : MyList.{0} Nat :=
  .cons 0 (.cons 1 .nil)

def myListOfNat : MyList.{1} Type :=
  .cons Nat .nil

def myListOfList : MyList.{1} (Type → Type) :=
  .cons MyList.{0} .nil
</code></pre>
<!--
When a universe-polymorphic definition takes multiple types as arguments, it's a good idea to give each argument its own level variable for maximum flexibility.
For example, a version of `Sum` with a single level argument can be written as follows:
```lean
inductive Sum (α : Type u) (β : Type u) : Type u where
  | inl : α → Sum α β
  | inr : β → Sum α β
```
This definition can be used at multiple levels:
```lean
def stringOrNat : Sum String Nat := .inl "hello"

def typeOrType : Sum Type Type := .inr Nat
```
However, it requires that both arguments be in the same universe:
```lean
def stringOrType : Sum String Type := .inr Nat
```
```output error
application type mismatch
  Sum String Type
argument
  Type
has type
  Type 1 : Type 2
but is expected to have type
  Type : Type 1
```
-->
<p>当一个宇宙多态定义接受了多个类型作为参数时，最好给每个参数赋予其自己的层级变量，以实现最大的灵活性。
例如，一个带有单个层级参数的 <code>Sum</code> 版本可以写成如下形式：</p>
<pre><code class="language-lean">inductive Sum (α : Type u) (β : Type u) : Type u where
  | inl : α → Sum α β
  | inr : β → Sum α β
</code></pre>
<p>这个定义可以在多个层级上使用：</p>
<pre><code class="language-lean">def stringOrNat : Sum String Nat := .inl &quot;hello&quot;

def typeOrType : Sum Type Type := .inr Nat
</code></pre>
<p>但是，它要求两个参数位于同一个宇宙内：</p>
<pre><code class="language-lean">def stringOrType : Sum String Type := .inr Nat
</code></pre>
<pre><code class="language-output error">application type mismatch
  Sum String Type
argument
  Type
has type
  Type 1 : Type 2
but is expected to have type
  Type : Type 1
</code></pre>
<!--
This datatype can be made more flexible by using different variables for the two type arguments' universe levels, and then declaring that the resulting datatype is in the largest of the two:
```lean
inductive Sum (α : Type u) (β : Type v) : Type (max u v) where
  | inl : α → Sum α β
  | inr : β → Sum α β
```
This allows `Sum` to be used with arguments from different universes:
```lean
def stringOrType : Sum String Type := .inr Nat
```
-->
<p>通过为两个类型参数的宇宙层级使用不同的变量，并声明生成的数据类型是两者中最大的层级，这可以使该数据类型更加灵活：</p>
<pre><code class="language-lean">inductive Sum (α : Type u) (β : Type v) : Type (max u v) where
  | inl : α → Sum α β
  | inr : β → Sum α β
</code></pre>
<p>这使得 <code>Sum</code> 可以与来自不同宇宙的参数一起使用：</p>
<pre><code class="language-lean">def stringOrType : Sum String Type := .inr Nat
</code></pre>
<!--
In positions where Lean expects a universe level, any of the following are allowed:
 * A concrete level, like `0` or `1`
 * A variable that stands for a level, such as `u` or `v`
 * The maximum of two levels, written as `max` applied to the levels
 * A level increase, written with `+ 1`
-->
<p>在 Lean 需要宇宙层级的位置，以下任意一种都是被允许的：</p>
<ul>
<li>具体的层级，如 <code>0</code> 或 <code>1</code></li>
<li>代表层级的变量，如 <code>u</code> 或 <code>v</code></li>
<li>两个层级的最大值，写作 <code>max</code> 应用于这些层级</li>
<li>层级增加，写作 <code>+ 1</code></li>
</ul>
<!--
### Writing Universe-Polymorphic Definitions
-->
<h3 id="编写宇宙多态定义"><a class="header" href="#编写宇宙多态定义">编写宇宙多态定义</a></h3>
<!--
Until now, every datatype defined in this book has been in `Type`, the smallest universe of data.
When presenting polymorphic datatypes from the Lean standard library, such as `List` and `Sum`, this book created non-universe-polymorphic versions of them.
The real versions use universe polymorphism to enable code re-use between type-level and non-type-level programs.
-->
<p>到目前为止，本书中定义的每种数据类型都在 <code>Type</code> 中，即最小的数据宇宙。
在展示 Lean 标准库中的多态数据类型时，例如 <code>List</code> 和 <code>Sum</code>，本书创建了它们的非宇宙多态的版本。
实际的版本使用了宇宙多态性来实现类型层级和非类型层级程序之间的代码复用。</p>
<!--
There are a few general guidelines to follow when writing universe-polymorphic types.
First off, independent type arguments should have different universe variables, which enables the polymorphic definition to be used with a wider variety of arguments, increasing the potential for code reuse.
Secondly, the whole type is itself typically either in the maximum of all the universe variables, or one greater than this maximum.
Try the smaller of the two first.
Finally, it's a good idea to put the new type in as small of a universe as possible, which allows it to be used more flexibly in other contexts.
Non-polymorphic types, such as `Nat` and `String`, can be placed directly in `Type 0`.
-->
<p>在编写宇宙多态类型时，有一些通用的指导准则需要遵守。
首先，独立的类型参数应具有不同的宇宙变量，这使得多态定义能够与更多种类的参数一起使用，从而增加代码复用的可能性。
其次，整个类型本身通常要么位于所有宇宙变量的最大值，要么位于比这个最大值大一的层级。
先尝试使用两者中较小的那个。
最后，最好将新类型放在一个尽可能小的宇宙中，这使得它在其他内容中可以更灵活地使用。
非多态类型，如 <code>Nat</code> 和 <code>String</code>，可以直接放在 <code>Type 0</code> 中。</p>
<!--
### `Prop` and Polymorphism
-->
<h3 id="prop-和多态"><a class="header" href="#prop-和多态"><code>Prop</code> 和多态</a></h3>
<!--
Just as `Type`, `Type 1`, and so on describe types that classify programs and data, `Prop` classifies logical propositions.
A type in `Prop` describes what counts as convincing evidence for the truth of a statement.
Propositions are like ordinary types in many ways: they can be declared inductively, they can have constructors, and functions can take propositions as arguments.
However, unlike datatypes, it typically doesn't matter _which_ evidence is provided for the truth of a statement, only _that_ evidence is provided.
On the other hand, it is very important that a program not only return a `Nat`, but that it's the _correct_ `Nat`.
-->
<p>就像 <code>Type</code>、<code>Type 1</code> 等描述了对程序和数据进行分类的类型一样，<code>Prop</code> 则用于对逻辑命题进行分类。
<code>Prop</code> 中的类型描述了什么可以作为令人信服的证据以证明一个陈述的真。
命题在许多方面与普通类型相似：它们可以被归纳地声明，它们可以有构造子，并且函数也可以将命题作为参数。
然而，与数据类型不同的是，通常来说，为证明陈述的真实性所提供的 <strong>那个</strong> 证据的具体内容并不重要，重要的是提供了 <strong>那个</strong> 证据。
另一方面，程序不仅要返回一个 <code>Nat</code>，而且要返回 <strong>正确的</strong> <code>Nat</code>，这一点非常重要。</p>
<!--
`Prop` is at the bottom of the universe hierarchy, and the type of `Prop` is `Type`.
This means that `Prop` is a suitable argument to provide to `List`, for the same reason that `Nat` is.
Lists of propositions have type `List Prop`:
```lean
def someTruePropositions : List Prop := [
  1 + 1 = 2,
  "Hello, " ++ "world!" = "Hello, world!"
]
```
Filling out the universe argument explicitly demonstrates that `Prop` is a `Type`:
```lean
def someTruePropositions : List.{0} Prop := [
  1 + 1 = 2,
  "Hello, " ++ "world!" = "Hello, world!"
]
```
-->
<p><code>Prop</code> 位于宇宙层级体系的底部，且 <code>Prop</code> 的类型是 <code>Type</code>。
这意味着 <code>Prop</code> 适合作为 <code>List</code> 的一个参数，原因和 <code>Nat</code> 一样。
命题列表的类型是 <code>List Prop</code>：</p>
<pre><code class="language-lean">def someTruePropositions : List Prop := [
  1 + 1 = 2,
  &quot;Hello, &quot; ++ &quot;world!&quot; = &quot;Hello, world!&quot;
]
</code></pre>
<p>显式地填写宇宙参数表明了 <code>Prop</code> 是一个 <code>Type</code>：</p>
<pre><code class="language-lean">def someTruePropositions : List.{0} Prop := [
  1 + 1 = 2,
  &quot;Hello, &quot; ++ &quot;world!&quot; = &quot;Hello, world!&quot;
]
</code></pre>
<!--
Behind the scenes, `Prop` and `Type` are united into a single hierarchy called `Sort`.
`Prop` is the same as `Sort 0`, `Type 0` is `Sort 1`, `Type 1` is `Sort 2`, and so forth.
In fact, `Type u` is the same as `Sort (u+1)`.
When writing programs with Lean, this is typically not relevant, but it may occur in error messages from time to time, and it explains the name of the `CoeSort` class.
Additionally, having `Prop` as `Sort 0` allows one more universe operator to become useful.
The universe level `imax u v` is `0` when `v` is `0`, or the larger of `u` or `v` otherwise.
Together with `Sort`, this allows the special rule for functions that return `Prop`s to be used when writing code that should be as portable as possible between `Prop` and `Type` universes.
-->
<p>在幕后，<code>Prop</code> 和 <code>Type</code> 被统一到一个称为 <code>Sort</code> 的层级体系中。
<code>Prop</code> 与 <code>Sort 0</code> 相同，<code>Type 0</code> 是 <code>Sort 1</code>，<code>Type 1</code> 是 <code>Sort 2</code>，依此类推。
实际上，<code>Type u</code> 就是 <code>Sort (u+1)</code>。
在使用 Lean 编写程序时，这通常并不相关，但它可能有时会出现在错误消息中，并解释 <code>CoeSort</code> 类的名称。
此外，将 <code>Prop</code> 作为 <code>Sort 0</code> 可以使得一个额外的宇宙运算符变得有用。
宇宙级别 <code>imax u v</code> 在 <code>v</code> 为 <code>0</code> 时为 <code>0</code>，否则为 <code>u</code> 或 <code>v</code> 中较大的那个。
结合 <code>Sort</code>，这使得在编写代码时可以使用一个特殊规则，该规则允许返回 <code>Prop</code> 的函数在 <code>Prop</code> 和 <code>Type</code> 宇宙之间尽可能地具有可移植性。</p>
<!--
## Polymorphism in Practice
-->
<h2 id="多态的实际应用"><a class="header" href="#多态的实际应用">多态的实际应用</a></h2>
<!--
In the remainder of the book, definitions of polymorphic datatypes, structures, and classes will use universe polymorphism in order to be consistent with the Lean standard library.
This will enable the complete presentation of the `Functor`, `Applicative`, and `Monad` classes to be completely consistent with their actual definitions.
-->
<p>在本书的其余部分，多态数据类型、结构体和类的定义将使用宇宙多态性，以便与 Lean 的标准库保持一致。
这将使 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 类的完整展示与它们的实际定义完全一致。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../functor-applicative-monad/alternative.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../functor-applicative-monad/complete.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../functor-applicative-monad/alternative.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../functor-applicative-monad/complete.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
