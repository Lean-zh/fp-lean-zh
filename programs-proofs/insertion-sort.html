<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>插入排序与数组可变性 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html" class="active"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/programs-proofs/insertion-sort.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Insertion Sort and Array Mutation
-->
<h1 id="插入排序与数组可变性"><a class="header" href="#插入排序与数组可变性">插入排序与数组可变性</a></h1>
<!--
While insertion sort does not have the optimal worst-case time complexity for a sorting algorithm, it still has a number of useful properties:

 * It is simple and straightforward to implement and understand
 * It is an in-place algorithm, requiring no additional space to run
 * It is a stable sort
 * It is fast when the input is already almost sorted
-->
<p>虽然插入排序的最差时间复杂度并不是最优，但它仍然有一些有用的属性：</p>
<ul>
<li>它简单明了，易于实现和理解</li>
<li>它是一种原地排序算法，不需要额外的空间来运行</li>
<li>它是一种稳定排序</li>
<li>当输入已经排序得差不多时，它很快</li>
</ul>
<!--
In-place algorithms are particularly useful in Lean due to the way it manages memory.
In some cases, operations that would normally copy an array can be optimized into mutation.
This includes swapping elements in an array.
-->
<p>原地算法在 Lean 中特别有用，因为它管理内存的方式。
在某些情况下，会复制数组的操作通常可以优化为直接修改。这包括交换数组中的元素。</p>
<!--
Most languages and run-time systems with automatic memory management, including JavaScript, the JVM, and .NET, use tracing garbage collection.
When memory needs to be reclaimed, the system starts at a number of _roots_ (such as the call stack and global values) and then determines which values can be reached by recursively chasing pointers.
Any values that can't be reached are deallocated, freeing memory.
-->
<p>大多数语言和具有自动内存管理的运行时系统，包括 JavaScript、JVM 和 .NET，都使用跟踪垃圾回收。
当需要回收内存时，系统从许多 <strong>根</strong>（例如调用栈和全局值）开始，
然后通过递归地追踪指针来确定可以到达哪些值。任何无法到达的值都会被释放，从而释放内存。</p>
<!--
Reference counting is an alternative to tracing garbage collection that is used by a number of languages, including Python, Swift, and Lean.
In a system with reference counting, each object in memory has a field that tracks how many references there are to it.
When a new reference is established, the counter is incremented.
When a reference ceases to exist, the counter is decremented.
When the counter reaches zero, the object is immediately deallocated.
-->
<p>引用计数是追踪式垃圾回收的替代方法，它被许多语言使用，包括 Python、Swift 和 Lean。
在引用计数系统中，内存中的每个对象都有一个字段来跟踪对它的引用数。
当建立一个新引用时，计数器会增加。当一个引用不再存在时，计数器会减少。
当计数器达到零时，对象会立即被释放。</p>
<!--
Reference counting has one major disadvantage compared to a tracing garbage collector: circular references can lead to memory leaks.
If object \\( A \\) references object \\( B \\) , and object \\( B \\) references object \\( A \\), they will never be deallocated, even if nothing else in the program references either \\( A \\) or \\( B \\).
Circular references result either from uncontrolled recursion or from mutable references.
Because Lean supports neither, it is impossible to construct circular references.
-->
<p>与追踪式垃圾回收器相比，引用计数有一个主要的缺点：循环引用会导致内存泄漏。
如果对象 \( A \) 引用对象 \( B \)，而对象 \( B \) 引用对象 \( A \)，
它们将永远不会被释放，即使程序中没有其他内容引用 \( A \) 或 \( B \)。
循环引用要么是由不受控制的递归引起的，要么是由可变引用引起的。由于 Lean 不支持这两者，
因此不可能构造循环引用。</p>
<!--
Reference counting means that the Lean runtime system's primitives for allocating and deallocating data structures can check whether a reference count is about to fall to zero, and re-use an existing object instead of allocating a new one.
This is particularly important when working with large arrays.
-->
<p>引用计数意味着 Lean 运行时系统用于分配和释放数据结构的原语可以检查引用计数是否即将降至零，
并重新使用现有对象而非分配一个新对象。当使用大型数组时，这一点尤其重要。</p>
<!--
An implementation of insertion sort for Lean arrays should satisfy the following criteria:

 1. Lean should accept the function without a `partial` annotation
 2. If passed an array to which there are no other references, it should modify the array in-place rather than allocating a new one
-->
<p>针对 Lean 数组的插入排序的实现应满足以下条件：</p>
<ol>
<li>Lean 应当接受没有 <code>partial</code> 标注的函数</li>
<li>若传递了一个没有其他引用的数组，它应原地修改数组，而非分配一个新数组</li>
</ol>
<!--
The first criterion is easy to check: if Lean accepts the definition, then it is satisfied.
The second, however, requires a means of testing it.
Lean provides a built-in function called `dbgTraceIfShared` with the following signature:
-->
<p>第一个条件很容易检查：如果 Lean 接受该定义，则满足该条件。
然而，第二个条件需要一种测试方法。Lean 提供了一个名为 <code>dbgTraceIfShared</code> 的内置函数，其签名如下：</p>
<pre><code class="language-lean">#check dbgTraceIfShared
</code></pre>
<pre><code class="language-output info">dbgTraceIfShared.{u} {α : Type u} (s : String) (a : α) : α
</code></pre>
<!--
It takes a string and a value as arguments, and prints a message that uses the string to standard error if the value has more than one reference, returning the value.
This is not, strictly speaking, a pure function.
However, it is intended to be used only during development to check that a function is in fact able to re-use memory rather than allocating and copying.
-->
<p>它以一个字符串和一个值作为参数，如果该值有多个引用，则使用该字符串打印一条消息到标准错误，
并返回该值。严格来说，它不是一个纯函数。
但是，它仅在开发期间用于检查函数实际上能够重用内存而非分配和复制。</p>
<!--
When learning to use `dbgTraceIfShared`, it's important to know that `#eval` will report that many more values are shared than in compiled code.
This can be confusing.
It's important to build an executable with `lake` rather than experimenting in an editor.
-->
<p>在学习使用 <code>dbgTraceIfShared</code> 时，重要的是要知道 <code>#eval</code> 会报告的值比已编译的代码中共享的值更多，
这可能会令人困惑。重要的是使用 <code>lake</code> 构建可执行文件，而非在编辑器中进行实验。</p>
<!--
Insertion sort consists of two loops.
The outer loop moves a pointer from left to right across the array to be sorted.
After each iteration, the region of the array to the left of the pointer is sorted, while the region to the right may not yet be sorted.
The inner loop takes the element pointed to by the pointer and moves it to the left until the appropriate location has been found and the loop invariant has been restored.
In other words, each iteration inserts the next element of the array into the appropriate location in the sorted region.
-->
<p>插入排序由两个循环组成。外层循环将指针从左向右移动到要排序的数组中。
每次迭代后，指针左边的数组区域都会被排序，而右边的区域可能尚未被排序。
内层循环获取指针指向的元素，并将其向左移动，直到找到合适的位置并恢复循环不变式。
换句话说，每次迭代都会将数组的下一个元素插入到已排序区域的合适位置。</p>
<!--
## The Inner Loop
-->
<h2 id="内层循环"><a class="header" href="#内层循环">内层循环</a></h2>
<!--
The inner loop of insertion sort can be implemented as a tail-recursive function that takes the array and the index of the element being inserted as arguments.
The element being inserted is repeatedly swapped with the element to its left until either the element to the left is smaller or the beginning of the array is reached.
The inner loop is structurally recursive on the `Nat` that is inside the `Fin` used to index into the array:
-->
<p>插入排序的内层循环可以实现为一个尾递归函数，该函数将数组和要插入的元素的索引作为参数。
要插入的元素会与它左边的元素反复交换，直到左边的元素更小或到达数组的开头。
内层循环会在用来索引数组的 <code>Fin</code> 中的 <code>Nat</code> 上进行结构化递归：</p>
<pre><code class="language-leantac">def insertSorted [Ord α] (arr : Array α) (i : Fin arr.size) : Array α :=
  match i with
  | ⟨0, _⟩ =&gt; arr
  | ⟨i' + 1, _⟩ =&gt;
    have : i' &lt; arr.size := by
      simp [Nat.lt_of_succ_lt, *]
    match Ord.compare arr[i'] arr[i] with
    | .lt | .eq =&gt; arr
    | .gt =&gt;
      insertSorted (arr.swap ⟨i', by assumption⟩ i) ⟨i', by simp [*]⟩
</code></pre>
<!--
If the index `i` is `0`, then the element being inserted into the sorted region has reached the beginning of the region and is the smallest.
If the index is `i' + 1`, then the element at `i'` should be compared to the element at `i`.
Note that while `i` is a `Fin arr.size`, `i'` is just a `Nat` because it results from the `val` field of `i`.
It is thus necessary to prove that `i' < arr.size` before `i'` can be used to index into `arr`.
-->
<p>若索引 <code>i</code> 为 <code>0</code>，则插入到已排序区域的元素已到达该区域的开头，并且是最小的。
若索引为 <code>i' + 1</code>，则应将 <code>i'</code> 处的元素与 <code>i</code> 处的元素进行比较。
请注意，虽然 <code>i</code> 是 <code>Fin arr.size</code>，但 <code>i'</code> 只是一个 <code>Nat</code>，因为它是由 <code>i</code> 的 <code>val</code> 字段产生的。
因此，在使用 <code>i'</code> 对 <code>arr</code> 进行索引之前，有必要证明 <code>i' &lt; arr.size</code>。</p>
<!--
Omitting the `have`-expression with the proof that `i' < arr.size` reveals the following goal:
-->
<p>省略带有证明 <code>i' &lt; arr.size</code> 的 <code>have</code> 表达式，将显示以下目标：</p>
<pre><code class="language-output error">unsolved goals
α : Type ?u.7
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
i' : Nat
isLt✝ : i' + 1 &lt; Array.size arr
⊢ i' &lt; Array.size arr
</code></pre>
<!--
The hint `Nat.lt_of_succ_lt` is a theorem from Lean's standard library.
Its signature, found by `#check Nat.lt_of_succ_lt`, is
-->
<p>提示 <code>Nat.lt_of_succ_lt</code> 是 Lean 标准库中的一个定理。
它的签名可以通过 <code>#check Nat.lt_of_succ_lt</code> 查看：</p>
<pre><code class="language-output info">Nat.lt_of_succ_lt {n m : Nat} (a✝ : Nat.succ n &lt; m) : n &lt; m
</code></pre>
<!--
In other words, it states that if `n + 1 < m`, then `n < m`.
The `*` passed to `simp` causes it to combine `Nat.lt_of_succ_lt` with the `isLt` field from `i` to get the final proof.
-->
<p>换句话说，它指出如果 <code>n + 1 &lt; m</code>，则 <code>n &lt; m</code>。传递给 <code>simp</code> 的 <code>*</code> 会使其将
<code>Nat.lt_of_succ_lt</code> 与 <code>i</code> 中的 <code>isLt</code> 字段结合起来以获得最终证明。</p>
<!--
Having established that `i'` can be used to look up the element to the left of the element being inserted, the two elements are looked up and compared.
If the element to the left is less than or equal to the element being inserted, then the loop is finished and the invariant has been restored.
If the element to the left is greater than the element being inserted, then the elements are swapped and the inner loop begins again.
`Array.swap` takes both of its indices as `Fin`s, and the `by assumption` that establishes that `i' < arr.size` makes use of the `have`.
The index to be examined on the next round through the inner loop is also `i'`, but `by assumption` is not sufficient in this case.
This is because the proof was written for the original array `arr`, not the result of swapping two elements.
The `simp` tactic's database contains the fact that swapping two elements of an array doesn't change its size, and the `[*]` argument instructs it to additionally use the assumption introduced by `have`.
-->
<p>在确定 <code>i'</code> 可用于查找要插入元素左侧的元素后，就要查找并比较这两个元素。
若左侧元素小于或等于要插入的元素，则循环结束并且不变量被恢复。
若左侧元素大于要插入的元素，则交换元素并重新开始内层循环。
<code>Array.swap</code> 将其两个索引都作为 <code>Fin</code>，并且利用 <code>have</code> 建立 <code>i' &lt; arr.size</code> 的 <code>by assumption</code>。
在内层循环的下一轮中要检查的索引也是 <code>i'</code>，但在这种情况下 <code>by assumption</code> 并足够。
这是因为该证明是针对原始数组 <code>arr</code> 编写的，而非交换两个元素的结果。
<code>simp</code> 策略的数据库包含这样一个事实：交换数组的两个元素不会改变其大小，
并且 <code>[*]</code> 参数会指示它额外使用 <code>have</code> 引入的假设。</p>
<!--
## The Outer Loop
-->
<h2 id="外层循环"><a class="header" href="#外层循环">外层循环</a></h2>
<!--
The outer loop of insertion sort moves the pointer from left to right, invoking `insertSorted` at each iteration to insert the element at the pointer into the correct position in the array.
The basic form of the loop resembles the implementation of `Array.map`:
-->
<p>插入排序的外层循环将指针从左向右移动，在每次迭代中调用 <code>insertSorted</code>
将指针处的元素插入到数组中正确的位置。循环的基本形式类似于 <code>Array.map</code> 的实现：</p>
<pre><code class="language-lean">def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
</code></pre>
<!--
The resulting error is also the same as the error that occurs without a `termination_by` clause on `Array.map`, because there is no argument that decreases at every recursive call:
-->
<p>它产生的错误也与在 <code>Array.map</code> 上没有 <code>termination_by</code> 子句时发生的错误相同，
因为没有在每次递归调用时都会减少的参数：</p>
<pre><code class="language-output error">fail to show termination for
  insertionSortLoop
with errors
argument #4 was not used for structural recursion
  failed to eliminate recursive application
    insertionSortLoop (insertSorted arr { val := i, isLt := h }) (i + 1)

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<!--
Before constructing the termination proof, it can be convenient to test the definition with a `partial` modifier to make sure that it returns the expected answers:
-->
<p>在构建停机证明之前，可以使用 <code>partial</code> 修饰符测试定义以确保它返回预期的答案：</p>
<pre><code class="language-lean">partial def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
</code></pre>
<pre><code class="language-lean">#eval insertionSortLoop #[5, 17, 3, 8] 0
</code></pre>
<pre><code class="language-output info">#[3, 5, 8, 17]
</code></pre>
<pre><code class="language-lean">#eval insertionSortLoop #[&quot;metamorphic&quot;, &quot;igneous&quot;, &quot;sedentary&quot;] 0
</code></pre>
<pre><code class="language-output info">#[&quot;igneous&quot;, &quot;metamorphic&quot;, &quot;sedentary&quot;]
</code></pre>
<!--
### Termination
-->
<h3 id="停机性"><a class="header" href="#停机性">停机性</a></h3>
<!--
Once again, the function terminates because the difference between the index and the size of the array being processed decreases on each recursive call.
This time, however, Lean does not accept the `termination_by`:
-->
<p>同样，该函数会停机是因为正在处理的索引和数组大小之差在每次递归调用时都会减小。
然而，这一次，Lean 不接受 <code>termination_by</code>：</p>
<pre><code class="language-lean">def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
termination_by insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<pre><code class="language-output error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Nat
h : i &lt; Array.size arr
⊢ Array.size (insertSorted arr { val := i, isLt := h }) - (i + 1) &lt; Array.size arr - i
</code></pre>
<!--
The problem is that Lean has no way to know that `insertSorted` returns an array that's the same size as the one it is passed.
In order to prove that `insertionSortLoop` terminates, it is necessary to first prove that `insertSorted` doesn't change the size of the array.
Copying the unproved termination condition from the error message to the function and "proving" it with `sorry` allows the function to be temporarily accepted:
-->
<p>问题在于 Lean 无法知道 <code>insertSorted</code> 返回的数组与传递给它的数组大小相同。
为了证明 <code>insertionSortLoop</code> 会停机，首先有必要证明 <code>insertSorted</code> 不会改变数组的大小。
将未经证明的停机条件从错误消息复制到函数中，并使用 <code>sorry</code>「证明」它，可以暂时接受该函数：</p>
<pre><code class="language-leantac">def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    have : (insertSorted arr ⟨i, h⟩).size - (i + 1) &lt; arr.size - i := by
      sorry
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
termination_by insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<pre><code class="language-output warning">declaration uses 'sorry'
</code></pre>
<!--
Because `insertSorted` is structurally recursive on the index of the element being inserted, the proof should be by induction on the index.
In the base case, the array is returned unchanged, so its length certainly does not change.
For the inductive step, the induction hypothesis is that a recursive call on the next smaller index will not change the length of the array.
There are two cases two consider: either the element has been fully inserted into the sorted region and the array is returned unchanged, in which case the length is also unchanged, or the element is swapped with the next one before the recursive call.
However, swapping two elements in an array doesn't change the size of it, and the induction hypothesis states that the recursive call with the next index returns an array that's the same size as its argument.
Thus, the size remains unchanged.
-->
<p>由于 <code>insertSorted</code> 在要插入的元素的索引上是结构化递归的，所以应该通过索引归纳进行证明。
在基本情况下，数组返回不变，因此其长度肯定不会改变。对于归纳步骤，
归纳假设是在下一个更小的索引上的递归调用不会改变数组的长度。
这里有两种情况需要考虑：要么元素已完全插入到已排序区域中，并且数组返回不变，
在这种情况下长度也不会改变，要么元素在递归调用之前与下一个元素交换。
然而，在数组中交换两个元素不会改变它的大小，
并且归纳假设指出以下一个索引的递归调用返回的数组与其参数大小相同。因此，大小仍然保持不变。</p>
<!--
Translating this English-language theorem statement to Lean and proceeding using the techniques from this chapter is enough to prove the base case and make progress in the inductive step:
-->
<p>将自然语言的定理陈述翻译为 Lean，并使用本章中的技术进行操作，足以证明基本情况并在归纳步骤中取得进展：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (arr : Array α) (i : Fin arr.size) :
    (insertSorted arr i).size = arr.size := by
  match i with
  | ⟨j, isLt⟩ =&gt;
    induction j with
    | zero =&gt; simp [insertSorted]
    | succ j' ih =&gt;
      simp [insertSorted]
</code></pre>
<!--
The simplification using `insertSorted` in the inductive step revealed the pattern match in `insertSorted`:
-->
<p>在归纳步骤中使用 <code>insertSorted</code> 的简化揭示了 <code>insertSorted</code> 中的模式匹配：</p>
<pre><code class="language-output error">unsolved goals
case succ
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
⊢ Array.size
      (match compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] with
      | Ordering.lt =&gt; arr
      | Ordering.eq =&gt; arr
      | Ordering.gt =&gt;
        insertSorted
          (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
          { val := j',
            isLt :=
              (_ :
                j' &lt;
                  Array.size
                    (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                      { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<!--
When faced with a goal that includes `if` or `match`, the `split` tactic (not to be confused with the `split` function used in the definition of merge sort) replaces the goal with one new goal for each path of control flow:
-->
<p>当面对包含 <code>if</code> 或 <code>match</code> 的目标时，<code>split</code> 策略（不要与归并排序定义中使用的 <code>split</code> 函数混淆）
会用一个新目标替换原目标，用于控制流的每条路径：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (arr : Array α) (i : Fin arr.size) :
    (insertSorted arr i).size = arr.size := by
  match i with
  | ⟨j, isLt⟩ =&gt;
    induction j with
    | zero =&gt; simp [insertSorted]
    | succ j' ih =&gt;
      simp [insertSorted]
      split
</code></pre>
<!--
Additionally, each new goal has an assumption that indicates which branch led to that goal, named `heq✝` in this case:
-->
<p>此外，每个新目标都有一个假设，表明哪个分支导致了该目标，在本例中命名为 <code>heq✝</code>：</p>
<pre><code class="language-output error">unsolved goals
case succ.h_1
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.lt
⊢ Array.size arr = Array.size arr

case succ.h_2
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.eq
⊢ Array.size arr = Array.size arr

case succ.h_3
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
⊢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<!--
Rather than write proofs for both simple cases, adding `<;> try rfl` after `split` causes the two straightforward cases to disappear immediately, leaving only a single goal:
-->
<p>与其为这两个简单情况编写证明，不如在 <code>split</code> 后添加 <code>&lt;;&gt; try rfl</code>，
这样这两个直接的情况会立即消失，只留下一个目标：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (arr : Array α) (i : Fin arr.size) :
    (insertSorted arr i).size = arr.size := by
  match i with
  | ⟨j, isLt⟩ =&gt;
    induction j with
    | zero =&gt; simp [insertSorted]
    | succ j' ih =&gt;
      simp [insertSorted]
      split &lt;;&gt; try rfl
</code></pre>
<pre><code class="language-output error">unsolved goals
case succ.h_3
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
⊢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<!--
Unfortunately, the induction hypothesis is not strong enough to prove this goal.
The induction hypothesis states that calling `insertSorted` on `arr` leaves the size unchanged, but the proof goal is to show that the result of the recursive call with the result of swapping leaves the size unchanged.
Successfully completing the proof requires an induction hypothesis that works for _any_ array that is passed to `insertSorted` together with the smaller index as an argument
-->
<p>不幸的是，归纳假设不足以证明这个目标。归纳假设指出对 <code>arr</code> 调用 <code>insertSorted</code> 不会改变大小，
但证明目标是要证明用交换的结果来进行递归调用的结果不会改变大小。成功完成证明需要一个归纳假设，
该假设适用于传递给 <code>insertSorted</code> 的任何数组，以及作为参数的更小的索引。</p>
<!--
It is possible to get a strong induction hypothesis by using the `generalizing` option to the `induction` tactic.
This option brings additional assumptions from the context into the statement that's used to generate the base case, the induction hypothesis, and the goal to be shown in the inductive step.
Generalizing over `arr` leads to a stronger hypothesis:
-->
<p>可以使用 <code>induction</code> 策略的 <code>generalizing</code> 选项来获得强归纳假设。
此选项会将语境中的附加假设引入到一个语句中，该语句用于生成基本情况、归纳假设和在归纳步骤中显示的目标。
对 <code>arr</code> 进行推广会产生更强的假设：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (arr : Array α) (i : Fin arr.size) :
    (insertSorted arr i).size = arr.size := by
  match i with
  | ⟨j, isLt⟩ =&gt;
    induction j generalizing arr with
    | zero =&gt; simp [insertSorted]
    | succ j' ih =&gt;
      simp [insertSorted]
      split &lt;;&gt; try rfl
</code></pre>
<!--
In the resulting goal, `arr` is now part of a "for all" statement in the inductive hypothesis:
-->
<p>在生成的证明目标中，<code>arr</code> 现在是归纳假设中「对于所有」语句的一部分：</p>
<pre><code class="language-output error">unsolved goals
case succ.h_3
α : Type u_1
inst✝ : Ord α
j' : Nat
ih :
  ∀ (arr : Array α),
    Fin (Array.size arr) →
      ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
arr : Array α
i : Fin (Array.size arr)
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
⊢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<!--
However, this whole proof is beginning to get unmanageable.
The next step would be to introduce a variable standing for the length of the result of swapping, show that it is equal to `arr.size`, and then show that this variable is also equal to the length of the array that results from the recursive call.
These equality statement can then be chained together to prove the goal.
It's much easier, however, to carefully reformulate the theorem statement such that the induction hypothesis is automatically strong enough and the variables are already introduced.
The reformulated statement reads:
-->
<p>然而，整个证明开始变得难以控制。下一步是引入一个变量表示交换结果的长度，
证明它等于 <code>arr.size</code>，然后证明这个变量也等于递归调用产生的数组的长度。
之后可以将这些相等语句链接在一起来证明目标。
然而，仔细地重新表述定理的陈述要容易得多，这样归纳假设就能自动变得足够强，变量也会被引入。
重新表述的陈述如下：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → arr.size = len →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  skip
</code></pre>
<!--
This version of the theorem statement is easier to prove for a few reasons:

 1. Rather than bundling up the index and the proof of its validity in a `Fin`, the index comes before the array.
    This allows the induction hypothesis to naturally generalize over the array and the proof that `i` is in bounds.
 2. An abstract length `len` is introduced to stand for `array.size`.
    Proof automation is often better at working with explicit statements of equality.
-->
<p>这个版本的定理陈述更容易证明，原因有以下几个：</p>
<ol>
<li>与其将索引及其有效性证明捆绑在 <code>Fin</code> 中，不如将索引放在数组之前。
这使得归纳假设可以自然地推广到整个数组，并证明 <code>i</code> 在范围内。</li>
<li>引入了一个抽象长度 <code>len</code> 来表示 <code>array.size</code>。证明自动化通常更擅长处理显式相等性陈述。</li>
</ol>
<!--
The resulting proof state shows the statement that will be used to generate the induction hypothesis, as well as the base case and the goal of the inductive step:
-->
<p>生成的证明状态显示了将要用于生成归纳假设的语句，以及基本情况和归纳步骤的目标：</p>
<pre><code class="language-output error">unsolved goals
α : Type u_1
inst✝ : Ord α
len i : Nat
⊢ ∀ (arr : Array α) (isLt : i &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := i, isLt := isLt }) = len
</code></pre>
<!--
Compare the statement with the goals that result from the `induction` tactic:
-->
<p>将该语句与 <code>induction</code> 策略产生的目标进行比较：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → arr.size = len →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt; skip
  | succ i' ih =&gt; skip
</code></pre>
<!--
In the base case, each occurrence of `i` has been replaced by `0`.
Using `intro` to introduce each assumption and then simplifying using `insertSorted` will prove the goal, because `insertSorted` at index `zero` returns its argument unchanged:
-->
<p>在基本情况下，每个 <code>i</code> 的出现都会被替换为 <code>0</code>。使用 <code>intro</code> 引入每个假设，
然后使用 <code>insertSorted</code> 简化就能证明目标，因为在索引 <code>zero</code> 处的 <code>insertSorted</code> 会返回其参数不变：</p>
<pre><code class="language-output error">unsolved goals
case zero
α : Type u_1
inst✝ : Ord α
len : Nat
⊢ ∀ (arr : Array α) (isLt : Nat.zero &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := Nat.zero, isLt := isLt }) = len
</code></pre>
<!--
In the inductive step, the induction hypothesis has exactly the right strength.
It will be useful for _any_ array, so long as that array has length `len`:
-->
<p>在归纳步骤中，归纳假设具有恰当的强度。它对 <strong>任何</strong> 数组都适用，只要该数组的长度为 <code>len</code>：</p>
<pre><code class="language-output error">unsolved goals
case succ
α : Type u_1
inst✝ : Ord α
len i' : Nat
ih :
  ∀ (arr : Array α) (isLt : i' &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := i', isLt := isLt }) = len
⊢ ∀ (arr : Array α) (isLt : Nat.succ i' &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := Nat.succ i', isLt := isLt }) = len
</code></pre>
<!--
In the base case, `simp` reduces the goal to `arr.size = len`:
-->
<p>在基本情况下，<code>simp</code> 将目标简化为 <code>arr.size = len</code>：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → arr.size = len →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt;
    intro arr isLt hLen
    simp [insertSorted]
  | succ i' ih =&gt; skip
</code></pre>
<pre><code class="language-output error">unsolved goals
case zero
α : Type u_1
inst✝ : Ord α
len : Nat
arr : Array α
isLt : Nat.zero &lt; Array.size arr
hLen : Array.size arr = len
⊢ Array.size arr = len
</code></pre>
<!--
This can be proved using the assumption `hLen`.
Adding the `*` parameter to `simp` instructs it to additionally use assumptions, which solves the goal:
-->
<p>这可以使用假设 <code>hLen</code> 来证明。向 <code>simp</code> 添加 <code>*</code> 参数指示它额外使用假设，这解决了目标：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → arr.size = len →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt;
    intro arr isLt hLen
    simp [insertSorted, *]
  | succ i' ih =&gt; skip
</code></pre>
<!--
In the inductive step, introducing assumptions and simplifying the goal results once again in a goal that contains a pattern match:
-->
<p>在归纳步骤中，引入假设并简化目标会再次产生包含模式匹配的目标：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → (arr.size = len) →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt;
    intro arr isLt hLen
    simp [insertSorted, *]
  | succ i' ih =&gt;
    intro arr isLt hLen
    simp [insertSorted]
</code></pre>
<pre><code class="language-output error">unsolved goals
case succ
α : Type u_1
inst✝ : Ord α
len i' : Nat
ih :
  ∀ (arr : Array α) (isLt : i' &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array α
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
⊢ Array.size
      (match compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] with
      | Ordering.lt =&gt; arr
      | Ordering.eq =&gt; arr
      | Ordering.gt =&gt;
        insertSorted
          (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) } { val := Nat.succ i', isLt := isLt })
          { val := i',
            isLt :=
              (_ :
                i' &lt;
                  Array.size
                    (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) }
                      { val := Nat.succ i', isLt := isLt })) }) =
    len
</code></pre>
<!--
Using the `split` tactic results in one goal for each pattern.
Once again, the first two goals result from branches without recursive calls, so the induction hypothesis is not necessary:
-->
<p>使用 <code>split</code> 策略会为每个模式生成一个目标。同样，前两个目标来自没有递归调用的分支，因此不需要归纳假设：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → (arr.size = len) →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt;
    intro arr isLt hLen
    simp [insertSorted, *]
  | succ i' ih =&gt;
    intro arr isLt hLen
    simp [insertSorted]
    split
</code></pre>
<pre><code class="language-output error">unsolved goals
case succ.h_1
α : Type u_1
inst✝ : Ord α
len i' : Nat
ih :
  ∀ (arr : Array α) (isLt : i' &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array α
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
x✝ : Ordering
heq✝ : compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] = Ordering.lt
⊢ Array.size arr = len

case succ.h_2
α : Type u_1
inst✝ : Ord α
len i' : Nat
ih :
  ∀ (arr : Array α) (isLt : i' &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array α
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
x✝ : Ordering
heq✝ : compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] = Ordering.eq
⊢ Array.size arr = len

case succ.h_3
α : Type u_1
inst✝ : Ord α
len i' : Nat
ih :
  ∀ (arr : Array α) (isLt : i' &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array α
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
x✝ : Ordering
heq✝ : compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] = Ordering.gt
⊢ Array.size
      (insertSorted
        (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) } { val := Nat.succ i', isLt := isLt })
        { val := i',
          isLt :=
            (_ :
              i' &lt;
                Array.size
                  (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) }
                    { val := Nat.succ i', isLt := isLt })) }) =
    len
</code></pre>
<!--
Running `try assumption` in each goal that results from `split` eliminates both of the non-recursive goals:
-->
<p>在 <code>split</code> 产生的每个目标中运行 <code>try assumption</code> 会消除两个非递归目标：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → (arr.size = len) →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt;
    intro arr isLt hLen
    simp [insertSorted, *]
  | succ i' ih =&gt;
    intro arr isLt hLen
    simp [insertSorted]
    split &lt;;&gt; try assumption
</code></pre>
<pre><code class="language-output error">unsolved goals
case succ.h_3
α : Type u_1
inst✝ : Ord α
len i' : Nat
ih :
  ∀ (arr : Array α) (isLt : i' &lt; Array.size arr),
    Array.size arr = len → Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array α
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
x✝ : Ordering
heq✝ : compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] = Ordering.gt
⊢ Array.size
      (insertSorted
        (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) } { val := Nat.succ i', isLt := isLt })
        { val := i',
          isLt :=
            (_ :
              i' &lt;
                Array.size
                  (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) }
                    { val := Nat.succ i', isLt := isLt })) }) =
    len
</code></pre>
<!--
The new formulation of the proof goal, in which a constant `len` is used for the lengths of all the arrays involved in the recursive function, falls nicely within the kinds of problems that `simp` can solve.
This final proof goal can be solved by `simp [*]`, because the assumptions that relate the array's length to `len` are important:
-->
<p>对于证明目标的全新表述，其中常量 <code>len</code> 用于递归函数中涉及的所有数组的长度，
恰好属于 <code>simp</code> 可以解决的问题类型。最终的证明目标可以通过 <code>simp [*]</code> 来解决，
因为将数组的长度与 <code>len</code> 联系起来的假设很重要：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → (arr.size = len) →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt;
    intro arr isLt hLen
    simp [insertSorted, *]
  | succ i' ih =&gt;
    intro arr isLt hLen
    simp [insertSorted]
    split &lt;;&gt; try assumption
    simp [*]
</code></pre>
<!--
Finally, because `simp [*]` can use assumptions, the `try assumption` line can be replaced by `simp [*]`, shortening the proof:
-->
<p>最后，因为 <code>simp [*]</code> 可以使用假设，所以 <code>try assumption</code> 一行可以用 <code>simp [*]</code> 替换来缩短证明：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → (arr.size = len) →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt;
    intro arr isLt hLen
    simp [insertSorted, *]
  | succ i' ih =&gt;
    intro arr isLt hLen
    simp [insertSorted]
    split &lt;;&gt; simp [*]
</code></pre>
<!--
This proof can now be used to replace the `sorry` in `insertionSortLoop`.
Providing `arr.size` as the `len` argument to the theorem causes the final conclusion to be `(insertSorted arr ⟨i, isLt⟩).size = arr.size`, so the rewrite ends with a very manageable proof goal:
-->
<p>现在可以使用这个证明来替换 <code>insertionSortLoop</code> 中的 <code>sorry</code>。
将 <code>arr.size</code> 作为定理的 <code>len</code> 参数会导致最终结论为 <code>(insertSorted arr ⟨i, isLt⟩).size = arr.size</code>，
因此重写以一个非常易于管理的证明目标结束：</p>
<pre><code class="language-leantacnorfl">  def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
    if h : i &lt; arr.size then
      have : (insertSorted arr ⟨i, h⟩).size - (i + 1) &lt; arr.size - i := by
        rw [insert_sorted_size_eq arr.size i arr h rfl]
      insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
    else
      arr
termination_by insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type ?u.22173
inst✝ : Ord α
arr : Array α
i : Nat
h : i &lt; Array.size arr
⊢ Array.size arr - (i + 1) &lt; Array.size arr - i
</code></pre>
<!--
The proof `Nat.sub_succ_lt_self` is part of Lean's standard library.
It's type is `∀ (a i : Nat), i < a → a - (i + 1) < a - i`, which is exactly what's needed:
-->
<p>证明 <code>Nat.sub_succ_lt_self</code>
是 Lean 标准库的一部分，其类型为
<code>∀ (a i : Nat), i &lt; a → a - (i + 1) &lt; a - i</code>
它刚好就是我们所需要的：</p>
<pre><code class="language-leantacnorfl">def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    have : (insertSorted arr ⟨i, h⟩).size - (i + 1) &lt; arr.size - i := by
      rw [insert_sorted_size_eq arr.size i arr h rfl]
      simp [Nat.sub_succ_lt_self, *]
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
termination_by insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<!--
## The Driver Function
-->
<h2 id="驱动函数"><a class="header" href="#驱动函数">驱动函数</a></h2>
<!--
Insertion sort itself calls `insertionSortLoop`, initializing the index that demarcates the sorted region of the array from the unsorted region to `0`:
-->
<p>插入排序本身会调用 <code>insertionSortLoop</code>，以将数组中已排序区域与未排序区域的分界索引初始化为 <code>0</code>：</p>
<pre><code class="language-lean">def insertionSort [Ord α] (arr : Array α) : Array α :=
   insertionSortLoop arr 0
</code></pre>
<!--
A few quick tests show the function is at least not blatantly wrong:
-->
<p>一些快速测试表明该函数至少不是明显错误的：</p>
<pre><code class="language-lean">#eval insertionSort #[3, 1, 7, 4]
</code></pre>
<pre><code class="language-output info">#[1, 3, 4, 7]
</code></pre>
<pre><code class="language-lean">#eval insertionSort #[ &quot;quartz&quot;, &quot;marble&quot;, &quot;granite&quot;, &quot;hematite&quot;]
</code></pre>
<pre><code class="language-output info">#[&quot;granite&quot;, &quot;hematite&quot;, &quot;marble&quot;, &quot;quartz&quot;]
</code></pre>
<!--
## Is This Really Insertion Sort?
-->
<h2 id="它真的是插入排序吗"><a class="header" href="#它真的是插入排序吗">它真的是插入排序吗？</a></h2>
<!--
Insertion sort is _defined_ to be an in-place sorting algorithm.
What makes it useful, despite its quadratic worst-case run time, is that it is a stable sorting algorithm that doesn't allocate extra space and that handles almost-sorted data efficiently.
If each iteration of the inner loop allocated a new array, then the algorithm wouldn't _really_ be insertion sort.
-->
<p>插入排序被 <strong>定义</strong> 为原地排序算法。尽管它具有二次最差运行时间，但它仍然有用，
因为它是一种稳定的排序算法，不会分配额外的空间，并且可以有效处理几乎已排序的数据。
如果内层循环的每次迭代都分配一个新数组，那么该算法就不会真正成为插入排序。</p>
<!--
Lean's array operations, such as `Array.set` and `Array.swap`, check whether the array in question has a reference count that is greater than one.
If so, then the array is visible to multiple parts of the code, which means that it must be copied.
Otherwise, Lean would no longer be a pure functional language.
However, when the reference count is exactly one, there are no other potential observers of the value.
In these cases, the array primitives mutate the array in place.
What other parts of the program don't know can't hurt them.
-->
<p>Lean 的数组操作（例如 <code>Array.set</code> 和 <code>Array.swap</code>）会检查所讨论的数组的引用计数是否大于 1。
如果是，则该数组对代码的多个部分可见，这意味着它必须被复制。
否则，Lean 将不再是一种纯函数式语言。但是，当引用计数恰好为 1 时，没有其他潜在的值观察者。
在这种情况下，数组原语会就地改变数组。程序其他不知道的部分不会对它造成破坏。</p>
<!--
Lean's proof logic works at the level of pure functional programs, not the underlying implementation.
This means that the best way to discover whether a program unnecessarily copies data is to test it.
Adding calls to `dbgTraceIfShared` at each point where mutation is desired causes the provided message to be printed to `stderr` when the value in question has more than one reference.
-->
<p>Lean 的证明逻辑在纯函数式程序的级别上，而非在底层实现上工作。
这意味着发现程序是否不必要地复制了数据的最好方法是测试它。
在需要改变的每个点添加对 <code>dbgTraceIfShared</code> 的调用，当所讨论的值有多个引用时，
它会将提供的消息打印到 <code>stderr</code>。</p>
<!--
Insertion sort has precisely one place that is at risk of copying rather than mutating: the call to `Array.swap`.
Replacing `arr.swap ⟨i', by assumption⟩ i` with `((dbgTraceIfShared "array to swap" arr).swap ⟨i', by assumption⟩ i)` causes the program to emit `shared RC array to swap` whenever it is unable to mutate the array.
However, this change to the program changes the proofs as well, because now there's a call to an additional function.
Because `dbgTraceIfShared` returns its second argument directly, adding it to the calls to `simp` is enough to fix the proofs.
-->
<p>插入排序刚好有一个地方有复制而非改变的风险：调用 <code>Array.swap</code>。将 <code>arr.swap ⟨i', by assumption⟩ i</code>
替换为 <code>((dbgTraceIfShared &quot;array to swap&quot; arr).swap ⟨i', by assumption⟩ i)</code>
会让程序在无法改变数组时发出 <code>shared RC array to swap</code>。然而，对程序的这一更改也会更改证明，
因为现在调用了一个附加函数。由于 <code>dbgTraceIfShared</code> 直接返回其第二个参数，
因此将其添加到对 <code>simp</code> 的调用中足以修复证明。</p>
<!--
The complete instrumented code for insertion sort is:
-->
<p>插入排序的完整形式化验证代码为：</p>
<pre><code class="language-leantacnorfl">def insertSorted [Ord α] (arr : Array α) (i : Fin arr.size) : Array α :=
  match i with
  | ⟨0, _⟩ =&gt; arr
  | ⟨i' + 1, _⟩ =&gt;
    have : i' &lt; arr.size := by
      simp [Nat.lt_of_succ_lt, *]
    match Ord.compare arr[i'] arr[i] with
    | .lt | .eq =&gt; arr
    | .gt =&gt;
      insertSorted
        ((dbgTraceIfShared &quot;array to swap&quot; arr).swap ⟨i', by assumption⟩ i)
        ⟨i', by simp [dbgTraceIfShared, *]⟩

theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :
    (arr : Array α) → (isLt : i &lt; arr.size) → (arr.size = len) →
    (insertSorted arr ⟨i, isLt⟩).size = len := by
  induction i with
  | zero =&gt;
    intro arr isLt hLen
    simp [insertSorted, *]
  | succ i' ih =&gt;
    intro arr isLt hLen
    simp [insertSorted, dbgTraceIfShared]
    split &lt;;&gt; simp [*]

def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    have : (insertSorted arr ⟨i, h⟩).size - (i + 1) &lt; arr.size - i := by
      rw [insert_sorted_size_eq arr.size i arr h rfl]
      simp [Nat.sub_succ_lt_self, *]
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
termination_by insertionSortLoop arr i =&gt; arr.size - i

def insertionSort [Ord α] (arr : Array α) : Array α :=
  insertionSortLoop arr 0
</code></pre>
<!--
A bit of cleverness is required to check whether the instrumentation actually works.
First off, the Lean compiler aggressively optimizes function calls away when all their arguments are known at compile time.
Simply writing a program that applies `insertionSort` to a large array is not sufficient, because the resulting compiled code may contain only the sorted array as a constant.
The easiest way to ensure that the compiler doesn't optimize away the sorting routine is to read the array from `stdin`.
Secondly, the compiler performs dead code elimination.
Adding extra `let`s to the program won't necessarily result in more references in running code if the `let`-bound variables are never used.
To ensure that the extra reference is not eliminated entirely, it's important to ensure that the extra reference is somehow used.
-->
<p>要检查形式化验证是否实际起作用，需要一点技巧。首先，当所有参数在编译时都已知时，
Lean 编译器会积极地优化函数调用。仅仅编写一个将 <code>insertionSort</code> 应用于大数组的程序是不够的，
因为生成的编译代码可能只包含已排序的数组作为常量。确保编译器不会优化排序例程的最简单方法是从
<code>stdin</code> 读取数组。其次，编译器会执行死代码消除。如果从未使用 <code>let</code> 绑定的变量，
则向程序中添加额外的 <code>let</code> 并不一定会导致运行代码中更多的引用。为了确保不会完全消除额外的引用，
重点在于确保以某种方式使用了额外的引用。</p>
<!--
The first step in testing the instrumentation is to write `getLines`, which reads an array of lines from standard input:
-->
<p>测试形式化验证代码的第一步是编写 <code>getLines</code>，它从标准输入读取一行数组：</p>
<pre><code class="language-lean">def getLines : IO (Array String) := do
  let stdin ← IO.getStdin
  let mut lines : Array String := #[]
  let mut currLine ← stdin.getLine
  while !currLine.isEmpty do
     -- Drop trailing newline:
    lines := lines.push (currLine.dropRight 1)
    currLine ← stdin.getLine
  pure lines
</code></pre>
<!--
`IO.FS.Stream.getLine` returns a complete line of text, including the trailing newline.
It returns `""` when the end-of-file marker has been reached.
-->
<p><code>IO.FS.Stream.getLine</code> 返回一行完整的文本，包括结尾的换行。当到达文件结尾标记时，它返回空字符串 <code>&quot;&quot;</code>。</p>
<!--
Next, two separate `main` routines are needed.
Both read the array to be sorted from standard input, ensuring that the calls to `insertionSort` won't be replaced by their return values at compile time.
Both then print to the console, ensuring that the calls to `insertionSort` won't be optimized away entirely.
One of them prints only the sorted array, while the other prints both the sorted array and the original array.
The second function should trigger a warning that `Array.swap` had to allocate a new array:
-->
<p>接下来，需要两个单独的 <code>main</code> 例程。两者都从标准输入读取要排序的数组，
确保在编译时不会用它们的返回值替换对 <code>insertionSort</code> 的调用。然后两者都打印到控制台，
确保对 <code>insertionSort</code> 的调用不会被完全优化掉。其中一个只打印排序后的数组，
而另一个同时打印排序后的数组和原始数组。第二个函数应该触发一个警告，
即 <code>Array.swap</code> 必须分配一个新数组：</p>
<pre><code class="language-lean">def mainUnique : IO Unit := do
  let lines ← getLines
  for line in insertionSort lines do
    IO.println line

def mainShared : IO Unit := do
  let lines ← getLines
  IO.println &quot;--- Sorted lines: ---&quot;
  for line in insertionSort lines do
    IO.println line

  IO.println &quot;&quot;
  IO.println &quot;--- Original data: ---&quot;
  for line in lines do
    IO.println line
</code></pre>
<!--
The actual `main` simply selects one of the two main actions based on the provided command-line arguments:
-->
<p>实际的 <code>main</code> 只需根据提供的命令行参数选择两个 main 活动二者之一：</p>
<pre><code class="language-lean">def main (args : List String) : IO UInt32 := do
  match args with
  | [&quot;--shared&quot;] =&gt; mainShared; pure 0
  | [&quot;--unique&quot;] =&gt; mainUnique; pure 0
  | _ =&gt;
    IO.println &quot;Expected single argument, either \&quot;--shared\&quot; or \&quot;--unique\&quot;&quot;
    pure 1
</code></pre>
<!--
Running it with no arguments produces the expected usage information:
-->
<p>在没有参数的情况下运行它会产生预期的用法信息：</p>
<pre><code>$ sort
Expected single argument, either &quot;--shared&quot; or &quot;--unique&quot;
</code></pre>
<!--
The file `test-data` contains the following rocks:
-->
<p><code>test-data</code> 文件包含以下岩石：</p>
<pre><code>schist
feldspar
diorite
pumice
obsidian
shale
gneiss
marble
flint
</code></pre>
<!--
Using the instrumented insertion sort on these rocks results them being printed in alphabetical order:
-->
<p>对这些岩石使用形式化验证的插入排序，结果按字母顺序打印出来：</p>
<pre><code>$ sort --unique &lt; test-data
diorite
feldspar
flint
gneiss
marble
obsidian
pumice
schist
shale
</code></pre>
<!--
However, the version in which a reference is retained to the original array results in a notification on `stderr` (namely, `shared RC array to swap`) from the first call to `Array.swap`:
-->
<p>然而，保留对原始数组的引用的版本会导致对 <code>Array.swap</code> 的第一次调用在 <code>stderr</code>
上发出通知（即 <code>shared RC array to swap</code>）：</p>
<pre><code>$ sort --shared &lt; test-data
shared RC array to swap
--- Sorted lines: ---
diorite
feldspar
flint
gneiss
marble
obsidian
pumice
schist
shale

--- Original data: ---
schist
feldspar
diorite
pumice
obsidian
shale
gneiss
marble
flint
</code></pre>
<!--
The fact that only a single `shared RC` notification appears means that the array is copied only once.
This is because the copy that results from the call to `Array.swap` is itself unique, so no further copies need to be made.
In an imperative language, subtle bugs can result from forgetting to explicitly copy an array before passing it by reference.
When running `sort --shared`, the array is copied as needed to preserve the pure functional meaning of Lean programs, but no more.
-->
<p>仅出现一个 <code>shared RC</code> 通知这一事实意味着数组仅被复制了一次。
这是因为由对 <code>Array.swap</code> 的调用产生的副本本身是唯一的，因此不需要进行进一步的复制。
在命令式语言中，由于忘记在按引用传递数组之前显式复制数组，可能会导致微妙的 Bug。
在运行 <code>sort --shared</code> 时，数组会安需复制，以保持 Lean 程序的纯函数语义，但仅此而已。</p>
<!--
## Other Opportunities for Mutation
-->
<h2 id="其他可变性的机会"><a class="header" href="#其他可变性的机会">其他可变性的机会</a></h2>
<!--
The use of mutation instead of copying when references are unique is not limited to array update operators.
Lean also attempts to "recycle" constructors whose reference counts are about to fall to zero, reusing them instead of allocating new data.
This means, for instance, that `List.map` will mutate a linked list in place, at least in cases when nobody could possibly notice.
One of the most important steps in optimizing hot loops in Lean code is making sure that the data being modified is not referred to from multiple locations.
-->
<p>当引用唯一时，使用修改而非复制并不仅限于数组更新操作。
Lean 还会尝试「回收」引用计数即将降至零的构造函数，重新使用它们而不是分配新数据。
这意味着，例如，<code>List.map</code> 将原地修改链表，至少在无人能注意到的情况下。
优化 Lean 代码中的热循环最重要的步骤之一是确保被修改的数据不会被从多个位置引用。</p>
<!--
## Exercises
-->
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<!--
 * Write a function that reverses arrays. Test that if the input array has a reference count of one, then your function does not allocate a new array.
-->
<ul>
<li>编写一个反转数组的函数。测试如果输入数组的引用计数为一，则你的函数不会分配一个新数组。</li>
</ul>
<!--
 * Implement either merge sort or quicksort for arrays. Prove that your implementation terminates, and test that it doesn't allocate more arrays than expected. This is a challenging exercise!
-->
<ul>
<li>为数组实现归并排序或快速排序。证明你的实现会停机，并测试它不会分配比预期更多的数组。
这是一个具有挑战性的练习！</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../programs-proofs/fin.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../programs-proofs/special-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../programs-proofs/fin.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../programs-proofs/special-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
