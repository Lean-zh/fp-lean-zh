<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>结构体和继承 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html" class="active"><strong aria-hidden="true">6.1.</strong> 结构体和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的契约</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/functor-applicative-monad/inheritance.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Structures and Inheritance
-->
<h1 id="结构体和继承"><a class="header" href="#结构体和继承">结构体和继承</a></h1>
<!--
In order to understand the full definitions of `Functor`, `Applicative`, and `Monad`, another Lean feature is necessary: structure inheritance.
Structure inheritance allows one structure type to provide the interface of another, along with additional fields.
This can be useful when modeling concepts that have a clear taxonomic relationship.
For example, take a model of mythical creatures.
Some of them are large, and some are small:
-->
<p>为了理解 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 的完整定义，另一个 Lean 的特性必不可少：结构体继承 (Structure Inheritance)。
结构体继承允许一种结构体类型提供另一种结构体类型的接口，并添加额外的属性。
这在对具有明确分类关系的概念进行建模时非常有用。
例如，以 神话生物 (Mythical Creature) 的模型为例。
其中有些很大型，有些很小型：</p>
<pre><code class="language-lean">structure MythicalCreature where
  large : Bool
deriving Repr
</code></pre>
<!--
Behind the scenes, defining the `MythicalCreature` structure creates an inductive type with a single constructor called `mk`:
-->
<p>在幕后，定义 <code>MythicalCreature</code> 结构体会创建一个具有名为 <code>mk</code> 的单一构造子的归纳类型：</p>
<pre><code class="language-lean">#check MythicalCreature.mk
</code></pre>
<pre><code class="language-output info">MythicalCreature.mk (large : Bool) : MythicalCreature
</code></pre>
<!--
Similarly, a function `MythicalCreature.large` is created that actually extracts the field from the constructor:
-->
<p>类似地，当一个函数 <code>MythicalCreature.large</code> 被创建，它实际上从构造子中提取了属性：</p>
<pre><code class="language-lean">#check MythicalCreature.large
</code></pre>
<pre><code class="language-output info">MythicalCreature.large (self : MythicalCreature) : Bool
</code></pre>
<!--
In most old stories, each monster can be defeated in some way.
A description of a monster should include this information, along with whether it is large:
-->
<p>在大多数古老的故事中，每个怪物都可以用某种方式被击败。
一只怪物 (Monster) 的描述应该包括以下信息，以及它是否庞大：</p>
<pre><code class="language-lean">structure Monster extends MythicalCreature where
  vulnerability : String
deriving Repr
</code></pre>
<!--
The `extends MythicalCreature` in the heading states that every monster is also mythical.
To define a `Monster`, both the fields from `MythicalCreature` and the fields from `Monster` should be provided.
A troll is a large monster that is vulnerable to sunlight:
-->
<p>标题中的 <code>extends MythicalCreature</code> 表明每个 <code>Monster</code> 也都是 <code>MythicalCreature</code>。
要定义一个 <code>Monster</code>，其 <code>MythicalCreature</code> 的属性和 <code>Monster</code> 的属性应被同时提供。
巨魔 (Troll) 是一种对阳光敏感的大型怪物。</p>
<pre><code class="language-lean">def troll : Monster where
  large := true
  vulnerability := &quot;sunlight&quot;
</code></pre>
<!--
Behind the scenes, inheritance is implemented using composition.
The constructor `Monster.mk` takes a `MythicalCreature` as its argument:
-->
<p>在幕后，继承是通过组合来实现的。构造子 <code>Monster.mk</code> 将 <code>MythicalCreature</code> 作为其参数：</p>
<pre><code class="language-lean">#check Monster.mk
</code></pre>
<pre><code class="language-output info">Monster.mk (toMythicalCreature : MythicalCreature) (vulnerability : String) : Monster
</code></pre>
<!--
In addition to defining functions to extract the value of each new field, a function `Monster.toMythicalCreature` is defined with type `Monster → MythicalCreature`.
This can be used to extract the underlying creature.
-->
<p>除了定义函数来提取每个新属性的值之外，一个类型为 <code>Monster → MythicalCreature</code> 的函数 <code>Monster.toMythicalCreature</code> 也被定义了。
其可以被用于提取底层的生物。</p>
<!--
Moving up the inheritance hierarchy in Lean is not the same thing as upcasting in object-oriented languages.
An upcast operator causes a value from a derived class to be treated as an instance of the parent class, but the value retains its identity and structure.
In Lean, however, moving up the inheritance hierarchy actually erases the underlying information.
To see this in action, consider the result of evaluating `troll.toMythicalCreature`:
-->
<p>在 Lean 的继承层级体系中逐级上升与面向对象语言中的向上转型（Upcasting）并不相同。
向上转型运算符会使派生类的值被视为父类的实例，但该值会保留其原有的特性和结构体。
然而，在 Lean 中，在继承层级体系内逐级上升实际上会擦除原有的底层信息。
要查看此操作，请看 <code>troll.toMythicalCreature</code> 的求值结果：</p>
<pre><code class="language-lean">#eval troll.toMythicalCreature
</code></pre>
<pre><code class="language-output info">{ large := true }
</code></pre>
<!--
Only the fields of `MythicalCreature` remain.
-->
<p>只有 <code>MythicalCreature</code> 的属性被保留了。</p>
<!--
Just like the `where` syntax, curly-brace notation with field names also works with structure inheritance:
-->
<p>如同 <code>where</code> 语法一样，使用属性名称的花括号表示法也适用于结构体继承：</p>
<pre><code class="language-lean">def troll : Monster := {large := true, vulnerability := &quot;sunlight&quot;}
</code></pre>
<!--
However, the anonymous angle-bracket notation that delegates to the underlying constructor reveals the internal details:
-->
<p>不过，委托给底层构造子的匿名尖括号表示法揭示了内部的细节：</p>
<pre><code class="language-lean">def troll : Monster := ⟨true, &quot;sunlight&quot;⟩
</code></pre>
<pre><code class="language-output error">application type mismatch
  Monster.mk true
argument
  true
has type
  Bool : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<!--
An extra set of angle brackets is required, which invokes `MythicalCreature.mk` on `true`:
-->
<p>需要额外的一对尖括号，这将对 <code>true</code> 调用 <code>MythicalCreature.mk</code>：</p>
<pre><code class="language-lean">def troll : Monster := ⟨⟨true⟩, &quot;sunlight&quot;⟩
</code></pre>
<!--
Lean's dot notation is capable of taking inheritance into account.
In other words, the existing `MythicalCreature.large` can be used with a `Monster`, and Lean automatically inserts the call to `Monster.toMythicalCreature` before the call to `MythicalCreature.large`.
However, this only occurs when using dot notation, and applying the field lookup function using normal function call syntax results in a type error:
-->
<p>Lean 的点表示法能够考虑继承。
换句话说，现有的 <code>MythicalCreature.large</code> 可以和 <code>Monster</code> 一起使用，并且 Lean 会在调用 <code>MythicalCreature.large</code> 之前自动插入对 <code>Monster.toMythicalCreature</code> 的调用。
不过，这仅在使用点表示法时发生，并且使用正常的函数调用语法来应用属性查找函数会致使一个类型错误的发生：</p>
<pre><code class="language-lean">#eval MythicalCreature.large troll
</code></pre>
<pre><code class="language-output error">application type mismatch
  troll.large
argument
  troll
has type
  Monster : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<!--
Dot notation can also take inheritance into account for user-defined functions.
A small creature is one that is not large:
-->
<p>对于用户定义函数 (User-Defined Function)，点表示法还可以考虑其继承关系。
小型生物是指那些不大的生物：</p>
<pre><code class="language-lean">def MythicalCreature.small (c : MythicalCreature) : Bool := !c.large
</code></pre>
<!--
Evaluating `troll.small` yields `false`, while attempting to evaluate `MythicalCreature.small troll` results in:
-->
<p>对于 <code>troll.small</code> 的求值结果是 <code>false</code>，而尝试对 <code>MythicalCreature.small troll</code> 求值则会产生以下结果：</p>
<pre><code class="language-output error">application type mismatch
  MythicalCreature.small troll
argument
  troll
has type
  Monster : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<!--
### Multiple Inheritance
-->
<h3 id="多重继承"><a class="header" href="#多重继承">多重继承</a></h3>
<!--
A helper is a mythical creature that can provide assistance when given the correct payment:
-->
<p>助手是一种神话生物，当给予适当的报酬时，它就可以提供帮助。</p>
<pre><code class="language-lean">structure Helper extends MythicalCreature where
  assistance : String
  payment : String
deriving Repr
</code></pre>
<!--
For example, a _nisse_ is a kind of small elf that's known to help around the house when provided with tasty porridge:
-->
<p>例如，<strong>nisse</strong> 是一种小精灵，众所周知，当给他提供美味的粥时，它就会帮忙打理家务。</p>
<pre><code class="language-lean">def nisse : Helper where
  large := false
  assistance := &quot;household tasks&quot;
  payment := &quot;porridge&quot;
</code></pre>
<!--
If domesticated, trolls make excellent helpers.
They are strong enough to plow a whole field in a single night, though they require model goats to keep them satisfied with their lot in life.
A monstrous assistant is a monster that is also a helper:
-->
<p>如果巨魔被驯化，它们便会成为出色的助手。
它们强壮到可以在一个晚上耕完整片田地，尽管它们需要模型山羊来让它们对自己的生活感到满意。
怪物助手是既是怪物又是助手。</p>
<pre><code class="language-lean">structure MonstrousAssistant extends Monster, Helper where
deriving Repr
</code></pre>
<!--
A value of this structure type must fill in all of the fields from both parent structures:
-->
<p>这种结构体类型的值必须由两个父结构体的所有属性进行填充：</p>
<pre><code class="language-lean">def domesticatedTroll : MonstrousAssistant where
  large := false
  assistance := &quot;heavy labor&quot;
  payment := &quot;toy goats&quot;
  vulnerability := &quot;sunlight&quot;
</code></pre>
<!--
Both of the parent structure types extend `MythicalCreature`.
If multiple inheritance were implemented naïvely, then this could lead to a "diamond problem", where it would be unclear which path to `large` should be taken from a given `MonstrousAssistant`.
Should it take `large` from the contained `Monster` or from the contained `Helper`?
In Lean, the answer is that the first specified path to the grandparent structure is taken, and the additional parent structures' fields are copied rather than having the new structure include both parents directly.
-->
<p>这两种父结构体类型都扩展自 <code>MythicalCreature</code>。
如果多重继承被简单地实现，那么这可能会导致“菱形问题”，即在一个给定的 <code>MonstrousAssistant</code> 中，不清楚应该采用哪条路径来获取 <code>large</code>。
它应该从所包含的 <code>Monster</code> 还是 <code>Helper</code> 中去获取 <code>large</code> 呢？
在 Lean 中，答案是采用第一条指定到祖先结构体的路径，并且其他父结构体的属性会被复制，而不是让新的结构体直接包含两个父结构体。</p>
<!--
This can be seen by examining the signature of the constructor for `MonstrousAssistant`:
-->
<p>通过检验 <code>MonstrousAssistant</code> 的构造子的签名可以看到这一点。</p>
<pre><code class="language-lean">#check MonstrousAssistant.mk
</code></pre>
<pre><code class="language-output info">MonstrousAssistant.mk (toMonster : Monster) (assistance payment : String) : MonstrousAssistant
</code></pre>
<!--
It takes a `Monster` as an argument, along with the two fields that `Helper` introduces on top of `MythicalCreature`.
Similarly, while `MonstrousAssistant.toMonster` merely extracts the `Monster` from the constructor, `MonstrousAssistant.toHelper` has no `Helper` to extract.
The `#print` command exposes its implementation:
-->
<p>它接受一个 <code>Monster</code> 作为参数，以及 <code>Helper</code> 在 <code>MythicalCreature</code> 之上引入的两个属性。
类似地，虽然 <code>MonstrousAssistant.toMonster</code> 仅仅是从构造子中提取出 <code>Monster</code>，但 <code>MonstrousAssistant.toHelper</code> 并没有 <code>Helper</code> 可以提取。
<code>#print</code> 命令展现了其实现方式：</p>
<pre><code class="language-lean">#print MonstrousAssistant.toHelper
</code></pre>
<pre><code class="language-output info">@[reducible] def MonstrousAssistant.toHelper : MonstrousAssistant → Helper :=
fun self =&gt;
  { toMythicalCreature := self.toMonster.toMythicalCreature, assistance := self.assistance, payment := self.payment }
</code></pre>
<!--
This function constructs a `Helper` from the fields of `MonstrousAssistant`.
The `@[reducible]` attribute has the same effect as writing `abbrev`.
-->
<p>此函数从 <code>MonstrousAssistant</code> 的属性中构造了一个 <code>Helper</code>。
<code>@[reducible]</code> 属性的作用与编写 <code>abbrev</code> 相同。</p>
<!--
### Default Declarations
-->
<h3 id="默认声明"><a class="header" href="#默认声明">默认声明</a></h3>
<!--
When one structure inherits from another, default field definitions can be used to instantiate the parent structure's fields based on the child structure's fields.
If more size specificity is required than whether a creature is large or not, a dedicated datatype describing sizes can be used together with inheritance, yielding a structure in which the `large` field is computed from the contents of the `size` field:
-->
<p>当一个结构体继承自另一个结构体时，可以使用默认属性定义，即基于子结构体的属性去实例化父结构体的属性。
如果需要比生物是否庞大更具体的尺寸特征，则可以结合使用描述尺寸的专用数据类型和继承机制，以此产生一个结构体，其中 <code>large</code> 属性是根据 <code>size</code> 属性的内容计算得出的：</p>
<pre><code class="language-lean">inductive Size where
  | small
  | medium
  | large
deriving BEq

structure SizedCreature extends MythicalCreature where
  size : Size
  large := size == Size.large
</code></pre>
<!--
This default definition is only a default definition, however.
Unlike property inheritance in a language like C# or Scala, the definitions in the child structure are only used when no specific value for `large` is provided, and nonsensical results can occur:
-->
<p>但是，这个默认定义只是一个默认定义。
与 C# 或 Scala 等语言中的属性继承不同，子结构体中的定义仅在没有提供 <code>large</code> 的具体值时才会使用，并且可能会出现无意义的结果：</p>
<pre><code class="language-lean">def nonsenseCreature : SizedCreature where
  large := false
  size := .large
</code></pre>
<!--
If the child structure should not deviate from the parent structure, there are a few options:

 1. Documenting the relationship, as is done for `BEq` and `Hashable`
 2. Defining a proposition that the fields are related appropriately, and designing the API to require evidence that the proposition is true where it matters
 3. Not using inheritance at all

The second option could look like this:
-->
<p>如果子结构体不应偏离父结构体，则有以下几种选择：</p>
<ol>
<li>记录其关系，如同 <code>BEq</code> 和 <code>Hashable</code> 所做的那样</li>
<li>定义一个属性之间适当关联的命题，并设计 API 以在需要的地方要求提供命题为真的证据</li>
<li>完全不使用继承</li>
</ol>
<p>第二种选择可以如同这样：</p>
<pre><code class="language-lean">abbrev SizesMatch (sc : SizedCreature) : Prop :=
  sc.large = (sc.size == Size.large)
</code></pre>
<!--
Note that a single equality sign is used to indicate the equality _proposition_, while a double equality sign is used to indicate a function that checks equality and returns a `Bool`.
`SizesMatch` is defined as an `abbrev` because it should automatically be unfolded in proofs, so that `simp` can see the equality that should be proven.
-->
<p>请注意，单个等号用于表示等式 <strong>命题</strong> ，而双等号用于表示一个检查相等性并返回 <code>Bool</code> 的函数。
<code>SizesMatch</code> 被定义为 <code>abbrev</code>，因为它应该在证明中自动展开，以使得 <code>simp</code> 能看到需要被证明的等式。</p>
<!--
A _huldre_ is a medium-sized mythical creature—in fact, they are the same size as humans.
The two sized fields on `huldre` match one another:
-->
<p><strong>huldre</strong> 是一种中等体型的神话生物——实际上，它们与人类的体型相同。
<code>huldre</code> 上的两个大小属性是相互匹配的：</p>
<pre><code class="language-lean">def huldre : SizedCreature where
  size := .medium

example : SizesMatch huldre := by
  simp
</code></pre>
<!--
### Type Class Inheritance
-->
<h3 id="类型类继承"><a class="header" href="#类型类继承">类型类继承</a></h3>
<!--
Behind the scenes, type classes are structures.
Defining a new type class defines a new structure, and defining an instance creates a value of that structure type.
They are then added to internal tables in Lean that allow it to find the instances upon request.
A consequence of this is that type classes may inherit from other type classes.
-->
<p>在幕后，类型类是结构体。
定义一个新的类型类会定义一个新的结构体，而定义一个实例会创建该结构体类型的一个值。
然后，它们被添加到 Lean 的内部表中，以便 Lean 可以根据请求找到实例。
这样做的结果是类型类能够继承其他类型类。</p>
<!--
Because it uses precisely the same language features, type class inheritance supports all the features of structure inheritance, including multiple inheritance, default implementations of parent types' methods, and automatic collapsing of diamonds.
This is useful in many of the same situations that multiple interface inheritance is useful in languages like Java, C# and Kotlin.
By carefully designing type class inheritance hierarchies, programmers can get the best of both worlds: a fine-grained collection of independently-implementable abstractions, and automatic construction of these specific abstractions from larger, more general abstractions.
-->
<p>由于使用了完全相同的语言特性，类型类继承支持结构体继承的所有特性，包括多重继承、父类型方法的默认实现以及自动解决菱形继承问题。
这在许多情况下都很有用，就像 Java、C# 和 Kotlin 等语言中的多重接口继承。
通过精心设计类型类的继承层级体系，程序员可以兼得两方面的优势：一方面是得到一个可独立实现的抽象的精细集合，另一方面是从更大、更通用的抽象中自动构造出这些特定的抽象。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../functor-applicative-monad.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../functor-applicative-monad/applicative.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../functor-applicative-monad.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../functor-applicative-monad/applicative.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
