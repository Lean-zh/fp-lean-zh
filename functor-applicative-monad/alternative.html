<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>选择子 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构体和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的契约</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html" class="active"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/functor-applicative-monad/alternative.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Alternatives
-->
<h1 id="选择子"><a class="header" href="#选择子">选择子</a></h1>
<!--
## Recovery from Failure
-->
<h2 id="从失败中恢复"><a class="header" href="#从失败中恢复">从失败中恢复</a></h2>
<!--
`Validate` can also be used in situations where there is more than one way for input to be acceptable.
For the input form `RawInput`, an alternative set of business rules that implement conventions from a legacy system might be the following:

 1. All human users must provide a birth year that is four digits.
 2. Users born prior to 1970 do not need to provide names, due to incomplete older records.
 3. Users born after 1970 must provide names.
 4. Companies should enter `"FIRM"` as their year of birth and provide a company name.
-->
<p><code>Validate</code> 还可以用于当输入有多种可接受方式的情况。
对于输入表单 <code>RawInput</code>，实现来自遗留系统的约定的替代业务规则集合可能如下：</p>
<ol>
<li>所有人类用户必须提供四位数的出生年份。</li>
<li>由于旧记录不完整，1970年以前出生的用户不需要提供姓名。</li>
<li>1970年以后出生的用户必须提供姓名。</li>
<li>公司应输入 <code>&quot;FIRM&quot;</code> 作为其出生年份并提供公司名称。</li>
</ol>
<!--
No particular provision is made for users born in 1970.
It is expected that they will either give up, lie about their year of birth, or call.
The company considers this an acceptable cost of doing business.
-->
<p>对于出生于1970年的用户，没有做出特别的规定。
预计他们要么放弃，要么谎报出生年份，要么打电话咨询。
公司认为这是可以接受的经营成本。</p>
<!--
The following inductive type captures the values that can be produced from these stated rules:
```lean
abbrev NonEmptyString := {s : String // s ≠ ""}

inductive LegacyCheckedInput where
  | humanBefore1970 :
    (birthYear : {y : Nat // y > 999 ∧ y < 1970}) →
    String →
    LegacyCheckedInput
  | humanAfter1970 :
    (birthYear : {y : Nat // y > 1970}) →
    NonEmptyString →
    LegacyCheckedInput
  | company :
    NonEmptyString →
    LegacyCheckedInput
deriving Repr
```
-->
<p>以下归纳类型捕获了可以从这些既定规则中生成的值：</p>
<pre><code class="language-lean">abbrev NonEmptyString := {s : String // s ≠ &quot;&quot;}

inductive LegacyCheckedInput where
  | humanBefore1970 :
    (birthYear : {y : Nat // y &gt; 999 ∧ y &lt; 1970}) →
    String →
    LegacyCheckedInput
  | humanAfter1970 :
    (birthYear : {y : Nat // y &gt; 1970}) →
    NonEmptyString →
    LegacyCheckedInput
  | company :
    NonEmptyString →
    LegacyCheckedInput
deriving Repr
</code></pre>
<!--
A validator for these rules is more complicated, however, as it must address all three cases.
While it can be written as a series of nested `if` expressions, it's easier to design the three cases independently and then combine them.
This requires a means of recovering from failure while preserving error messages:
```lean
def Validate.orElse (a : Validate ε α) (b : Unit → Validate ε α) : Validate ε α :=
  match a with
  | .ok x => .ok x
  | .errors errs1 =>
    match b () with
    | .ok x => .ok x
    | .errors errs2 => .errors (errs1 ++ errs2)
```
-->
<p>然而，一个针对这些规则的验证器会更复杂，因为它必须处理所有三种情况。
虽然可以将其写成一系列嵌套的 <code>if</code> 表达式，但更容易的方式是独立设计这三种情况，然后再将它们组合起来。
这需要一种在保留错误信息的同时从失败中恢复的方法：</p>
<pre><code class="language-lean">def Validate.orElse (a : Validate ε α) (b : Unit → Validate ε α) : Validate ε α :=
  match a with
  | .ok x =&gt; .ok x
  | .errors errs1 =&gt;
    match b () with
    | .ok x =&gt; .ok x
    | .errors errs2 =&gt; .errors (errs1 ++ errs2)
</code></pre>
<!--
This pattern of recovery from failures is common enough that Lean has built-in syntax for it, attached to a type class named `OrElse`:
```lean
class OrElse (α : Type) where
  orElse : α → (Unit → α) → α
```
The expression `E1 <|> E2` is short for `OrElse.orElse E1 (fun () => E2)`.
An instance of `OrElse` for `Validate` allows this syntax to be used for error recovery:
```lean
instance : OrElse (Validate ε α) where
  orElse := Validate.orElse
```
-->
<p>这种从失败中恢复的模式非常常见，以至于 Lean 为此内置了一种语法，并将其附加到了一个名为 <code>OrElse</code> 的类型类上:</p>
<pre><code class="language-lean">class OrElse (α : Type) where
  orElse : α → (Unit → α) → α
</code></pre>
<p>表达式 <code>E1 &lt;|&gt; E2</code> 是 <code>OrElse.orElse E1 (fun () =&gt; E2)</code> 的简写形式。
<code>Validate</code> 的 <code>OrElse</code> 实例允许使用这种语法去进行错误恢复：</p>
<pre><code class="language-lean">instance : OrElse (Validate ε α) where
  orElse := Validate.orElse
</code></pre>
<!--
The validator for `LegacyCheckedInput` can be built from a validator for each constructor.
The rules for a company state that the birth year should be the string `"FIRM"` and that the name should be non-empty.
The constructor `LegacyCheckedInput.company`, however, has no representation of the birth year at all, so there's no easy way to carry it out using `<*>`.
The key is to use a function with `<*>` that ignores its argument.
-->
<p><code>LegacyCheckedInput</code> 的验证器可以由每个构造子的验证器构建而成。
对于公司的规则，规定了其出生年份应为字符串 <code>&quot;FIRM&quot;</code>，且名称应为非空。
然而，构造子 <code>LegacyCheckedInput.company</code> 根本没有出生年份的表示，因此无法通过 <code>&lt;*&gt;</code> 去轻松执行此操作。
关键是使用一个忽略其参数的函数与 <code>&lt;*&gt;</code> 一起使用。</p>
<!--
Checking that a Boolean condition holds without recording any evidence of this fact in a type can be accomplished with `checkThat`:
```lean
def checkThat (condition : Bool) (field : Field) (msg : String) : Validate (Field × String) Unit :=
  if condition then pure () else reportError field msg
```
This definition of `checkCompany` uses `checkThat`, and then throws away the resulting `Unit` value:
```lean
def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  pure (fun () name => .company name) <*>
    checkThat (input.birthYear == "FIRM") "birth year" "FIRM if a company" <*>
    checkName input.name
```
-->
<p>要检查一个布尔条件是否成立，而无需在类型中记录此事实的任何证据，可以通过 <code>checkThat</code> 来完成：</p>
<pre><code class="language-lean">def checkThat (condition : Bool) (field : Field) (msg : String) : Validate (Field × String) Unit :=
  if condition then pure () else reportError field msg
</code></pre>
<p>这个 <code>checkCompany</code> 的定义使用了 <code>checkThat</code>，然后丢弃了生成的 <code>Unit</code> 值：</p>
<pre><code class="language-lean">def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  pure (fun () name =&gt; .company name) &lt;*&gt;
    checkThat (input.birthYear == &quot;FIRM&quot;) &quot;birth year&quot; &quot;FIRM if a company&quot; &lt;*&gt;
    checkName input.name
</code></pre>
<!--
However, this definition is quite noisy.
It can be simplified in two ways.
The first is to replace the first use of `<*>` with a specialized version that automatically ignores the value returned by the first argument, called `*>`.
This operator is also controlled by a type class, called `SeqRight`, and `E1 *> E2` is syntactic sugar for `SeqRight.seqRight E1 (fun () => E2)`:
```lean
class SeqRight (f : Type → Type) where
  seqRight : f α → (Unit → f β) → f β
```
There is a default implementation of `seqRight` in terms of `seq`: `seqRight (a : f α) (b : Unit → f β) : f β := pure (fun _ x => x) <*> a <*> b ()`.
-->
<p>但是，这个定义相当繁琐。
可以通过两种方式来简化它。
第一种方法是将第一次使用的 <code>&lt;*&gt;</code> 替换为一个专门的版本，称为 <code>*&gt;</code>，改版本会自动忽略第一个参数所返回的值。
这个运算符也是由一个类型类控制，称为 <code>SeqRight</code>，<code>E1 *&gt; E2</code> 是 <code>SeqRight.seqRight E1 (fun () =&gt; E2)</code> 的语法糖：</p>
<pre><code class="language-lean">class SeqRight (f : Type → Type) where
  seqRight : f α → (Unit → f β) → f β
</code></pre>
<p>基于 <code>seq</code>，<code>seqRight</code> 有一个默认实现：<code>seqRight (a : f α) (b : Unit → f β) : f β := pure (fun _ x =&gt; x) &lt;*&gt; a &lt;*&gt; b ()</code>。</p>
<!--
Using `seqRight`, `checkCompany` becomes simpler:
```lean
def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkThat (input.birthYear == "FIRM") "birth year" "FIRM if a company" *>
  pure .company <*> checkName input.name
```
One more simplification is possible.
For every `Applicative`, `pure F <*> E` is equivalent to `f <$> E`.
In other words, using `seq` to apply a function that was placed into the `Applicative` type using `pure` is overkill, and the function could have just been applied using `Functor.map`.
This simplification yields:
```lean
def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkThat (input.birthYear == "FIRM") "birth year" "FIRM if a company" *>
  .company <$> checkName input.name
```
-->
<p>使用 <code>seqRight</code> 后，<code>checkCompany</code> 变得更简单了：</p>
<pre><code class="language-lean">def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkThat (input.birthYear == &quot;FIRM&quot;) &quot;birth year&quot; &quot;FIRM if a company&quot; *&gt;
  pure .company &lt;*&gt; checkName input.name
</code></pre>
<p>还可以进行进一步简化。
对于每个 <code>Applicative</code>，<code>pure F &lt;*&gt; E</code> 等价于 <code>f &lt;$&gt; E</code>。
换句话说，使用 <code>seq</code> 来应用到使用 <code>pure</code> 放入 <code>Applicative</code> 类型的函数是多余的，这个函数完全可以使用 <code>Functor.map</code> 来应用。
这种简化得到的结果是：</p>
<pre><code class="language-lean">def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkThat (input.birthYear == &quot;FIRM&quot;) &quot;birth year&quot; &quot;FIRM if a company&quot; *&gt;
  .company &lt;$&gt; checkName input.name
</code></pre>
<!--
The remaining two constructors of `LegacyCheckedInput` use subtypes for their fields.
A general-purpose tool for checking subtypes will make these easier to read:
```lean
def checkSubtype {α : Type} (v : α) (p : α → Prop) [Decidable (p v)] (err : ε) : Validate ε {x : α // p x} :=
  if h : p v then
    pure ⟨v, h⟩
  else
    .errors { head := err, tail := [] }
```
In the function's argument list, it's important that the type class `[Decidable (p v)]` occur after the specification of the arguments `v` and `p`.
Otherwise, it would refer to an additional set of automatic implicit arguments, rather than to the manually-provided values.
The `Decidable` instance is what allows the proposition `p v` to be checked using `if`.
-->
<p><code>LegacyCheckedInput</code> 的其余两个构造子在其属性中使用了子类型。
一个用于检查子类型的通用工具将使这些构造函数更易读：</p>
<pre><code class="language-lean">def checkSubtype {α : Type} (v : α) (p : α → Prop) [Decidable (p v)] (err : ε) : Validate ε {x : α // p x} :=
  if h : p v then
    pure ⟨v, h⟩
  else
    .errors { head := err, tail := [] }
</code></pre>
<p>在函数的参数列表中，重要的是类型类 <code>[Decidable (p v)]</code> 应出现在参数 <code>v</code> 和 <code>p</code> 的指定之后。
否则，它将引用一组额外的自动隐式参数，而不是手动提供的值。
<code>Decidable</code> 实例允许使用 <code>if</code> 来检查命题 <code>p v</code>。</p>
<!--
The two human cases do not need any additional tools:
```lean
def checkHumanBefore1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  (checkYearIsNat input.birthYear).andThen fun y =>
    .humanBefore1970 <$>
      checkSubtype y (fun x => x > 999 ∧ x < 1970) ("birth year", "less than 1970") <*>
      pure input.name

def checkHumanAfter1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  (checkYearIsNat input.birthYear).andThen fun y =>
    .humanAfter1970 <$>
      checkSubtype y (· > 1970) ("birth year", "greater than 1970") <*>
      checkName input.name
```
-->
<p>这两种人类情况不需要任何额外的工具：</p>
<pre><code class="language-lean">def checkHumanBefore1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  (checkYearIsNat input.birthYear).andThen fun y =&gt;
    .humanBefore1970 &lt;$&gt;
      checkSubtype y (fun x =&gt; x &gt; 999 ∧ x &lt; 1970) (&quot;birth year&quot;, &quot;less than 1970&quot;) &lt;*&gt;
      pure input.name

def checkHumanAfter1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  (checkYearIsNat input.birthYear).andThen fun y =&gt;
    .humanAfter1970 &lt;$&gt;
      checkSubtype y (· &gt; 1970) (&quot;birth year&quot;, &quot;greater than 1970&quot;) &lt;*&gt;
      checkName input.name
</code></pre>
<!--
The validators for the three cases can be combined using `<|>`:
```lean
def checkLegacyInput (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkCompany input <|> checkHumanBefore1970 input <|> checkHumanAfter1970 input
```
-->
<p>可以使用 <code>&lt;|&gt;</code> 将这三种情况的验证器组合在一起：</p>
<pre><code class="language-lean">def checkLegacyInput (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkCompany input &lt;|&gt; checkHumanBefore1970 input &lt;|&gt; checkHumanAfter1970 input
</code></pre>
<!--
The successful cases return constructors of `LegacyCheckedInput`, as expected:
```lean
#eval checkLegacyInput ⟨"Johnny's Troll Groomers", "FIRM"⟩
```
```output info
Validate.ok (LegacyCheckedInput.company "Johnny's Troll Groomers")
```
```lean
#eval checkLegacyInput ⟨"Johnny", "1963"⟩
```
```output info
Validate.ok (LegacyCheckedInput.humanBefore1970 1963 "Johnny")
```
```lean
#eval checkLegacyInput ⟨"", "1963"⟩
```
```output info
Validate.ok (LegacyCheckedInput.humanBefore1970 1963 "")
```
-->
<p>成功的情况会返回 <code>LegacyCheckedInput</code> 的构造子，正如预期的那样：</p>
<pre><code class="language-lean">#eval checkLegacyInput ⟨&quot;Johnny's Troll Groomers&quot;, &quot;FIRM&quot;⟩
</code></pre>
<pre><code class="language-output info">Validate.ok (LegacyCheckedInput.company &quot;Johnny's Troll Groomers&quot;)
</code></pre>
<pre><code class="language-lean">#eval checkLegacyInput ⟨&quot;Johnny&quot;, &quot;1963&quot;⟩
</code></pre>
<pre><code class="language-output info">Validate.ok (LegacyCheckedInput.humanBefore1970 1963 &quot;Johnny&quot;)
</code></pre>
<pre><code class="language-lean">#eval checkLegacyInput ⟨&quot;&quot;, &quot;1963&quot;⟩
</code></pre>
<pre><code class="language-output info">Validate.ok (LegacyCheckedInput.humanBefore1970 1963 &quot;&quot;)
</code></pre>
<!--
The worst possible input returns all the possible failures:
```lean
#eval checkLegacyInput ⟨"", "1970"⟩
```
```output info
Validate.errors
  { head := ("birth year", "FIRM if a company"),
    tail := [("name", "Required"),
             ("birth year", "less than 1970"),
             ("birth year", "greater than 1970"),
             ("name", "Required")] }
```
-->
<p>最糟糕的输入会返回所有可能的失败：</p>
<pre><code class="language-lean">#eval checkLegacyInput ⟨&quot;&quot;, &quot;1970&quot;⟩
</code></pre>
<pre><code class="language-output info">Validate.errors
  { head := (&quot;birth year&quot;, &quot;FIRM if a company&quot;),
    tail := [(&quot;name&quot;, &quot;Required&quot;),
             (&quot;birth year&quot;, &quot;less than 1970&quot;),
             (&quot;birth year&quot;, &quot;greater than 1970&quot;),
             (&quot;name&quot;, &quot;Required&quot;)] }
</code></pre>
<!--
## The `Alternative` Class
-->
<h2 id="alternative-类"><a class="header" href="#alternative-类"><code>Alternative</code> 类</a></h2>
<!--
Many types support a notion of failure and recovery.
The `Many` monad from the section on [evaluating arithmetic expressions in a variety of monads](../monads/arithmetic.md#nondeterministic-search) is one such type, as is `Option`.
Both support failure without providing a reason (unlike, say, `Except` and `Validate`, which require some indication of what went wrong).
-->
<p>许多类型都支持失败和恢复的概念。
<a href="../monads/arithmetic.html#nondeterministic-search">多种单子中对算术表达式的求值</a>小节中的 <code>Many</code> 单子就是其中的一种，<code>Option</code> 也是如此。
这两种类型都支持失败但不提供失败的原因的情况（不同于 <code>Except</code> 和 <code>Validate</code>，它们需要对出错的原因进行某些指示）。</p>
<!--
The `Alternative` class describes applicative functors that have additional operators for failure and recovery:
```lean
class Alternative (f : Type → Type) extends Applicative f where
  failure : f α
  orElse : f α → (Unit → f α) → f α
```
Just as implementors of `Add α` get `HAdd α α α` instances for free, implementors of `Alternative` get `OrElse` instances for free:
```lean
instance [Alternative f] : OrElse (f α) where
  orElse := Alternative.orElse
```
-->
<p><code>Alternative</code> 类描述了具有用于失败和恢复的附加运算符的应用函子：</p>
<pre><code class="language-lean">class Alternative (f : Type → Type) extends Applicative f where
  failure : f α
  orElse : f α → (Unit → f α) → f α
</code></pre>
<p>正如 <code>Add α</code> 的实现者可以免费获得 <code>HAdd α α α</code> 实例一样，<code>Alternative</code> 的实现者也可以免费获得 <code>OrElse</code> 实例：</p>
<pre><code class="language-lean">instance [Alternative f] : OrElse (f α) where
  orElse := Alternative.orElse
</code></pre>
<!--
The implementation of `Alternative` for `Option` keeps the first none-`none` argument:
```lean
instance : Alternative Option where
  failure := none
  orElse
    | some x, _ => some x
    | none, y => y ()
```
Similarly, the implementation for `Many` follows the general structure of `Many.union`, with minor differences due to the laziness-inducing `Unit` parameters being placed differently:
```lean
def Many.orElse : Many α → (Unit → Many α) → Many α
  | .none, ys => ys ()
  | .more x xs, ys => .more x (fun () => orElse (xs ()) ys)

instance : Alternative Many where
  failure := .none
  orElse := Many.orElse
```
-->
<p><code>Option</code> 的 <code>Alternative</code> 实现保留着第一个非 <code>none</code> 的参数：</p>
<pre><code class="language-lean">instance : Alternative Option where
  failure := none
  orElse
    | some x, _ =&gt; some x
    | none, y =&gt; y ()
</code></pre>
<p>同样，<code>Many</code> 的实现遵循着 <code>Many.union</code> 的一般结构，由于惰性诱导的 <code>Unit</code> 参数放置位置不同，它们仅在一些细节上有所差异：</p>
<pre><code class="language-lean">def Many.orElse : Many α → (Unit → Many α) → Many α
  | .none, ys =&gt; ys ()
  | .more x xs, ys =&gt; .more x (fun () =&gt; orElse (xs ()) ys)

instance : Alternative Many where
  failure := .none
  orElse := Many.orElse
</code></pre>
<!--
Like other type classes, `Alternative` enables the definition of a variety of operations that work for _any_ applicative functor that implements `Alternative`.
One of the most important is `guard`, which causes `failure` when a decidable proposition is false:
```lean
def guard [Alternative f] (p : Prop) [Decidable p] : f Unit :=
  if p then
    pure ()
  else failure
```
It is very useful in monadic programs to terminate execution early.
In `Many`, it can be used to filter out a whole branch of a search, as in the following program that computes all even divisors of a natural number:
```lean
def Many.countdown : Nat → Many Nat
  | 0 => .none
  | n + 1 => .more n (fun () => countdown n)

def evenDivisors (n : Nat) : Many Nat := do
  let k ← Many.countdown (n + 1)
  guard (k % 2 = 0)
  guard (n % k = 0)
  pure k
```
Running it on `20` yields the expected results:
```lean
#eval (evenDivisors 20).takeAll
```
```output info
[20, 10, 4, 2]
```
-->
<p>和其他类型类一样，<code>Alternative</code> 允许为实现了 <code>Alternative</code> 的 <strong>任意</strong> 应用函子定义各种操作。
其中最重要的是 <code>guard</code>，当一个可判定的命题为假时，它会导致 <code>failure</code>：</p>
<pre><code class="language-lean">def guard [Alternative f] (p : Prop) [Decidable p] : f Unit :=
  if p then
    pure ()
  else failure
</code></pre>
<p>在单子程序中，提前终止执行是非常有用的。
在 <code>Many</code> 中，它可以用来过滤掉搜索中的整个分支，如以下程序所示，该程序计算一个自然数的所有偶因数：</p>
<pre><code class="language-lean">def Many.countdown : Nat → Many Nat
  | 0 =&gt; .none
  | n + 1 =&gt; .more n (fun () =&gt; countdown n)

def evenDivisors (n : Nat) : Many Nat := do
  let k ← Many.countdown (n + 1)
  guard (k % 2 = 0)
  guard (n % k = 0)
  pure k
</code></pre>
<p>在 <code>20</code> 上运行它会产生预期的结果：</p>
<pre><code class="language-lean">#eval (evenDivisors 20).takeAll
</code></pre>
<pre><code class="language-output info">[20, 10, 4, 2]
</code></pre>
<!--
## Exercises
-->
<h2 id="练习题"><a class="header" href="#练习题">练习题</a></h2>
<!--
### Improve Validation Friendliness
-->
<h3 id="提高验证的友好性"><a class="header" href="#提高验证的友好性">提高验证的友好性</a></h3>
<!--
The errors returned from `Validate` programs that use `<|>` can be difficult to read, because inclusion in the list of errors simply means that the error can be reached through _some_ code path.
A more structured error report can be used to guide the user through the process more accurately:

 * Replace the `NonEmptyList` in `Validate.error` with a bare type variable, and then update the definitions of the `Applicative (Validate ε)` and `OrElse (Validate ε α)` instances to require only that there be an `Append ε` instance available.
 * Define a function `Validate.mapErrors : Validate ε α → (ε → ε') → Validate ε' α` that transforms all the errors in a validation run.
 * Using the datatype `TreeError` to represent errors, rewrite the legacy validation system to track its path through the three alternatives.
 * Write a function `report : TreeError → String` that outputs a user-friendly view of the `TreeError`'s accumulated warnings and errors.
 
```lean
inductive TreeError where
  | field : Field → String → TreeError
  | path : String → TreeError → TreeError
  | both : TreeError → TreeError → TreeError

instance : Append TreeError where
  append := .both
```
-->
<p>使用 <code>&lt;|&gt;</code> 的 <code>Validate</code> 程序返回的错误可能难以阅读，因为被包含在错误列表中仅意味着通过 <strong>某些</strong> 代码路径可以到达该错误。
可以使用更结构化的错误报告来更准确地指导用户完成这个过程：</p>
<ul>
<li>将 <code>Validate.error</code> 中的 <code>NonEmptyList</code> 替换为裸类型变量，然后更新 <code>Applicative (Validate ε)</code> 和 <code>OrElse (Validate ε α)</code> 实例的定义，以此来仅要求存在一个 <code>Append ε</code> 实例。</li>
<li>定义一个函数 <code>Validate.mapErrors : Validate ε α → (ε → ε') → Validate ε' α</code>，该函数会转换验证运行中的所有错误。</li>
<li>使用数据类型 <code>TreeError</code> 来表示错误，重写遗留验证系统，以通过三种选择子去追踪其路径。</li>
<li>编写一个函数 <code>report : TreeError → String</code>，该函数会输出 <code>TreeError</code> 的累计警告和错误的用户友好视图。</li>
</ul>
<pre><code class="language-lean">inductive TreeError where
  | field : Field → String → TreeError
  | path : String → TreeError → TreeError
  | both : TreeError → TreeError → TreeError

instance : Append TreeError where
  append := .both
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../functor-applicative-monad/applicative-contract.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../functor-applicative-monad/universes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../functor-applicative-monad/applicative-contract.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../functor-applicative-monad/universes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
