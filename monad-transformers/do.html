<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>更多 do 的特性 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构体和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的契约</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html" class="active"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/monad-transformers/do.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# More do Features
-->
<h1 id="更多-do-的特性"><a class="header" href="#更多-do-的特性">更多 do 的特性</a></h1>
<!--
Lean's `do`-notation provides a syntax for writing programs with monads that resembles imperative programming languages.
In addition to providing a convenient syntax for programs with monads, `do`-notation provides syntax for using certain monad transformers.
-->
<p>Lean 的 <code>do</code>-标记为使用单子编写程序提供了一种类似命令式编程语言的语法。
除了为使用单子的程序提供方便的语法外，<code>do</code>-标记还提供了使用某些单子转换器的语法。</p>
<!--
## Single-Branched `if`
-->
<h2 id="单分支-if"><a class="header" href="#单分支-if">单分支 <code>if</code></a></h2>
<!--
When working in a monad, a common pattern is to carry out a side effect only if some condition is true.
For instance, `countLetters` contains a check for vowels or consonants, and letters that are neither have no effect on the state.
This is captured by having the `else` branch evaluate to `pure ()`, which has no effects:
-->
<p>在单子中工作时，一种常见的模式是只有当某些条件为真时才执行副作用。
例如，<code>countLetters</code> 包含对元音或辅音的检查，而两者都不是的字母对状态没有影响。
通过将 <code>else</code> 分支设置为 <code>pure ()</code>，可以达成这一目的，因为 <code>pure ()</code> 不会产生任何影响：</p>
<pre><code class="language-lean">def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=
  let rec loop (chars : List Char) := do
    match chars with
    | [] =&gt; pure ()
    | c :: cs =&gt;
      if c.isAlpha then
        if vowels.contains c then
          modify fun st =&gt; {st with vowels := st.vowels + 1}
        else if consonants.contains c then
          modify fun st =&gt; {st with consonants := st.consonants + 1}
        else -- modified or non-English letter
          pure ()
      else throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<!--
When an `if` is a statement in a `do`-block, rather than being an expression, then `else pure ()` can simply be omitted, and Lean inserts it automatically.
The following definition of `countLetters` is completely equivalent:
-->
<p>如果 <code>if</code> 是一个 <code>do</code> 块中的语句，而不是一个表达式，那么 <code>else pure ()</code> 可以直接省略，Lean 会自动插入它。
下面的 <code>countLetters</code> 定义完全等价：</p>
<pre><code class="language-lean">def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=
  let rec loop (chars : List Char) := do
    match chars with
    | [] =&gt; pure ()
    | c :: cs =&gt;
      if c.isAlpha then
        if vowels.contains c then
          modify fun st =&gt; {st with vowels := st.vowels + 1}
        else if consonants.contains c then
          modify fun st =&gt; {st with consonants := st.consonants + 1}
      else throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<!--
A program that uses a state monad to count the entries in a list that satisfy some monadic check can be written as follows:
-->
<p>使用状态单子计算列表中满足某种单子检查的条目的程序，可以写成下面这样：</p>
<pre><code class="language-lean">def count [Monad m] [MonadState Nat m] (p : α → m Bool) : List α → m Unit
  | [] =&gt; pure ()
  | x :: xs =&gt; do
    if ← p x then
      modify (· + 1)
    count p xs
</code></pre>
<!--
Similarly, `if not E1 then STMT...` can instead be written `unless E1 do STMT...`.
The converse of `count` that counts entries that don't satisfy the monadic check can be written by replacing `if` with `unless`:
-->
<p>同样，<code>if not E1 then STMT...</code> 可以写成 <code>unless E1 do STMT...</code> 。
<code>count</code> 的相反（计算不满足单子检查的条目），的可以用 <code>unless</code> 代替 <code>if</code>：</p>
<pre><code class="language-lean">def countNot [Monad m] [MonadState Nat m] (p : α → m Bool) : List α → m Unit
  | [] =&gt; pure ()
  | x :: xs =&gt; do
    unless ← p x do
      modify (· + 1)
    countNot p xs
</code></pre>
<!--
Understanding single-branched `if` and `unless` does not require thinking about monad transformers.
They simply replace the missing branch with `pure ()`.
The remaining extensions in this section, however, require Lean to automatically rewrite the `do`-block to add a local transformer on top of the monad that the `do`-block is written in.
-->
<p>理解单分支的 <code>if</code> 和 <code>unless</code> 不需要考虑单子转换器。
它们只需用 <code>pure ()</code> 替换缺失的分支。
然而，本节中的其余扩展要求 Lean 自动重写 <code>do</code> 块，以便在写入 <code>do</code> 块的单子上添加一个局部转换器。</p>
<!--
## Early Return
-->
<h2 id="提前返回"><a class="header" href="#提前返回">提前返回</a></h2>
<!--
The standard library contains a function `List.find?` that returns the first entry in a list that satisfies some check.
A simple implementation that doesn't make use of the fact that `Option` is a monad loops over the list using a recursive function, with an `if` to stop the loop when the desired entry is found:
-->
<p>标准库中有一个函数 <code>List.find?</code>，用于返回列表中满足某些检查条件的第一个条目。
一个简单的实现并没有利用 <code>Option</code> 是一个单子的事实，而是使用一个递归函数在列表中循环，并使用 <code>if</code> 在找到所需条目时停止循环：</p>
<pre><code class="language-lean">def List.find? (p : α → Bool) : List α → Option α
  | [] =&gt; none
  | x :: xs =&gt;
    if p x then
      some x
    else
      find? p xs
</code></pre>
<!--
Imperative languages typically sport the `return` keyword that aborts the execution of a function, immediately returning some value to the caller.
In Lean, this is available in `do`-notation, and `return` halts the execution of a `do`-block, with `return`'s argument being the value returned from the monad.
In other words, `List.find?` could have been written like this:
-->
<p>命令式语言通常会使用 <code>return</code> 关键字来终止函数的执行，并立即将某个值返回给调用者。
在 Lean 中，这个关键字在 <code>do</code>-标记中可用，<code>return</code> 停止了一个 <code>do</code> 块的执行，且 <code>return</code> 的参数是从单子返回的值。
换句话说，<code>List.find?</code> 可以这样写：</p>
<pre><code class="language-lean">def List.find? (p : α → Bool) : List α → Option α
  | [] =&gt; failure
  | x :: xs =&gt; do
    if p x then return x
    find? p xs
</code></pre>
<!--
Early return in imperative languages is a bit like an exception that can only cause the current stack frame to be unwound.
Both early return and exceptions terminate execution of a block of code, effectively replacing the surrounding code with the thrown value.
Behind the scenes, early return in Lean is implemented using a version of `ExceptT`.
Each `do`-block that uses early return is wrapped in an exception handler (in the sense of the function `tryCatch`).
Early returns are translated to throwing the value as an exception, and the handlers catch the thrown value and return it immediately.
In other words, the `do`-block's original return value type is also used as the exception type.
-->
<p>在命令式语言中，提前返回有点像异常，只能导致当前堆栈帧被释放。
提前返回和异常都会终止代码块的执行，从而有效地用抛出的值替换周围的代码。
在后台，Lean 中的提前返回是使用 <code>ExceptT</code> 的一个版本实现的。
每个使用提前返回的 <code>do</code> 代码块都被包裹在异常处理程序中（在函数 <code>tryCatch</code> 的意义上）。
提前返回被转换为将值作为异常抛出，处理程序捕获抛出的值并立即返回。
换句话说，<code>do</code> 块的原始返回值类型也被用作异常类型。</p>
<!--
Making this more concrete, the helper function `runCatch` strips a layer of `ExceptT` from the top of a monad transformer stack when the exception type and return type are the same:
-->
<p>更具体地说，当异常类型和返回类型相同时，辅助函数 <code>runCatch</code> 会从单子转换器栈的顶部删除一层 <code>ExceptT</code> ：</p>
<pre><code class="language-lean">def runCatch [Monad m] (action : ExceptT α m α) : m α := do
  match ← action with
  | Except.ok x =&gt; pure x
  | Except.error x =&gt; pure x
</code></pre>
<!--
The `do`-block in `List.find?` that uses early return is translated to a `do`-block that does not use early return by wrapping it in a use of `runCatch`, and replacing early returns with `throw`:
-->
<p>将 <code>List.find?</code> 中使用提前返回的 <code>do</code> 块封装为使用 <code>runCatch</code> 的 <code>do</code> 块，并用 <code>throw</code> 代替提前返回，从而将其转换为不使用提前返回的 <code>do</code> 块：</p>
<pre><code class="language-lean">def List.find? (p : α → Bool) : List α → Option α
  | [] =&gt; failure
  | x :: xs =&gt;
    runCatch do
      if p x then throw x else pure ()
      monadLift (find? p xs)
</code></pre>
<!--
Another situation in which early return is useful is command-line applications that terminate early if the arguments or input are incorrect.
Many programs begin with a section that validates arguments and inputs before proceeding to the main body of the program.
The following version of [the greeting program `hello-name`](../hello-world/running-a-program.md) checks that no command-line arguments were provided:
-->
<p>提前返回有用的另一种情况是，如果参数或输入不正确，命令行应用程序会提前终止。
许多程序在进入主体部分之前，都会有一个验证参数和输入的部分。
以下版本的 <a href="../hello-world/running-a-program.html">问候程序 <code>hello-name</code></a> 会检查是否没有提供命令行参数：</p>
<pre><code class="language-lean">def main (argv : List String) : IO UInt32 := do
  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
  let stderr ← IO.getStderr

  unless argv == [] do
    stderr.putStrLn s!&quot;Expected no arguments, but got {argv.length}&quot;
    return 1

  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  stdout.flush

  let name := (← stdin.getLine).trim
  if name == &quot;&quot; then
    stderr.putStrLn s!&quot;No name provided&quot;
    return 1

  stdout.putStrLn s!&quot;Hello, {name}!&quot;

  return 0
</code></pre>
<!--
Running it with no arguments and typing the name `David` yields the same result as the previous version:
-->
<p>在不带参数的情况下运行该程序并输入姓名 <code>David</code>，得到的结果与前一版本相同：</p>
<pre><code>$ lean --run EarlyReturn.lean
How would you like to be addressed?
David
Hello, David!
</code></pre>
<!--
Providing the name as a command-line argument instead of an answer causes an error:
-->
<p>将名称作为命令行参数而不是答案提供会导致错误：</p>
<pre><code>$ lean --run EarlyReturn.lean David
Expected no arguments, but got 1
</code></pre>
<!--
And providing no name causes the other error:
-->
<p>不提供名字也会导致其他错误：</p>
<pre><code>$ lean --run EarlyReturn.lean
How would you like to be addressed?

No name provided
</code></pre>
<!--
The program that uses early return avoids needing to nest the control flow, as is done in this version that does not use early return:
-->
<p>使用提前返回的程序可以避免像下面这个不使用提前返回的版本一样嵌套控制流：</p>
<pre><code class="language-lean">def main (argv : List String) : IO UInt32 := do
  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
  let stderr ← IO.getStderr

  if argv != [] then
    stderr.putStrLn s!&quot;Expected no arguments, but got {argv.length}&quot;
    pure 1
  else
    stdout.putStrLn &quot;How would you like to be addressed?&quot;
    stdout.flush

    let name := (← stdin.getLine).trim
    if name == &quot;&quot; then
      stderr.putStrLn s!&quot;No name provided&quot;
      pure 1
    else
      stdout.putStrLn s!&quot;Hello, {name}!&quot;
      pure 0
</code></pre>
<!--
One important difference between early return in Lean and early return in imperative languages is that Lean's early return applies only to the current `do`-block.
When the entire definition of a function is in the same `do` block, this difference doesn't matter.
But if `do` occurs underneath some other structures, then the difference becomes apparent.
For example, given the following definition of `greet`:
-->
<p>Lean 中的提前返回与命令式语言中的提前返回之间的一个重要区别是，Lean 的提前返回仅适用于当前的 <code>do</code> 块。
当函数的整个定义都在同一个 <code>do</code> 块中时，这个区别并不重要。
但如果 <code>do</code> 出现在其他结构之下，那么这种差异就会变得很明显。
例如，下面这个 <code>greet</code> 的定义：</p>
<pre><code class="language-lean">def greet (name : String) : String :=
  &quot;Hello, &quot; ++ Id.run do return name
</code></pre>
<!--
the expression `greet "David"` evaluates to `"Hello, David"`, not just `"David"`.
-->
<p>表达式 <code>greet &quot;David&quot;</code> 被求值为 <code>&quot;Hello, David&quot;</code> ，而不只是 <code>&quot;David&quot;</code> 。</p>
<!--
## Loops
-->
<h2 id="循环"><a class="header" href="#循环">循环</a></h2>
<!--
Just as every program with mutable state can be rewritten to a program that passes the state as arguments, every loop can be rewritten as a recursive function.
From one perspective, `List.find?` is most clear as a recursive function.
After all, its definition mirrors the structure of the list: if the head passes the check, then it should be returned; otherwise look in the tail.
When no more entries remain, the answer is `none`.
From another perspective, `List.find?` is most clear as a loop.
After all, the program consults the entries in order until a satisfactory one is found, at which point it terminates.
If the loop terminates without having returned, the answer is `none`.
-->
<p>正如每个具有可变状态的程序都可以改写成将状态作为参数传递的程序一样，每个循环都可以改写成递归函数。
从某个角度看，<code>List.find?</code> 作为递归函数是最清晰不过的了。
毕竟，它的定义反映了列表的结构：如果头部通过了检查，那么就应该返回；否则就在尾部查找。
当没有条目时，答案就是 <code>none</code>。
从另一个角度看，<code>List.find?</code> 作为一个循环最为清晰。
毕竟，程序会按顺序查询条目，直到找到合适的条目，然后终止。
如果循环没有返回就终止了，那么答案就是 <code>none</code>。</p>
<!--
### Looping with ForM
-->
<h3 id="使用-form-循环"><a class="header" href="#使用-form-循环">使用 ForM 循环</a></h3>
<!--
Lean includes a type class that describes looping over a container type in some monad.
This class is called `ForM`:
-->
<p>Lean 包含一个类型类，用于描述在某个单子中对容器类型的循环。
这个类型类叫做 <code>ForM</code>：</p>
<pre><code class="language-lean">class ForM (m : Type u → Type v) (γ : Type w₁) (α : outParam (Type w₂)) where
  forM [Monad m] : γ → (α → m PUnit) → m PUnit
</code></pre>
<!--
This class is quite general.
The parameter `m` is a monad with some desired effects, `γ` is the collection to be looped over, and `α` is the type of elements from the collection.
Typically, `m` is allowed to be any monad, but it is possible to have a data structure that e.g. only supports looping in `IO`.
The method `forM` takes a collection, a monadic action to be run for its effects on each element from the collection, and is then responsible for running the actions.
-->
<p>该类型类非常通用。
参数 <code>m</code> 是一个具有某些预期作用的单子， <code>γ</code> 是要循环的集合，<code>α</code> 是集合中元素的类型。
通常情况下，<code>m</code> 可以是任何单子，但也可以是只支持在 <code>IO</code> 中循环的数据结构。
方法 <code>forM</code> 接收一个集合、一个要对集合中每个元素产生影响的单子操作，然后负责运行这些动作。</p>
<!--
The instance for `List` allows `m` to be any monad, it sets `γ` to be `List α`, and sets the class's `α` to be the same `α` found in the list:
-->
<p><code>List</code> 的实例允许 <code>m</code> 是任何单子，它将 <code>γ</code> 设置为 <code>List α</code>，并将类型类的 <code>α</code> 设置为列表中的 <code>α</code>：</p>
<pre><code class="language-lean">def List.forM [Monad m] : List α → (α → m PUnit) → m PUnit
  | [], _ =&gt; pure ()
  | x :: xs, action =&gt; do
    action x
    forM xs action

instance : ForM m (List α) α where
  forM := List.forM
</code></pre>
<!--
The [function `doList` from `doug`](reader-io.md#implementation) is `forM` for lists.
Because `forM` is intended to be used in `do`-blocks, it uses `Monad` rather than `Applicative`.
`forM` can be used to make `countLetters` much shorter:
-->
<p><a href="reader-io.html#implementation">来自 <code>doug</code> 的函数 <code>doList</code></a> 是针对列表的 <code>forM</code>。
由于 <code>forM</code> 的目的是在 <code>do</code> 块中使用，它使用了 <code>Monad</code> 而不是 <code>Applicative</code>。
使用 <code>forM</code> 可以使 <code>countLetters</code> 更短：</p>
<pre><code class="language-lean">def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=
  forM str.toList fun c =&gt; do
    if c.isAlpha then
      if vowels.contains c then
        modify fun st =&gt; {st with vowels := st.vowels + 1}
      else if consonants.contains c then
        modify fun st =&gt; {st with consonants := st.consonants + 1}
    else throw (.notALetter c)
</code></pre>
<!--
The instance for `Many` is very similar:
-->
<p><code>Many</code> 的实例也差不多：</p>
<pre><code class="language-lean">def Many.forM [Monad m] : Many α → (α → m PUnit) → m PUnit
  | Many.none, _ =&gt; pure ()
  | Many.more first rest, action =&gt; do
    action first
    forM (rest ()) action

instance : ForM m (Many α) α where
  forM := Many.forM
</code></pre>
<!--
Because `γ` can be any type at all, `ForM` can support non-polymorphic collections.
A very simple collection is one of the natural numbers less than some given number, in reverse order:
-->
<p>因为 <code>γ</code> 可以是任何类型，所以 <code>ForM</code> 可以支持非多态集合。
一个非常简单的集合是按相反顺序排列的小于某个给定数的自然数：</p>
<pre><code class="language-lean">structure AllLessThan where
  num : Nat
</code></pre>
<!--
Its `forM` operator applies the provided action to each smaller `Nat`:
-->
<p>它的 <code>forM</code> 操作符将给定的操作应用于每个更小的 <code>Nat</code>：</p>
<pre><code class="language-lean">def AllLessThan.forM [Monad m] (coll : AllLessThan) (action : Nat → m Unit) : m Unit :=
  let rec countdown : Nat → m Unit
    | 0 =&gt; pure ()
    | n + 1 =&gt; do
      action n
      countdown n
  countdown coll.num

instance : ForM m AllLessThan Nat where
  forM := AllLessThan.forM
</code></pre>
<!--
Running `IO.println` on each number less than five can be accomplished with `forM`:
-->
<p>在每个小于 5 的数字上运行 <code>IO.println</code> 可以用 <code>forM</code> 来实现：</p>
<pre><code class="language-lean">#eval forM { num := 5 : AllLessThan } IO.println
</code></pre>
<pre><code class="language-output info">4
3
2
1
0
</code></pre>
<!--
An example `ForM` instance that works only in a particular monad is one that loops over the lines read from an IO stream, such as standard input:
-->
<p>一个仅在特定单子中工作的 <code>ForM</code> 实例示例是，循环读取从 IO 流（如标准输入）获取的行：</p>
<pre><code class="language-lean">structure LinesOf where
  stream : IO.FS.Stream

partial def LinesOf.forM (readFrom : LinesOf) (action : String → IO Unit) : IO Unit := do
  let line ← readFrom.stream.getLine
  if line == &quot;&quot; then return ()
  action line
  forM readFrom action

instance : ForM IO LinesOf String where
  forM := LinesOf.forM
</code></pre>
<!--
The definition of `forM` is marked `partial` because there is no guarantee that the stream is finite.
In this case, `IO.FS.Stream.getLine` works only in the `IO` monad, so no other monad can be used for looping.
-->
<p><code>forM</code> 的定义被标记为 <code>partial</code> ，因为无法保证流是有限的。
在这种情况下，<code>IO.FS.Stream.getLine</code> 只在 <code>IO</code> 单子中起作用，因此不能使用其他单子进行循环。</p>
<!--
This example program uses this looping construct to filter out lines that don't contain letters:
-->
<p>本示例程序使用这种循环结构过滤掉不包含字母的行：</p>
<pre><code class="language-lean">def main (argv : List String) : IO UInt32 := do
  if argv != [] then
    IO.eprintln &quot;Unexpected arguments&quot;
    return 1

  forM (LinesOf.mk (← IO.getStdin)) fun line =&gt; do
    if line.any (·.isAlpha) then
      IO.print line

  return 0
</code></pre>
<!--
The file `test-data` contains:
-->
<p><code>test-data</code> 文件包含：</p>
<pre><code>Hello!
!!!!!
12345
abc123

Ok
</code></pre>
<!--
Invoking this program, which is stored in `ForMIO.lean`, yields the following output:
-->
<p>调用保存在 <code>ForMIO.lean</code> 的这个程序，产生如下输出：</p>
<pre><code>$ lean --run ForMIO.lean &lt; test-data
Hello!
abc123
Ok
</code></pre>
<!--
### Stopping Iteration
-->
<h3 id="中止循环"><a class="header" href="#中止循环">中止循环</a></h3>
<!--
Terminating a loop early is difficult to do with `forM`.
Writing a function that iterates over the `Nat`s in an `AllLessThan` only until `3` is reached requires a means of stopping the loop partway through.
One way to achieve this is to use `forM` with the `OptionT` monad transformer.
The first step is to define `OptionT.exec`, which discards information about both the return value and whether or not the transformed computation succeeded:
-->
<p>使用 <code>forM</code> 时很难提前终止循环。
要编写一个在 <code>AllLessThan</code> 中遍历 <code>Nat</code> 直到 <code>3</code> 的函数，就需要一种中途停止循环的方法。
实现这一点的方法之一是使用 <code>forM</code> 和 <code>OptionT</code> 单子转换器。
第一步是定义 <code>OptionT.exec</code>，它会丢弃有关返回值和转换计算是否成功的信息：</p>
<pre><code class="language-lean">def OptionT.exec [Applicative m] (action : OptionT m α) : m Unit :=
  action *&gt; pure ()
</code></pre>
<!--
Then, failure in the `OptionT` instance of `Alternative` can be used to terminate looping early:
-->
<p>然后，<code>Alternative</code> 的 <code>OptionT</code> 实例中的失败可以用来提前终止循环：</p>
<pre><code class="language-lean">def countToThree (n : Nat) : IO Unit :=
  let nums : AllLessThan := ⟨n⟩
  OptionT.exec (forM nums fun i =&gt; do
    if i &lt; 3 then failure else IO.println i)
</code></pre>
<!--
A quick test demonstrates that this solution works:
-->
<p>快速测试表明，这一解决方案是可行的：</p>
<pre><code class="language-lean">#eval countToThree 7
</code></pre>
<pre><code class="language-output info">6
5
4
3
</code></pre>
<!--
However, this code is not so easy to read.
Terminating a loop early is a common task, and Lean provides more syntactic sugar to make this easier.
This same function can also be written as follows:
-->
<p>然而，这段代码并不容易阅读。
提前终止循环是一项常见的任务，Lean 提供了更多语法糖来简化这项任务。
同样的函数也可以写成下面这样：</p>
<pre><code class="language-lean">def countToThree (n : Nat) : IO Unit := do
  let nums : AllLessThan := ⟨n⟩
  for i in nums do
    if i &lt; 3 then break
    IO.println i
</code></pre>
<!--
Testing it reveals that it works just like the prior version:
-->
<p>测试后发现，它用起来与之前的版本一样：</p>
<pre><code class="language-lean">#eval countToThree 7
</code></pre>
<pre><code class="language-output info">6
5
4
3
</code></pre>
<!--
At the time of writing, the `for ... in ... do ...` syntax desugars to the use of a type class called `ForIn`, which is a somewhat more complicated version of `ForM` that keeps track of state and early termination.
However, there is a plan to refactor `for` loops to use the simpler `ForM`, with monad transformers inserted as necessary.
In the meantime, an adapter is provided that converts a `ForM` instance into a `ForIn` instance, called `ForM.forIn`.
To enable `for` loops based on a `ForM` instance, add something like the following, with appropriate replacements for `AllLessThan` and `Nat`:
-->
<p>在撰写本文时，<code>for ... in ... do ...</code> 语法会解糖为使用一个名为 <code>ForIn</code> 的类型类，它是 <code>ForM</code> 的一个更为复杂的版本，可以跟踪状态和提前终止。
不过，我们计划重构 <code>for</code> 循环，使用更简单的 <code>ForM</code>，并在必要时插入单子转换器。
与此同时，我们还提供了一个适配器，可将 <code>ForM</code> 实例转换为 <code>ForIn</code> 实例，称为 <code>ForM.forIn</code>。
要启用基于 <code>ForM</code> 实例的 <code>for</code> 循环，请添加类似下面的内容，并适当替换 <code>AllLessThan</code> 和 <code>Nat</code>：</p>
<pre><code class="language-lean">instance : ForIn m AllLessThan Nat where
  forIn := ForM.forIn
</code></pre>
<!--
Note, however, that this adapter only works for `ForM` instances that keep the monad unconstrained, as most of them do.
This is because the adapter uses `StateT` and `ExceptT`, rather than the underlying monad.
-->
<p>但请注意，这个适配器只适用于保持无约束单子的 <code>ForM</code> 实例，大多数实例都是如此。
这是因为适配器使用的是 <code>StateT</code> 和 <code>ExceptT</code> 而不是底层单子。</p>
<!--
Early return is supported in `for` loops.
The translation of `do` blocks with early return into a use of an exception monad transformer applies equally well underneath `forM` as the earlier use of `OptionT` to halt iteration does.
This version of `List.find?` makes use of both:
-->
<p><code>for</code> 循环支持提前返回。
将提前返回的 <code>do</code> 块转换为异常单子转换器的使用，与之前使用 <code>OptionT</code> 来停止迭代一样，同样适用于 <code>forM</code> 循环。
这个版本的 <code>List.find?</code> 同时使用了这两种方法：</p>
<pre><code class="language-lean">def List.find? (p : α → Bool) (xs : List α) : Option α := do
  for x in xs do
    if p x then return x
  failure
</code></pre>
<!--
In addition to `break`, `for` loops support `continue` to skip the rest of the loop body in an iteration.
An alternative (but confusing) formulation of `List.find?` skips elements that don't satisfy the check:
-->
<p>除了 <code>break</code> 以外，<code>for</code> 循环还支持 <code>continue</code> 以在迭代中跳过循环体的其余部分。
<code>List.find?</code> 的另一种表述方式（但容易引起混淆）是跳过不满足检查条件的元素：</p>
<pre><code class="language-lean">def List.find? (p : α → Bool) (xs : List α) : Option α := do
  for x in xs do
    if not (p x) then continue
    return x
  failure
</code></pre>
<!--
A `Range` is a structure that consists of a starting number, an ending number, and a step.
They represent a sequence of natural numbers, from the starting number to the ending number, increasing by the step each time.
Lean has special syntax to construct ranges, consisting of square brackets, numbers, and colons that comes in four varieties.
The stopping point must always be provided, while the start and the step are optional, defaulting to `0` and `1`, respectively:
-->
<p><code>Range</code> 是一个由起始数、终止数和步长组成的结构。
它们代表一个自然数序列，从起始数到终止数，每次增加一个步长。
Lean 有特殊的语法来构造范围，由方括号、数字和冒号组成，有四种类型。
必须始终提供终止数，而起始数和步长是可选的，默认值分别为 <code>0</code> 和 <code>1</code>：</p>
<!--
| Expression | Start      | Stop       | Step | As List |
|------------|------------|------------|------|---------|
| `[:10]` | `0` | `10` | `1` | `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]` |
| `[2:10]` | `2` | `10` | `1` | `[2, 3, 4, 5, 6, 7, 8, 9]` |
| `[:10:3]` | `0` | `10` | `3` | `[0, 3, 6, 9]` |
| `[2:10:3]` | `2` | `10` | `3` | `[2, 5, 8]` |
-->
<table><thead><tr><th>表达式</th><th>起始数</th><th>终止数</th><th>步长</th><th>转化为列表</th></tr></thead><tbody>
<tr><td><code>[:10]</code></td><td><code>0</code></td><td><code>10</code></td><td><code>1</code></td><td><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></td></tr>
<tr><td><code>[2:10]</code></td><td><code>2</code></td><td><code>10</code></td><td><code>1</code></td><td><code>[2, 3, 4, 5, 6, 7, 8, 9]</code></td></tr>
<tr><td><code>[:10:3]</code></td><td><code>0</code></td><td><code>10</code></td><td><code>3</code></td><td><code>[0, 3, 6, 9]</code></td></tr>
<tr><td><code>[2:10:3]</code></td><td><code>2</code></td><td><code>10</code></td><td><code>3</code></td><td><code>[2, 5, 8]</code></td></tr>
</tbody></table>
<!--
Note that the starting number _is_ included in the range, while the stopping numbers is not.
All three arguments are `Nat`s, which means that ranges cannot count down—a range where the starting number is greater than or equal to the stopping number simply contains no numbers.
-->
<p>请注意，起始数 <em>包含</em> 在范围内，而终止数不包含在范围内。
所有三个参数都是 <code>Nat</code>，这意味着范围不能向下计数 —— 当起始数大于或等于终止数时，范围中就不包含任何数字。</p>
<!--
Ranges can be used with `for` loops to draw numbers from the range.
This program counts even numbers from four to eight:
-->
<p>范围可与 <code>for</code> 循环一起使用，从范围中抽取数字。
该程序将偶数从 4 数到 8：</p>
<pre><code class="language-lean">def fourToEight : IO Unit := do
  for i in [4:9:2] do
    IO.println i
</code></pre>
<!--
Running it yields:
-->
<p>运行它会输出：</p>
<pre><code class="language-output info">4
6
8
</code></pre>
<!--
Finally, `for` loops support iterating over multiple collections in parallel, by separating the `in` clauses with commas.
Looping halts when the first collection runs out of elements, so the declaration:
-->
<p>最后，<code>for</code> 循环支持并行迭代多个集合，方法是用逗号分隔 <code>in</code> 子句。
当第一个集合中的元素用完时，循环就会停止，因此定义：</p>
<pre><code class="language-lean">def parallelLoop := do
  for x in [&quot;currant&quot;, &quot;gooseberry&quot;, &quot;rowan&quot;], y in [4:8] do
    IO.println (x, y)
</code></pre>
<!--
produces three lines of output:
-->
<p>产生如下输出：</p>
<pre><code class="language-lean">#eval parallelLoop
</code></pre>
<pre><code class="language-output info">(currant, 4)
(gooseberry, 5)
(rowan, 6)
</code></pre>
<!--
## Mutable Variables
-->
<h2 id="可变变量"><a class="header" href="#可变变量">可变变量</a></h2>
<!--
In addition to early `return`, `else`-less `if`, and `for` loops, Lean supports local mutable variables within a `do` block.
Behind the scenes, these mutable variables desugar to a use of `StateT`, rather than being implemented by true mutable variables.
Once again, functional programming is used to simulate imperative programming.
-->
<p>除了提前 <code>return</code>、无 <code>if</code> 的 <code>else</code> 和 <code>for</code> 循环之外，Lean 还支持在 <code>do</code> 代码块中使用局部可变变量。
在后台，这些可变变量是通过使用 <code>StateT</code> 来实现的，而不是通过真正的可变变量来实现。
函数式编程再次被用来模拟命令式编程。</p>
<!--
A local mutable variable is introduced with `let mut` instead of plain `let`.
The definition `two`, which uses the identity monad `Id` to enable `do`-syntax without introducing any effects, counts to `2`:
-->
<p>使用 <code>let mut</code> 而不是普通的 <code>let</code> 来引入局部可变变量。
定义 <code>two</code> 使用恒等单子 <code>Id</code> 来启用 <code>do</code> 语法，但不引入任何副作用，计数到 <code>2</code>：</p>
<pre><code class="language-lean">def two : Nat := Id.run do
  let mut x := 0
  x := x + 1
  x := x + 1
  return x
</code></pre>
<!--
This code is equivalent to a definition that uses `StateT` to add `1` twice:
-->
<p>这段代码等同于使用 <code>StateT</code> 添加两次 <code>1</code> 的定义：</p>
<pre><code class="language-lean">def two : Nat :=
  let block : StateT Nat Id Nat := do
    modify (· + 1)
    modify (· + 1)
    return (← get)
  let (result, _finalState) := block 0
  result
</code></pre>
<!--
Local mutable variables work well with all the other features of `do`-notation that provide convenient syntax for monad transformers.
The definition `three` counts the number of entries in a three-entry list:
-->
<p>局部可变变量与 <code>do</code>-标记的所有其他特性配合得很好，这些特性为单子转换器提供了方便的语法。
定义 <code>three</code> 计算一个三条目列表中的条目数：</p>
<pre><code class="language-lean">def three : Nat := Id.run do
  let mut x := 0
  for _ in [1, 2, 3] do
    x := x + 1
  return x
</code></pre>
<!--
Similarly, `six` adds the entries in a list:
-->
<p>同样，<code>six</code> 将条目添加到一个列表中：</p>
<pre><code class="language-lean">def six : Nat := Id.run do
  let mut x := 0
  for y in [1, 2, 3] do
    x := x + y
  return x
</code></pre>
<!--
`List.count` counts the number of entries in a list that satisfy some check:
-->
<p><code>List.count</code> 计算列表中满足某些检查条件的条目的数量：</p>
<pre><code class="language-lean">def List.count (p : α → Bool) (xs : List α) : Nat := Id.run do
  let mut found := 0
  for x in xs do
    if p x then found := found + 1
  return found
</code></pre>
<!--
Local mutable variables can be more convenient to use and easier to read than an explicit local use of `StateT`.
However, they don't have the full power of unrestricted mutable variables from imperative languages.
In particular, they can only be modified in the `do`-block in which they are introduced.
This means, for instance, that `for`-loops can't be replaced by otherwise-equivalent recursive helper functions.
This version of `List.count`:
-->
<p>局部可变变量比局部显式使用 <code>StateT</code> 更方便，也更易于阅读。
然而，它们并不具备命令式语言中无限制的可变变量的全部功能。
特别是，它们只能在引入它们的 <code>do</code> 块中被修改。
例如，这意味着 <code>for</code> 循环不能被其他等价的递归辅助函数所替代。
该版本的 <code>List.count</code>：</p>
<pre><code class="language-lean">def List.count (p : α → Bool) (xs : List α) : Nat := Id.run do
  let mut found := 0
  let rec go : List α → Id Unit
    | [] =&gt; pure ()
    | y :: ys =&gt; do
      if p y then found := found + 1
      go ys
  return found
</code></pre>
<!--
yields the following error on the attempted mutation of `found`:
-->
<p>在尝试修改 <code>found</code> 时产生以下错误：</p>
<pre><code class="language-output info">`found` cannot be mutated, only variables declared using `let mut` can be mutated. If you did not intent to mutate but define `found`, consider using `let found` instead
</code></pre>
<!--
This is because the recursive function is written in the identity monad, and only the monad of the `do`-block in which the variable is introduced is transformed with `StateT`.
-->
<p>这是因为递归函数是用恒等单子编写的，只有引入变量的 <code>do</code> 块的单子才会被 <code>StateT</code> 转换。</p>
<!--
## What counts as a `do` block?
-->
<h2 id="什么算作-do-区块"><a class="header" href="#什么算作-do-区块">什么算作 <code>do</code> 区块？</a></h2>
<!--
Many features of `do`-notation apply only to a single `do`-block.
Early return terminates the current block, and mutable variables can only be mutated in the block that they are defined in.
To use them effectively, it's important to know what counts as "the same block".
-->
<p><code>do</code>-标记的许多特性只适用于单个 <code>do</code> 块。
提前返回会终止当前代码块，可变变量只能在其定义的代码块中被改变。
要有效地使用它们，了解什么是 “同一代码块” 尤为重要。</p>
<!--
Generally speaking, the indented block following the `do` keyword counts as a block, and the immediate sequence of statements underneath it are part of that block.
Statements in independent blocks that are nonetheless contained in a block are not considered part of the block.
However, the rules that govern what exactly counts as the same block are slightly subtle, so some examples are in order.
The precise nature of the rules can be tested by setting up a program with a mutable variable and seeing where the mutation is allowed.
This program has a mutation that is clearly in the same block as the mutable variable:
-->
<p>一般来说，<code>do</code> 关键字后的缩进块算作一个块，其下的语句序列是该块的一部分。
独立代码块中的语句如果包含在另一个代码块中，则不被视为该独立代码块的一部分。
不过，关于哪些语句属于同一代码块的规则略有微妙，因此需要举例说明。
可以通过设置一个带有可变变量的程序来测试规则的精确性，并查看允许修改的地方。
这个程序中的允许可变的区域显然与可变变量位于同一快中：</p>
<pre><code class="language-lean">example : Id Unit := do
  let mut x := 0
  x := x + 1
</code></pre>
<!--
When a mutation occurs in a `do`-block that is part of a `let`-statement that defines a name using `:=`, then it is not considered to be part of the block:
-->
<p>如果变化发生在使用 <code>:=</code> 定义名称的 <code>let</code> 语句的一部分的 <code>do</code> 块中，则它不被视为该块的一部分：</p>
<pre><code class="language-lean">example : Id Unit := do
  let mut x := 0
  let other := do
    x := x + 1
  other
</code></pre>
<pre><code class="language-output error">`x` cannot be mutated, only variables declared using `let mut` can be mutated. If you did not intent to mutate but define `x`, consider using `let x` instead
</code></pre>
<!--
However, a `do`-block that occurs under a `let`-statement that defines a name using `←` is considered part of the surrounding block.
The following program is accepted:
-->
<p>但是，在 <code>let</code> 语句下，使用 <code>←</code> 定义名称的 <code>do</code> 块被视为周围块的一部分。
以下程序是可以接受的：</p>
<pre><code class="language-lean">example : Id Unit := do
  let mut x := 0
  let other ← do
    x := x + 1
  pure other
</code></pre>
<!--
Similarly, `do`-blocks that occur as arguments to functions are independent of their surrounding blocks.
The following program is not accepted:
-->
<p>同样，作为函数参数出现的 <code>do</code> 块与周围的块无关。
以下程序并不合理：</p>
<pre><code class="language-lean">example : Id Unit := do
  let mut x := 0
  let addFour (y : Id Nat) := Id.run y + 4
  addFour do
    x := 5
</code></pre>
<pre><code class="language-output error">`x` cannot be mutated, only variables declared using `let mut` can be mutated. If you did not intent to mutate but define `x`, consider using `let x` instead
</code></pre>
<!--
If the `do` keyword is completely redundant, then it does not introduce a new block.
This program is accepted, and is equivalent to the first one in this section:
-->
<p>如果 <code>do</code> 关键字完全是多余的，那么它就不会引入一个新的程序块。
这个程序可以接受，等同于本节的第一个程序：</p>
<pre><code class="language-lean">example : Id Unit := do
  let mut x := 0
  do x := x + 1
</code></pre>
<!--
The contents of branches under a `do` (such as those introduced by `match` or `if`) are considered to be part of the surrounding block, whether or not a redundant `do` is added.
The following programs are all accepted:
-->
<p>无论是否添加了多余的 <code>do</code> ，<code>do</code> 下的分支内容（例如由 <code>match</code> 或 <code>if</code> 引入的分支）都被视为周围程序块的一部分。
以下程序均可接受：</p>
<pre><code class="language-lean">example : Id Unit := do
  let mut x := 0
  if x &gt; 2 then
    x := x + 1

example : Id Unit := do
  let mut x := 0
  if x &gt; 2 then do
    x := x + 1

example : Id Unit := do
  let mut x := 0
  match true with
  | true =&gt; x := x + 1
  | false =&gt; x := 17

example : Id Unit := do
  let mut x := 0
  match true with
  | true =&gt; do
    x := x + 1
  | false =&gt; do
    x := 17
</code></pre>
<!--
Similarly, the `do` that occurs as part of the `for` and `unless` syntax is just part of their syntax, and does not introduce a fresh `do`-block.
These programs are also accepted:
-->
<p>同样，作为 <code>for</code> 和 <code>unless</code> 语法的一部分出现的 <code>do</code> 只是其语法的一部分，并不引入新的 <code>do</code> 块。
这些程序也被接受：</p>
<pre><code class="language-lean">example : Id Unit := do
  let mut x := 0
  for y in [1:5] do
   x := x + y

example : Id Unit := do
  let mut x := 0
  unless 1 &lt; 5 do
    x := x + 1
</code></pre>
<!--
## Imperative or Functional Programming?
-->
<h2 id="命令式还是函数式编程"><a class="header" href="#命令式还是函数式编程">命令式还是函数式编程？</a></h2>
<!--
The imperative features provided by Lean's `do`-notation allow many programs to very closely resemble their counterparts in languages like Rust, Java, or C#.
This resemblance is very convenient when translating an imperative algorithm into Lean, and some tasks are just most naturally thought of imperatively.
The introduction of monads and monad transformers enables imperative programs to be written in purely functional languages, and `do`-notation as a specialized syntax for monads (potentially locally transformed) allows functional programmers to have the best of both worlds: the strong reasoning principles afforded by immutability and a tight control over available effects through the type system are combined with syntax and libraries that allow programs that use effects to look familiar and be easy to read.
Monads and monad transformers allow functional versus imperative programming to be a matter of perspective.
-->
<p>Lean 的 <code>do</code>-标记提供的命令式特性让许多程序与 Rust、Java 或 C# 等语言中的对应程序非常相似。
在将命令式算法转化为 Lean 的算法时，这种相似性非常方便，而且有些任务可以很自然地以命令式的方式进行思考。
单子和单子转换器的引入使得命令式程序可以用纯函数式语言编写，而作为单子（可能是局部转换的）专用语法的 <code>do</code>-标记则让函数式程序员获得了两全其美的结果：不变性提供了强大的推理原则，通过类型系统对可用作用进行了严格控制，同时还结合了语法和库，使得具有副作用的程序看起来熟悉且易于阅读。
单子和单子转换器让函数式编程与命令式编程成为一个视角问题。</p>
<!--
## Exercises
-->
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<!--
* Rewrite `doug` to use `for` instead of the `doList` function. Are there other opportunities to use the features introduced in this section to improve the code? If so, use them!
-->
<ul>
<li>重写 <code>doug</code> 以使用 <code>for</code> 代替 <code>doList</code> 函数。是否还有其他机会使用本节介绍的功能来改进代码？如果有，请使用它们！</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../monad-transformers/order.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../monad-transformers/conveniences.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../monad-transformers/order.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../monad-transformers/conveniences.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
