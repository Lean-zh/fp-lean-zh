<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数组与索引 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html" class="active"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">接下来做什么</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/type-classes/indexing.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Arrays and Indexing
-->
<h1 id="数组与索引"><a class="header" href="#数组与索引">数组与索引</a></h1>
<!--
The [Interlude](../props-proofs-indexing.md) describes how to use indexing notation in order to look up entries in a list by their position.
This syntax is also governed by a type class, and it can be used for a variety of different types.
-->
<p>在<a href="../props-proofs-indexing.html">插入章节</a>中描述了如何使用索引符号来通过位置查找列表中的条目。
此语法也由类型类管理，并且可以用于各种不同的类型。</p>
<!--
## Arrays
-->
<h2 id="数组"><a class="header" href="#数组">数组</a></h2>
<!--
For instance, Lean arrays are much more efficient than linked lists for most purposes.
In Lean, the type `Array α` is a dynamically-sized array holding values of type `α`, much like a Java `ArrayList`, a C++ `std::vector`, or a Rust `Vec`.
Unlike `List`, which has a pointer indirection on each use of the `cons` constructor, arrays occupy a contiguous region of memory, which is much better for processor caches.
Also, looking up a value in an array takes constant time, while lookup in a linked list takes time proportional to the index being accessed.
-->
<p>比如说，Lean 中的数组在多数情况下就比链表更为高效。在 Lean 中，<code>Array α</code> 类型是一个动态大小的数组，可以用来装类型为 <code>α</code> 的值。
这很像是 Java 中的 <code>ArrayList</code>，C++ 中的 <code>std::vector</code>，或者 Rust 中的 <code>Vec</code>。
不像是 <code>List</code> 在每一次用到 <code>cons</code> 构造子的地方都会有一个指针指向每个节点，数组会占用内存中一段连续的空间。这会带来更好的处理器缓存效果。
并且，在数组中查找值的时间复杂度为常数，但在链表中查找值所需要的时间则与遍历的节点数量成正比。</p>
<!--
In pure functional languages like Lean, it is not possible to mutate a given position in a data structure.
Instead, a copy is made that has the desired modifications.
When using an array, the Lean compiler and runtime contain an optimization that can allow modifications to be implemented as mutations behind the scenes when there is only a single unique reference to an array.
-->
<p>在像 Lean 这样的纯函数式语言中，在数据结构中改变某位置上的数据的值是不可能的。
相反，Lean 会制作一个副本，该副本具有所需的修改。
当使用一个数组时，Lean 编译器和运行时包含了一个优化：当该数组只被引用了一次时，会在幕后将制作副本优化为原地操作。</p>
<!--
Arrays are written similarly to lists, but with a leading `#`:
-->
<p>数组写起来很像列表，只是在开头多了一个 <code>#</code>：</p>
<pre><code class="language-lean">def northernTrees : Array String :=
  #[&quot;sloe&quot;, &quot;birch&quot;, &quot;elm&quot;, &quot;oak&quot;]
</code></pre>
<!--
The number of values in an array can be found using `Array.size`.
For instance, `northernTrees.size` evaluates to `4`.
For indices that are smaller than an array's size, indexing notation can be used to find the corresponding value, just as with lists.
That is, `northernTrees[2]` evaluates to `"elm"`.
Similarly, the compiler requires a proof that an index is in bounds, and attempting to look up a value outside the bounds of the array results in a compile-time error, just as with lists.
For instance, `northernTrees[8]` results in:
-->
<p>数组中值的数量可以通过 <code>Array.size</code> 找到。
例如：<code>northernTrees.size</code> 结果是 <code>4</code>。
对于小于数组大小的索引值，索引符号可以被用来找到对应的值，就像列表一样。
就是说，<code>northernTrees[2]</code> 会被计算为 <code>&quot;elm&quot;</code>。
类似地，编译器需要一个索引值未越界的证明。尝试去查找越界的值会导致编译时错误，就和列表一样。
例如：<code>northernTrees[8]</code> 的结果为：</p>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ 8 &lt; Array.size northernTrees
</code></pre>
<!--
## Non-Empty Lists
-->
<h2 id="非空列表"><a class="header" href="#非空列表">非空列表</a></h2>
<!--
A datatype that represents non-empty lists can be defined as a structure with a field for the head of the list and a field for the tail, which is an ordinary, potentially empty list:
-->
<p>一个表示非空列表的数据类型可以被定义为一个结构，这个结构有一个列表头字段，和一个尾字段。尾字段是一个常规的，可能为空的列表。</p>
<pre><code class="language-lean">structure NonEmptyList (α : Type) : Type where
  head : α
  tail : List α
</code></pre>
<!--
For example, the non-empty list `idahoSpiders` (which contains some spider species native to the US state of Idaho) consists of `"Banded Garden Spider"` followed by four other spiders, for a total of five spiders:
-->
<p>例如：非空列表 <code>idahoSpiders</code>（包含了一些美国爱达荷州的本土蜘蛛品种）由 <code>&quot;Banded Garden Spider&quot;</code> 和四种其它蜘蛛构成，一共有五种蜘蛛：</p>
<pre><code class="language-lean">def idahoSpiders : NonEmptyList String := {
  head := &quot;Banded Garden Spider&quot;,
  tail := [
    &quot;Long-legged Sac Spider&quot;,
    &quot;Wolf Spider&quot;,
    &quot;Hobo Spider&quot;,
    &quot;Cat-faced Spider&quot;
  ]
}
</code></pre>
<!--
Looking up the value at a specific index in this list with a recursive function should consider three possibilities:
 1. The index is `0`, in which case the head of the list should be returned.
 2. The index is `n + 1` and the tail is empty, in which case the index is out of bounds.
 3. The index is `n + 1` and the tail is non-empty, in which case the function can be called recursively on the tail and `n`.
-->
<p>通过递归函数在列表中查找特定索引的值需要考虑到三种情况：</p>
<ol>
<li>索引是 <code>0</code>，此时应返回列表头。</li>
<li>索引是 <code>n + 1</code> 并且列表尾是空的，这意味着索引越界了。</li>
<li>索引是 <code>n + 1</code> 并且列表尾非空，此时应该在列表尾上递归调用函数并传入 <code>n</code>。</li>
</ol>
<!--
For example, a lookup function that returns an `Option` can be written as follows:
-->
<p>例如，一个返回 <code>Option</code> 的查找函数可以写成如下形式：</p>
<pre><code class="language-lean">def NonEmptyList.get? : NonEmptyList α → Nat → Option α
  | xs, 0 =&gt; some xs.head
  | {head := _, tail := []}, _ + 1 =&gt; none
  | {head := _, tail := h :: t}, n + 1 =&gt; get? {head := h, tail := t} n
</code></pre>
<!--
Each case in the pattern match corresponds to one of the possibilities above.
The recursive call to `get?` does not require a `NonEmptyList` namespace qualifier because the body of the definition is implicitly in the definition's namespace.
Another way to write this function uses `get?` for lists when the index is greater than zero:
-->
<p>每种模式匹配的情况都对应于上面的一种可能性。
<code>get?</code> 的递归调用不需要 <code>NonEmptyList</code> 命名空间标识符，因为定义内部隐式地在定义的命名空间中。
另一种方式来编写这个函数是：当索引大于零时就将 <code>get?</code> 应用在列表上。</p>
<pre><code class="language-lean">def NonEmptyList.get? : NonEmptyList α → Nat → Option α
  | xs, 0 =&gt; some xs.head
  | xs, n + 1 =&gt; xs.tail.get? n
</code></pre>
<!--
If the list contains one entry, then only `0` is a valid index.
If it contains two entries, then both `0` and `1` are valid indices.
If it contains three entries, then `0`, `1`, and `2` are valid indices.
In other words, the valid indices into a non-empty list are natural numbers that are strictly less than the length of the list, which are less than or equal to the length of the tail.
-->
<p>如果列表包含一个条目，那么只有 <code>0</code> 是合法的索引。
如果它包含两个条目，那么 <code>0</code> 和 <code>1</code> 是合法的索引。
如果它包含三个条目，那么 <code>0</code>, <code>1</code>, 和 <code>2</code> 都是合法的索引。
换句话说，非空列表的合法索引是严格小于列表长度的自然数。同时它也是小于等于列表尾的长度的。</p>
<!--
The definition of what it means for an index to be in bounds should be written as an `abbrev` because the tactics used to find evidence that indices are acceptable are able to solve inequalities of numbers, but they don't know anything about the name `NonEmptyList.inBounds`:
-->
<p>“索引值没有出界”意味着什么的这个定义，应该被写成一个 <code>abbrev</code>。
因为这个可以用来证明索引值未越界的策略（tactics）要在不知道 <code>NonEmptyList.inBounds</code> 这个方法的情况下解决数字之间的不等关系。
(此处原文表意不明，按原文字面意思译出。原文大致意思应为 <code>abbrev</code> 比 <code>def</code> 对tactic的适应性更好)</p>
<pre><code class="language-lean">abbrev NonEmptyList.inBounds (xs : NonEmptyList α) (i : Nat) : Prop :=
  i ≤ xs.tail.length
</code></pre>
<!--
This function returns a proposition that might be true or false.
For instance, `2` is in bounds for `idahoSpiders`, while `5` is not:
-->
<!--
This function returns a proposition that might be true or false.
For instance, `2` is in bounds for `idahoSpiders`, while `5` is not:
-->
<p>这个函数返回一个可能为真也可能为假的命题。
例如，<code>2</code> 对于 <code>idahoSpiders</code>未越界，而 <code>5</code> 就越界了。</p>
<pre><code class="language-leantac">theorem atLeastThreeSpiders : idahoSpiders.inBounds 2 := by simp

theorem notSixSpiders : ¬idahoSpiders.inBounds 5 := by simp
</code></pre>
<!--
The logical negation operator has a very low precedence, which means that `¬idahoSpiders.inBounds 5` is equivalent to `¬(idahoSpiders.inBounds 5)`.
-->
<p>逻辑非运算符有很低的结合度，这意味着 <code>¬idahoSpiders.inBounds 5</code> 等价于 <code>¬(idahoSpiders.inBounds 5)</code>。</p>
<!--
This fact can be used to write a lookup function that requires evidence that the index is valid, and thus need not return `Option`, by delegating to the version for lists that checks the evidence at compile time:
-->
<p>这个事实可被用于编写能证明索引值合法的查找函数，并且无需返回一个 <code>Option</code>。
该证据会在编译时检查。下面给出代码：</p>
<pre><code class="language-lean">def NonEmptyList.get (xs : NonEmptyList α) (i : Nat) (ok : xs.inBounds i) : α :=
  match i with
  | 0 =&gt; xs.head
  | n + 1 =&gt; xs.tail[n]
</code></pre>
<!--
It is, of course, possible to write this function to use the evidence directly, rather than delegating to a standard library function that happens to be able to use the same evidence.
This requires techniques for working with proofs and propositions that are described later in this book.
-->
<p>当然，将这个函数写成直接用证据的形式也是可能的。
但这需要会玩证明和命题的一些技术，这些内容会在本书后续内容中提到。</p>
<!--
## Overloading Indexing
-->
<h2 id="重载索引"><a class="header" href="#重载索引">重载索引</a></h2>
<!--
Indexing notation for a collection type can be overloaded by defining an instance of the `GetElem` type class.
For the sake of flexiblity, `GetElem` has four parameters:
 * The type of the collection
 * The type of the index
 * The type of elements that are extracted from the collection
 * A function that determines what counts as evidence that the index is in bounds
-->
<p>对于集合类型的索引符号，可通过定义 <code>GetElem</code> 类型类的实例来重载。
出于灵活性考虑，<code>GetElem</code> 有四个参数：</p>
<ul>
<li>集合的类型</li>
<li>索引的类型</li>
<li>集合中元素的类型</li>
<li>一个函数，用于确定什么是索引在边界内的证据</li>
</ul>
<!--
The element type and the evidence function are both output parameters.
`GetElem` has a single method, `getElem`, which takes a collection value, an index value, and evidence that the index is in bounds as arguments, and returns an element:
-->
<p>元素类型和证明函数都是输出参数。
<code>GetElem</code> 有一个方法 —— <code>getElem</code> —— 接受一个集合值，一个索引值，和一个索引未越界的证明，并且返回一个元素：</p>
<pre><code class="language-lean">class GetElem (coll : Type) (idx : Type) (item : outParam Type) (inBounds : outParam (coll → idx → Prop)) where
  getElem : (c : coll) → (i : idx) → inBounds c i → item
</code></pre>
<!--
In the case of `NonEmptyList α`, these parameters are:
 * The collection is `NonEmptyList α`
 * Indices have type `Nat`
 * The type of elements is `α`
 * An index is in bounds if it is less than or equal to the length of the tail
-->
<p>在 <code>NonEmptyList α</code> 中，这些参数是：</p>
<ul>
<li>集合是 <code>NonEmptyList α</code></li>
<li>索引的类型是 <code>Nat</code></li>
<li>元素的类型是 <code>α</code></li>
<li>索引如果小于等于列表尾那么就没有越界</li>
</ul>
<!--
In fact, the `GetElem` instance can delegate directly to `NonEmptyList.get`:
-->
<p>事实上，<code>GetElem</code> 实例可以直接使用 <code>NonEmptyList.get</code>：</p>
<pre><code class="language-lean">instance : GetElem (NonEmptyList α) Nat α NonEmptyList.inBounds where
  getElem := NonEmptyList.get
</code></pre>
<!--
With this instance, `NonEmptyList` becomes just as convenient to use as `List`.
Evaluating `idahoSpiders[0]` yields `"Banded Garden Spider"`, while `idahoSpiders[9]` leads to the compile-time error:
-->
<p>有了这个实例，<code>NonEmptyList</code> 就和 <code>List</code> 一样方便了。
计算 <code>idahoSpiders[0]</code> 结果为 <code>&quot;Banded Garden Spider&quot;</code>，而 <code>idahoSpiders[9]</code> 会导致编译时错误：</p>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ NonEmptyList.inBounds idahoSpiders 9
</code></pre>
<!--
Because both the collection type and the index type are input parameters to the `GetElem` type class, new types can be used to index into existing collections.
The positive number type `Pos` is a perfectly reasonable index into a `List`, with the caveat that it cannot point at the first entry.
The follow instance of `GetElem` allows `Pos` to be used just as conveniently as `Nat` to find a list entry:
-->
<p>因为集合的类型和索引的类型都是 <code>GetElem</code> 类型类的参数，所以可以使用新类型来索引现有的集合。
之前的 <code>Pos</code> 是一个完全合理的可以用来索引 <code>List</code> 的类型，但注意它不能指向第一个条目。
下面 <code>GetElem</code> 的实例使 <code>Pos</code> 在查找列表条目方面和 <code>Nat</code> 一样方便。</p>
<pre><code class="language-lean">instance : GetElem (List α) Pos α (fun list n =&gt; list.length &gt; n.toNat) where
  getElem (xs : List α) (i : Pos) ok := xs[i.toNat]
</code></pre>
<!--
Indexing can also make sense for non-numeric indices.
For example, `Bool` can be used to select between the fields in a point, with `false` corresponding to `x` and `true` corresponding to `y`:
-->
<p>使用非数字索引值来进行索引也可以是合理的。
例如：<code>Bool</code> 也可以被用于选择点中的字段，比如我们可以让 <code>false</code> 对应于 <code>x</code>，<code>true</code> 对应于 <code>y</code>：</p>
<pre><code class="language-lean">instance : GetElem (PPoint α) Bool α (fun _ _ =&gt; True) where
  getElem (p : PPoint α) (i : Bool) _ :=
    if not i then p.x else p.y
</code></pre>
<!--
In this case, both Booleans are valid indices.
Because every possible `Bool` is in bounds, the evidence is simply the true proposition `True`.
-->
<p>在这个例子中，布尔值都是合法的索引。
因为每个可能的 <code>Bool</code> 值都是未越界的，证据我们只需简单地给出 <code>True</code> 命题。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../type-classes/out-params.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../type-classes/standard-classes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../type-classes/out-params.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../type-classes/standard-classes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
