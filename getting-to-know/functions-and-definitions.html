<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>函数与定义 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html" class="active"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">接下来做什么</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/getting-to-know/functions-and-definitions.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Functions and Definitions
-->
<h1 id="函数与定义"><a class="header" href="#函数与定义">函数与定义</a></h1>
<!--
In Lean, definitions are introduced using the `def` keyword. For instance, to define the name `hello` to refer to the string `"Hello"`, write:
-->
<p>在 Lean 中，需使用 <code>def</code> 关键字引入定义。例如，若要定义名称
<code>hello</code> 来引用字符串
<code>&quot;Hello&quot;</code>，请编写：</p>
<pre><code class="language-lean">def hello := &quot;Hello&quot;
</code></pre>
<!--
In Lean, new names are defined using the colon-equal operator`:=`
rather than `=`. This is because `=` is used to describe equalities
between existing expressions, and using two different operators helps
prevent confusion.
-->
<p>在 Lean 中，使用冒号加等号运算符 <code>:=</code> 而非 <code>=</code> 来定义新名称。这是因为 <code>=</code>
用于描述现有表达式之间的相等性，而使用两个不同的运算符有助于避免混淆。</p>
<!--
In the definition of `hello`, the expression `"Hello"` is simple enough that Lean is able to determine the definition's type automatically.
However, most definitions are not so simple, so it will usually be necessary to add a type.
This is done using a colon after the name being defined.
-->
<p>在 <code>hello</code> 的定义中，表达式
<code>&quot;Hello&quot;</code> 足够简单，Lean
能够自动确定定义的类型。然而，大多数定义并不那么简单，因此通常需要添加类型。
这可以通过在要定义的名称后使用冒号来完成。</p>
<pre><code class="language-lean">def lean : String := &quot;Lean&quot;
</code></pre>
<!--
Now that the names have been defined, they can be used, so
-->
<p>定义了名称后，就可以使用它们了，因此</p>
<pre><code class="language-Lean">#eval String.append hello (String.append &quot; &quot; lean)
</code></pre>
<!--
outputs
-->
<p>会输出</p>
<pre><code class="language-Lean info">&quot;Hello Lean&quot;
</code></pre>
<!--
In Lean, defined names may only be used after their definitions.
-->
<p>在 Lean 中，定义的名称只能在其定义之后使用。</p>
<!--
In many languages, definitions of functions use a different syntax than definitions of other values.
For instance, Python function definitions begin with the `def` keyword, while other definitions are defined with an equals sign.
In Lean, functions are defined using the same `def` keyword as other values.
Nonetheless, definitions such as `hello` introduce names that refer _directly_ to their values, rather than to zero-argument functions that return equivalent results each time they are called.
-->
<p>在很多语言中，函数定义的语法与其他值的不同。例如，Python 函数定义以 <code>def</code> 关键字开头，
而其他定义则以等号定义。在 Lean 中，函数使用与其他值相同的 <code>def</code> 关键字定义。
尽管如此，像 <code>hello</code> 这类的定义引入的名字会 <strong>直接</strong> 引用其值，而非每次调用一个零参函数返回等价的值。</p>
<!--
## Defining Functions
-->
<h2 id="定义函数"><a class="header" href="#定义函数">定义函数</a></h2>
<!--
There are a variety of ways to define functions in Lean. The simplest is to place the function's arguments before the definition's type, separated by spaces. For instance, a function that adds one to its argument can be written:
-->
<p>在 Lean 中有多种方法可以定义函数，最简单的就是在定义的类型之前写上函数的参数，并用空格分隔。
例如，可以编写一个将其参数加 1 的函数：</p>
<pre><code class="language-lean">def add1 (n : Nat) : Nat := n + 1
</code></pre>
<!--
Testing this function with `#eval` gives `8`, as expected:
-->
<p>测试此函数时，<code>#eval</code> 给出了 <code>8</code>，符合预期：</p>
<pre><code class="language-lean">#eval add1 7
</code></pre>
<!--
Just as functions are applied to multiple arguments by writing spaces between each argument, functions that accept multiple arguments are defined with spaces between the arguments' names and types. The function `maximum`, whose result is equal to the greatest of its two arguments, takes two `Nat` arguments `n` and `k` and returns a `Nat`.
-->
<p>就像将函数应用于多个参数会用空格分隔一样，接受多个参数的函数定义也是在参数名与类型之间加上空格。
函数 <code>maximum</code> 的结果等于其两个参数中最大的一个，它接受两个 <code>Nat</code> 参数 <code>n</code> 和 <code>k</code>，并返回一个 <code>Nat</code>。</p>
<pre><code class="language-lean">def maximum (n : Nat) (k : Nat) : Nat :=
  if n &lt; k then
    k
  else n
</code></pre>
<!--
When a defined function like `maximum` has been provided with its arguments, the result is determined by first replacing the argument names with the provided values in the body, and then evaluating the resulting body. For example:
-->
<p>当向 <code>maximum</code> 这样的已定义函数提供参数时，其结果会首先用提供的值替换函数体中对应的参数名称，
然后对产生的函数体求值。例如：</p>
<pre><code class="language-lean">maximum (5 + 8) (2 * 7)
===&gt;
maximum 13 14
===&gt;
if 13 &lt; 14 then 14 else 13
===&gt;
14
</code></pre>
<!--
Expressions that evaluate to natural numbers, integers, and strings have types that say this (`Nat`, `Int`, and `String`, respectively).
This is also true of functions.
A function that accepts a `Nat` and returns a `Bool` has type `Nat → Bool`, and a function that accepts two `Nat`s and returns a `Nat` has type `Nat → Nat → Nat`.
-->
<p>求值结果为自然数、整数和字符串的表达式具有表示它们的类型（分别为 <code>Nat</code>、<code>Int</code> 和 <code>String</code>）。
函数也是如此，接受一个 <code>Nat</code> 并返回一个 <code>Bool</code> 的函数的类型为 <code>Nat → Bool</code>，接受两个 <code>Nat</code>
并返回一个 <code>Nat</code> 的函数的类型为 <code>Nat → Nat → Nat</code>。</p>
<!--
As a special case, Lean returns a function's signature when its name is used directly with `#check`.
Entering `#check add1` yields `add1 (n : Nat) : Nat`.
However, Lean can be "tricked" into showing the function's type by writing the function's name in parentheses, which causes the function to be treated as an ordinary expression, so `#check (add1)` yields `add1 : Nat → Nat` and `#check (maximum)` yields `maximum : Nat → Nat → Nat`.
This arrow can also be written with an ASCII alternative arrow `->`, so the preceding function types can be written `Nat -> Nat` and `Nat -> Nat -> Nat`, respectively.
-->
<p>作为一个特例，当函数的名称直接与 <code>#check</code> 一起使用时，Lean 会返回函数的签名。
输入 <code>#check add1</code>
会产生 <code>add1 (n : Nat) : Nat</code>。
但是，可以通过用括号括住函数名称来「欺骗」Lean 显示函数的类型，
这会导致函数被视为一个普通表达式，所以 <code>#check (add1)</code>
会产生 <code>add1 : Nat → Nat</code>
而 <code>#check (maximum)</code>
会产生 <code>maximum : Nat → Nat → Nat</code>。
此箭头也可以写作 ASCII 的箭头 <code>-&gt;</code>，因此前面的函数类型可以分别写作
<code>Nat -&gt; Nat</code> 和
<code>Nat -&gt; Nat -&gt; Nat</code>。</p>
<!--
Behind the scenes, all functions actually expect precisely one argument.
Functions like `maximum` that seem to take more than one argument are in fact functions that take one argument and then return a new function.
This new function takes the next argument, and the process continues until no more arguments are expected.
This can be seen by providing one argument to a multiple-argument function: `#check maximum 3` yields `maximum 3 : Nat → Nat` and `#check String.append "Hello "` yields `String.append "Hello " : String → String`.
Using a function that returns a function to implement multiple-argument functions is called _currying_ after the mathematician Haskell Curry.
Function arrows associate to the right, which means that `Nat → Nat → Nat` should be parenthesized `Nat → (Nat → Nat)`.
-->
<p>在幕后，所有函数实际上都刚好接受一个参数。像 <code>maximum</code> 这样的函数看起来需要多个参数，
但实际上它们会接受一个参数并返回一个新的函数，新函数接受下一个参数，
直到不再需要更多参数为止。可以通过向一个多参数函数提供一个参数来看到这一点：
<code>#check maximum 3</code>
会产生 <code>maximum 3 : Nat → Nat</code>，
而 <code>#check String.append &quot;Hello &quot;</code>
会产生 <code>String.append &quot;Hello &quot; : String → String</code>。
使用返回函数的函数来实现多参数函数被称为&quot; <strong>柯里化（Currying）</strong> ，
以数学家哈斯克尔·柯里（Haskell Curry）命名。
函数箭头是右结合的，这意味着 <code>Nat → Nat → Nat</code> 等价于 <code>Nat → (Nat → Nat)</code>。</p>
<!--
### Exercises
-->
<h3 id="练习"><a class="header" href="#练习">练习</a></h3>
<!--
 * Define the function `joinStringsWith` with type `String -> String -> String -> String` that creates a new string by placing its first argument between its second and third arguments. `joinStringsWith ", " "one" "and another"` should evaluate to `"one, and another"`.
 * What is the type of `joinStringsWith ": "`? Check your answer with Lean.
 * Define a function `volume` with type `Nat → Nat → Nat → Nat` that computes the volume of a rectangular prism with the given height, width, and depth.
-->
<ul>
<li>定义函数 <code>joinStringsWith</code>，类型为 <code>String -&gt; String -&gt; String -&gt; String</code>，
它通过将第一个参数放在第二个和第三个参数之间来创建一个新字符串。
<code>joinStringsWith &quot;, &quot; &quot;one&quot; &quot;and another&quot;</code> 应当会求值为
<code>&quot;one, and another&quot;</code>。</li>
<li><code>joinStringsWith &quot;: &quot;</code> 的类型是什么？用 Lean 检查你的答案。</li>
<li>定义一个函数 <code>volume</code>，类型为 <code>Nat → Nat → Nat → Nat</code>，
它计算给定高度、宽度和深度的矩形棱柱的体积。</li>
</ul>
<!--
## Defining Types
-->
<h2 id="定义类型"><a class="header" href="#定义类型">定义类型</a></h2>
<!--
Most typed programming languages have some means of defining aliases for types, such as C's `typedef`.
In Lean, however, types are a first-class part of the language - they are expressions like any other.
This means that definitions can refer to types just as well as they can refer to other values.
-->
<p>大多数类型化编程语言都有一些方法来定义类型的别名，例如 C 语言的 <code>typedef</code>。
然而，在 Lean 中，类型是语言的一等部分——它们与其他表达式一样都是表达式，
这意味着定义可以引用类型，就像它们可以引用其他值一样。</p>
<!--
For instance, if ``String`` is too much to type, a shorter abbreviation ``Str`` can be defined:
-->
<p>例如，如果 <code>String</code> 输入起来太长，可以定义一个简写 <code>Str</code>：</p>
<pre><code class="language-lean">def Str : Type := String
</code></pre>
<!--
It is then possible to use ``Str`` as a definition's type instead of ``String``:
-->
<p>然后就可以使用 <code>Str</code> 而非 <code>String</code> 作为定义的类型：</p>
<pre><code class="language-lean">def aStr : Str := &quot;This is a string.&quot;
</code></pre>
<!--
The reason this works is that types follow the same rules as the rest of Lean.
Types are expressions, and in an expression, a defined name can be replaced with its definition.
Because ``Str`` has been defined to mean ``String``, the definition of ``aStr`` makes sense.
-->
<p>之所以能这样做，是因为类型遵循与 Lean 其他部分相同的规则。
类型是表达式，而在表达式中，已定义的名称可以用其定义替换。由于 <code>Str</code> 已被定义为
<code>String</code>，因此 <code>aStr</code> 的定义是有意义的。</p>
<!--
### Messages You May Meet
-->
<h3 id="你可能会遇到的信息"><a class="header" href="#你可能会遇到的信息">你可能会遇到的信息</a></h3>
<!--
Experimenting with using definitions for types is made more complicated by the way that Lean supports overloaded integer literals.
If ``Nat`` is too short, a longer name ``NaturalNumber`` can be defined:
-->
<p>由于 Lean 支持重载整数字面量，因此使用定义作为类型进行实验会变得更加复杂。
如果 <code>Nat</code> 太短，可以定义一个较长的名称 <code>NaturalNumber</code>：</p>
<pre><code class="language-lean">def NaturalNumber : Type := Nat
</code></pre>
<!--
However, using ``NaturalNumber`` as a definition's type instead of ``Nat`` does not have the expected effect.
In particular, the definition:
-->
<p>然而，使用 <code>NaturalNumber</code> 作为定义的类型而非 <code>Nat</code> 并没有达到预期的效果。特别是，定义：</p>
<pre><code class="language-lean">def thirtyEight : NaturalNumber := 38
</code></pre>
<!--
results in the following error:
-->
<p>会导致以下错误：</p>
<pre><code class="language-output error">failed to synthesize instance
  OfNat NaturalNumber 38
</code></pre>
<!--
This error occurs because Lean allows number literals to be _overloaded_.
When it makes sense to do so, natural number literals can be used for new types, just as if those types were built in to the system.
This is part of Lean's mission of making it convenient to represent mathematics, and different branches of mathematics use number notation for very different purposes.
The specific feature that allows this overloading does not replace all defined names with their definitions before looking for overloading, which is what leads to the error message above.
-->
<p>产生该错误的原因是 Lean 允许数字字面量被 <strong>重载（Overload）</strong> 。
当有意义时，自然数字面量可用作新类型，就像这些类型内置在系统中一样。
这能让 Lean 方便地表示数学，而数学的不同分支会将数字符号用作完全不同的目的。
这种允许重载的特性，并不会在找到重载之前用其定义替换所有已定义的名称，
这正是导致出现以上错误消息的原因。</p>
<!--
One way to work around this limitation is by providing the type `Nat` on the right-hand side of the definition, causing `Nat`'s overloading rules to be used for `38`:
-->
<p>解决此限制的一种方法是在定义的右侧提供类型 <code>Nat</code>，从而让 <code>Nat</code> 的重载规则用于 <code>38</code>：</p>
<pre><code class="language-lean">def thirtyEight : NaturalNumber := (38 : Nat)
</code></pre>
<!--
The definition is still type-correct because `NaturalNumber` is the same type as `Nat`—by definition!
-->
<p>该定义的类型仍然正确，因为根据定义，<code>NaturalNumber</code>
与 <code>Nat</code> 是同一种类型！</p>
<!--
Another solution is to define an overloading for `NaturalNumber` that works equivalently to the one for `Nat`.
This requires more advanced features of Lean, however.
-->
<p>另一种解决方案是为 <code>NaturalNumber</code> 定义一个重载，其作用等同于 <code>Nat</code> 的重载。
然而，这需要 Lean 的更多高级特性。</p>
<!--
Finally, defining the new name for `Nat` using `abbrev` instead of `def` allows overloading resolution to replace the defined name with its definition.
Definitions written using `abbrev` are always unfolded.
For instance,
-->
<p>最后，使用 <code>abbrev</code> 而非 <code>def</code> 来为 <code>Nat</code> 定义新名称，
能够让重载解析以其定义来替换所定义的名称。使用 <code>abbrev</code> 编写的定义总是会展开。例如，</p>
<pre><code class="language-lean">abbrev N : Type := Nat
</code></pre>
<!--
and
-->
<p>和</p>
<pre><code class="language-lean">def thirtyNine : N := 39
</code></pre>
<!--
are accepted without issue.
-->
<p>都会被接受而不会出现问题。</p>
<!--
Behind the scenes, some definitions are internally marked as being unfoldable during overload resolution, while others are not.
Definitions that are to be unfolded are called _reducible_.
Control over reducibility is essential to allow Lean to scale: fully unfolding all definitions can result in very large types that are slow for a machine to process and difficult for users to understand.
Definitions produced with `abbrev` are marked as reducible.
-->
<p>在幕后，一些定义会在重载解析期间被内部标记为可展开的，而另一些则不会标记。
可展开的定义称为 <strong>可约的（Reducible）</strong> 。控制可约性对 Lean 的灵活性而言至关重要：
完全展开所有的定义可能会产生非常大的类型，这对于机器处理和用户理解来说都很困难。
使用 <code>abbrev</code> 生成的定义会被标记为可约定义。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-to-know/types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../getting-to-know/structures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-to-know/types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../getting-to-know/structures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
