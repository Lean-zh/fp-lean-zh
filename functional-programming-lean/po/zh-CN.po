#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Lean\n"
"POT-Creation-Date: 2024-04-18T15:02:27+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/SUMMARY.md:1 src/title.md:1
msgid "Functional Programming in Lean"
msgstr "Lean 函数式编程"

#: src/SUMMARY.md:3
msgid "Functional Programming in Lean Introduction Acknowledgments"
msgstr "Lean 函数式编程 引言与致谢"

#: src/SUMMARY.md:7
msgid "Getting to Know Lean"
msgstr "了解 Lean"

#: src/SUMMARY.md:8 src/getting-to-know/evaluating.md:1
#: src/getting-to-know/summary.md:3 src/monads/arithmetic.md:41
msgid "Evaluating Expressions"
msgstr "求值表达式"

#: src/SUMMARY.md:9 src/getting-to-know/types.md:1
#: src/getting-to-know/summary.md:28
msgid "Types"
msgstr "类型"

#: src/SUMMARY.md:10 src/getting-to-know/functions-and-definitions.md:1
msgid "Functions and Definitions"
msgstr "函数与定义"

#: src/SUMMARY.md:11 src/getting-to-know/structures.md:1
msgid "Structures"
msgstr "结构体"

#: src/SUMMARY.md:12
msgid "Datatypes, Patterns and Recursion"
msgstr "数据类型、模式与递归"

#: src/SUMMARY.md:13 src/getting-to-know/polymorphism.md:1
msgid "Polymorphism"
msgstr "多态"

#: src/SUMMARY.md:14 src/SUMMARY.md:21 src/SUMMARY.md:31 src/SUMMARY.md:38
#: src/SUMMARY.md:53 src/getting-to-know/conveniences.md:1
#: src/hello-world/conveniences.md:1 src/type-classes/conveniences.md:1
#: src/monads/conveniences.md:1 src/monad-transformers/conveniences.md:1
msgid "Additional Conveniences"
msgstr "其他便利功能"

#: src/SUMMARY.md:15 src/SUMMARY.md:22 src/SUMMARY.md:32 src/SUMMARY.md:39
#: src/SUMMARY.md:47 src/SUMMARY.md:54 src/SUMMARY.md:61 src/SUMMARY.md:71
#: src/getting-to-know/summary.md:1 src/hello-world/summary.md:1
#: src/type-classes/summary.md:1 src/monads/summary.md:1
#: src/functor-applicative-monad/summary.md:1
#: src/monad-transformers/summary.md:1 src/dependent-types/summary.md:1
#: src/programs-proofs/summary.md:1
msgid "Summary"
msgstr "总结"

#: src/SUMMARY.md:16 src/hello-world.md:1
msgid "Hello, World!"
msgstr "Hello, World!"

#: src/SUMMARY.md:17 src/hello-world/running-a-program.md:1
msgid "Running a Program"
msgstr "运行程序"

#: src/SUMMARY.md:18 src/hello-world/step-by-step.md:1
msgid "Step By Step"
msgstr "单步运行"

#: src/SUMMARY.md:19 src/hello-world/starting-a-project.md:1
msgid "Starting a Project"
msgstr "开始一个项目"

#: src/SUMMARY.md:20 src/hello-world/cat.md:1
msgid "Worked Example: `cat`"
msgstr "现实示例：`cat`"

#: src/SUMMARY.md:23 src/props-proofs-indexing.md:1
msgid "Interlude: Propositions, Proofs, and Indexing"
msgstr "插曲：命题、证明与索引"

#: src/SUMMARY.md:24 src/type-classes.md:1
msgid "Overloading and Type Classes"
msgstr "重载与类型类"

#: src/SUMMARY.md:25 src/type-classes/pos.md:1 src/type-classes/coercion.md:12
msgid "Positive Numbers"
msgstr "正数"

#: src/SUMMARY.md:26 src/type-classes/polymorphism.md:1
msgid "Type Classes and Polymorphism"
msgstr "类型类与多态"

#: src/SUMMARY.md:27 src/type-classes/out-params.md:1
msgid "Controlling Instance Search"
msgstr "控制实例搜索"

#: src/SUMMARY.md:28 src/type-classes/indexing.md:1
msgid "Arrays and Indexing"
msgstr "数组和索引"

#: src/SUMMARY.md:29 src/type-classes/standard-classes.md:1
msgid "Standard Classes"
msgstr "标准类"

#: src/SUMMARY.md:30 src/type-classes/coercion.md:1
#: src/type-classes/summary.md:59
msgid "Coercions"
msgstr "强制转换"

#: src/SUMMARY.md:33 src/monads.md:1
msgid "Monads"
msgstr "单子"

#: src/SUMMARY.md:34 src/monads/class.md:1 src/monads/summary.md:15
msgid "The Monad Type Class"
msgstr "单子类型类"

#: src/SUMMARY.md:35 src/monads/arithmetic.md:1
msgid "Example: Arithmetic in Monads"
msgstr "示例：用单子表达算术运算"

#: src/SUMMARY.md:36 src/monads/do.md:1 src/monads/summary.md:26
msgid "`do`\\-Notation for Monads"
msgstr "单子的 `do`\\-记法"

#: src/SUMMARY.md:37 src/monads/summary.md:41
msgid "The `IO` Monad"
msgstr "`IO` 单子"

#: src/SUMMARY.md:40 src/functor-applicative-monad.md:1
msgid "Functors, Applicative Functors, and Monads"
msgstr "函子、应用函子和单子"

#: src/SUMMARY.md:41 src/functor-applicative-monad/inheritance.md:1
#: src/functor-applicative-monad/summary.md:11
msgid "Structures and Inheritance"
msgstr "结构体和继承"

#: src/SUMMARY.md:42 src/functor-applicative-monad/applicative.md:1
#: src/functor-applicative-monad/summary.md:22
msgid "Applicative Functors"
msgstr "应用函子"

#: src/SUMMARY.md:43 src/functor-applicative-monad/applicative-contract.md:1
msgid "The Applicative Contract"
msgstr "应用函子契约"

#: src/SUMMARY.md:44 src/functor-applicative-monad/alternative.md:1
msgid "Alternatives"
msgstr "替代"

#: src/SUMMARY.md:45 src/functor-applicative-monad/universes.md:1
#: src/functor-applicative-monad/summary.md:42
msgid "Universes"
msgstr "宇宙"

#: src/SUMMARY.md:46 src/functor-applicative-monad/complete.md:1
msgid "The Complete Definitions"
msgstr "完整定义"

#: src/SUMMARY.md:48 src/monad-transformers.md:1
msgid "Monad Transformers"
msgstr "单子转换器"

#: src/SUMMARY.md:49 src/monad-transformers/reader-io.md:1
msgid "Combining IO and Reader"
msgstr "组合 IO 与 Reader"

#: src/SUMMARY.md:50 src/monad-transformers/transformers.md:1
msgid "A Monad Construction Kit"
msgstr "单子构建工具包"

#: src/SUMMARY.md:51 src/monad-transformers/order.md:1
msgid "Ordering Monad Transformers"
msgstr "对单子转换器排序"

#: src/SUMMARY.md:52
msgid "More `do` Features"
msgstr "更多 `do` 的特性"

#: src/SUMMARY.md:55 src/dependent-types.md:1 src/next-steps.md:48
msgid "Programming with Dependent Types"
msgstr "使用依值类型编程"

#: src/SUMMARY.md:56 src/dependent-types/indexed-families.md:1
#: src/dependent-types/summary.md:34
msgid "Indexed Families"
msgstr "索引族"

#: src/SUMMARY.md:57 src/dependent-types/universe-pattern.md:1
msgid "The Universe Design Pattern"
msgstr "宇宙设计模式"

#: src/SUMMARY.md:58 src/dependent-types/typed-queries.md:1
msgid "Worked Example: Typed Queries"
msgstr "现实示例：类型化查询"

#: src/SUMMARY.md:59 src/dependent-types/indices-parameters-universes.md:1
msgid "Indices, Parameters, and Universe Levels"
msgstr "索引、参数和宇宙层级"

#: src/SUMMARY.md:60 src/dependent-types/pitfalls.md:1
msgid "Pitfalls of Programming with Dependent Types"
msgstr "使用依值类型编程的陷阱"

#: src/SUMMARY.md:62 src/tactics-induction-proofs.md:1
msgid "Interlude: Tactics, Induction, and Proofs"
msgstr "插曲：策略、归纳与证明"

#: src/SUMMARY.md:63 src/programs-proofs.md:1
msgid "Programming, Proving, and Performance"
msgstr "编程、证明与性能"

#: src/SUMMARY.md:64 src/programs-proofs/tail-recursion.md:1
#: src/programs-proofs/summary.md:3
msgid "Tail Recursion"
msgstr "尾递归"

#: src/SUMMARY.md:65 src/programs-proofs/tail-recursion-proofs.md:1
msgid "Proving Equivalence"
msgstr "证明等价"

#: src/SUMMARY.md:66 src/programs-proofs/arrays-termination.md:1
msgid "Arrays and Termination"
msgstr "数组与停机"

#: src/SUMMARY.md:67 src/programs-proofs/inequalities.md:1
msgid "More Inequalities"
msgstr "更多不等式"

#: src/SUMMARY.md:68 src/programs-proofs/fin.md:1
#: src/programs-proofs/summary.md:44
msgid "Safe Array Indices"
msgstr "安全数组索引"

#: src/SUMMARY.md:69 src/programs-proofs/insertion-sort.md:1
msgid "Insertion Sort and Array Mutation"
msgstr "插入排序与数组可变性"

#: src/SUMMARY.md:70 src/programs-proofs/special-types.md:1
msgid "Special Types"
msgstr "特殊类型"

#: src/SUMMARY.md:73 src/next-steps.md:1
msgid "Next Steps"
msgstr "接下来做什么"

#: src/title.md:3
msgid "_by David Thrane Christiansen_"
msgstr "_作者：David Thrane Christiansen_"

#: src/title.md:5
msgid "_Copyright Microsoft Corporation 2023_"
msgstr "_版权所有：Microsoft Corporation 2023_"

#: src/title.md:9
msgid ""
"This is a free book on using Lean 4 as a programming language. All code "
"samples are tested with Lean 4 release `4.1.0`."
msgstr "这是一本免费的书，介绍如何使用 Lean 4 作为编程语言。所有代码示例均经过 Lean 4 版本 `4.1.0` 验证。"

#: src/title.md:11
msgid "Release history"
msgstr "发行历史"

#: src/title.md:13
msgid "January, 2024"
msgstr "2024 年 1 月"

#: src/title.md:15
msgid ""
"This is a minor bugfix release that fixes a regression in an example "
"program."
msgstr "这是一个次要错误修复版本，修复了示例程序中的后退方向。"

#: src/title.md:17
msgid "October, 2023"
msgstr "2023 年 10 月"

#: src/title.md:19
msgid ""
"In this first maintenance release, a number of smaller issues were fixed and"
" the text was brought up to date with the latest release of Lean."
msgstr "在首次维护版本中，修复了许多较小的错误，并根据 Lean 的最新版本更新了文本。"

#: src/title.md:21
msgid "May, 2023"
msgstr "2023 年 5 月"

#: src/title.md:23
msgid ""
"The book is now complete! Compared to the April pre-release, many small "
"details have been improved and minor mistakes have been fixed."
msgstr "本书现已完成！与 4 月份的预发布版本相比，许多小细节得到了改进，并修复了小错误。"

#: src/title.md:25
msgid "April, 2023"
msgstr "2023 年 4 月"

#: src/title.md:27
msgid ""
"This release adds an interlude on writing proofs with tactics as well as a "
"final chapter that combines discussion of performance and cost models with "
"proofs of termination and program equivalence. This is the last release "
"prior to the final release."
msgstr "此版本添加了关于使用策略编写证明的插曲，以及添加了将性能和成本模型的讨论，与停机证明和程序等价性证明相结合的最后一章。这是最终版本前的最后一个版本。"

#: src/title.md:30
msgid "March, 2023"
msgstr "2023 年 3 月"

#: src/title.md:32
msgid ""
"This release adds a chapter on programming with dependent types and indexed "
"families."
msgstr "此版本添加了关于使用依值类型和索引族编程的章节。"

#: src/title.md:34
msgid "January, 2023"
msgstr "2023 年 1 月"

#: src/title.md:36
msgid ""
"This release adds a chapter on monad transformers that includes a "
"description of the imperative features that are available in "
"`do`\\-notation."
msgstr "此版本添加了关于单子变换器的章节，其中包括对 `do`\\-记法中可用的命令式特性的描述。"

#: src/title.md:38
msgid "December, 2022"
msgstr "2022 年 12 月"

#: src/title.md:40
msgid ""
"This release adds a chapter on applicative functors that additionally "
"describes structures and type classes in more detail. This is accompanied "
"with improvements to the description of monads. The December 2022 release "
"was delayed until January 2023 due to winter holidays."
msgstr ""
"此版本添加了关于应用函子的章节，此外还更加详细地描述了结构体和类型类。此外改进了对单子的描述。由于冬季假期，2022 年 12 月版本被推迟到 2023 年 1 月。"

#: src/title.md:44
msgid "November, 2022"
msgstr "2022 年 11 月"

#: src/title.md:45
msgid ""
"This release adds a chapter on programming with monads. Additionally, the "
"example of using JSON in the coercions section has been updated to include "
"the complete code."
msgstr "此版本添加了关于使用单子编程的章节。此外，强制转换一节中使用 JSON 的示例已更新为包含完整代码。"

#: src/title.md:47
msgid "October, 2022"
msgstr "2022 年 10 月"

#: src/title.md:49
msgid ""
"This release completes the chapter on type classes. In addition, a short "
"interlude introducing propositions, proofs, and tactics has been added just "
"before the chapter on type classes, because a small amount of familiarity "
"with the concepts helps to understand some of the standard library type "
"classes."
msgstr ""
"此版本完成了类型类的章节。此外，在类型类章节之前添加了一个简短的插曲，介绍了命题、证明和策略，因为简单了解一下这些概念有助于理解一些标准库中的类型类。"

#: src/title.md:51
msgid "September, 2022"
msgstr "2022 年 9 月"

#: src/title.md:53
msgid ""
"This release adds the first half of a chapter on type classes, which are "
"Lean's mechanism for overloading operators and an important means of "
"organizing code and structuring libraries. Additionally, the second chapter "
"has been updated to account for changes in Lean's stream API."
msgstr ""
"本次发布增加了关于类型类的章节的前半部分，类型类是 Lean 中用于重载运算符的机制，也是组织代码和构建库的重要手段。此外，第二章已更新，以适配 Lean 中的 Stream 流 API 的变化。"

#: src/title.md:55
msgid "August, 2022"
msgstr "2022 年 8 月"

#: src/title.md:57
msgid ""
"This third public release adds a second chapter, which describes compiling "
"and running programs along with Lean's model for side effects."
msgstr "第三次公开发布增加了第二章，其中描述了编译和运行程序以及 Lean 的副作用模型。"

#: src/title.md:59
msgid "July, 2022"
msgstr "2022 年 7 月"

#: src/title.md:61
msgid "The second public release completes the first chapter."
msgstr "第二次公开发布，完成了第一章。"

#: src/title.md:63
msgid "June, 2022"
msgstr "2022 年 6 月"

#: src/title.md:65
msgid ""
"This was the first public release, consisting of an introduction and part of"
" the first chapter."
msgstr "这是第一次公开发布，包括引言和第一章的一部分。"

#: src/title.md:67
msgid "About the Author"
msgstr "关于作者"

#: src/title.md:69
msgid ""
"David Thrane Christiansen has been using functional languages for twenty "
"years, and dependent types for ten. Together with Daniel P. Friedman, he "
"wrote [_The Little Typer_](https://thelittletyper.com/), an introduction to "
"the key ideas of dependent type theory. He has a Ph.D. from the IT "
"University of Copenhagen. During his studies, he was a major contributor to "
"the first version of the Idris language. Since leaving academia, he has "
"worked as a software developer at Galois in Portland, Oregon and Deon "
"Digital in Copenhagen, Denmark, and he was the Executive Director of the "
"Haskell Foundation. At the time of writing, he is employed at the [Lean "
"Focused Research Organization](https://lean-fro.org) working full-time on "
"Lean."
msgstr ""
"David Thrane Christiansen 已使用函数式语言二十年，并使用依值类型十年。他与 Daniel P. Friedman "
"合著了《[_The Little "
"Typer_](https://thelittletyper.com/)》，介绍了依值类型论的关键思想。他拥有哥本哈根 IT "
"大学的博士学位。在学习期间，他为 Idris 语言的第一个版本做出了重大贡献。离开学术界后，他曾在俄勒冈州波特兰的 Galois 和丹麦哥本哈根的 "
"Deon Digital 担任软件开发人员，并担任 Haskell 基金会执行董事。在撰写本文时，他受雇于 [Lean "
"专注研究组织](https://lean-fro.org)，全职从事 Lean 的工作。"

#: src/title.md:76
msgid "License"
msgstr "许可证"

#: src/title.md:78
msgid "This work is licensed under a "
msgstr "本作品采用"

#: src/title.md:78
msgid "Creative Commons Attribution 4.0 International License"
msgstr "知识共享 署名 4.0 国际许可协议"

#: src/title.md:78
msgid "."
msgstr "授权。"

#: src/introduction.md:3
msgid ""
"Lean is an interactive theorem prover developed at Microsoft Research, based"
" on dependent type theory. Dependent type theory unites the worlds of "
"programs and proofs; thus, Lean is also a programming language. Lean takes "
"its dual nature seriously, and it is designed to be suitable for use as a "
"general-purpose programming language—Lean is even implemented in itself. "
"This book is about writing programs in Lean."
msgstr ""
"Lean 是 Microsoft Research 开发的交互式定理证明器，基于依值类型论。依值类型论将程序和证明的世界统一起来；因此，Lean "
"也是一门编程语言。Lean 认真对待其双重性质，并且被设计为适合用作通用编程语言——Lean 甚至是用它自己实现的。本书介绍了如何用 Lean "
"编写程序。"

#: src/introduction.md:8
msgid ""
"When viewed as a programming language, Lean is a strict pure functional "
"language with dependent types. A large part of learning to program with Lean"
" consists of learning how each of these attributes affects the way programs "
"are written, and how to think like a functional programmer. _Strictness_ "
"means that function calls in Lean work similarly to the way they do in most "
"languages: the arguments are fully computed before the function's body "
"begins running. _Purity_ means that Lean programs cannot have side effects "
"such as modifying locations in memory, sending emails, or deleting files "
"without the program's type saying so. Lean is a _functional_ language in the"
" sense that functions are first-class values like any other and that the "
"execution model is inspired by the evaluation of mathematical expressions. "
"_Dependent types_, which are the most unusual feature of Lean, make types "
"into a first-class part of the language, allowing types to contain programs "
"and programs to compute types."
msgstr ""
"作为一门编程语言，Lean 是一种具有依值类型的严格纯函数式语言。学习使用 Lean "
"编程很大一部分内容在于学习这些属性中的每一个如何影响程序的编写方式，以及如何像函数式程序员一样思考。**严格性（Strictness）**意味着 Lean "
"中的函数调用与大多数语言中的工作方式类似：在函数体开始运行之前，参数被完全计算。**纯粹性（Purity）**意味着 Lean "
"程序不能产生副作用，例如修改内存中的位置、发送电子邮件或删除文件，除非程序的类型声明如此。Lean "
"是一种**函数式（Functional）**语言，这意味着函数就像任何其他值一样是一等值，并且执行模型受数学表达式的求值启发。**依值类型（Dependent type）**是 Lean "
"最不寻常的特性，它使类型成为语言的一等部分，允许类型包含程序，而程序计算类型。"

#: src/introduction.md:15
msgid ""
"This book is intended for programmers who want to learn Lean, but who have "
"not necessarily used a functional programming language before. Familiarity "
"with functional languages such as Haskell, OCaml, or F# is not required. On "
"the other hand, this book does assume knowledge of concepts like loops, "
"functions, and data structures that are common to most programming "
"languages. While this book is intended to be a good first book on functional"
" programming, it is not a good first book on programming in general."
msgstr ""
"本书面向希望学习 Lean 的程序员，但他们不一定以前使用过函数式编程语言。不需要熟悉 Haskell、OCaml 或 F# "
"等函数式语言。另一方面，本书确实假设读者了解循环、函数和数据结构体等大多数编程语言中常见的概念。虽然本书旨在成为一本关于函数式编程的优秀入门书，但它并不是一本关于一般编程的优秀入门书。"

#: src/introduction.md:20
msgid ""
"Mathematicians who are using Lean as a proof assistant will likely need to "
"write custom proof automation tools at some point. This book is also for "
"them. As these tools become more sophisticated, they begin to resemble "
"programs in functional languages, but most working mathematicians are "
"trained in languages like Python and Mathematica. This book can help bridge "
"the gap, empowering more mathematicians to write maintainable and "
"understandable proof automation tools."
msgstr ""
"对于将 Lean "
"作为证明助手的数学家来说，他们可能需要在某个时间点编写自定义的证明自动化工具。本书也适用于他们。随着这些工具变得越来越复杂，它们也越来越像函数式语言编写的程序，但大多数在职数学家接受的是"
" Python 和 Mathematica 等语言的培训。本书可以帮助他们弥合这一差距，让更多数学家能够编写可维护且易于理解的证明自动化工具。"

#: src/introduction.md:25
msgid ""
"This book is intended to be read linearly, from the beginning to the end. "
"Concepts are introduced one at a time, and later sections assume familiarity"
" with earlier sections. Sometimes, later chapters will go into depth on a "
"topic that was only briefly addressed earlier on. Some sections of the book "
"contain exercises. These are worth doing, in order to cement your "
"understanding of the section. It is also useful to explore Lean as you read "
"the book, finding creative new ways to use what you have learned."
msgstr ""
"本书旨在从头到尾线性阅读。概念一次引入一个，后面的章节假定读者熟悉前面的章节。有时，后面的章节会深入探讨一个之前仅简要讨论过的主题。本书的某些章节包含练习。为了巩固你对该章节的理解，这些练习值得一做。在阅读本书时探索"
" Lean 也很有用，找到使用你所学知识的创造性新方法。"

#: src/introduction.md:32
msgid "Getting Lean"
msgstr "获取 Lean"

#: src/introduction.md:34
msgid ""
"Before writing and running programs written in Lean, you'll need to set up "
"Lean on your own computer. The Lean tooling consists of the following:"
msgstr "在编写和运行用 Lean 编写的程序之前，你需要在自己的计算机上设置 Lean。Lean 工具包括以下内容："

#: src/introduction.md:37
msgid ""
"`elan` manages the Lean compiler toolchains, similarly to `rustup` or "
"`ghcup`."
msgstr "`elan`：用于管理 Lean 编译器工具链，类似于 `rustup` 或 `ghcup`。"

#: src/introduction.md:38
msgid ""
"`lake` builds Lean packages and their dependencies, similarly to `cargo`, "
"`make`, or Gradle."
msgstr "`lake`：用于构建 Lean 包及其依赖项，类似于 `cargo`、`make` 或 Gradle。"

#: src/introduction.md:39
msgid ""
"`lean` type checks and compiles individual Lean files as well as providing "
"information to programmer tools about files that are currently being "
"written. Normally, `lean` is invoked by other tools rather than directly by "
"users."
msgstr ""
"`lean`：对各个 Lean 文件进行类型检查和编译，并向程序员的工具提供有关当前正在编写的文件的信息。通常，`lean` "
"是由其他工具而非用户直接调用的。"

#: src/introduction.md:41
msgid ""
"Plugins for editors, such as Visual Studio Code or Emacs, that communicate "
"with `lean` and present its information conveniently."
msgstr "编辑器插件，如 Visual Studio Code 或 Emacs，可与 Lean 通信并方便地显示其信息。"

#: src/introduction.md:43
msgid ""
"Please refer to the [Lean manual](https://lean-"
"lang.org/lean4/doc/quickstart.html) for up-to-date instructions for "
"installing Lean."
msgstr ""
"有关安装 Lean 的最新说明，请参阅 [Lean 手册](https://lean-"
"lang.org/lean4/doc/quickstart.html)。"

#: src/introduction.md:45
msgid "Typographical Conventions"
msgstr "排版约定"

#: src/introduction.md:47
msgid ""
"Code examples that are provided to Lean as _input_ are formatted like this:"
msgstr "作为**输入**提供给 Lean 的代码示例格式如下："

#: src/introduction.md:53
msgid ""
"The last line above (beginning with `#eval`) is a command that instructs "
"Lean to calculate an answer. Lean's replies are formatted like this:"
msgstr "上面最后一行（以 `#eval` 开头）是指示 Lean 计算答案的命令。Lean 的回复格式如下："

#: src/introduction.md:58
msgid "Error messages returned by Lean are formatted like this:"
msgstr "Lean 返回的错误消息格式如下："

#: src/introduction.md:59
msgid ""
"```output error\n"
"application type mismatch\n"
"  add1 \"seven\"\n"
"argument\n"
"  \"seven\"\n"
"has type\n"
"  String : Type\n"
"but is expected to have type\n"
"  Nat : Type\n"
"```"
msgstr ""
"```output error\n"
"应用程序类型不匹配\n"
"  add1 \"seven\"\n"
"参数\n"
"  \"seven\"\n"
"类型为\n"
"  String : Type\n"
"但预期类型为\n"
"  Nat : Type\n"
"```"

#: src/introduction.md:69
msgid "Warnings are formatted like this:"
msgstr "警告格式如下："

#: src/introduction.md:74
msgid "Unicode"
msgstr "Unicode"

#: src/introduction.md:76
msgid ""
"Idiomatic Lean code makes use of a variety of Unicode characters that are "
"not part of ASCII. For instance, Greek letters like `α` and `β` and the "
"arrow `→` both occur in the first chapter of this book. This allows Lean "
"code to more closely resemble ordinary mathematical notation."
msgstr ""
"惯用的 Lean 代码使用各种不属于 ASCII 的 Unicode 字符。例如，希腊字母（如 `α` 和 "
"`β`）和箭头（`→`）都出现在本书的第一章中。这使得 Lean 代码更接近于普通的数学记法。"

#: src/introduction.md:80
msgid ""
"With the default Lean settings, both Visual Studio Code and Emacs allow "
"these characters to be typed with a backslash (`\\`) followed by a name. For"
" example, to enter `α`, type `\\alpha`. To find out how to type a character "
"in Visual Studio Code, point the mouse at it and look at the tooltip. In "
"Emacs, use `C-c C-k` with point on the character in question."
msgstr ""
"在默认的 Lean 设置中，Visual Studio Code 和 Emacs 都允许使用反斜杠 (`\\`) 后跟名称来输入这些字符。例如，要输入 "
"`α`，请键入 `\\alpha`。要了解如何在 Visual Studio Code 中键入字符，请将鼠标指向该字符并查看工具提示。在 Emacs "
"中，将光标置于相关字符上，然后使用 `C-c C-k`。"

#: src/acknowledgments.md:1
msgid "Acknowledgments"
msgstr "致谢"

#: src/acknowledgments.md:4
msgid ""
"This free online book was made possible by the generous support of Microsoft"
" Research, who paid for it to be written and given away. During the process "
"of writing, they made the expertise of the Lean development team available "
"to both answer my questions and make Lean easier to use. In particular, "
"Leonardo de Moura initiated the project and helped me get started, Chris "
"Lovett set up the CI and deployment automation and provided great feedback "
"as a test reader, Gabriel Ebner provided technical reviews, Sarah Smith kept"
" the administrative side working well, and Vanessa Rodriguez helped me "
"diagnose a tricky interaction between the source-code highlighting library "
"and certain versions of Safari on iOS."
msgstr ""
"这本免费的在线书籍得益于 Microsoft Research 的慷慨支持，他们支付了撰写和赠送的费用。在撰写过程中，他们让 Lean "
"开发团队的专家随时解答我的问题并让 Lean 更易于使用。特别是，Leonardo de Moura 发起了该项目并帮助我入门，Chris Lovett"
" 设置了 CI 和部署自动化，并作为测试的读者提供了宝贵的反馈，Gabriel Ebner 提供了技术审查，Sarah Smith "
"让管理方面的工作顺利进行，Vanessa Rodriguez 帮助我诊断了源代码高亮库与 iOS 上某些版本的 Safari 之间棘手的交互。"

#: src/acknowledgments.md:8
msgid ""
"Writing this book has taken up many hours outside of normal working hours. "
"My wife Ellie Thrane Christiansen has taken on a larger than usual share of "
"running the family, and this book could not exist if she had not done so. An"
" extra day of work each week has not been easy for my family—thank you for "
"your patience and support while I was writing."
msgstr ""
"撰写本书占用了我许多正常工作时间之外的时间。我的妻子艾莉·特兰·克里斯蒂安森承担了比平时更大的家庭事务，如果没有她，这本书就不可能存在。每周多工作一天对我的家庭来说并不容易——感谢你在我写作期间的耐心和支持。"

#: src/acknowledgments.md:12
msgid ""
"The online community surrounding Lean provided enthusiastic support for the "
"project, both technical and emotional. In particular, Sebastian Ullrich "
"provided key help when I was learning Lean's metaprogramming system in order"
" to write the supporting code that allowed the text of error messages to be "
"both checked in CI and easily included in the book itself. Within hours of "
"posting a new revision, excited readers would be finding mistakes, providing"
" suggestions, and showering me with kindness. In particular, I'd like to "
"thank Arien Malec, Asta Halkjær From, Bulhwi Cha, Craig Stuntz, Daniel "
"Fabian, Evgenia Karunus, eyelash, Floris van Doorn, František Silváši, "
"Henrik Böving, Ian Young, Jeremy Salwen, Jireh Loreaux, Kevin Buzzard, Lars "
"Ericson, Liu Yuxi, Mac Malone, Malcolm Langfield, Mario Carneiro, Newell "
"Jensen, Patrick Massot, Paul Chisholm, Pietro Monticone, Tomas Puverle, Yaël"
" Dillies, Zhiyuan Bao, and Zyad Hassan for their many suggestions, both "
"stylistic and technical."
msgstr ""
"Lean 的在线社区为该项目提供了热情的支持，包括技术和情感上的支持。特别是，Sebastian Ullrich 在我学习 Lean "
"的元编程系统时提供了关键帮助，以便编写支持代码，使错误消息的文本既可以在 CI "
"中进行检查，又可以轻松包含在书中本身。在发布新修订后的几个小时内，兴奋的读者就会发现错误，提出建议，并善意地提醒我。特别是，我要感谢 Arien "
"Malec、Asta Halkjær From、Bulhwi Cha、Craig Stuntz、Daniel Fabian、Evgenia "
"Karunus、eyelash、Floris van Doorn、František Silváši、Henrik Böving、Ian "
"Young、Jeremy Salwen、Jireh Loreaux、Kevin Buzzard、Lars Ericson、Liu Yuxi、Mac "
"Malone、Malcolm Langfield、Mario Carneiro、Newell Jensen、Patrick Massot、Paul "
"Chisholm、Pietro Monticone、Tomas Puverle、Yaël Dillies、Zhiyuan Bao 和 Zyad "
"Hassan，感谢他们提出的许多建议，包括文体和技术方面的建议。"

#: src/getting-to-know.md:1
msgid ""
"According to tradition, a programming language should be introduced by "
"compiling and running a program that displays `\"Hello, world!\"` on the "
"console. This simple program ensures that the language tooling is installed "
"correctly and that the programmer is able to run the compiled code."
msgstr ""
"按照惯例，介绍编程语言通常会编译并运行一个在控制台上显示「Hello, "
"world!」的程序。这个简单的程序能确保语言工具安装正确，且程序员能够运行已编译的代码。"

#: src/getting-to-know.md:7
msgid ""
"Since the 1970s, however, programming has changed. Today, compilers are "
"typically integrated into text editors, and the programming environment "
"offers feedback as the program is written. Lean is no exception: it "
"implements an extended version of the Language Server Protocol that allows "
"it to communicate with a text editor and provide feedback as the user types."
msgstr ""
"然而，自 20 世纪 70 年代以来，编程发生了变化。如今，编译器通常集成到文本编辑器中，编程环境会在编写程序时提供反馈。Lean "
"也是如此：它实现了语言服务器协议（Language Server Protocol，LSP）的扩展版本，允许它与文本编辑器通信并在用户键入时提供反馈。"

#: src/getting-to-know.md:14
msgid ""
"Languages as varied as Python, Haskell, and JavaScript offer a read-eval-"
"print-loop (REPL), also known as an interactive toplevel or a browser "
"console, in which expressions or statements can be entered. The language "
"then computes and displays the result of the user's input. Lean, on the "
"other hand, integrates these features into the interaction with the editor, "
"providing commands that cause the text editor to display feedback integrated"
" into the program text itself. This chapter provides a short introduction to"
" interacting with Lean in an editor, while [Hello, World!]() describes how "
"to use Lean traditionally from the command line in batch mode."
msgstr ""
"从 Python、Haskell 到 JavaScript 等各种语言都提供读取-求值-打印循环 "
"(REPL)，也称为交互式顶层环境或浏览器控制台，可以在其中输入表达式或语句。然后，该语言计算并显示用户输入的结果。另一方面，Lean "
"将这些特性集成到与编辑器的交互中，它提供的命令能让文本编辑器将程序的反馈集成到程序文本中。本章简要介绍了在编辑器中与 Lean 的交互，而 [Hello, "
"World!]() 则描述了如何在批处理模式下以传统的命令行方式使用 Lean。"

#: src/getting-to-know.md:19
msgid ""
"It is best if you read this book with Lean open in your editor, following "
"along and typing in each example. Please play with the examples, and see "
"what happens!"
msgstr "阅读本书最好的方式是在编辑器中打开 Lean，输入书中的每个示例并运行他们，然后看看会发生什么。"

#: src/getting-to-know/evaluating.md:3
msgid ""
"The most important thing to understand as a programmer learning Lean is how "
"evaluation works. Evaluation is the process of finding the value of an "
"expression, just as one does in arithmetic. For instance, the value of 15 - "
"6 is 9 and the value of 2 × (3 + 1) is 8. To find the value of the latter "
"expression, 3 + 1 is first replaced by 4, yielding 2 × 4, which itself can "
"be reduced to 8. Sometimes, mathematical expressions contain variables: the "
"value of _x_ + 1 cannot be computed until we know what the value of _x_ is. "
"In Lean, programs are first and foremost expressions, and the primary way to"
" think about computation is as evaluating expressions to find their values."
msgstr ""
"作为学习 Lean 的程序员，最重要的是理解求值的工作原理。求值是得到表达式的值的过程，就像算术那样。"
"例如，15 - 6 的值为 9，2 × (3 + 1) 的值为 8。要得到后一个表达式的值，首先将 3 + 1 替换为 4，得到 2 × 4，它本身可以简化为 "
"8。有时，数学表达式包含变量：在知道 **x** 的值之前，无法计算 **x** + 1 的值。在 Lean "
"中，程序首先是表达式，思考计算的主要方式是对表达式求值以得到其值。"

#: src/getting-to-know/evaluating.md:11
msgid ""
"Most programming languages are _imperative_, where a program consists of a "
"series of statements that should be carried out in order to find the "
"program's result. Programs have access to mutable memory, so the value "
"referred to by a variable can change over time. In addition to mutable "
"state, programs may have other side effects, such as deleting files, making "
"outgoing network connections, throwing or catching exceptions, and reading "
"data from a database. \"Side effects\" is essentially a catch-all term for "
"describing things that may happen in a program that don't follow the model "
"of evaluating mathematical expressions."
msgstr ""
"大多数编程语言都是 "
"**命令式的**，其中程序由一系列语句组成，这些语句应按顺序执行以找到程序的结果。程序可以访问可变内存，因此变量引用的值可以随时间而改变。除了可变状态之外，程序还可能产生其他副作用，例如删除文件、建立传出网络连接、抛出或捕获异常以及从数据库读取数据。「副作用（Side Effect）」本质上是一个统称，用于描述程序中可能发生的事情，这些事情不遵循求值数学表达式的模型。"

#: src/getting-to-know/evaluating.md:21
msgid ""
"In Lean, however, programs work the same way as mathematical expressions. "
"Once given a value, variables cannot be reassigned. Evaluating an expression"
" cannot have side effects. If two expressions have the same value, then "
"replacing one with the other will not cause the program to compute a "
"different result. This does not mean that Lean cannot be used to write "
"`Hello, world!` to the console, but performing I/O is not a core part of the"
" experience of using Lean in the same way. Thus, this chapter focuses on how"
" to evaluate expressions interactively with Lean, while the next chapter "
"describes how to write, compile, and run the `Hello, world!` program."
msgstr ""
"然而，在 Lean "
"中，程序的工作方式与数学表达式相同。一旦赋予一个值，变量就不能重新赋值。求值表达式不会产生副作用。如果两个表达式具有相同的值，那么用一个表达式替换另一个表达式不会导致程序计算出不同的结果。这并不意味着"
" Lean 不能用于向控制台写入 `Hello, world!`，而是执行 I/O 并不是以同样的方式使用 Lean 的核心部分。因此，本章重点介绍如何使用"
" Lean 交互式地求值表达式，而下一章将介绍如何编写、编译并运行 `Hello, world!` 程序。"

#: src/getting-to-know/evaluating.md:31
msgid ""
"To ask Lean to evaluate an expression, write `#eval` before it in your "
"editor, which will then report the result back. Typically, the result is "
"found by putting the cursor or mouse pointer over `#eval`. For instance,"
msgstr ""
"要让 Lean 对一个表达式求值，请在编辑器中该表达式的前面加上 `#eval`，然后它将报告结果。通常可通过将光标或鼠标指针放在 `#eval` "
"上来查看结果。例如，"

#: src/getting-to-know/evaluating.md:39
msgid "yields the value `3`."
msgstr "会产生值 `3`。"

#: src/getting-to-know/evaluating.md:41
msgid ""
"Lean obeys the ordinary rules of precedence and associativity for arithmetic"
" operators. That is,"
msgstr "Lean 遵循一般的算术运算符优先级和结合性规则。也就是说，"

#: src/getting-to-know/evaluating.md:47
msgid "yields the value `11` rather than `15`."
msgstr "会产生值 `11` 而非 `15`。"

#: src/getting-to-know/evaluating.md:51
msgid ""
"While both ordinary mathematical notation and the majority of programming "
"languages use parentheses (e.g. `f(x)`) to apply a function to its "
"arguments, Lean simply writes the function next to its arguments (e.g. `f "
"x`). Function application is one of the most common operations, so it pays "
"to keep it concise. Rather than writing"
msgstr ""
"虽然普通的数学符号和大多数编程语言都使用括号（例如 `f(x)`）将函数应用于其参数，但 Lean 只是将函数写在其参数后边（例如 `f "
"x`）。函数应用是最常见的操作之一，因此保持简洁很重要。与其编写"

#: src/getting-to-know/evaluating.md:56
msgid ""
"```lean\n"
"#eval String.append(\"Hello, \", \"Lean!\")\n"
"```"
msgstr ""
"```lean\n"
"#eval String.append(\"Hello, \", \"Lean!\")\n"
"```"

#: src/getting-to-know/evaluating.md:59
msgid "to compute `\"Hello, Lean!\"`, one would instead write"
msgstr "来计算 `\"Hello, Lean!\"`，不如编写"

#: src/getting-to-know/evaluating.md:61
msgid ""
"```Lean\n"
"#eval String.append \"Hello, \" \"Lean!\"\n"
"```"
msgstr ""
"```Lean\n"
"#eval String.append \"Hello, \" \"Lean!\"\n"
"```"

#: src/getting-to-know/evaluating.md:64
msgid ""
"where the function's two arguments are simply written next to it with "
"spaces."
msgstr "其中函数的两个参数只是用空格隔开写在后面。"

#: src/getting-to-know/evaluating.md:67
msgid ""
"Just as the order-of-operations rules for arithmetic demand parentheses in "
"the expression `(1 + 2) * 5`, parentheses are also necessary when a "
"function's argument is to be computed via another function call. For "
"instance, parentheses are required in"
msgstr ""
"就像算术运算的顺序规则需要在表达式中使用括号（如 `(1 + 2) * 5`）表示一样，当函数的参数需要通过另一个函数调用来计算时，括号也是必需的。例如，在"

#: src/getting-to-know/evaluating.md:71
msgid ""
"```Lean\n"
"#eval String.append \"great \" (String.append \"oak \" \"tree\")\n"
"```"
msgstr ""
"```Lean\n"
"#eval String.append \"great \" (String.append \"oak \" \"tree\")\n"
"```"

#: src/getting-to-know/evaluating.md:74
msgid ""
"because otherwise the second `String.append` would be interpreted as an "
"argument to the first, rather than as a function being passed `\"oak \"` and"
" `\"tree\"` as arguments. The value of the inner `String.append` call must "
"be found first, after which it can be appended to `\"great \"`, yielding the"
" final value `\"great oak tree\"`."
msgstr ""
"中需要括号，否则第二个 `String.append` 将被解释为第一个参数，而非作为接受 `\"oak \"` 和 `\"tree\"` "
"作为参数的函数。必须先得到内部 `String.append` 调用的值，然后才能将其传入到 `\"great \"`，从而产生最终的值 "
"`\"great oak tree\"`。"

#: src/getting-to-know/evaluating.md:80
msgid ""
"Imperative languages often have two kinds of conditional: a conditional "
"_statement_ that determines which instructions to carry out based on a "
"Boolean value, and a conditional _expression_ that determines which of two "
"expressions to evaluate based on a Boolean value. For instance, in C and "
"C++, the conditional statement is written using `if` and `else`, while the "
"conditional expression is written with a ternary operator `?` and `:`. In "
"Python, the conditional statement begins with `if`, while the conditional "
"expression puts `if` in the middle. Because Lean is an expression-oriented "
"functional language, there are no conditional statements, only conditional "
"expressions. They are written using `if`, `then`, and `else`. For instance,"
msgstr ""
"命令式语言通常有两种条件：根据布尔值确定要执行哪些指令的条件**语句（Statement）**，以及根据布尔值确定要计算两个表达式中哪一个的条件**表达式（Expression）**。例如，在 C 和 "
"C++ 中，条件语句使用 `if` 和 `else` 编写，而条件表达式使用三元运算符 `?` 和 `:` 编写。在 Python 中，条件语句以 "
"`if` 开头，而条件表达式则将 `if` 放在中间。由于 Lean 是一种面向表达式的函数式语言，因此没有条件语句，只有条件表达式。条件表达式使用 "
"`if`、`then` 和 `else` 编写。例如，"

#: src/getting-to-know/evaluating.md:92
msgid ""
"```Lean\n"
"String.append \"it is \" (if 1 > 2 then \"yes\" else \"no\")\n"
"```"
msgstr ""
"```lean\n"
"String.append \"it is \" (if 1 > 2 then \"yes\" else \"no\")\n"
"```"

#: src/getting-to-know/evaluating.md:95
#: src/dependent-types/indexed-families.md:197
#: src/dependent-types/typed-queries.md:582
msgid "evaluates to"
msgstr "会求值为"

#: src/getting-to-know/evaluating.md:96
msgid ""
"```Lean\n"
"String.append \"it is \" (if false then \"yes\" else \"no\")\n"
"```"
msgstr ""
"```Lean\n"
"String.append \"it is \" (if false then \"yes\" else \"no\")\n"
"```"

#: src/getting-to-know/evaluating.md:99
msgid "which evaluates to"
msgstr "进而求值为"

#: src/getting-to-know/evaluating.md:100
msgid ""
"```lean\n"
"String.append \"it is \" \"no\"\n"
"```"
msgstr ""
"```lean\n"
"String.append \"it is \" \"no\"\n"
"```"

#: src/getting-to-know/evaluating.md:103
msgid "which finally evaluates to `\"it is no\"`."
msgstr "最终求值为 `\"it is no\"`。"

#: src/getting-to-know/evaluating.md:105
msgid ""
"For the sake of brevity, a series of evaluation steps like this will "
"sometimes be written with arrows between them:"
msgstr "为简洁起见，有时会用箭头表示一系列求值步骤："

#: src/getting-to-know/evaluating.md:106
msgid ""
"```lean\n"
"String.append \"it is \" (if 1 > 2 then \"yes\" else \"no\")\n"
"===>\n"
"String.append \"it is \" (if false then \"yes\" else \"no\")\n"
"===>\n"
"String.append \"it is \" \"no\"\n"
"===>\n"
"\"it is no\"\n"
"```"
msgstr ""
"```lean\n"
"String.append \"it is \" (if 1 > 2 then \"yes\" else \"no\")\n"
"===>\n"
"String.append \"it is \" (if false then \"yes\" else \"no\")\n"
"===>\n"
"String.append \"it is \" \"no\"\n"
"===>\n"
"\"it is no\"\n"
"```"

#: src/getting-to-know/evaluating.md:116
#: src/getting-to-know/functions-and-definitions.md:112
#: src/getting-to-know/polymorphism.md:466 src/props-proofs-indexing.md:254
#: src/type-classes/standard-classes.md:350 src/type-classes/coercion.md:402
msgid "Messages You May Meet"
msgstr "可能会遇到的信息"

#: src/getting-to-know/evaluating.md:118
msgid ""
"Asking Lean to evaluate a function application that is missing an argument "
"will lead to an error message. In particular, the example"
msgstr "让 Lean 对缺少参数的函数应用进行求值会产生错误信息。具体来说，例如"

#: src/getting-to-know/evaluating.md:120
msgid ""
"```lean\n"
"#eval String.append \"it is \"\n"
"```"
msgstr ""
"```lean\n"
"#eval String.append \"it is \"\n"
"```"

#: src/getting-to-know/evaluating.md:123
msgid "yields a quite long error message:"
msgstr "会产生一个很长的错误信息："

#: src/getting-to-know/evaluating.md:124
msgid ""
"```output error\n"
"expression\n"
"  String.append \"it is \"\n"
"has type\n"
"  String → String\n"
"but instance\n"
"  Lean.MetaEval (String → String)\n"
"failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class\n"
"```"
msgstr ""
"```output error\n"
"expression\n"
"  String.append \"it is \"\n"
"has type\n"
"  String → String\n"
"but instance\n"
"  Lean.MetaEval (String → String)\n"
"failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class\n"
"```"
"```output error\n"
"表达式\n"
"  String.append \"it is \"\n"
"类型为\n"
"  String → String\n"
"但实例\n"
"  Lean.MetaEval (String → String)\n"
"合成失败，此实例指示 Lean 如何显示结果值，回想一下任何实现了 `Repr` 类的类型也实现了 `Lean.MetaEval` 类\n"
"```"

#: src/getting-to-know/evaluating.md:134
msgid ""
"This message occurs because Lean functions that are applied to only some of "
"their arguments return new functions that are waiting for the rest of the "
"arguments. Lean cannot display functions to users, and thus returns an error"
" when asked to do so."
msgstr ""
"会出现此信息是因为在 Lean 中，仅接受了部分参数的函数会返回一个等待其余参数的新函数。Lean 无法向用户显示函数，因此在被要求这样做时会返回错误。"

#: src/getting-to-know/evaluating.md:138
#: src/getting-to-know/functions-and-definitions.md:87
#: src/getting-to-know/structures.md:318
#: src/getting-to-know/polymorphism.md:522 src/props-proofs-indexing.md:287
#: src/type-classes/pos.md:303 src/type-classes/polymorphism.md:127
#: src/type-classes/out-params.md:180 src/type-classes/standard-classes.md:365
#: src/monads/class.md:222 src/monads/arithmetic.md:646 src/monads/do.md:157
#: src/functor-applicative-monad/alternative.md:241
#: src/functor-applicative-monad/complete.md:152
#: src/monad-transformers/reader-io.md:381
#: src/monad-transformers/transformers.md:496
#: src/monad-transformers/order.md:135 src/monad-transformers/do.md:649
#: src/dependent-types/indexed-families.md:262
#: src/dependent-types/universe-pattern.md:325
#: src/dependent-types/typed-queries.md:738
#: src/dependent-types/pitfalls.md:470 src/tactics-induction-proofs.md:418
#: src/programs-proofs/tail-recursion.md:202
#: src/programs-proofs/arrays-termination.md:330
#: src/programs-proofs/inequalities.md:784
#: src/programs-proofs/insertion-sort.md:916
msgid "Exercises"
msgstr "练习"

#: src/getting-to-know/evaluating.md:140
msgid ""
"What are the values of the following expressions? Work them out by hand, "
"then enter them into Lean to check your work."
msgstr "以下表达式的值是什么？请手动计算，然后输入 Lean 来检查你的答案。"

#: src/getting-to-know/evaluating.md:143
msgid "`42 + 19`"
msgstr "`42 + 19`"

#: src/getting-to-know/evaluating.md:144
msgid "`String.append \"A\" (String.append \"B\" \"C\")`"
msgstr "`String.append \"A\" (String.append \"B\" \"C\")`"

#: src/getting-to-know/evaluating.md:145
msgid "`String.append (String.append \"A\" \"B\") \"C\"`"
msgstr "`String.append (String.append \"A\" \"B\") \"C\"`"

#: src/getting-to-know/evaluating.md:146
msgid "`if 3 == 3 then 5 else 7`"
msgid "`if 3 == 3 then 5 else 7`"

#: src/getting-to-know/evaluating.md:147
msgid "`if 3 == 4 then \"equal\" else \"not equal\"`"
msgid "`if 3 == 4 then \"equal\" else \"not equal\"`"

#: src/getting-to-know/types.md:3
msgid ""
"Types classify programs based on the values that they can compute. Types "
"serve a number of roles in a program:"
msgstr "类型根据程序可以计算的值对程序进行分类。类型在程序中扮演着多种角色："

#: src/getting-to-know/types.md:6
msgid ""
"They allow the compiler to make decisions about the in-memory representation"
" of a value."
msgstr "可以让编译器对值在内存中的表示做出决策。"

#: src/getting-to-know/types.md:9
msgid ""
"They help programmers to communicate their intent to others, serving as a "
"lightweight specification for the inputs and outputs of a function that the "
"compiler can ensure the program adheres to."
msgstr "帮助程序员向他人传达他们的意图，作为函数输入和输出的轻量级规范，编译器可以确保程序遵守该规范。"

#: src/getting-to-know/types.md:13
msgid ""
"They prevent various potential mistakes, such as adding a number to a "
"string, and thus reduce the number of tests that are necessary for a "
"program."
msgstr "防止各种潜在错误，例如将数字加到字符串上，从而减少程序所需的测试数量。"

#: src/getting-to-know/types.md:17
msgid ""
"They help the Lean compiler automate the production of auxiliary code that "
"can save boilerplate."
msgstr "帮助 Lean 编译器自动生成辅助代码，可以节省样板代码。"

#: src/getting-to-know/types.md:19
msgid ""
"Lean's type system is unusually expressive. Types can encode strong "
"specifications like \"this sorting function returns a permutation of its "
"input\" and flexible specifications like \"this function has different "
"return types, depending on the value of its argument\". The type system can "
"even be used as a full-blown logic for proving mathematical theorems. This "
"cutting-edge expressive power doesn't obviate the need for simpler types, "
"however, and understanding these simpler types is a prerequisite for using "
"the more advanced features."
msgstr ""
"Lean 的类型系统具有非同寻常的表现力。类型可以编码强规范，如「此排序函数返回其输入的排列」，以及灵活的规范，如「此函数具有不同的返回类型，具体取决于其参数的值」。类型系统甚至可以用作证明数学定理的完整逻辑系统。然而，这种尖端的表现力并不能消除对更简单类型的需求，理解这些更简单的类型是使用更高级功能的先决条件。"

#: src/getting-to-know/types.md:24
msgid ""
"Every program in Lean must have a type. In particular, every expression must"
" have a type before it can be evaluated. In the examples so far, Lean has "
"been able to discover a type on its own, but it is sometimes necessary to "
"provide one. This is done using the colon operator:"
msgstr ""
"Lean 中的每个程序都必须有一个类型。特别是，每个表达式在求值之前都必须具有类型。在迄今为止的示例中，Lean "
"已经能够自行发现类型，但有时也需要提供一个类型。这是使用冒号运算符完成的："

#: src/getting-to-know/types.md:34
msgid ""
"Here, `Nat` is the type of _natural numbers_, which are arbitrary-precision "
"unsigned integers. In Lean, `Nat` is the default type for non-negative "
"integer literals. This default type is not always the best choice. In C, "
"unsigned integers underflow to the largest representable numbers when "
"subtraction would otherwise yield a result less than zero. `Nat`, however, "
"can represent arbitrarily-large unsigned numbers, so there is no largest "
"number to underflow to. Thus, subtraction on `Nat` returns `0` when the "
"answer would have otherwise been negative. For instance,"
msgstr ""
"在这里，`Nat` 是**自然数**的类型，它们是任意精度的无符号整数。在 Lean 中，`Nat` "
"是非负整数字面量的默认类型。此默认类型并不总是最佳选择。在 C 中，当减法运算结果小于零时，无符号整数会下溢到最大的可表示数字。然而，`Nat` "
"可以表示任意大的无符号数字，因此没有最大的数字可以下溢到。因此，当答案原本为负数时，`Nat` 上的减法运算返回 `0`。例如，"

#: src/getting-to-know/types.md:46
msgid ""
"evaluates to `0` rather than `-1`. To use a type that can represent the "
"negative integers, provide it directly:"
msgstr "求值为 `0` 而非 `-1`。若要使用可以表示负整数的类型，请直接提供它："

#: src/getting-to-know/types.md:54
msgid "With this type, the result is `-1`, as expected."
msgstr "使用此类型，结果为 `-1`，符合预期。"

#: src/getting-to-know/types.md:56
msgid ""
"To check the type of an expression without evaluating it, use `#check` "
"instead of `#eval`. For instance:"
msgstr "若要检查表达式的类型而不求值，请使用 `#check` 而不是 `#eval`。例如："

#: src/getting-to-know/types.md:63
msgid "reports `1 - 2 : Int` without actually performing the subtraction."
msgstr "报告 `1 - 2 : Int` 而不会实际执行减法运算。"

#: src/getting-to-know/types.md:65
msgid ""
"When a program can't be given a type, an error is returned from both "
"`#check` and `#eval`. For instance:"
msgstr "当无法为程序指定类型时，`#check` 和 `#eval` 都会返回错误。例如："

#: src/getting-to-know/types.md:68
msgid ""
"```lean\n"
"#check String.append \"hello\" [\" \", \"world\"]\n"
"```"
msgstr ""
"```lean\n"
"#check String.append \"hello\" [\" \", \"world\"]\n"
"```"

#: src/getting-to-know/types.md:72
#: src/getting-to-know/functions-and-definitions.md:26
#: src/programs-proofs/fin.md:48 src/programs-proofs/fin.md:56
msgid "outputs"
msgstr "会输出"

#: src/getting-to-know/types.md:74
msgid ""
"```output error\n"
"application type mismatch\n"
"  String.append \"hello\" [\" \", \"world\"]\n"
"argument\n"
"  [\" \", \"world\"]\n"
"has type\n"
"  List String : Type\n"
"but is expected to have type\n"
"  String : Type\n"
"```"
msgstr ""
"```output error\n"
"application type mismatch\n"
"  String.append \"hello\" [\" \", \"world\"]\n"
"argument\n"
"  [\" \", \"world\"]\n"
"has type\n"
"  List String : Type\n"
"but is expected to have type\n"
"  String : Type\n"
"```"
"```output error\n"
"应用程序类型不匹配\n"
"  String.append \"hello\" [\" \", \"world\"]\n"
"参数\n"
"  [\" \", \"world\"]\n"
"类型为\n"
"  List String : Type\n"
"但预期类型为\n"
"  String : Type\n"
"```"

#: src/getting-to-know/types.md:85
msgid ""
"because the second argument to `String.append` is expected to be a string, "
"but a list of strings was provided instead."
msgstr "因为 `String.append` 的第二个参数应为字符串，但提供的是字符串列表。"

#: src/getting-to-know/functions-and-definitions.md:3
msgid ""
"In Lean, definitions are introduced using the `def` keyword. For instance, "
"to define the name `hello` to refer to the string `\"Hello\"`, write:"
msgstr "在 Lean 中，使用 `def` 关键字引入定义。例如，若要定义名称 `hello` 来引用字符串 `\"Hello\"`，请编写："

#: src/getting-to-know/functions-and-definitions.md:5
msgid ""
"```lean\n"
"def hello := \"Hello\"\n"
"```"
msgstr ""
"```lean\n"
"def hello := \"Hello\"\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:9
msgid ""
"In Lean, new names are defined using the colon-equal operator`:=` rather "
"than `=`. This is because `=` is used to describe equalities between "
"existing expressions, and using two different operators helps prevent "
"confusion."
msgstr ""
"在 Lean 中，使用冒号加等号运算符 `:=` 而不是 `=` 来定义新名称。这是因为 `=` "
"用于描述现有表达式之间的相等性，而使用两个不同的运算符有助于防止混淆。"

#: src/getting-to-know/functions-and-definitions.md:14
msgid ""
"In the definition of `hello`, the expression `\"Hello\"` is simple enough "
"that Lean is able to determine the definition's type automatically. However,"
" most definitions are not so simple, so it will usually be necessary to add "
"a type. This is done using a colon after the name being defined."
msgstr ""
"在 `hello` 的定义中，表达式 `\"Hello\"` 足够简单，Lean "
"能够自动确定定义的类型。但是，大多数定义并不那么简单，因此通常需要添加类型。这可以通过在要定义的名称后使用冒号来完成。"

#: src/getting-to-know/functions-and-definitions.md:18
msgid ""
"```lean\n"
"def lean : String := \"Lean\"\n"
"```"
msgstr ""
"```Lean\n"
"def lean : String := \"Lean\"\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:22
msgid "Now that the names have been defined, they can be used, so"
msgstr "现在已经定义了名称，就可以使用它们了，因此"

#: src/getting-to-know/functions-and-definitions.md:23
msgid ""
"```Lean\n"
"#eval String.append hello (String.append \" \" lean)\n"
"```"
msgstr ""
"```Lean\n"
"#eval String.append hello (String.append \" \" lean)\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:27
msgid ""
"```Lean info\n"
"\"Hello Lean\"\n"
"```"
msgstr ""
"```Lean info\n"
"\"Hello Lean\"\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:30
msgid "In Lean, defined names may only be used after their definitions."
msgstr "在 Lean 中，定义的名称只能在其定义之后使用。"

#: src/getting-to-know/functions-and-definitions.md:32
msgid ""
"In many languages, definitions of functions use a different syntax than "
"definitions of other values. For instance, Python function definitions begin"
" with the `def` keyword, while other definitions are defined with an equals "
"sign. In Lean, functions are defined using the same `def` keyword as other "
"values. Nonetheless, definitions such as `hello` introduce names that refer "
"_directly_ to their values, rather than to zero-argument functions that "
"return equivalent results each time they are called."
msgstr ""
"在许多语言中，函数定义的语法与其他值的不同。例如，Python 函数定义以 `def` 关键字开头，而其他定义则以等号定义。在 Lean "
"中，函数使用与其他值相同的 `def` 关键字定义。尽管如此，像 `hello` 这类的定义"
"引入的名字会**直接**引用其值，而非每次调用一个零参函数返回等价的值。"

#: src/getting-to-know/functions-and-definitions.md:37
msgid "Defining Functions"
msgstr "定义函数"

#: src/getting-to-know/functions-and-definitions.md:39
msgid ""
"There are a variety of ways to define functions in Lean. The simplest is to "
"place the function's arguments before the definition's type, separated by "
"spaces. For instance, a function that adds one to its argument can be "
"written:"
msgstr ""
"在 Lean 中有各种方法可以定义函数。最简单的方法是在定义的类型之前放置函数的参数，并用空格分隔。例如，可以编写一个将其参数加 1 的函数："

#: src/getting-to-know/functions-and-definitions.md:45
msgid "Testing this function with `#eval` gives `8`, as expected:"
msgstr "测试此函数时，`#eval` 给出了 `8`，符合预期："

#: src/getting-to-know/functions-and-definitions.md:51
msgid ""
"Just as functions are applied to multiple arguments by writing spaces "
"between each argument, functions that accept multiple arguments are defined "
"with spaces between the arguments' names and types. The function `maximum`, "
"whose result is equal to the greatest of its two arguments, takes two `Nat` "
"arguments `n` and `k` and returns a `Nat`."
msgstr ""
"就像通过在每个参数之间写空格来将函数应用于多个参数一样，接受多个参数的函数定义是在参数名称和类型之间用空格分隔。函数 `maximum` "
"的结果等于其两个参数中最大的一个，它接受两个 `Nat` 参数 `n` 和 `k`，并返回一个 `Nat`。"

#: src/getting-to-know/functions-and-definitions.md:60
msgid ""
"When a defined function like `maximum` has been provided with its arguments,"
" the result is determined by first replacing the argument names with the "
"provided values in the body, and then evaluating the resulting body. For "
"example:"
msgstr "当像 `maximum` 这样的已定义函数被提供其参数时，其结果为首先用提供的值替换函数体中对应的参数名称，然后对产生的函数体求值。例如："

#: src/getting-to-know/functions-and-definitions.md:71
msgid ""
"Expressions that evaluate to natural numbers, integers, and strings have "
"types that say this (`Nat`, `Int`, and `String`, respectively). This is also"
" true of functions. A function that accepts a `Nat` and returns a `Bool` has"
" type `Nat → Bool`, and a function that accepts two `Nat`s and returns a "
"`Nat` has type `Nat → Nat → Nat`."
msgstr ""
"求值结果为自然数、整数和字符串的表达式具有表示它们的类型（分别为 `Nat`、`Int` 和 `String`）。函数也是如此。接受一个 `Nat` "
"并返回一个 `Bool` 的函数的类型为 `Nat → Bool`，接受两个 `Nat` 并返回一个 `Nat` 的函数的类型为 `Nat → Nat → Nat`。"

#: src/getting-to-know/functions-and-definitions.md:75
msgid ""
"As a special case, Lean returns a function's signature when its name is used"
" directly with `#check`. Entering `#check add1` yields `add1 (n : Nat) : "
"Nat`. However, Lean can be \"tricked\" into showing the function's type by "
"writing the function's name in parentheses, which causes the function to be "
"treated as an ordinary expression, so `#check (add1)` yields `add1 : Nat → "
"Nat` and `#check (maximum)` yields `maximum : Nat → Nat → Nat`. This arrow "
"can also be written with an ASCII alternative arrow `->`, so the preceding "
"function types can be written `Nat -> Nat` and `Nat -> Nat -> Nat`, "
"respectively."
msgstr ""
"作为一个特例，当函数的名称直接与 `#check` 一起使用时，Lean 会返回函数的签名。输入 `#check add1` 会产生 `add1 (n "
": Nat) : Nat`。但是，可以通过用括号括住函数名称来「欺骗」 Lean 显示函数的类型，这会导致函数被视为一个普通表达式，所以 `#check"
" (add1)` 会产生 `add1 : Nat → Nat`，而 `#check (maximum)` 会产生 `maximum : Nat → "
"Nat → Nat`。此箭头也可以用 ASCII 替代箭头 `->` 来写，因此前面的函数类型可以分别写成 `Nat -> Nat` 和 `Nat ->"
" Nat -> Nat`。"

#: src/getting-to-know/functions-and-definitions.md:80
msgid ""
"Behind the scenes, all functions actually expect precisely one argument. "
"Functions like `maximum` that seem to take more than one argument are in "
"fact functions that take one argument and then return a new function. This "
"new function takes the next argument, and the process continues until no "
"more arguments are expected. This can be seen by providing one argument to a"
" multiple-argument function: `#check maximum 3` yields `maximum 3 : Nat → "
"Nat` and `#check String.append \"Hello \"` yields `String.append \"Hello \" "
": String → String`. Using a function that returns a function to implement "
"multiple-argument functions is called _currying_ after the mathematician "
"Haskell Curry. Function arrows associate to the right, which means that `Nat"
" → Nat → Nat` should be parenthesized `Nat → (Nat → Nat)`."
msgstr ""
"在幕后，所有函数实际上都刚好期望一个参数。像 `maximum` "
"这样的函数看起来需要多个参数，但实际上它们时接受一个参数并返回一个新的函数。这个新函数接受下一个参数，一直持续到不再需要更多参数。可以通过向一个多参数函数提供一个参数来看到这一点：`#check"
" maximum 3` 会生成 `maximum 3 : Nat → Nat`，而 `#check String.append \"Hello \"` "
"会生成 `String.append \"Hello \" : String → String`。使用返回函数的函数来实现多参数函数被称为 "
"**柯里化（Currying）**，以数学家哈斯克尔·柯里（Haskell Curry）命名。函数箭头是右结合的，这意味着 `Nat → Nat → Nat` 等价于 `Nat → (Nat → Nat)`。"

#: src/getting-to-know/functions-and-definitions.md:89
msgid ""
"Define the function `joinStringsWith` with type `String -> String -> String "
"-> String` that creates a new string by placing its first argument between "
"its second and third arguments. `joinStringsWith \", \" \"one\" \"and "
"another\"` should evaluate to `\"one, and another\"`."
msgstr ""
"定义函数 `joinStringsWith`，类型为 `String -> String -> String -> "
"String`，它通过将第一个参数放在第二个和第三个参数之间来创建一个新字符串。`joinStringsWith \", \" \"one\" "
"\"and another\"` 会求值为 `\"one, and another\"`。"

#: src/getting-to-know/functions-and-definitions.md:90
msgid "What is the type of `joinStringsWith \": \"`? Check your answer with Lean."
msgstr "`joinStringsWith \": \"` 的类型是什么？用 Lean 检查你的答案。"

#: src/getting-to-know/functions-and-definitions.md:91
msgid ""
"Define a function `volume` with type `Nat → Nat → Nat → Nat` that computes "
"the volume of a rectangular prism with the given height, width, and depth."
msgstr "定义一个函数 `volume`，类型为 `Nat → Nat → Nat → Nat`，它计算给定高度、宽度和深度的矩形棱柱的体积。"

#: src/getting-to-know/functions-and-definitions.md:93
msgid "Defining Types"
msgstr "定义类型"

#: src/getting-to-know/functions-and-definitions.md:95
msgid ""
"Most typed programming languages have some means of defining aliases for "
"types, such as C's `typedef`. In Lean, however, types are a first-class part"
" of the language - they are expressions like any other. This means that "
"definitions can refer to types just as well as they can refer to other "
"values."
msgstr ""
"大多数类型化编程语言都有一些方法来定义类型的别名，例如 C 语言的 `typedef`。然而，在 Lean "
"中，类型是语言的一等部分——它们与其他任何表达式一样都是表达式。这意味着定义可以引用类型，就像它们可以引用其他值一样。"

#: src/getting-to-know/functions-and-definitions.md:99
msgid ""
"For instance, if `String` is too much to type, a shorter abbreviation `Str` "
"can be defined:"
msgstr "例如，如果 `String` 输入起来太长，可以定义一个较短的缩写 `Str`："

#: src/getting-to-know/functions-and-definitions.md:103
msgid ""
"It is then possible to use `Str` as a definition's type instead of `String`:"
msgstr "然后就可以使用 `Str` 作为定义的类型，而非 `String`："

#: src/getting-to-know/functions-and-definitions.md:104
msgid ""
"```lean\n"
"def aStr : Str := \"This is a string.\"\n"
"```"
msgstr ""
"```lean\n"
"def aStr : Str := \"这是一个字符串。\"\n"
"```"

#: src/getting-to-know/functions-and-definitions.md:108
msgid ""
"The reason this works is that types follow the same rules as the rest of "
"Lean. Types are expressions, and in an expression, a defined name can be "
"replaced with its definition. Because `Str` has been defined to mean "
"`String`, the definition of `aStr` makes sense."
msgstr ""
"之所以可行，是因为类型遵循与 Lean 其他部分相同的规则。类型是表达式，在表达式中，已定义的名称可以用其定义替换。由于 `Str` 已被定义为 "
"`String`，因此 `aStr` 的定义是有意义的。"

#: src/getting-to-know/functions-and-definitions.md:114
msgid ""
"Experimenting with using definitions for types is made more complicated by "
"the way that Lean supports overloaded integer literals. If `Nat` is too "
"short, a longer name `NaturalNumber` can be defined:"
msgstr ""
"由于 Lean 支持重载整数字面量，因此使用定义作为类型进行实验会变得更加复杂。如果 `Nat` 太短，可以定义一个较长的名称 "
"`NaturalNumber`："

#: src/getting-to-know/functions-and-definitions.md:119
msgid ""
"However, using `NaturalNumber` as a definition's type instead of `Nat` does "
"not have the expected effect. In particular, the definition:"
msgstr "但是，使用 `NaturalNumber` 作为定义的类型而非 `Nat` 并没有预期的效果。特别是，定义："

#: src/getting-to-know/functions-and-definitions.md:124
#: src/type-classes/standard-classes.md:357
msgid "results in the following error:"
msgstr "会导致以下错误："

#: src/getting-to-know/functions-and-definitions.md:130
msgid ""
"This error occurs because Lean allows number literals to be _overloaded_. "
"When it makes sense to do so, natural number literals can be used for new "
"types, just as if those types were built in to the system. This is part of "
"Lean's mission of making it convenient to represent mathematics, and "
"different branches of mathematics use number notation for very different "
"purposes. The specific feature that allows this overloading does not replace"
" all defined names with their definitions before looking for overloading, "
"which is what leads to the error message above."
msgstr ""
"出现此错误是因为 Lean 允许数字字面量被**重载（Overload）**。当有意义时，自然数字面量可用于新类型，就像这些类型内置于系统中一样。这是 Lean "
"使得表示数学变得方便的一部分，并且数学的不同分支将数字符号用于完全不同的目的。允许这种重载的特定功能不会在查找重载之前用其定义替换所有已定义的名称，这正是导致上述错误消息的原因。"

#: src/getting-to-know/functions-and-definitions.md:135
msgid ""
"One way to work around this limitation is by providing the type `Nat` on the"
" right-hand side of the definition, causing `Nat`'s overloading rules to be "
"used for `38`:"
msgstr "解决此限制的一种方法是在定义的右侧提供类型 `Nat`，从而导致 `Nat` 的重载规则用于 `38`："

#: src/getting-to-know/functions-and-definitions.md:139
msgid ""
"The definition is still type-correct because `NaturalNumber` is the same "
"type as `Nat`—by definition!"
msgstr "定义仍然类型正确，因为根据定义，`NaturalNumber` 与 `Nat` 是同一种类型！"

#: src/getting-to-know/functions-and-definitions.md:141
msgid ""
"Another solution is to define an overloading for `NaturalNumber` that works "
"equivalently to the one for `Nat`. This requires more advanced features of "
"Lean, however."
msgstr ""
"另一种解决方案是为 `NaturalNumber` 定义一个重载，其作用等同于 `Nat` 的重载。然而，这需要 Lean 的更多高级特性。"

#: src/getting-to-know/functions-and-definitions.md:144
msgid ""
"Finally, defining the new name for `Nat` using `abbrev` instead of `def` "
"allows overloading resolution to replace the defined name with its "
"definition. Definitions written using `abbrev` are always unfolded. For "
"instance,"
msgstr ""
"最后，使用 `abbrev` 而非 `def` 为 `Nat` 定义新名称，能够允许重载解析用其定义替换定义的名称。使用 `abbrev` "
"编写的定义总是会展开。例如，"

#: src/getting-to-know/functions-and-definitions.md:150
#: src/hello-world/step-by-step.md:79 src/monads/io.md:30
msgid "and"
msgstr "和"

#: src/getting-to-know/functions-and-definitions.md:154
msgid "are accepted without issue."
msgstr "会被接受且没有问题。"

#: src/getting-to-know/functions-and-definitions.md:156
msgid ""
"Behind the scenes, some definitions are internally marked as being "
"unfoldable during overload resolution, while others are not. Definitions "
"that are to be unfolded are called _reducible_. Control over reducibility is"
" essential to allow Lean to scale: fully unfolding all definitions can "
"result in very large types that are slow for a machine to process and "
"difficult for users to understand. Definitions produced with `abbrev` are "
"marked as reducible."
msgstr ""
"在幕后，一些定义在重载解析期间被内部标记为可展开的，而另一些则不被标记。要展开的定义称为**可约的（Reducible）**。对可约性的控制对于允许 Lean "
"的扩展性至关重要：完全展开所有定义可能会产生非常大的类型，这对于机器处理和用户理解来说都很困难。使用 `abbrev` 生成的定义被标记为可约的。"

#: src/getting-to-know/structures.md:3
msgid ""
"The first step in writing a program is usually to identify the problem "
"domain's concepts, and then find suitable representations for them in code. "
"Sometimes, a domain concept is a collection of other, simpler, concepts. In "
"that case, it can be convenient to group these simpler components together "
"into a single \"package\", which can then be given a meaningful name. In "
"Lean, this is done using _structures_, which are analogous to `struct`s in C"
" or Rust and `record`s in C#."
msgstr ""
"编写程序的第一步通常是找出问题域中的概念，然后用合适的代码表示它们。有时，一个域概念是其他更简单概念的集合。此时，将这些更简单的组件分组到一个「包」中会很方便，然后可以给它取一个有意义的名称。在"
" Lean 中，这是使用**结构体（Structure）**完成的，它类似于 C 或 Rust 中的 `struct` 和 C# 中的 `record`。"

#: src/getting-to-know/structures.md:8
#, fuzzy
msgid ""
"Defining a structure introduces a completely new type to Lean that can't be "
"reduced to any other type. This is useful because multiple structures might "
"represent different concepts that nonetheless contain the same data. For "
"instance, a point might be represented using either Cartesian or polar "
"coordinates, each being a pair of floating-point numbers. Defining separate "
"structures prevents API clients from confusing one for another."
msgstr ""
"定义一个结构体会向 Lean "
"引入一个全新的类型，该类型不能简化为任何其他类型。这很有用，因为多个结构体可能表示不同的概念，但它们包含相同的数据。例如，一个点可以用笛卡尔坐标或极坐标表示，每个都是一对浮点数。定义单独的结构体可以防止"
" API 客户端将一个与另一个混淆。"

#: src/getting-to-know/structures.md:13
msgid ""
"Lean's floating-point number type is called `Float`, and floating-point "
"numbers are written in the usual notation."
msgstr "Lean 的浮点数类型称为 `Float`，浮点数采用通常的表示法。"

#: src/getting-to-know/structures.md:32
msgid ""
"When floating point numbers are written with the decimal point, Lean will "
"infer the type `Float`. If they are written without it, then a type "
"annotation may be necessary."
msgstr "当浮点数使用小数点书写时，Lean 会推断类型 `Float`。如果不用小数点书写，则可能需要类型标注。"

#: src/getting-to-know/structures.md:48
msgid ""
"A Cartesian point is a structure with two `Float` fields, called `x` and "
"`y`. This is declared using the `structure` keyword."
msgstr "笛卡尔点是一个结构体，有两个 `Float` 字段，称为 `x` 和 `y`，它使用 `structure` 关键字声明。"

#: src/getting-to-know/structures.md:58
msgid ""
"After this declaration, `Point` is a new structure type. The final line, "
"which says `deriving Repr`, asks Lean to generate code to display values of "
"type `Point`. This code is used by `#eval` to render the result of "
"evaluation for consumption by programmers, analogous to the `repr` function "
"in Python. It is also possible to override the compiler's generated display "
"code."
msgstr ""
"声明之后，`Point` 就是一个新的结构体类型。最后一行写着 `deriving Repr`，要求 Lean 生成代码以显示类型为 `Point` "
"的值。此代码由 `#eval` 用于呈现求值结果供程序员使用，类似于 Python 中的 `repr` 函数。还可以覆盖编译器生成的显示代码。"

#: src/getting-to-know/structures.md:63
msgid ""
"The typical way to create a value of a structure type is to provide values "
"for all of its fields inside of curly braces. The origin of a Cartesian "
"plane is where `x` and `y` are both zero:"
msgstr "创建结构体类型值通常的方法是在大括号内为其所有字段提供值。笛卡尔平面的原点是 `x` 和 `y` 均为零的位置："

#: src/getting-to-know/structures.md:70
msgid ""
"If the `deriving Repr` line in `Point`'s definition were omitted, then "
"attempting `#eval origin` would yield an error similar to that which occurs "
"when omitting a function's argument:"
msgstr ""
"如果 `Point` 定义中的 `deriving Repr` 行被省略，则尝试 `#eval origin` 会产生类似于省略函数参数时发生的错误："

#: src/getting-to-know/structures.md:80
msgid ""
"That message is saying that the evaluation machinery doesn't know how to "
"communicate the result of evaluation back to the user."
msgstr "该消息表明求值机制不知道如何将求值结果传达给用户。"

#: src/getting-to-know/structures.md:82
msgid ""
"Happily, with `deriving Repr`, the result of `#eval origin` looks very much "
"like the definition of `origin`."
msgstr "幸运的是，使用 `deriving Repr`，`#eval origin` 的结果看起来非常像 `origin` 的定义。"

#: src/getting-to-know/structures.md:87
msgid ""
"Because structures exist to \"bundle up\" a collection of data, naming it "
"and treating it as a single unit, it is also important to be able to extract"
" the individual fields of a structure. This is done using dot notation, as "
"in C, Python, or Rust."
msgstr ""
"由于结构体是用来「捆绑」一组数据，并将其命名并后作为单个单元进行处理的，因此能够提取结构体的各个字段也很重要。这可以使用点记法，就像在 C、Python 或 Rust 中一样。"

#: src/getting-to-know/structures.md:104
msgid ""
"This can be used to define functions that take structures as arguments. For "
"instance, addition of points is performed by adding the underlying "
"coordinate values. It should be the case that `#eval addPoints { x := 1.5, y"
" := 32 } { x := -8, y := 0.2 }` yields"
msgstr ""
"可以定义以结构体作为参数的函数。例如，点的加法可通过底层坐标值相加来执行。`#eval addPoints { x := 1.5, y := 32 } { "
"x := -8, y := 0.2 }` 会产生"

#: src/getting-to-know/structures.md:110
msgid ""
"The function itself takes two `Points` as arguments, called `p1` and `p2`. "
"The resulting point is based on the `x` and `y` fields of both `p1` and "
"`p2`:"
msgstr ""
"函数本身以两个 `Points` 作为参数，分别为 `p1` 和 `p2`。结果点基于 `p1` 和 `p2` 的 `x` 和 `y` 字段："

#: src/getting-to-know/structures.md:117
msgid ""
"Similarly, the distance between two points, which is the square root of the "
"sum of the squares of the differences in their `x` and `y` components, can "
"be written:"
msgstr "类似地，两点之间的距离（即其 `x` 和 `y` 分量差的平方和的平方根）可以写成："

#: src/getting-to-know/structures.md:122
msgid "For example, the distance between (1, 2) and (5, -1) is 5:"
msgstr "例如，(1, 2) 和 (5, -1) 之间的距离为 5："

#: src/getting-to-know/structures.md:131
msgid ""
"Multiple structures may have fields with the same names. For instance, a "
"three-dimensional point datatype may share the fields `x` and `y`, and be "
"instantiated with the same field names:"
msgstr "不同结构体可能具有同名的字段。例如，三维点数据类型可能共享字段 `x` 和 `y`，并使用相同的字段名进行实例化："

#: src/getting-to-know/structures.md:142
msgid ""
"This means that the structure's expected type must be known in order to use "
"the curly-brace syntax. If the type is not known, Lean will not be able to "
"instantiate the structure. For instance,"
msgstr "这意味着必须知道结构体的预期类型才能使用大括号语法。如果类型未知，Lean 将无法实例化结构体。例如，"

#: src/getting-to-know/structures.md:148
msgid "leads to the error"
msgstr "会导致错误"

#: src/getting-to-know/structures.md:153
msgid ""
"As usual, the situation can be remedied by providing a type annotation."
msgstr "通常，可以通过提供类型标注来补救这种情况。"

#: src/getting-to-know/structures.md:161
msgid ""
"To make programs more concise, Lean also allows the structure type "
"annotation inside the curly braces."
msgstr "为了使程序更简洁，Lean 还允许在大括号内进行结构体类型标注。"

#: src/getting-to-know/structures.md:169
msgid "Updating Structures"
msgstr "更新结构体"

#: src/getting-to-know/structures.md:171
msgid ""
"Imagine a function `zeroX` that replaces the `x` field of a `Point` with "
"`0.0`. In most programming language communities, this sentence would mean "
"that the memory location pointed to by `x` was to be overwritten with a new "
"value. However, Lean does not have mutable state. In functional programming "
"communities, what is almost always meant by this kind of statement is that a"
" fresh `Point` is allocated with the `x` field pointing to the new value, "
"and all other fields pointing to the original values from the input. One way"
" to write `zeroX` is to follow this description literally, filling out the "
"new value for `x` and manually transferring `y`:"
msgstr ""
"设想一个函数 `zeroX`，它将 `Point` 的 `x` 字段替换为 `0.0`。在大多数编程语言社区中，这句话意味着指向 `x` "
"的内存位置将被新值覆盖。但是，Lean 没有可变状态。在函数式编程社区中，这种说法几乎总是意味着分配一个新的 `Point`，其 `x` "
"字段指向新值，而所有其他字段指向输入中的原始值。编写 `zeroX` 的一种方法是逐字遵循此描述，填写 `x` 的新值并手动传入 `y`："

#: src/getting-to-know/structures.md:180
msgid ""
"This style of programming has drawbacks, however. First off, if a new field "
"is added to a structure, then every site that updates any field at all must "
"be updated, causing maintenance difficulties. Secondly, if the structure "
"contains multiple fields with the same type, then there is a real risk of "
"copy-paste coding leading to field contents being duplicated or switched. "
"Finally, the program becomes long and bureaucratic."
msgstr ""
"然而，这种编程风格也存在一些缺点。首先，如果向结构体中添加了一个新字段，那么所有更新任何字段的代码都需要更新，这会导致维护困难。其次，如果结构体中包含多个具有相同类型的字段，那么存在真正的风险，即复制粘贴代码会导致字段内容被复制或交换。最后，程序变得冗长且呆板。"

#: src/getting-to-know/structures.md:185
msgid ""
"Lean provides a convenient syntax for replacing some fields in a structure "
"while leaving the others alone. This is done by using the `with` keyword in "
"a structure initialization. The source of unchanged fields occurs before the"
" `with`, and the new fields occur after. For instance, `zeroX` can be "
"written with only the new `x` value:"
msgstr ""
"Lean 提供了一种便捷的语法，用于替换结构体中的一些字段，同时保留其他字段。这是通过在结构体初始化中使用 `with` "
"关键字来完成的。未更改字段的源代码写在 `with` 之前，而新字段写在 `with` 之后。例如，`zeroX` 可以仅使用新的 `x` 值编写："

#: src/getting-to-know/structures.md:195
msgid ""
"Remember that this structure update syntax does not modify existing "
"values—it creates new values that share some fields with old values. For "
"instance, given the point `fourAndThree`:"
msgstr "请记住，此结构体更新语法不会修改现有值，它会创建一些与旧值共享某些字段的新值。例如，给定点 `fourAndThree`："

#: src/getting-to-know/structures.md:201
msgid ""
"evaluating it, then evaluating an update of it using `zeroX`, then "
"evaluating it again yields the original value:"
msgstr "对其进行求值，然后使用 `zeroX` 对其进行更新，然后再次对其进行求值，将产生原始值："

#: src/getting-to-know/structures.md:221
msgid ""
"One consequence of the fact that structure updates do not modify the "
"original structure is that it becomes easier to reason about cases where the"
" new value is computed from the old one. All references to the old structure"
" continue to refer to the same field values in all of the new values "
"provided."
msgstr ""
"结构体更新不会修改原始结构体，这样更容易推理新值是从旧值计算得出的情况。对旧结构体的所有引用会在所有提供的新值中继续引用相同的字段值。"

#: src/getting-to-know/structures.md:227
msgid "Behind the Scenes"
msgstr "幕后"

#: src/getting-to-know/structures.md:229
msgid ""
"Every structure has a _constructor_. Here, the term \"constructor\" may be a"
" source of confusion. Unlike constructors in languages such as Java or "
"Python, constructors in Lean are not arbitrary code to be run when a "
"datatype is initialized. Instead, constructors simply gather the data to be "
"stored in the newly-allocated data structure. It is not possible to provide "
"a custom constructor that pre-processes data or rejects invalid arguments. "
"This is really a case of the word \"constructor\" having different, but "
"related, meanings in the two contexts."
msgstr ""
"每个结构体都有一个**构造子（Constructor）**。此处，「Constructor」一词在英文中可能会引起混淆。与 Java 或 Python 等语言中的构造函数不同，Lean "
"中的构造子不是在初始化数据类型时运行的任意代码。相反，构造子只是收集要存储在新分配的数据结构体中的数据。不可能提供一个预处理数据或拒绝无效参数的自定义构造子。这实际上是「Constructor」一词在两种情况下具有不同但相关的含义的情况。"

#: src/getting-to-know/structures.md:237
msgid ""
"By default, the constructor for a structure named `S` is named `S.mk`. Here,"
" `S` is a namespace qualifier, and `mk` is the name of the constructor "
"itself. Instead of using curly-brace initialization syntax, the constructor "
"can also be applied directly."
msgstr ""
"默认情况下，名为 `S` 的结构体的构造子命名为 `S.mk`。其中，`S` 是命名空间限定符，`mk` "
"是构造子本身的名称。除了使用大括号初始化语法，还可以直接应用构造子。"

#: src/getting-to-know/structures.md:243
msgid ""
"However, this is not generally considered to be good Lean style, and Lean "
"even returns its feedback using the standard structure initializer syntax."
msgstr "但是，这通常不被认为是良好的 Lean 风格，Lean 甚至使用标准结构体初始化语法返回其结果。"

#: src/getting-to-know/structures.md:248
msgid ""
"Constructors have function types, which means they can be used anywhere that"
" a function is expected. For instance, `Point.mk` is a function that accepts"
" two `Float`s (respectively `x` and `y`) and returns a new `Point`."
msgstr ""
"构造子具有函数类型，这意味着它们可以在需要函数的任何地方使用。例如，`Point.mk` 是一个接受两个 `Float`（分别是 `x` 和 "
"`y`）并返回一个新 `Point` 的函数。"

#: src/getting-to-know/structures.md:256
msgid ""
"To override a structure's constructor name, write it with two colons at the "
"beginning. For instance, to use `Point.point` instead of `Point.mk`, write:"
msgstr "要覆盖结构体的构造子名称，请在开头写出新的名称后跟两个冒号。例如，要使用 `Point.point` 而不是 `Point.mk`，请编写："

#: src/getting-to-know/structures.md:266
msgid ""
"In addition to the constructor, an accessor function is defined for each "
"field of a structure. These have the same name as the field, in the "
"structure's namespace. For `Point`, accessor functions `Point.x` and "
"`Point.y` are generated."
msgstr ""
"除了构造子，结构体的每个字段还定义了一个访问器函数。它们在结构体的命名空间中与字段具有相同的名称。对于 `Point`，会生成访问器函数 `Point.x` 和 `Point.y`。"

#: src/getting-to-know/structures.md:283
msgid ""
"In fact, just as the curly-braced structure construction syntax is converted"
" to a call to the structure's constructor behind the scenes, the syntax "
"`p1.x` in the prior definition of `addPoints` is converted into a call to "
"the `Point.x` accessor. That is, `#eval origin.x` and `#eval Point.x origin`"
" both yield"
msgstr ""
"实际上，就像大括号结构体构造语法会在幕后转换为对结构体构造子的调用一样，`addPoints` 中先前定义中的语法 `p1.x` 会被转换为对 `Point.x` 访问器的调用。也就是说，`#eval origin.x` 和 `#eval Point.x origin` 都会产生"

#: src/getting-to-know/structures.md:289
msgid ""
"Accessor dot notation is usable with more than just structure fields. It can"
" also be used for functions that take any number of arguments. More "
"generally, accessor notation has the form `TARGET.f ARG1 ARG2 ...`. If "
"`TARGET` has type `T`, the function named `T.f` is called. `TARGET` becomes "
"its leftmost argument of type `T`, which is often but not always the first "
"one, and `ARG1 ARG2 ...` are provided in order as the remaining arguments. "
"For instance, `String.append` can be invoked from a string with accessor "
"notation, even though `String` is not a structure with an `append` field."
msgstr ""
"访问器的点记法不仅可以与结构体字段一起使用。它还可以用于接受任意数量参数的函数。更一般地说，访问器记法具有以下形式：`TARGET.f ARG1 "
"ARG2 ...`。如果 `TARGET` 的类型为 `T`，则调用名为 `T.f` 的函数。`TARGET` 是其类型为 `T` "
"的最左边的参数，它通常但并非总是第一个参数，并且 `ARG1 ARG2 ...` 按顺序作为其余参数提供。例如，即使 `String` 不是具有 "
"`append` 字段的结构体，也可以使用访问器记法从字符串中调用 `String.append`。"

#: src/getting-to-know/structures.md:295
msgid ""
"```lean\n"
"#eval \"one string\".append \" and another\"\n"
"```"
msgstr ""
"```lean\n"
"#eval \"一个字符串\".append \"和另一个\"\n"
"```"

#: src/getting-to-know/structures.md:298
msgid ""
"```output info\n"
"\"one string and another\"\n"
"```"
msgstr ""
"```output info\n"
"\"一个字符串和另一个\"\n"
"```"

#: src/getting-to-know/structures.md:301
msgid ""
"In that example, `TARGET` represents `\"one string\"` and `ARG1` represents "
"`\" and another\"`."
msgstr "在该示例中，`TARGET` 表示 `\"一个字符串\"`，`ARG1` 表示 `\"和另一个\"`。"

#: src/getting-to-know/structures.md:303
msgid ""
"The function `Point.modifyBoth` (that is, `modifyBoth` defined in the "
"`Point` namespace) applies a function to both fields in a `Point`:"
msgstr ""
"`Point.modifyBoth` 函数（即在 `Point` 命名空间中定义的 `modifyBoth`）将一个函数应用于 `Point` "
"中的两个字段："

#: src/getting-to-know/structures.md:308
msgid ""
"Even though the `Point` argument comes after the function argument, it can "
"be used with dot notation as well:"
msgstr "即使 `Point` 参数位于函数参数之后，也可以使用点记法："

#: src/getting-to-know/structures.md:315
#, fuzzy
msgid ""
"In this case, `TARGET` represents `fourAndThree`, while `ARG1` is "
"`Float.floor`. This is because the target of the accessor notation is used "
"as the first argument in which the type matches, not necessarily the first "
"argument."
msgstr ""
"在这种情况下，`TARGET` 表示 `fourAndThree`，而 `ARG1` 是 "
"`Float.floor`。这是因为访问器记法的目标用作第一个类型匹配的参数，而不一定是第一个参数。"

#: src/getting-to-know/structures.md:320
msgid ""
"Define a structure named `RectangularPrism` that contains the height, width,"
" and depth of a rectangular prism, each as a `Float`."
msgstr "定义一个名为 `RectangularPrism` 的结构体，其中包含一个矩形棱柱的高度、宽度和深度，每个都是 `Float`。"

#: src/getting-to-know/structures.md:321
msgid ""
"Define a function named `volume : RectangularPrism → Float` that computes "
"the volume of a rectangular prism."
msgstr "定义一个名为 `volume : RectangularPrism → Float` 的函数，用于计算矩形棱柱的体积。"

#: src/getting-to-know/structures.md:322
msgid ""
"Define a structure named `Segment` that represents a line segment by its "
"endpoints, and define a function `length : Segment → Float` that computes "
"the length of a line segment. `Segment` should have at most two fields."
msgstr ""
"定义一个名为 `Segment` 的结构体，它通过其端点表示线段，并定义一个函数 `length : Segment → "
"Float`，用于计算线段的长度。`Segment` 最多应有两个字段。"

#: src/getting-to-know/structures.md:323
msgid "Which names are introduced by the declaration of `RectangularPrism`?"
msgstr "`RectangularPrism` 的声明引入了哪些名称？"

#: src/getting-to-know/structures.md:324
msgid ""
"Which names are introduced by the following declarations of `Hamster` and "
"`Book`? What are their types?"
msgstr "以下 `Hamster` 和 `Book` 的声明引入了哪些名称？它们的类型是什么？"

#: src/getting-to-know/datatypes-and-patterns.md:1
msgid "Datatypes and Patterns"
msgstr "数据类型和模式"

#: src/getting-to-know/datatypes-and-patterns.md:3
#, fuzzy
msgid ""
"Structures enable multiple independent pieces of data to be combined into a "
"coherent whole that is represented by a brand new type. Types such as "
"structures that group together a collection of values are called _product "
"types_. Many domain concepts, however, can't be naturally represented as "
"structures. For instance, an application might need to track user "
"permissions, where some users are document owners, some may edit documents, "
"and others may only read them. A calculator has a number of binary "
"operators, such as addition, subtraction, and multiplication. Structures do "
"not provide an easy way to encode multiple choices."
msgstr ""
"结构体使多个独立的数据块可以组合成一个连贯的整体，该整体由一个全新的类型表示。将一组值组合在一起的类型（如结构体）称为 "
"_积类型_。然而，许多领域概念不能自然地表示为结构体。例如，应用程序可能需要跟踪用户权限，其中一些用户是文档所有者，一些用户可以编辑文档，而另一些用户只能阅读文档。计算器具有许多二元运算符，例如加法、减法和乘法。结构体无法提供一种简单的方法来编码多项选择。"

#: src/getting-to-know/datatypes-and-patterns.md:10
#, fuzzy
msgid ""
"Similarly, while a structure is an excellent way to keep track of a fixed "
"set of fields, many applications require data that may contain an arbitrary "
"number of elements. Most classic data structures, such as trees and lists, "
"have a recursive structure, where the tail of a list is itself a list, or "
"where the left and right branches of a binary tree are themselves binary "
"trees. In the aforementioned calculator, the structure of expressions "
"themselves is recursive. The summands in an addition expression may "
"themselves be multiplication expressions, for instance."
msgstr ""
"同样，尽管结构体是跟踪固定字段集的绝佳方式，但许多应用程序需要可能包含任意数量元素的数据。大多数经典数据结构体（例如树和列表）具有递归结构体，其中列表的尾部本身是一个列表，或者二叉树的左右分支本身是二叉树。在上述计算器中，表达式本身的结构体是递归的。例如，加法表达式中的加数本身可能是乘法表达式。"

#: src/getting-to-know/datatypes-and-patterns.md:15
#, fuzzy
msgid ""
"Datatypes that allow choices are called _sum types_ and datatypes that can "
"include instances of themselves are called _recursive datatypes_. Recursive "
"sum types are called _inductive datatypes_, because mathematical induction "
"may be used to prove statements about them. When programming, inductive "
"datatypes are consumed through pattern matching and recursive functions."
msgstr ""
"允许选择的类型称为 _和类型_，而可以包含自身实例的类型称为 _递归类型_。递归和类型称为 "
"_归纳类型_，因为可以用数学归纳法来证明有关它们的陈述。在编程时，归纳类型通过模式匹配和递归函数来消耗。"

#: src/getting-to-know/datatypes-and-patterns.md:19
#, fuzzy
msgid ""
"Many of the built-in types are actually inductive datatypes in the standard "
"library. For instance, `Bool` is an inductive datatype:"
msgstr "许多内置类型实际上是标准库中的归纳类型。例如，`Bool` 是一个归纳类型："

#: src/getting-to-know/datatypes-and-patterns.md:26
#, fuzzy
msgid ""
"This definition has two main parts. The first line provides the name of the "
"new type (`Bool`), while the remaining lines each describe a constructor. As"
" with constructors of structures, constructors of inductive datatypes are "
"mere inert receivers of and containers for other data, rather than places to"
" insert arbitrary initialization and validation code. Unlike structures, "
"inductive datatypes may have multiple constructors. Here, there are two "
"constructors, `true` and `false`, and neither takes any arguments. Just as a"
" structure declaration places its names in a namespace named after the "
"declared type, an inductive datatype places the names of its constructors in"
" a namespace. In the Lean standard library, `true` and `false` are re-"
"exported from this namespace so that they can be written alone, rather than "
"as `Bool.true` and `Bool.false`, respectively."
msgstr ""
"此定义有两个主要部分。第一行提供了新类型（`Bool`）的名称，而其余各行分别描述了一个构造子。与结构体的构造子一样，归纳类型的构造子只是其他数据的惰性接收器和容器，而不是插入任意初始化和验证代码的地方。与结构体不同，归纳类型可以有多个构造子。这里有两个构造子，`true`"
" 和 `false`，并且都不接受任何参数。就像结构体声明将其名称放在以声明类型命名的命名空间中一样，归纳类型将构造子的名称放在命名空间中。在 "
"Lean 标准库中，`true` 和 `false` 从此命名空间重新导出，以便可以单独编写它们，而不是分别作为 `Bool.true` 和 "
"`Bool.false`。"

#: src/getting-to-know/datatypes-and-patterns.md:34
#, fuzzy
msgid ""
"From a data modeling perspective, inductive datatypes are used in many of "
"the same contexts where a sealed abstract class might be used in other "
"languages. In languages like C# or Java, one might write a similar "
"definition of `Bool`:"
msgstr ""
"从数据建模的角度来看，归纳数据类型在许多与其他语言中可能使用密封抽象类相同的上下文中使用。在 C# 或 Java 等语言中，人们可能会编写类似的 "
"`Bool` 定义："

#: src/getting-to-know/datatypes-and-patterns.md:41
#, fuzzy
msgid ""
"However, the specifics of these representations are fairly different. In "
"particular, each non-abstract class creates both a new type and new ways of "
"allocating data. In the object-oriented example, `True` and `False` are both"
" types that are more specific than `Bool`, while the Lean definition "
"introduces only the new type `Bool`."
msgstr ""
"然而，这些表示的具体内容有很大不同。特别是，每个非抽象类都会创建一种新类型和分配数据的新方式。在面向对象示例中，`True` 和 `False` 都是比"
" `Bool` 更具体的类型，而 Lean 定义仅引入了新类型 `Bool`。"

#: src/getting-to-know/datatypes-and-patterns.md:43
#, fuzzy
msgid "The type `Nat` of non-negative integers is an inductive datatype:"
msgstr "非负整数的类型 `Nat` 是一个归纳数据类型："

#: src/getting-to-know/datatypes-and-patterns.md:49
#, fuzzy
msgid ""
"Here, `zero` represents 0, while `succ` represents the successor of some "
"other number. The `Nat` mentioned in `succ`'s declaration is the very type "
"`Nat` that is in the process of being defined. _Successor_ means \"one "
"greater than\", so the successor of five is six and the successor of 32,185 "
"is 32,186. Using this definition, `4` is represented as `Nat.succ (Nat.succ "
"(Nat.succ (Nat.succ Nat.zero)))`. This definition is almost like the "
"definition of `Bool` with slightly different names. The only real difference"
" is that `succ` is followed by `(n : Nat)`, which specifies that the "
"constructor `succ` takes an argument of type `Nat` which happens to be named"
" `n`. The names `zero` and `succ` are in a namespace named after their type,"
" so they must be referred to as `Nat.zero` and `Nat.succ`, respectively."
msgstr ""
"这里，`zero` 表示 0，而 `succ` 表示其他一些数字的后继。`succ` 声明中提到的 `Nat` 正是我们正在定义的类型 "
"`Nat`。_后继_表示「比...大一」，因此 5 的后继是 6，32,185 的后继是 32,186。使用此定义，`4` 表示为 `Nat.succ "
"(Nat.succ (Nat.succ (Nat.succ Nat.zero)))`。这个定义几乎就像 `Bool` "
"的定义，只是名称略有不同。唯一真正的区别是 `succ` 后面跟着 `(n : Nat)`，它指定构造子 `succ` 接受类型为 `Nat` "
"的参数，该参数恰好命名为 `n`。名称 `zero` 和 `succ` 位于以其类型命名的命名空间中，因此它们分别必须称为 `Nat.zero` 和 "
"`Nat.succ`。"

#: src/getting-to-know/datatypes-and-patterns.md:57
#, fuzzy
msgid ""
"Argument names, such as `n`, may occur in Lean's error messages and in "
"feedback provided when writing mathematical proofs. Lean also has an "
"optional syntax for providing arguments by name. Generally, however, the "
"choice of argument name is less important than the choice of a structure "
"field name, as it does not form as large a part of the API."
msgstr ""
"参数名称（如 `n`）可能出现在 Lean 的错误消息中以及编写数学证明时提供的反馈中。Lean "
"还具有按名称提供参数的可选语法。然而，通常情况下，参数名称的选择不如结构体字段名称的选择重要，因为它不构成 API 的很大一部分。"

#: src/getting-to-know/datatypes-and-patterns.md:61
#, fuzzy
msgid "In C# or Java, `Nat` could be defined as follows:"
msgstr "在 C# 或 Java 中，`Nat` 可以定义如下："

#: src/getting-to-know/datatypes-and-patterns.md:72
#, fuzzy
msgid ""
"Just as in the `Bool` example above, this defines more types than the Lean "
"equivalent. Additionally, this example highlights how Lean datatype "
"constructors are much more like subclasses of an abstract class than they "
"are like constructors in C# or Java, as the constructor shown here contains "
"initialization code to be executed."
msgstr ""
"与上面 `Bool` 的示例类似，这定义了比 Lean 等价项更多的类型。此外，此示例突出显示了 Lean 数据类型构造子更像是抽象类的子类，而不是像"
" C# 或 Java 中的构造子，因为此处显示的构造子包含要执行的初始化代码。"

#: src/getting-to-know/datatypes-and-patterns.md:75
#, fuzzy
msgid ""
"Sum types are also similar to using a string tag to encode discriminated "
"unions in TypeScript. In TypeScript, `Nat` could be defined as follows:"
msgstr "和类型也类似于使用字符串标记来对 TypeScript 中的判别联合进行编码。在 TypeScript 中，`Nat` 可以定义如下："

#: src/getting-to-know/datatypes-and-patterns.md:77
#, fuzzy
msgid ""
"```typescript\n"
"interface Zero {\n"
"    tag: \"zero\";\n"
"}\n"
"\n"
"interface Succ {\n"
"    tag: \"succ\";\n"
"    predecessor: Nat;\n"
"}\n"
"\n"
"type Nat = Zero | Succ;\n"
"```"
msgstr ""
"```typescript\n"
"interface Zero {\n"
"    tag: \"zero\";\n"
"}\n"
"\n"
"interface Succ {\n"
"    tag: \"succ\";\n"
"    predecessor: Nat;\n"
"}\n"
"\n"
"type Nat = Zero | Succ;\n"
"```"

#: src/getting-to-know/datatypes-and-patterns.md:89
#, fuzzy
msgid ""
"Just like C# and Java, this encoding ends up with more types than in Lean, "
"because `Zero` and `Succ` are each a type on their own. It also illustrates "
"that Lean constructors correspond to objects in JavaScript or TypeScript "
"that include a tag that identifies the contents."
msgstr ""
"与 C# 和 Java 一样，这种编码最终会产生比 Lean 中更多的类型，因为 `Zero` 和 `Succ` 都是它们自己的类型。它还说明了 "
"Lean 构造子对应于 JavaScript 或 TypeScript 中的对象，这些对象包含一个标识内容的标记。"

#: src/getting-to-know/datatypes-and-patterns.md:92
#, fuzzy
msgid "Pattern Matching"
msgstr "模式匹配"

#: src/getting-to-know/datatypes-and-patterns.md:94
#, fuzzy
msgid ""
"In many languages, these kinds of data are consumed by first using an "
"instance-of operator to check which subclass has been received and then "
"reading the values of the fields that are available in the given subclass. "
"The instance-of check determines which code to run, ensuring that the data "
"needed by this code is available, while the fields themselves provide the "
"data. In Lean, both of these purposes are simultaneously served by _pattern "
"matching_."
msgstr ""
"在许多语言中，这些类型的数据首先使用 instance-of 运算符来检查已接收哪个子类，然后读取给定子类中可用的字段的值。instance-of "
"检查确定要运行哪个代码，确保此代码所需的数据可用，而字段本身提供数据。在 Lean 中，这两个目的都由 _模式匹配_ 同时实现。"

#: src/getting-to-know/datatypes-and-patterns.md:98
#, fuzzy
msgid ""
"An example of a function that uses pattern matching is `isZero`, which is a "
"function that returns `true` when its argument is `Nat.zero`, or false "
"otherwise."
msgstr "使用模式匹配的函数示例是 `isZero`，这是一个当其参数为 `Nat.zero` 时返回 `true` 的函数，否则返回 false。"

#: src/getting-to-know/datatypes-and-patterns.md:105
#, fuzzy
msgid ""
"The `match` expression is provided the function's argument `n` for "
"destructuring. If `n` was constructed by `Nat.zero`, then the first branch "
"of the pattern match is taken, and the result is `true`. If `n` was "
"constructed by `Nat.succ`, then the second branch is taken, and the result "
"is `false`."
msgstr ""
"`match` 表达式为函数参数 `n` 提供了解构。如果 `n` 由 `Nat.zero` 构建，则采用模式匹配的第一分支，结果为 `true`。如果"
" `n` 由 `Nat.succ` 构建，则采用第二分支，结果为 `false`。"

#: src/getting-to-know/datatypes-and-patterns.md:109
#, fuzzy
msgid "Step-by-step, evaluation of `isZero Nat.zero` proceeds as follows:"
msgstr "`isZero Nat.zero` 的求值逐步进行，如下所示："

#: src/getting-to-know/datatypes-and-patterns.md:120
#, fuzzy
msgid "Evaluation of `isZero 5` proceeds similarly:"
msgstr "`isZero 5` 的求值过程类似："

#: src/getting-to-know/datatypes-and-patterns.md:133
#, fuzzy
msgid ""
"The `k` in the second branch of the pattern in `isZero` is not decorative. "
"It makes the `Nat` that is the argument to `succ` visible, with the provided"
" name. That smaller number can then be used to compute the final result of "
"the expression."
msgstr ""
"`isZero` 中模式的第二分支中的 `k` 并非装饰性符号。它使 `succ` 的参数 `Nat` "
"可见，并提供了名称。然后可以使用该较小的数字计算表达式的最终结果。"

#: src/getting-to-know/datatypes-and-patterns.md:137
#, fuzzy
msgid ""
"Just as the successor of some number \\\\( n \\\\) is one greater than \\\\("
" n \\\\) (that is, \\\\( n + 1\\\\)), the predecessor of a number is one "
"less than it. If `pred` is a function that finds the predecessor of a `Nat`,"
" then it should be the case that the following examples find the expected "
"result:"
msgstr ""
"正如某个数字 \\\\( n \\\\) 的后继比 \\\\( n \\\\) 大 1（即 \\\\( n + 1\\\\)），某个数字的前驱比它小 "
"1。如果 `pred` 是一个查找 `Nat` 前驱的函数，那么以下示例应该找到预期的结果："

#: src/getting-to-know/datatypes-and-patterns.md:151
#, fuzzy
msgid ""
"Because `Nat` cannot represent negative numbers, `0` is a bit of a "
"conundrum. Usually, when working with `Nat`, operators that would ordinarily"
" produce a negative number are redefined to produce `0` itself:"
msgstr ""
"由于 `Nat` 无法表示负数，因此 `0` 有点令人费解。通常，在使用 `Nat` 时，通常会产生负数的运算符被重新定义为产生 `0` 本身："

#: src/getting-to-know/datatypes-and-patterns.md:160
#, fuzzy
msgid ""
"To find the predecessor of a `Nat`, the first step is to check which "
"constructor was used to create it. If it was `Nat.zero`, then the result is "
"`Nat.zero`. If it was `Nat.succ`, then the name `k` is used to refer to the "
"`Nat` underneath it. And this `Nat` is the desired predecessor, so the "
"result of the `Nat.succ` branch is `k`."
msgstr ""
"要查找 `Nat` 的前驱，第一步是检查使用哪个构造子创建它。如果是 `Nat.zero`，则结果为 `Nat.zero`。如果是 "
"`Nat.succ`，则使用名称 `k` 引用其下的 `Nat`。而这个 `Nat` 是所需的前驱，因此 `Nat.succ` 分支的结果是 `k`。"

#: src/getting-to-know/datatypes-and-patterns.md:170
#, fuzzy
msgid "Applying this function to `5` yields the following steps:"
msgstr "将此函数应用于 `5` 会产生以下步骤："

#: src/getting-to-know/datatypes-and-patterns.md:183
#, fuzzy
msgid ""
"Pattern matching can be used with structures as well as with sum types. For "
"instance, a function that extracts the third dimension from a `Point3D` can "
"be written as follows:"
msgstr "模式匹配不仅可用于和类型，还可用于结构体。例如，一个从 `Point3D` 中提取第三维度的函数可以写成如下："

#: src/getting-to-know/datatypes-and-patterns.md:190
#, fuzzy
msgid ""
"In this case, it would have been much simpler to just use the `z` accessor, "
"but structure patterns are occasionally the simplest way to write a "
"function."
msgstr "在这种情况下，直接使用 `z` 访问器会简单得多，但结构体模式有时是编写函数的最简单方法。"

#: src/getting-to-know/datatypes-and-patterns.md:192
#, fuzzy
msgid "Recursive Functions"
msgstr "递归函数"

#: src/getting-to-know/datatypes-and-patterns.md:194
#, fuzzy
msgid ""
"Definitions that refer to the name being defined are called _recursive "
"definitions_. Inductive datatypes are allowed to be recursive; indeed, `Nat`"
" is an example of such a datatype because `succ` demands another `Nat`. "
"Recursive datatypes can represent arbitrarily large data, limited only by "
"technical factors like available memory. Just as it would be impossible to "
"write down one constructor for each natural number in the datatype "
"definition, it is also impossible to write down a pattern match case for "
"each possibility."
msgstr ""
"引用正在定义的名称的定义称为 _递归定义_。归纳数据类型允许是递归的；事实上，`Nat` 就是这样的数据类型的一个例子，因为 `succ` 需要另一个 "
"`Nat`。递归数据类型可以表示任意大的数据，仅受可用内存等技术因素限制。就像不可能在数据类型定义中为每个自然数编写一个构造子一样，也不可能为每个可能性编写一个模式匹配用例。"

#: src/getting-to-know/datatypes-and-patterns.md:199
#, fuzzy
msgid ""
"Recursive datatypes are nicely complemented by recursive functions. A simple"
" recursive function over `Nat` checks whether its argument is even. In this "
"case, `zero` is even. Non-recursive branches of the code like this one are "
"called _base cases_. The successor of an odd number is even, and the "
"successor of an even number is odd. This means that a number built with "
"`succ` is even if and only if its argument is not even."
msgstr ""
"递归数据类型与递归函数很好地互补。一个简单的 `Nat` 递归函数检查其参数是否是偶数。在这种情况下，`zero` 是偶数。像这样的代码的非递归分支称为"
" _基本情况_。奇数的后继是偶数，偶数的后继是奇数。这意味着使用 `succ` 构建的数字当且仅当其参数不是偶数时才是偶数。"

#: src/getting-to-know/datatypes-and-patterns.md:212
#, fuzzy
msgid ""
"This pattern of thought is typical for writing recursive functions on `Nat`."
" First, identify what to do for `zero`. Then, determine how to transform a "
"result for an arbitrary `Nat` into a result for its successor, and apply "
"this transformation to the result of the recursive call. This pattern is "
"called _structural recursion_."
msgstr ""
"这种思维模式对于在 `Nat` 上编写递归函数是典型的。首先，确定对 `zero` 做什么。然后，确定如何将任意 `Nat` "
"的结果转换为其后继的结果，并将此转换应用于递归调用的结果。此模式称为 _结构体递归_。"

#: src/getting-to-know/datatypes-and-patterns.md:217
#, fuzzy
msgid ""
"Unlike many languages, Lean ensures by default that every recursive function"
" will eventually reach a base case. From a programming perspective, this "
"rules out accidental infinite loops. But this feature is especially "
"important when proving theorems, where infinite loops cause major "
"difficulties. A consequence of this is that Lean will not accept a version "
"of `even` that attempts to invoke itself recursively on the original number:"
msgstr ""
"不同于许多语言，Lean "
"默认确保每个递归函数最终都会到达基本情况。从编程角度来看，这排除了意外的无限循环。但此特性在证明定理时尤其重要，因为无限循环会导致重大困难。由此产生的一个后果是，Lean"
" 不会接受尝试对原始数字递归调用自身的 `even` 版本："

#: src/getting-to-know/datatypes-and-patterns.md:228
#, fuzzy
msgid ""
"The important part of the error message is that Lean could not determine "
"that the recursive function always reaches a base case (because it doesn't)."
msgstr "错误消息的重要部分是 Lean 无法确定递归函数是否始终到达基本情况（因为它没有）。"

#: src/getting-to-know/datatypes-and-patterns.md:238
#, fuzzy
msgid ""
"Even though addition takes two arguments, only one of them needs to be "
"inspected. To add zero to a number \\\\( n \\\\), just return \\\\( n \\\\)."
" To add the successor of \\\\( k \\\\) to \\\\( n \\\\), take the successor "
"of the result of adding \\\\( k \\\\) to \\\\( n \\\\)."
msgstr ""
"尽管加法需要两个参数，但只需要检查其中一个参数。要将零添加到数字 \\\\( n \\\\)，只需返回 \\\\( n \\\\)。要将 \\\\( k"
" \\\\) 的后继添加到 \\\\( n \\\\)，请获取将 \\\\( k \\\\) 添加到 \\\\( n \\\\) 的结果的后继。"

#: src/getting-to-know/datatypes-and-patterns.md:247
#, fuzzy
msgid ""
"In the definition of `plus`, the name `k'` is chosen to indicate that it is "
"connected to, but not identical with, the argument `k`. For instance, "
"walking through the evaluation of `plus 3 2` yields the following steps:"
msgstr ""
"在 `plus` 的定义中，选择名称 `k'` 表示它与参数 `k` 相关联，但并不相同。例如，遍历 `plus 3 2` 的求值会产生以下步骤："

#: src/getting-to-know/datatypes-and-patterns.md:275
#, fuzzy
msgid ""
"One way to think about addition is that \\\\( n + k \\\\) applies `Nat.succ`"
" \\\\( k \\\\) times to \\\\( n \\\\). Similarly, multiplication \\\\( n × k"
" \\\\) adds \\\\( n \\\\) to itself \\\\( k \\\\) times and subtraction "
"\\\\( n - k \\\\) takes \\\\( n \\\\)'s predecessor \\\\( k \\\\) times."
msgstr ""
"考虑加法的一种方法是 \\\\( n + k \\\\) 将 `Nat.succ` 应用于 \\\\( n \\\\) \\\\( k \\\\) "
"次。类似地，乘法 \\\\( n × k \\\\) 将 \\\\( n \\\\) 加到自身 \\\\( k \\\\) 次，而减法 \\\\( n "
"- k \\\\) 将 \\\\( n \\\\) 的前驱减去 \\\\( k \\\\) 次。"

#: src/getting-to-know/datatypes-and-patterns.md:289
#, fuzzy
msgid ""
"Not every function can be easily written using structural recursion. The "
"understanding of addition as iterated `Nat.succ`, multiplication as iterated"
" addition, and subtraction as iterated predecessor suggests an "
"implementation of division as iterated subtraction. In this case, if the "
"numerator is less than the divisor, the result is zero. Otherwise, the "
"result is the successor of dividing the numerator minus the divisor by the "
"divisor."
msgstr ""
"并非每个函数都可以轻松地使用结构体递归来编写。将加法理解为迭代的 "
"`Nat.succ`，将乘法理解为迭代的加法，将减法理解为迭代的前驱，这表明除法可以实现为迭代的减法。在这种情况下，如果分子小于分母，则结果为零。否则，结果是将分子减去分母除以分母的后继。"

#: src/getting-to-know/datatypes-and-patterns.md:299
#, fuzzy
msgid ""
"As long as the second argument is not `0`, this program terminates, as it "
"always makes progress towards the base case. However, it is not structurally"
" recursive, because it doesn't follow the pattern of finding a result for "
"zero and transforming a result for a smaller `Nat` into a result for its "
"successor. In particular, the recursive invocation of the function is "
"applied to the result of another function call, rather than to an input "
"constructor's argument. Thus, Lean rejects it with the following message:"
msgstr ""
"只要第二个参数不为 `0`，这个程序就会终止，因为它始终朝着基本情况前进。然而，它不是结构体递归，因为它不遵循为零找到结果并转换较小 `Nat` "
"的结果为其后继结果的模式。特别是，函数的递归调用应用于另一个函数调用的结果，而不是输入构造子的参数。因此，Lean 拒绝它，并显示以下消息："

#: src/getting-to-know/datatypes-and-patterns.md:319
#, fuzzy
msgid ""
"This message means that `div` requires a manual proof of termination. This "
"topic is explored in [the final chapter](../programs-"
"proofs/inequalities.md#division-as-iterated-subtraction)."
msgstr ""
"此消息表示 `div` 需要手动终止证明。这个主题在 [最后一章](../programs-"
"proofs/inequalities.md#division-as-iterated-subtraction) 中进行了探讨。"

#: src/getting-to-know/polymorphism.md:3
#, fuzzy
msgid ""
"Just as in most languages, types in Lean can take arguments. For instance, "
"the type `List Nat` describes lists of natural numbers, `List String` "
"describes lists of strings, and `List (List Point)` describes lists of lists"
" of points. This is very similar to `List<Nat>`, `List<String>`, or "
"`List<List<Point>>` in a language like C# or Java. Just as Lean uses a space"
" to pass an argument to a function, it uses a space to pass an argument to a"
" type."
msgstr ""
"就像大多数语言一样，Lean 中的类型可以接受参数。例如，类型 `List Nat` 描述自然数列表，`List String` "
"描述字符串列表，`List (List Point)` 描述点列表列表。这与 C# 或 Java 中的 "
"`List<Nat>`、`List<String>` 或 `List<List<Point>>` 非常相似。就像 Lean "
"使用空格将参数传递给函数一样，它也使用空格将参数传递给类型。"

#: src/getting-to-know/polymorphism.md:8
#, fuzzy
msgid ""
"In functional programming, the term _polymorphism_ typically refers to "
"datatypes and definitions that take types as arguments. This is different "
"from the object-oriented programming community, where the term typically "
"refers to subclasses that may override some behavior of their superclass. In"
" this book, \"polymorphism\" always refers to the first sense of the word. "
"These type arguments can be used in the datatype or definition, which allows"
" the same datatype or definition to be used with any type that results from "
"replacing the arguments' names with some other types."
msgstr ""
"在函数式编程中，术语 _多态性_ "
"通常指将类型作为参数的数据类型和定义。这不同于面向对象编程社区，其中该术语通常指可以覆盖其超类某些行为的子类。在这本书中，「多态性」总是指这个词的第一个含义。这些类型参数可以在数据类型或定义中使用，这允许使用任何类型（通过将参数名称替换为其他一些类型而得到）来使用相同的数据类型或定义。"

#: src/getting-to-know/polymorphism.md:13
#, fuzzy
msgid ""
"The `Point` structure requires that both the `x` and `y` fields are "
"`Float`s. There is, however, nothing about points that require a specific "
"representation for each coordinate. A polymorphic version of `Point`, called"
" `PPoint`, can take a type as an argument, and then use that type for both "
"fields:"
msgstr ""
"`Point` 结构体要求 `x` 和 `y` 字段都是 `Float`。然而，对于点来说，没有关于每个坐标需要特定表示形式的要求。`Point` "
"的多态版本称为 `PPoint`，它可以将类型作为参数，然后将该类型用于两个字段："

#: src/getting-to-know/polymorphism.md:22
#, fuzzy
msgid ""
"Just as a function definition's arguments are written immediately after the "
"name being defined, a structure's arguments are written immediately after "
"the structure's name. It is customary to use Greek letters to name type "
"arguments in Lean when no more specific name suggests itself. `Type` is a "
"type that describes other types, so `Nat`, `List String`, and `PPoint Int` "
"all have type `Type`."
msgstr ""
"就像函数定义的参数紧跟在被定义的名称之后一样，结构体的参数紧跟在结构体的名称之后。在 Lean "
"中，当没有更具体的名称时，通常使用希腊字母来命名类型参数。`Type` 是描述其他类型的类型，因此 `Nat`、`List String` 和 "
"`PPoint Int` 都具有 `Type` 类型。"

#: src/getting-to-know/polymorphism.md:26
#, fuzzy
msgid ""
"Just like `List`, `PPoint` can be used by providing a specific type as its "
"argument:"
msgstr "就像 `List` 一样，`PPoint` 可以通过提供特定类型作为其参数来使用："

#: src/getting-to-know/polymorphism.md:31
#, fuzzy
msgid ""
"In this example, both fields are expected to be `Nat`s. Just as a function "
"is called by replacing its argument variables with its argument values, "
"providing `PPoint` with the type `Nat` as an argument yields a structure in "
"which the fields `x` and `y` have the type `Nat`, because the argument name "
"`α` has been replaced by the argument type `Nat`. Types are ordinary "
"expressions in Lean, so passing arguments to polymorphic types (like "
"`PPoint`) doesn't require any special syntax."
msgstr ""
"在这个示例中，期望两个字段都是 `Nat`。就像通过用其参数值替换其参数变量来调用函数一样，向 `PPoint` 提供类型 `Nat` "
"作为参数会产生一个结构体，其中字段 `x` 和 `y` 具有类型 `Nat`，因为参数名称 `α` 已被参数类型 `Nat` 替换。类型是 Lean "
"中的普通表达式，因此向多态类型（如 `PPoint`）传递参数不需要任何特殊语法。"

#: src/getting-to-know/polymorphism.md:35
#, fuzzy
msgid ""
"Definitions may also take types as arguments, which makes them polymorphic. "
"The function `replaceX` replaces the `x` field of a `PPoint` with a new "
"value. In order to allow `replaceX` to work with _any_ polymorphic point, it"
" must be polymorphic itself. This is achieved by having its first argument "
"be the type of the point's fields, with later arguments referring back to "
"the first argument's name."
msgstr ""
"定义也可以将类型作为参数，这使得它们具有多态性。函数 `replaceX` 用新值替换 `PPoint` 的 `x` 字段。为了允许 "
"`replaceX` 与 _any_ "
"多态点一起使用，它本身必须是多态的。这是通过让其第一个参数成为点字段的类型，后面的参数引用第一个参数的名称来实现的。"

#: src/getting-to-know/polymorphism.md:43
#, fuzzy
msgid ""
"In other words, when the types of the arguments `point` and `newX` mention "
"`α`, they are referring to _whichever type was provided as the first "
"argument_. This is similar to the way that function argument names refer to "
"the values that were provided when they occur in the function's body."
msgstr ""
"换句话说，当参数 `point` 和 `newX` 的类型提到 `α` 时，它们指的是 "
"_作为第一个参数提供的任何类型_。这类似于函数参数名称引用函数体中提供的值的方式。"

#: src/getting-to-know/polymorphism.md:46
#, fuzzy
msgid ""
"This can be seen by asking Lean to check the type of `replaceX`, and then "
"asking it to check the type of `replaceX Nat`."
msgstr "可以通过让 Lean 检查 `replaceX` 的类型，然后让它检查 `replaceX Nat` 的类型来看到这一点。"

#: src/getting-to-know/polymorphism.md:53
#, fuzzy
msgid ""
"This function type includes the _name_ of the first argument, and later "
"arguments in the type refer back to this name. Just as the value of a "
"function application is found by replacing the argument name with the "
"provided argument value in the function's body, the type of a function "
"application is found by replacing the argument's name with the provided "
"value in the function's return type. Providing the first argument, `Nat`, "
"causes all occurrences of `α` in the remainder of the type to be replaced "
"with `Nat`:"
msgstr ""
"此函数类型包括第一个参数的 "
"_名称_，并且类型中的后续参数引用此名称。就像函数应用程序的值是通过在函数体中用提供的参数值替换参数名称来找到的那样，函数应用程序的类型是通过在函数的返回类型中用提供的参数值替换参数的名称来找到的。提供第一个参数"
" `Nat`，会导致类型其余部分中 `α` 的所有出现都替换为 `Nat`："

#: src/getting-to-know/polymorphism.md:62
#, fuzzy
msgid ""
"Because the remaining arguments are not explicitly named, no further "
"substitution occurs as more arguments are provided:"
msgstr "因为剩余的参数没有明确命名，所以随着提供更多参数，不会发生进一步的替换："

#: src/getting-to-know/polymorphism.md:75
#, fuzzy
msgid ""
"The fact that the type of the whole function application expression was "
"determined by passing a type as an argument has no bearing on the ability to"
" evaluate it."
msgstr "通过传递类型作为参数来确定整个函数应用程序表达式的类型这一事实与评估它的能力无关。"

#: src/getting-to-know/polymorphism.md:83
#, fuzzy
msgid ""
"Polymorphic functions work by taking a named type argument and having later "
"types refer to the argument's name. However, there's nothing special about "
"type arguments that allows them to be named. Given a datatype that "
"represents positive or negative signs:"
msgstr ""
"多态函数通过获取一个命名的类型参数并让后续类型引用参数的名称来工作。但是，类型参数没有特殊之处允许它们被命名。给定一个表示正负号的数据类型："

#: src/getting-to-know/polymorphism.md:91
#, fuzzy
msgid ""
"it is possible to write a function whose argument is a sign. If the argument"
" is positive, the function returns a `Nat`, while if it's negative, it "
"returns an `Int`:"
msgstr "可以编写一个函数，其参数是一个符号。如果参数为正，则函数返回 `Nat`，如果为负，则返回 `Int`："

#: src/getting-to-know/polymorphism.md:99
#, fuzzy
msgid ""
"Because types are first class and can be computed using the ordinary rules "
"of the Lean language, they can be computed by pattern-matching against a "
"datatype. When Lean is checking this function, it uses the fact that the "
"`match`\\-expression in the function's body corresponds to the "
"`match`\\-expression in the type to make `Nat` be the expected type for the "
"`pos` case and to make `Int` be the expected type for the `neg` case."
msgstr ""
"类型是一等公民，可以使用 Lean 语言的普通规则进行计算，因此可以通过针对数据类型的模式匹配来计算它们。当 Lean 检查此函数时，它使用函数体中 "
"`match` 表达式对应于类型中 `match` 表达式的事实，使 `Nat` 成为 `pos` 情况的预期类型，并使 `Int` 成为 `neg` "
"情况的预期类型。"

#: src/getting-to-know/polymorphism.md:102
#, fuzzy
msgid ""
"Applying `posOrNegThree` to `Sign.pos` results in the argument name `s` in "
"both the body of the function and its return type being replaced by "
"`Sign.pos`. Evaluation can occur both in the expression and its type:"
msgstr ""
"将 `posOrNegThree` 应用于 `Sign.pos` 会导致函数体和其返回类型中的参数名称 `s` 都被 `Sign.pos` "
"替换。求值可以在表达式及其类型中同时发生："

#: src/getting-to-know/polymorphism.md:117
#, fuzzy
msgid "Linked Lists"
msgstr "链表"

#: src/getting-to-know/polymorphism.md:119
#, fuzzy
msgid ""
"Lean's standard library includes a canonical linked list datatype, called "
"`List`, and special syntax that makes it more convenient to use. Lists are "
"written in square brackets. For instance, a list that contains the prime "
"numbers less than 10 can be written:"
msgstr ""
"Lean 的标准库包含一个规范的链表数据类型，称为 `List`，以及使其更易于使用的特殊语法。列表写在方括号中。例如，一个包含小于 10 "
"的质数的列表可以写成："

#: src/getting-to-know/polymorphism.md:126
#, fuzzy
msgid "Behind the scenes, `List` is an inductive datatype, defined like this:"
msgstr "在幕后，`List` 是一个归纳数据类型，定义如下："

#: src/getting-to-know/polymorphism.md:132
#, fuzzy
msgid ""
"The actual definition in the standard library is slightly different, because"
" it uses features that have not yet been presented, but it is substantially "
"similar. This definition says that `List` takes a single type as its "
"argument, just as `PPoint` did. This type is the type of the entries stored "
"in the list. According to the constructors, a `List α` can be built with "
"either `nil` or `cons`. The constructor `nil` represents empty lists and the"
" constructor `cons` is used for non-empty lists. The first argument to "
"`cons` is the head of the list, and the second argument is its tail. A list "
"that contains \\\\( n \\\\) entries contains \\\\( n \\\\) `cons` "
"constructors, the last of which has `nil` as its tail."
msgstr ""
"标准库中的实际定义略有不同，因为它使用了尚未介绍的特性，但它基本上是相似的。此定义表示 `List` 将单个类型作为其参数，就像 `PPoint` "
"所做的那样。此类型是存储在列表中的项的类型。根据构造子，`List α` 可以使用 `nil` 或 `cons` 构建。构造子 `nil` "
"表示空列表，构造子 `cons` 用于非空列表。`cons` 的第一个参数是列表的头部，第二个参数是其尾部。包含 \\\\( n \\\\) "
"个项的列表包含 \\\\( n \\\\) 个 `cons` 构造子，最后一个以 `nil` 为尾部。"

#: src/getting-to-know/polymorphism.md:140
#, fuzzy
msgid ""
"The `primesUnder10` example can be written more explicitly by using `List`'s"
" constructors directly:"
msgstr "`primesUnder10` 示例可以通过直接使用 `List` 的构造子更明确地编写："

#: src/getting-to-know/polymorphism.md:145
#, fuzzy
msgid ""
"These two definitions are completely equivalent, but `primesUnder10` is much"
" easier to read than `explicitPrimesUnder10`."
msgstr "这两个定义完全等价，但 `primesUnder10` 比 `explicitPrimesUnder10` 更容易阅读。"

#: src/getting-to-know/polymorphism.md:147
#, fuzzy
msgid ""
"Functions that consume `List`s can be defined in much the same way as "
"functions that consume `Nat`s. Indeed, one way to think of a linked list is "
"as a `Nat` that has an extra data field dangling off each `succ` "
"constructor. From this point of view, computing the length of a list is the "
"process of replacing each `cons` with a `succ` and the final `nil` with a "
"`zero`. Just as `replaceX` took the type of the fields of the point as an "
"argument, `length` takes the type of the list's entries. For example, if the"
" list contains strings, then the first argument is `String`: `length String "
"[\"Sourdough\", \"bread\"]`. It should compute like this:"
msgstr ""
"使用 `List` 的函数可以与使用 `Nat` 的函数以相同的方式定义。事实上，一种考虑链表的方式是将其视为一个 `Nat`，每个 `succ` "
"构造子都悬挂着一个额外的数据字段。从这个角度来看，计算列表的长度的过程是将每个 `cons` 替换为 `succ`，将最终的 `nil` 替换为 "
"`zero`。就像 `replaceX` 将点的字段类型作为参数一样，`length` 采用列表项的类型。例如，如果列表包含字符串，则第一个参数是 "
"`String`：`length String [\"Sourdough\", \"bread\"]`。它应该这样计算："

#: src/getting-to-know/polymorphism.md:153
#, fuzzy
msgid ""
"```\n"
"length String [\"Sourdough\", \"bread\"]\n"
"===>\n"
"length String (List.cons \"Sourdough\" (List.cons \"bread\" List.nil))\n"
"===>\n"
"Nat.succ (length String (List.cons \"bread\" List.nil))\n"
"===>\n"
"Nat.succ (Nat.succ (length String List.nil))\n"
"===>\n"
"Nat.succ (Nat.succ Nat.zero)\n"
"===>\n"
"2\n"
"```"
msgstr ""
"```\n"
"length String [\"Sourdough\", \"bread\"]\n"
"===>\n"
"length String (List.cons \"Sourdough\" (List.cons \"bread\" List.nil))\n"
"===>\n"
"Nat.succ (length String (List.cons \"bread\" List.nil))\n"
"===>\n"
"Nat.succ (Nat.succ (length String List.nil))\n"
"===>\n"
"Nat.succ (Nat.succ Nat.zero)\n"
"===>\n"
"2\n"
"```"

#: src/getting-to-know/polymorphism.md:167
#, fuzzy
msgid ""
"The definition of `length` is both polymorphic (because it takes the list "
"entry type as an argument) and recursive (because it refers to itself). "
"Generally, functions follow the shape of the data: recursive datatypes lead "
"to recursive functions, and polymorphic datatypes lead to polymorphic "
"functions."
msgstr ""
"`length` "
"的定义既是多态的（因为它将列表项类型作为参数），又是递归的（因为它引用自身）。通常，函数遵循数据的形状：递归数据类型导致递归函数，多态数据类型导致多态函数。"

#: src/getting-to-know/polymorphism.md:176
#, fuzzy
msgid ""
"Names such as `xs` and `ys` are conventionally used to stand for lists of "
"unknown values. The `s` in the name indicates that they are plural, so they "
"are pronounced \"exes\" and \"whys\" rather than \"x s\" and \"y s\"."
msgstr ""
"按照惯例，`xs` 和 `ys` 等名称用于表示未知值的列表。名称中的 `s` 表示它们是复数，因此它们的发音是「exes」和「whys」，而不是“x "
"s”和「y s」。"

#: src/getting-to-know/polymorphism.md:179
#, fuzzy
msgid ""
"To make it easier to read functions on lists, the bracket notation `[]` can "
"be used to pattern-match against `nil`, and an infix `::` can be used in "
"place of `cons`:"
msgstr "为了便于阅读列表上的函数，可以使用方括号符号 `[]` 来匹配模式 `nil`，并且可以使用中缀 `::` 来代替 `cons`："

#: src/getting-to-know/polymorphism.md:187
#, fuzzy
msgid "Implicit Arguments"
msgstr "隐式参数"

#: src/getting-to-know/polymorphism.md:189
#, fuzzy
msgid ""
"Both `replaceX` and `length` are somewhat bureaucratic to use, because the "
"type argument is typically uniquely determined by the later values. Indeed, "
"in most languages, the compiler is perfectly capable of determining type "
"arguments on its own, and only occasionally needs help from users. This is "
"also the case in Lean. Arguments can be declared _implicit_ by wrapping them"
" in curly braces instead of parentheses when defining a function. For "
"instance, a version of `replaceX` with an implicit type argument looks like "
"this:"
msgstr ""
"`replaceX` 和 `length` "
"这两个函数使用起来有些繁琐，因为类型参数通常由后面的值唯一确定。事实上，在大多数语言中，编译器完全有能力自行确定类型参数，并且只需要偶尔从用户那里获得帮助。在"
" Lean 中也是如此。在定义函数时，可以通过用大括号而不是括号将参数括起来来声明参数为 _隐式_。例如，一个具有隐式类型参数的 `replaceX` "
"版本如下所示："

#: src/getting-to-know/polymorphism.md:198
#, fuzzy
msgid ""
"It can be used with `natOrigin` without providing `Nat` explicitly, because "
"Lean can _infer_ the value of `α` from the later arguments:"
msgstr "它可以与 `natOrigin` 一起使用，而无需显式提供 `Nat`，因为 Lean 可以从后面的参数中 _推断_ `α` 的值："

#: src/getting-to-know/polymorphism.md:206
#, fuzzy
msgid ""
"Similarly, `length` can be redefined to take the entry type implicitly:"
msgstr "类似地，`length` 可以重新定义为隐式获取输入类型："

#: src/getting-to-know/polymorphism.md:213
#, fuzzy
msgid "This `length` function can be applied directly to `primesUnder10`:"
msgstr "此 `length` 函数可以直接应用于 `primesUnder10`："

#: src/getting-to-know/polymorphism.md:221
msgid ""
"In the standard library, Lean calls this function `List.length`, which means"
" that the dot syntax that is used for structure field access can also be "
"used to find the length of a list:"
msgstr "在标准库中，Lean 将此函数称为 `List.length`，这意味着用于结构体字段访问的点语法也可以用于查找列表的长度："

#: src/getting-to-know/polymorphism.md:230
#, fuzzy
msgid ""
"Just as C# and Java require type arguments to be provided explicitly from "
"time to time, Lean is not always capable of finding implicit arguments. In "
"these cases, they can be provided using their names. For instance, a version"
" of `List.length` that only works for lists of integers can be specified by "
"setting `α` to `Int`:"
msgstr ""
"正如 C# 和 Java 要求不时显式提供类型参数一样，Lean 并不总是能够找到隐式参数。在这些情况下，可以使用它们的名称来提供它们。例如，可以通过将"
" `α` 设置为 `Int` 来指定仅适用于整数列表的 `List.length` 版本："

#: src/getting-to-know/polymorphism.md:240
#, fuzzy
msgid "More Built-In Datatypes"
msgstr "更多内置数据类型"

#: src/getting-to-know/polymorphism.md:242
#, fuzzy
msgid ""
"In addition to lists, Lean's standard library contains a number of other "
"structures and inductive datatypes that can be used in a variety of "
"contexts."
msgstr "除了列表之外，Lean 的标准库还包含许多其他结构体和归纳数据类型，可用于各种场景。"

#: src/getting-to-know/polymorphism.md:244
#, fuzzy
msgid "`Option`"
msgstr "`Option`"

#: src/getting-to-know/polymorphism.md:245
#, fuzzy
msgid ""
"Not every list has a first entry—some lists are empty. Many operations on "
"collections may fail to find what they are looking for. For instance, a "
"function that finds the first entry in a list may not find any such entry. "
"It must therefore have a way to signal that there was no first entry."
msgstr ""
"并非每个列表都有第一个条目——有些列表是空的。许多集合操作可能无法找到它们正在寻找的内容。例如，查找列表中第一个条目的函数可能找不到任何此类条目。因此，它必须有一种方法来表示没有第一个条目。"

#: src/getting-to-know/polymorphism.md:250
#, fuzzy
msgid ""
"Many languages have a `null` value that represents the absence of a value. "
"Instead of equipping existing types with a special `null` value, Lean "
"provides a datatype called `Option` that equips some other type with an "
"indicator for missing values. For instance, a nullable `Int` is represented "
"by `Option Int`, and a nullable list of strings is represented by the type "
"`Option (List String)`. Introducing a new type to represent nullability "
"means that the type system ensures that checks for `null` cannot be "
"forgotten, because an `Option Int` can't be used in a context where an `Int`"
" is expected."
msgstr ""
"许多语言都有一个 `null` 值来表示没有值。Lean 没有为现有类型配备一个特殊的 `null` 值，而是提供了一个名为 `Option` "
"的数据类型，为其他类型配备了一个缺失值指示器。例如，一个可为空的 `Int` 由 `Option Int` 表示，一个可为空的字符串列表由类型 "
"`Option (List String)` 表示。引入一个新类型来表示可空性意味着类型系统确保无法忘记对 `null` 的检查，因为 `Option "
"Int` 不能在需要 `Int` 的上下文中使用。"

#: src/getting-to-know/polymorphism.md:255
#, fuzzy
msgid ""
"`Option` has two constructors, called `some` and `none`, that respectively "
"represent the non-null and null versions of the underlying type. The non-"
"null constructor, `some`, contains the underlying value, while `none` takes "
"no arguments:"
msgstr ""
"`Option` 有两个构造子，称为 `some` 和 `none`，它们分别表示基础类型的非空和空版本。非空构造子 `some` 包含基础值，而 "
"`none` 不带参数："

#: src/getting-to-know/polymorphism.md:263
#, fuzzy
msgid ""
"The `Option` type is very similar to nullable types in languages like C# and"
" Kotlin, but it is not identical. In these languages, if a type (say, "
"`Boolean`) always refers to actual values of the type (`true` and `false`), "
"the type `Boolean?` or `Nullable<Boolean>` additionally admits the `null` "
"value. Tracking this in the type system is very useful: the type checker and"
" other tooling can help programmers remember to check for null, and APIs "
"that explicitly describe nullability through type signatures are more "
"informative than ones that don't. However, these nullable types differ from "
"Lean's `Option` in one very important way, which is that they don't allow "
"multiple layers of optionality. `Option (Option Int)` can be constructed "
"with `none`, `some none`, or `some (some 360)`. C#, on the other hand, "
"forbids multiple layers of nullability by only allowing `?` to be added to "
"non-nullable types, while Kotlin treats `T??` as being equivalent to `T?`. "
"This subtle difference is rarely relevant in practice, but it can matter "
"from time to time."
msgstr ""
"`Option` 类型与 C# 和 Kotlin 等语言中的可空类型非常相似，但并非完全相同。在这些语言中，如果一个类型（比如 "
"`Boolean`）总是引用该类型的实际值（`true` 和 `false`），那么类型 `Boolean?` 或 "
"`Nullable<Boolean>` 另外允许 `null` 值。在类型系统中跟踪这一点非常有用：类型检查器和其他工具可以帮助程序员记住检查 "
"null，并且通过类型签名明确描述可空性的 API 比不描述可空性的 API 更具信息性。然而，这些可空类型与 Lean 的 `Option` "
"在一个非常重要的方面有所不同，那就是它们不允许多层可选项性。`Option (Option Int)` 可以用 `none`、`some none` 或"
" `some (some 360)` 构造。另一方面，C# 禁止多层可空性，只允许将 `?` 添加到不可空类型，而 Kotlin 将 `T??` "
"视为等同于 `T?`。这种细微的差别在实践中很少相关，但有时会很重要。"

#: src/getting-to-know/polymorphism.md:271
#, fuzzy
msgid ""
"To find the first entry in a list, if it exists, use `List.head?`. The "
"question mark is part of the name, and is not related to the use of question"
" marks to indicate nullable types in C# or Kotlin. In the definition of "
"`List.head?`, an underscore is used to represent the tail of the list. In "
"patterns, underscores match anything at all, but do not introduce variables "
"to refer to the matched data. Using underscores instead of names is a way to"
" clearly communicate to readers that part of the input is ignored."
msgstr ""
"要查找列表中的第一个条目（如果存在），请使用 `List.head?`。问号是名称的一部分，与在 C# 或 Kotlin 中使用问号表示可空类型无关。在"
" `List.head?` "
"的定义中，下划线用于表示列表的尾部。在模式中，下划线匹配任何内容，但不会引入变量来引用匹配的数据。使用下划线而不是名称是一种向读者清楚传达输入部分被忽略的方式。"

#: src/getting-to-know/polymorphism.md:282
#, fuzzy
msgid ""
"A Lean naming convention is to define operations that might fail in groups "
"using the suffixes `?` for a version that returns an `Option`, `!` for a "
"version that crashes when provided with invalid input, and `D` for a version"
" that returns a default value when the operation would otherwise fail. For "
"instance, `head` requires the caller to provide mathematical evidence that "
"the list is not empty, `head?` returns an `Option`, `head!` crashes the "
"program when passed an empty list, and `headD` takes a default value to "
"return in case the list is empty. The question mark and exclamation mark are"
" part of the name, not special syntax, as Lean's naming rules are more "
"liberal than many languages."
msgstr ""
"Lean 的命名约定是使用后缀 `?` 定义可能失败的操作，用于返回 `Option` 的版本，`！` 用于在提供无效输入时崩溃的版本，`D` "
"用于在操作在其他情况下失败时返回默认值的版本。例如，`head` 要求调用者提供数学证据证明列表不为空，`head?` 返回 "
"`Option`，`head!` 在传递空列表时使程序崩溃，`headD` "
"采用一个默认值，以便在列表为空时返回。问号和感叹号是名称的一部分，而不是特殊语法，因为 Lean 的命名规则比许多语言更自由。"

#: src/getting-to-know/polymorphism.md:286
#, fuzzy
msgid ""
"Because `head?` is defined in the `List` namespace, it can be used with "
"accessor notation:"
msgstr "因为 `head?` 在 `List` 命名空间中定义，所以它可以使用访问器符号："

#: src/getting-to-know/polymorphism.md:293
#, fuzzy
msgid "However, attempting to test it on the empty list leads to two errors:"
msgstr "然而，尝试在空列表上测试它会导致两个错误："

#: src/getting-to-know/polymorphism.md:308
#, fuzzy
msgid ""
"This is because Lean was unable to fully determine the expression's type. In"
" particular, it could neither find the implicit type argument to "
"`List.head?`, nor could it find the implicit type argument to `List.nil`. In"
" Lean's output, `?m.XYZ` represents a part of a program that could not be "
"inferred. These unknown parts are called _metavariables_, and they occur in "
"some error messages. In order to evaluate an expression, Lean needs to be "
"able to find its type, and the type was unavailable because the empty list "
"does not have any entries from which the type can be found. Explicitly "
"providing a type allows Lean to proceed:"
msgstr ""
"这是因为 Lean 无法完全确定表达式的类型。特别是，它既找不到 `List.head?` 的隐式类型参数，也找不到 `List.nil` "
"的隐式类型参数。在 Lean 的输出中，`?m.XYZ` 表示程序中无法推断的部分。这些未知部分称为 "
"_元变量_，它们出现在一些错误消息中。为了计算一个表达式，Lean "
"需要能够找到它的类型，而类型不可用，因为空列表没有任何条目可以从中找到类型。显式提供类型允许 Lean 继续："

#: src/getting-to-know/polymorphism.md:320
#, fuzzy
msgid "The type can also be provided with a type annotation:"
msgstr "类型也可以提供类型注解："

#: src/getting-to-know/polymorphism.md:327
#, fuzzy
msgid ""
"The error messages provide a useful clue. Both messages use the _same_ "
"metavariable to describe the missing implicit argument, which means that "
"Lean has determined that the two missing pieces will share a solution, even "
"though it was unable to determine the actual value of the solution."
msgstr ""
"错误信息提供了一个有用的线索。两个信息都使用_相同_的元变量来描述缺少的隐式参数，这意味着 Lean "
"已经确定两个缺少的部分将共享一个解决方案，即使它无法确定解决方案的实际值。"

#: src/getting-to-know/polymorphism.md:330
#, fuzzy
msgid "`Prod`"
msgstr "`Prod`"

#: src/getting-to-know/polymorphism.md:332
#, fuzzy
msgid ""
"The `Prod` structure, short for \"Product\", is a generic way of joining two"
" values together. For instance, a `Prod Nat String` contains a `Nat` and a "
"`String`. In other words, `PPoint Nat` could be replaced by `Prod Nat Nat`. "
"`Prod` is very much like C#'s tuples, the `Pair` and `Triple` types in "
"Kotlin, and `tuple` in C++. Many applications are best served by defining "
"their own structures, even for simple cases like `Point`, because using "
"domain terminology can make it easier to read the code. Additionally, "
"defining structure types helps catch more errors by assigning different "
"types to different domain concepts, preventing them from being mixed up."
msgstr ""
"`Prod` 结构体，即「Product」的缩写，是一种将两个值连接在一起的通用方法。例如，`Prod Nat String` 包含一个 `Nat` "
"和一个 `String`。换句话说，`PPoint Nat` 可以替换为 `Prod Nat Nat`。`Prod` 非常类似于 C# "
"的元组、Kotlin 中的 `Pair` 和 `Triple` 类型以及 C++ 中的 `tuple`。许多应用程序最适合定义自己的结构体，即使对于像 "
"`Point` "
"这样的简单情况也是如此，因为使用领域术语可以使代码更容易阅读。此外，定义结构体类型有助于通过为不同的领域概念分配不同的类型来捕获更多错误，防止它们混淆。"

#: src/getting-to-know/polymorphism.md:339
#, fuzzy
msgid ""
"On the other hand, there are some cases where it is not worth the overhead "
"of defining a new type. Additionally, some libraries are sufficiently "
"generic that there is no more specific concept than \"pair\". Finally, the "
"standard library contains a variety of convenience functions that make it "
"easier to work with the built-in pair type."
msgstr ""
"另一方面，在某些情况下，定义新类型是不值得的开销。此外，一些库足够通用，以至于没有比「对」更具体的概念。最后，标准库包含各种便利函数，使使用内置对类型变得更容易。"

#: src/getting-to-know/polymorphism.md:343
#, fuzzy
msgid "The standard pair structure is called `Prod`."
msgstr "标准对结构体称为 `Prod`。"

#: src/getting-to-know/polymorphism.md:349
#, fuzzy
msgid ""
"Lists are used so frequently that there is special syntax to make them more "
"readable. For the same reason, both the product type and its constructor "
"have special syntax. The type `Prod α β` is typically written `α × β`, "
"mirroring the usual notation for a Cartesian product of sets. Similarly, the"
" usual mathematical notation for pairs is available for `Prod`. In other "
"words, instead of writing:"
msgstr ""
"列表使用如此频繁，以至于有特殊的语法使它们更具可读性。出于同样的原因，乘积类型及其构造子都有特殊的语法。类型 `Prod α β` 通常写为 `α ×"
" β`，反映了集合笛卡尔积的常用表示法。类似地，对的常用数学表示法可用于 `Prod`。换句话说，不要写："

#: src/getting-to-know/polymorphism.md:354
#, fuzzy
msgid ""
"```lean\n"
"def fives : String × Int := { fst := \"five\", snd := 5 }\n"
"```"
msgstr ""
"```lean\n"
"def fives : String × Int := (\"five\", 5)\n"
"```\n"
"\n"
"以上两种表示法都是右结合的。这意味着以下定义是等价的：\n"
"\n"
"```lean\n"
"def sevens : String × Int × Nat := (\"VII\", 7, 4 + 3)\n"
"\n"
"def sevens : String × (Int × Nat) := (\"VII\", (7, 4 + 3))\n"
"```\n"
"\n"
"换句话说，所有包含两个以上类型的乘积及其对应的构造子实际上都是嵌套乘积和嵌套对。\n"
"\n"
"`Sum`\n"
"\n"
"`Sum` 数据类型是一种通用的方式，允许在两种不同类型的值之间进行选择。例如，`Sum String Int` 要么是 `String`，要么是 `Int`。与 `Prod` 类似，`Sum` 应该在编写非常通用的代码时使用，用于没有合理域特定类型的小段代码，或者当标准库包含有用的函数时。在大多数情况下，使用自定义归纳类型更具可读性和可维护性。\n"
"\n"
"`Sum α β` 类型的取值要么是应用于 `α` 类型的值的构造子 `inl`，要么是应用于 `β` 类型的值的构造子 `inr`：\n"
"\n"
"```lean\n"
"inl (x : α) : Sum α β\n"
"inr (y : β) : Sum α β\n"
"```\n"
"\n"
"这些名称分别是「左注入」和「右注入」的缩写。就像笛卡尔积符号用于 `Prod` 一样，「圆圈加号」符号用于 `Sum`，所以 `α ⊕ β` 是编写 `Sum α β` 的另一种方式。`Sum.inl` 和 `Sum.inr` 没有特殊语法。\n"
"\n"
"例如，如果宠物名称可以是狗名或猫名，那么它们的类型可以作为一个字符串和的和来引入：\n"
"\n"
"```lean\n"
"def PetName : Type := String ⊕ String\n"
"```"

#: src/getting-to-know/polymorphism.md:357
#, fuzzy
msgid "it suffices to write:"
msgstr "只需编写："

#: src/getting-to-know/polymorphism.md:358
#, fuzzy
msgid ""
"```lean\n"
"def fives : String × Int := (\"five\", 5)\n"
"```"
msgstr ""
"```lean\n"
"def fives : String × Int := (\"five\", 5)\n"
"```"

#: src/getting-to-know/polymorphism.md:362
#, fuzzy
msgid ""
"Both notations are right-associative. This means that the following "
"definitions are equivalent:"
msgstr "这两种表示法都是右结合的。这意味着以下定义是等价的："

#: src/getting-to-know/polymorphism.md:364
#, fuzzy
msgid ""
"```lean\n"
"def sevens : String × Int × Nat := (\"VII\", 7, 4 + 3)\n"
"\n"
"def sevens : String × (Int × Nat) := (\"VII\", (7, 4 + 3))\n"
"```"
msgstr ""
"```lean\n"
"def sevens : String × Int × Nat := (\"VII\", 7, 4 + 3)\n"
"\n"
"def sevens : String × (Int × Nat) := (\"VII\", (7, 4 + 3))\n"
"```"

#: src/getting-to-know/polymorphism.md:369
#, fuzzy
msgid ""
"In other words, all products of more than two types, and their corresponding"
" constructors, are actually nested products and nested pairs behind the "
"scenes."
msgstr "换句话说，所有超过两种类型的乘积及其对应的构造子实际上都是嵌套乘积和嵌套对。"

#: src/getting-to-know/polymorphism.md:373
#, fuzzy
msgid "`Sum`"
msgstr "`Sum`"

#: src/getting-to-know/polymorphism.md:375
#, fuzzy
msgid ""
"The `Sum` datatype is a generic way of allowing a choice between values of "
"two different types. For instance, a `Sum String Int` is either a `String` "
"or an `Int`. Like `Prod`, `Sum` should be used either when writing very "
"generic code, for a very small section of code where there is no sensible "
"domain-specific type, or when the standard library contains useful "
"functions. In most situations, it is more readable and maintainable to use a"
" custom inductive type."
msgstr ""
"`Sum` 数据类型是一种允许在两种不同类型的值之间进行选择的一般方式。例如，`Sum String Int` 要么是 `String`，要么是 "
"`Int`。与 `Prod` 一样，`Sum` "
"应该在编写非常通用的代码时使用，对于没有合理域特定类型的一小段代码，或者当标准库包含有用的函数时使用。在大多数情况下，使用自定义归纳类型更具可读性和可维护性。"

#: src/getting-to-know/polymorphism.md:380
#, fuzzy
msgid ""
"Values of type `Sum α β` are either the constructor `inl` applied to a value"
" of type `α` or the constructor `inr` applied to a value of type `β`:"
msgstr "`Sum α β` 类型的取值要么是应用于 `α` 类型的构造子 `inl`，要么是应用于 `β` 类型的构造子 `inr`："

#: src/getting-to-know/polymorphism.md:386
#, fuzzy
msgid ""
"These names are abbreviations for \"left injection\" and \"right "
"injection\", respectively. Just as the Cartesian product notation is used "
"for `Prod`, a \"circled plus\" notation is used for `Sum`, so `α ⊕ β` is "
"another way to write `Sum α β`. There is no special syntax for `Sum.inl` and"
" `Sum.inr`."
msgstr ""
"这些名称分别是「左注入」和「右注入」的缩写。就像笛卡尔积符号用于 `Prod` 一样，「圆圈加号」符号用于 `Sum`，因此 `α ⊕ β` 是编写 "
"`Sum α β` 的另一种方式。`Sum.inl` 和 `Sum.inr` 没有特殊语法。"

#: src/getting-to-know/polymorphism.md:390
#, fuzzy
msgid ""
"For instance, if pet names can either be dog names or cat names, then a type"
" for them can be introduced as a sum of strings:"
msgstr "例如，如果宠物名称可以是狗名或猫名，那么它们的类型可以作为字符串的和来引入："

#: src/getting-to-know/polymorphism.md:394
#, fuzzy
msgid ""
"In a real program, it would usually be better to define a custom inductive "
"datatype for this purpose with informative constructor names. Here, "
"`Sum.inl` is to be used for dog names, and `Sum.inr` is to be used for cat "
"names. These constructors can be used to write a list of animal names:"
msgstr ""
"在实际程序中，通常最好为此目的定义一个自定义归纳数据类型，并使用有意义的构造子名称。这里，`Sum.inl` 用于狗的名字，`Sum.inr` "
"用于猫的名字。这些构造子可用于编写动物名称列表："

#: src/getting-to-know/polymorphism.md:397
#, fuzzy
msgid ""
"```lean\n"
"def animals : List PetName :=\n"
"  [Sum.inl \"Spot\", Sum.inr \"Tiger\", Sum.inl \"Fifi\", Sum.inl \"Rex\", Sum.inr \"Floof\"]\n"
"```"
msgstr ""
"```lean\n"
"def animals : List PetName :=\n"
"  [Sum.inl \"Spot\", Sum.inr \"Tiger\", Sum.inl \"Fifi\", Sum.inl \"Rex\", Sum.inr \"Floof\"]\n"
"```"

#: src/getting-to-know/polymorphism.md:401
#, fuzzy
msgid ""
"Pattern matching can be used to distinguish between the two constructors. "
"For instance, a function that counts the number of dogs in a list of animal "
"names (that is, the number of `Sum.inl` constructors) looks like this:"
msgstr "模式匹配可用于区分两个构造子。例如，一个函数用于统计动物名称列表中狗的数量（即 `Sum.inl` 构造子的数量），如下所示："

#: src/getting-to-know/polymorphism.md:410
#, fuzzy
msgid ""
"Function calls are evaluated before infix operators, so `howManyDogs "
"morePets + 1` is the same as `(howManyDogs morePets) + 1`. As expected, "
"`#eval howManyDogs animals` yields `3`."
msgstr ""
"函数调用在中缀运算符之前进行求值，因此 `howManyDogs morePets + 1` 等于 `(howManyDogs morePets) + "
"1`。正如预期的那样，`#eval howManyDogs animals` 产生 `3`。"

#: src/getting-to-know/polymorphism.md:413
#, fuzzy
msgid "`Unit`"
msgstr "`Unit`"

#: src/getting-to-know/polymorphism.md:415
#, fuzzy
msgid ""
"`Unit` is a type with just one argumentless constructor, called `unit`. In "
"other words, it describes only a single value, which consists of said "
"constructor applied to no arguments whatsoever. `Unit` is defined as "
"follows:"
msgstr ""
"`Unit` 是一个仅有一个无参构造子（称为 `unit`）的类型。换句话说，它只描述一个值，该值由应用于没有任何参数的构造子组成。`Unit` "
"定义如下："

#: src/getting-to-know/polymorphism.md:423
#, fuzzy
msgid ""
"On its own, `Unit` is not particularly useful. However, in polymorphic code,"
" it can be used as a placeholder for data that is missing. For instance, the"
" following inductive datatype represents arithmetic expressions:"
msgstr "单独使用时，`Unit` 并不是特别有用。但是，在多态代码中，它可以用作缺少数据的占位符。例如，以下归纳数据类型表示算术表达式："

#: src/getting-to-know/polymorphism.md:433
#, fuzzy
msgid ""
"The type argument `ann` stands for annotations, and each constructor is "
"annotated. Expressions coming from a parser might be annotated with source "
"locations, so a return type of `ArithExpr SourcePos` ensures that the parser"
" put a `SourcePos` at each subexpression. Expressions that don't come from "
"the parser, however, will not have source locations, so their type can be "
"`ArithExpr Unit`."
msgstr ""
"类型参数 `ann` 表示注释，每个构造子都有注释。来自解析器的表达式可能带有源位置注释，因此 `ArithExpr SourcePos` "
"的返回类型确保解析器在每个子表达式中放置 `SourcePos`。然而，不来自解析器的表达式将没有源位置，因此它们的类型可以是 `ArithExpr "
"Unit`。"

#: src/getting-to-know/polymorphism.md:438
#, fuzzy
msgid ""
"Additionally, because all Lean functions have arguments, zero-argument "
"functions in other languages can be represented as functions that take a "
"`Unit` argument. In a return position, the `Unit` type is similar to `void` "
"in languages derived from C. In the C family, a function that returns `void`"
" will return control to its caller, but it will not return any interesting "
"value. By being an intentionally uninteresting value, `Unit` allows this to "
"be expressed without requiring a special-purpose `void` feature in the type "
"system. Unit's constructor can be written as empty parentheses: `() : Unit`."
msgstr ""
"此外，由于所有 Lean 函数都有参数，因此其他语言中的零参数函数可以表示为接受 `Unit` 参数的函数。在返回位置，`Unit` 类型类似于源自 C"
" 的语言中的 `void`。在 C 系列中，返回 `void` 的函数会将控制权返回给调用者，但不会返回任何有意义的值。`Unit` "
"通过成为一个故意无意义的值，可以在不需要类型系统中具有特殊用途的 `void` 特性的情况下表达这一点。Unit 的构造子可以写成空括号：`() : "
"Unit`。"

#: src/getting-to-know/polymorphism.md:444
#, fuzzy
msgid "`Empty`"
msgstr "`Empty`"

#: src/getting-to-know/polymorphism.md:446
#, fuzzy
msgid ""
"The `Empty` datatype has no constructors whatsoever. Thus, it indicates "
"unreachable code, because no series of calls can ever terminate with a value"
" at type `Empty`."
msgstr "`Empty` 数据类型没有任何构造子。因此，它表示不可达代码，因为任何调用序列都无法以 `Empty` 类型的返回值终止。"

#: src/getting-to-know/polymorphism.md:449
#, fuzzy
msgid ""
"`Empty` is not used nearly as often as `Unit`. However, it is useful in some"
" specialized contexts. Many polymorphic datatypes do not use all of their "
"type arguments in all of their constructors. For instance, `Sum.inl` and "
"`Sum.inr` each use only one of `Sum`'s type arguments. Using `Empty` as one "
"of the type arguments to `Sum` can rule out one of the constructors at a "
"particular point in a program. This can allow generic code to be used in "
"contexts that have additional restrictions."
msgstr ""
"`Empty` 的使用频率远不及 "
"`Unit`。然而，它在一些特殊情况下很有用。许多多态数据类型并非在其所有构造子中使用其所有类型参数。例如，`Sum.inl` 和 `Sum.inr`"
" 各自只使用 `Sum` 的一个类型参数。将 `Empty` 用作 `Sum` "
"的类型参数之一可以在程序的特定点排除一个构造子。这允许在具有附加限制的上下文中使用泛型代码。"

#: src/getting-to-know/polymorphism.md:456
#, fuzzy
msgid "Naming: Sums, Products, and Units"
msgstr "命名：和、积和单位"

#: src/getting-to-know/polymorphism.md:458
#, fuzzy
msgid ""
"Generally speaking, types that offer multiple constructors are called _sum "
"types_, while types whose single constructor takes multiple arguments are "
"called _product types_. These terms are related to sums and products used in"
" ordinary arithmetic. The relationship is easiest to see when the types "
"involved contain a finite number of values. If `α` and `β` are types that "
"contain \\\\( n \\\\) and \\\\( k \\\\) distinct values, respectively, then "
"`α ⊕ β` contains \\\\( n + k \\\\) distinct values and `α × β` contains "
"\\\\( n \\times k \\\\) distinct values. For instance, `Bool` has two "
"values: `true` and `false`, and `Unit` has one value: `Unit.unit`. The "
"product `Bool × Unit` has the two values `(true, Unit.unit)` and `(false, "
"Unit.unit)`, and the sum `Bool ⊕ Unit` has the three values `Sum.inl true`, "
"`Sum.inl false`, and `Sum.inr unit`. Similarly, \\\\( 2 \\times 1 = 2 \\\\),"
" and \\\\( 2 + 1 = 3 \\\\)."
msgstr ""
"一般来说，提供多个构造子的类型称为 _和类型_，而其单个构造子接受多个参数的类型称为 "
"_积类型_。这些术语与普通算术中使用的和和积有关。当涉及的类型包含有限数量的值时，这种关系最容易看出。如果 `α` 和 `β` 是分别包含 \\\\( "
"n \\\\) 和 \\\\( k \\\\) 个不同值的数据类型，则 `α ⊕ β` 包含 \\\\( n + k \\\\) 个不同值，`α × "
"β` 包含 \\\\( n \\times k \\\\) 个不同值。例如，`Bool` 有两个值：`true` 和 `false`，`Unit` "
"有一个值：`Unit.unit`。积 `Bool × Unit` 有两个值 `(true, Unit.unit)` 和 `(false, "
"Unit.unit)`，和 `Bool ⊕ Unit` 有三个值 `Sum.inl true`、`Sum.inl false` 和 `Sum.inr "
"unit`。类似地，\\\\( 2 \\times 1 = 2 \\\\)，\\\\( 2 + 1 = 3 \\\\)。"

#: src/getting-to-know/polymorphism.md:468
#, fuzzy
msgid ""
"Not all definable structures or inductive types can have the type `Type`. In"
" particular, if a constructor takes an arbitrary type as an argument, then "
"the inductive type must have a different type. These errors usually state "
"something about \"universe levels\". For example, for this inductive type:"
msgstr ""
"并非所有可定义的结构体或归纳类型都可以具有类型 "
"`Type`。特别是，如果一个构造子将任意类型作为参数，则归纳类型必须具有不同的类型。这些错误通常会说明一些关于「宇宙级别」的内容。例如，对于这个归纳类型："

#: src/getting-to-know/polymorphism.md:476
#, fuzzy
msgid "Lean gives the following error:"
msgstr "Lean 给出了以下错误："

#: src/getting-to-know/polymorphism.md:485
#, fuzzy
msgid ""
"A later chapter describes why this is the case, and how to modify "
"definitions to make them work. For now, try making the type an argument to "
"the inductive type as a whole, rather than to the constructor."
msgstr "稍后的章节将描述为什么会这样，以及如何修改定义使其正常工作。现在，尝试将类型作为参数传递给整个归纳类型，而不是传递给构造子。"

#: src/getting-to-know/polymorphism.md:488
#, fuzzy
msgid ""
"Similarly, if a constructor's argument is a function that takes the datatype"
" being defined as an argument, then the definition is rejected. For example:"
msgstr "类似地，如果构造子的参数是一个将正在定义的数据类型作为参数的函数，那么该定义将被拒绝。例如："

#: src/getting-to-know/polymorphism.md:494
#, fuzzy
msgid "yields the message:"
msgstr "会产生以下消息："

#: src/getting-to-know/polymorphism.md:498
#, fuzzy
msgid ""
"For technical reasons, allowing these datatypes could make it possible to "
"undermine Lean's internal logic, making it unsuitable for use as a theorem "
"prover."
msgstr "出于技术原因，允许这些数据类型可能会破坏 Lean 的内部逻辑，使其不适合用作定理证明器。"

#: src/getting-to-know/polymorphism.md:500
#, fuzzy
msgid ""
"Forgetting an argument to an inductive type can also yield a confusing "
"message. For example, when the argument `α` is not passed to `MyType` in "
"`ctor`'s type:"
msgstr "忘记归纳类型的参数也可能产生令人困惑的消息。例如，当参数 `α` 没有传递给 `ctor` 的类型中的 `MyType` 时："

#: src/getting-to-know/polymorphism.md:506
#, fuzzy
msgid "Lean replies with the following error:"
msgstr "Lean 会返回以下错误："

#: src/getting-to-know/polymorphism.md:511
#, fuzzy
msgid ""
"The error message is saying that `MyType`'s type, which is `Type → Type`, "
"does not itself describe types. `MyType` requires an argument to become an "
"actual honest-to-goodness type."
msgstr ""
"错误消息表明 `MyType` 的类型 `Type → Type` 本身并不描述类型。`MyType` 需要一个参数才能成为一个真正的类型。"

#: src/getting-to-know/polymorphism.md:514
#, fuzzy
msgid ""
"The same message can appear when type arguments are omitted in other "
"contexts, such as in a type signature for a definition:"
msgstr "在其他上下文中省略类型参数时也会出现相同的消息，例如在定义的类型签名中："

#: src/getting-to-know/polymorphism.md:524
#, fuzzy
msgid ""
"Write a function to find the last entry in a list. It should return an "
"`Option`."
msgstr "编写一个函数来查找列表中的最后一个条目。它应该返回一个 `Option`。"

#: src/getting-to-know/polymorphism.md:525
#, fuzzy
msgid ""
"Write a function that finds the first entry in a list that satisfies a given"
" predicate. Start the definition with `def List.findFirst? {α : Type} (xs : "
"List α) (predicate : α → Bool) : Option α :=`"
msgstr ""
"编写一个函数，在列表中找到满足给定谓词的第一个条目。从 `def List.findFirst? {α : Type} (xs : List α) "
"(predicate : α → Bool) : Option α :=` 开始定义"

#: src/getting-to-know/polymorphism.md:526
#, fuzzy
msgid ""
"Write a function `Prod.swap` that swaps the two fields in a pair. Start the "
"definition with `def Prod.swap {α β : Type} (pair : α × β) : β × α :=`"
msgstr ""
"定义一个函数 `Prod.swap`，用于交换对中的两个字段。定义以 `def Prod.swap {α β : Type} (pair : α × "
"β) : β × α :=` 开始"

#: src/getting-to-know/polymorphism.md:527
#, fuzzy
msgid ""
"Rewrite the `PetName` example to use a custom datatype and compare it to the"
" version that uses `Sum`."
msgstr "使用自定义数据类型重写 `PetName` 示例，并将其与使用 `Sum` 的版本进行比较。"

#: src/getting-to-know/polymorphism.md:528
#, fuzzy
msgid ""
"Write a function `zip` that combines two lists into a list of pairs. The "
"resulting list should be as long as the shortest input list. Start the "
"definition with `def zip {α β : Type} (xs : List α) (ys : List β) : List (α "
"× β) :=`."
msgstr ""
"定义一个函数 `zip`，用于将两个列表组合成一个对列表。结果列表的长度应与最短的输入列表相同。定义以 `def zip {α β : Type} "
"(xs : List α) (ys : List β) : List (α × β) :=` 开始"

#: src/getting-to-know/polymorphism.md:529
#, fuzzy
msgid ""
"Write a polymorphic function `take` that returns the first \\\\( n \\\\) "
"entries in a list, where \\\\( n \\\\) is a `Nat`. If the list contains "
"fewer than `n` entries, then the resulting list should be the input list. "
"`#eval take 3 [\"bolete\", \"oyster\"]` should yield `[\"bolete\", "
"\"oyster\"]`, and `#eval take 1 [\"bolete\", \"oyster\"]` should yield "
"`[\"bolete\"]`."
msgstr ""
"编写一个多态函数 `take`，返回列表中的前 \\\\( n \\\\) 个条目，其中 \\\\( n \\\\) 是一个 "
"`Nat`。如果列表包含的条目少于 `n` 个，则结果列表应为输入列表。`#eval take 3 [\"bolete\", \"oyster\"]` "
"应生成 `[\"bolete\", \"oyster\"]`，而 `#eval take 1 [\"bolete\", \"oyster\"]` 应生成"
" `[\"bolete\"]`。"

#: src/getting-to-know/polymorphism.md:530
#, fuzzy
msgid ""
"Using the analogy between types and arithmetic, write a function that "
"distributes products over sums. In other words, it should have type `α × (β "
"⊕ γ) → (α × β) ⊕ (α × γ)`."
msgstr ""
"利用类型和算术之间的类比，编写一个将乘积分配到和上的函数。换句话说，它的类型应为 `α × (β ⊕ γ) → (α × β) ⊕ (α × γ)`。"

#: src/getting-to-know/polymorphism.md:531
#, fuzzy
msgid ""
"Using the analogy between types and arithmetic, write a function that turns "
"multiplication by two into a sum. In other words, it should have type `Bool "
"× α → α ⊕ α`."
msgstr "利用类型和算术之间的类比，编写一个将乘以 2 转换为和的函数。换句话说，它的类型应为 `Bool × α → α ⊕ α`。"
TODO
#: src/getting-to-know/conveniences.md:3
#, fuzzy
msgid ""
"Lean contains a number of convenience features that make programs much more "
"concise."
msgstr "Lean 包含许多便利功能，使程序更加简洁。"

#: src/getting-to-know/conveniences.md:5
#, fuzzy
msgid "Automatic Implicit Arguments"
msgstr "自动隐式参数"

#: src/getting-to-know/conveniences.md:7
#, fuzzy
msgid ""
"When writing polymorphic functions in Lean, it is typically not necessary to"
" list all the implicit arguments. Instead, they can simply be mentioned. If "
"Lean can determine their type, then they are automatically inserted as "
"implicit arguments. In other words, the previous definition of `length`:"
msgstr ""
"在 Lean 中编写多态函数时，通常不必列出所有隐式参数。相反，它们可以简单地被提及。如果 Lean "
"可以确定它们的类型，那么它们将自动插入为隐式参数。换句话说，`length` 的先前定义："

#: src/getting-to-know/conveniences.md:17
#, fuzzy
msgid "can be written without `{α : Type}`:"
msgstr "可以不写 `{α : Type}`："

#: src/getting-to-know/conveniences.md:24
#, fuzzy
msgid ""
"This can greatly simplify highly polymorphic definitions that take many "
"implicit arguments."
msgstr "这可以极大简化需要很多隐式参数的高级多态定义。"

#: src/getting-to-know/conveniences.md:26
#, fuzzy
msgid "Pattern-Matching Definitions"
msgstr "模式匹配定义"

#: src/getting-to-know/conveniences.md:28
#, fuzzy
msgid ""
"When defining functions with `def`, it is quite common to name an argument "
"and then immediately use it with pattern matching. For instance, in "
"`length`, the argument `xs` is used only in `match`. In these situations, "
"the cases of the `match` expression can be written directly, without naming "
"the argument at all."
msgstr ""
"用 `def` 定义函数时，通常会给参数命名，然后立即用模式匹配使用它。例如，在 `length` 中，参数 `xs` 仅在 `match` "
"中使用。在这些情况下，`match` 表达式的 case 可以直接编写，而无需给参数命名。"

#: src/getting-to-know/conveniences.md:32
#, fuzzy
msgid ""
"The first step is to move the arguments' types to the right of the colon, so"
" the return type is a function type. For instance, the type of `length` is "
"`List α → Nat`. Then, replace the `:=` with each case of the pattern match:"
msgstr ""
"第一步是将参数类型移到冒号的右侧，因此返回类型是函数类型。例如，`length` 的类型是 `List α → Nat`。然后，用模式匹配的每个 "
"case 替换 `:=`："

#: src/getting-to-know/conveniences.md:41
#, fuzzy
msgid ""
"This syntax can also be used to define functions that take more than one "
"argument. In this case, their patterns are separated by commas. For "
"instance, `drop` takes a number \\\\( n \\\\) and a list, and returns the "
"list after removing the first \\\\( n \\\\) entries."
msgstr ""
"此语法还可用于定义接受多个参数的函数。在这种情况下，它们的模式用逗号分隔。例如，`drop` 接受一个数字 \\\\( n \\\\) "
"和一个列表，并返回删除前 \\\\( n \\\\) 个条目的列表。"

#: src/getting-to-know/conveniences.md:51
#, fuzzy
msgid ""
"Named arguments and patterns can also be used in the same definition. For "
"instance, a function that takes a default value and an optional value, and "
"returns the default when the optional value is `none`, can be written:"
msgstr "命名参数和模式也可以在同一定义中使用。例如，一个函数接受一个默认值和一个可选值，当可选值为 `none` 时返回默认值，可以写成："

#: src/getting-to-know/conveniences.md:58
#, fuzzy
msgid ""
"This function is called `Option.getD` in the standard library, and can be "
"called with dot notation:"
msgstr "此函数在标准库中称为 `Option.getD`，可以用点表示法调用："

#: src/getting-to-know/conveniences.md:59
#, fuzzy
msgid ""
"```lean\n"
"#eval (some \"salmonberry\").getD \"\"\n"
"```"
msgstr ""
"```lean\n"
"#eval (some \"salmonberry\").getD \"\"\n"
"```"

#: src/getting-to-know/conveniences.md:62
#, fuzzy
msgid ""
"```output info\n"
"\"salmonberry\"\n"
"```"
msgstr ""
"```output info\n"
"\"salmonberry\"\n"
"```"

#: src/getting-to-know/conveniences.md:65
#, fuzzy
msgid ""
"```lean\n"
"#eval none.getD \"\"\n"
"```"
msgstr ""
"```lean\n"
"#eval none.getD \"\"\n"
"```"

#: src/getting-to-know/conveniences.md:68
#, fuzzy
msgid ""
"```output info\n"
"\"\"\n"
"```"
msgstr ""
"```output info\n"
"\"\"\n"
"```"

#: src/getting-to-know/conveniences.md:72
#, fuzzy
msgid "Local Definitions"
msgstr "局部定义"

#: src/getting-to-know/conveniences.md:74
#, fuzzy
msgid ""
"It is often useful to name intermediate steps in a computation. In many "
"cases, intermediate values represent useful concepts all on their own, and "
"naming them explicitly can make the program easier to read. In other cases, "
"the intermediate value is used more than once. As in most other languages, "
"writing down the same code twice in Lean causes it to be computed twice, "
"while saving the result in a variable leads to the result of the computation"
" being saved and re-used."
msgstr ""
"在计算中对中间步骤命名通常很有用。在许多情况下，中间值本身就代表有用的概念，明确地命名它们可以使程序更易于阅读。在其他情况下，中间值被使用多次。与大多数其他语言一样，在"
" Lean 中两次写下相同的代码会导致计算两次，而将结果保存在变量中会导致计算的结果被保存并重新使用。"

#: src/getting-to-know/conveniences.md:79
#, fuzzy
msgid ""
"For instance, `unzip` is a function that transforms a list of pairs into a "
"pair of lists. When the list of pairs is empty, then the result of `unzip` "
"is a pair of empty lists. When the list of pairs has a pair at its head, "
"then the two fields of the pair are added to the result of unzipping the "
"rest of the list. This definition of `unzip` follows that description "
"exactly:"
msgstr ""
"例如，`unzip` 是一个将对列表转换为一对列表的函数。当对列表为空时，`unzip` "
"的结果是一对空列表。当对列表的头部有一个对时，则该对的两个字段将添加到解压缩列表其余部分的结果中。`unzip` 的此定义完全遵循该描述："

#: src/getting-to-know/conveniences.md:89
#, fuzzy
msgid ""
"Unfortunately, there is a problem: this code is slower than it needs to be. "
"Each entry in the list of pairs leads to two recursive calls, which makes "
"this function take exponential time. However, both recursive calls will have"
" the same result, so there is no reason to make the recursive call twice."
msgstr ""
"不幸的是，存在一个问题：此代码比需要的速度慢。对列表中的每个条目都会导致两个递归调用，这使得此函数需要指数时间。然而，两个递归调用都会有相同的结果，因此没有理由进行两次递归调用。"

#: src/getting-to-know/conveniences.md:94
#, fuzzy
msgid ""
"In Lean, the result of the recursive call can be named, and thus saved, "
"using `let`. Local definitions with `let` resemble top-level definitions "
"with `def`: it takes a name to be locally defined, arguments if desired, a "
"type signature, and then a body following `:=`. After the local definition, "
"the expression in which the local definition is available (called the _body_"
" of the `let`\\-expression) must be on a new line, starting at a column in "
"the file that is less than or equal to that of the `let` keyword. For "
"instance, `let` can be used in `unzip` like this:"
msgstr ""
"在 Lean 中，可以使用 `let` 命名递归调用的结果，从而保存它。使用 `let` 的局部定义类似于使用 `def` "
"的顶级定义：它需要一个局部定义的名称，如果需要，还需要参数、类型签名，然后是 `:=` 后面的主体。在局部定义之后，局部定义可用的表达式（称为 "
"`let` 表达式的 _body_）必须在新行上，从文件中的列开始，该列小于或等于 `let` 关键字的列。例如，`let` 可以像这样用于 "
"`unzip`："

#: src/getting-to-know/conveniences.md:105
#, fuzzy
msgid ""
"To use `let` on a single line, separate the local definition from the body "
"with a semicolon."
msgstr "要在单行上使用 `let`，请使用分号将局部定义与主体分隔开。"

#: src/getting-to-know/conveniences.md:107
#, fuzzy
msgid ""
"Local definitions with `let` may also use pattern matching when one pattern "
"is enough to match all cases of a datatype. In the case of `unzip`, the "
"result of the recursive call is a pair. Because pairs have only a single "
"constructor, the name `unzipped` can be replaced with a pair pattern:"
msgstr ""
"当一个模式足以匹配数据类型的全部情况时，使用 `let` 的局部定义也可以使用模式匹配。在 `unzip` "
"的情况下，递归调用的结果是一对。因为对只有一个构造子，所以名称 `unzipped` 可以替换为对模式："

#: src/getting-to-know/conveniences.md:117
#, fuzzy
msgid ""
"Judicious use of patterns with `let` can make code easier to read, compared "
"to writing the accessor calls by hand."
msgstr "巧妙地使用带有 `let` 的模式可以使代码更易于阅读，而无需手动编写访问器调用。"

#: src/getting-to-know/conveniences.md:119
#, fuzzy
msgid ""
"The biggest difference between `let` and `def` is that recursive `let` "
"definitions must be explicitly indicated by writing `let rec`. For instance,"
" one way to reverse a list involves a recursive helper function, as in this "
"definition:"
msgstr ""
"`let` 和 `def` 之间最大的区别在于，递归 `let` 定义必须通过编写 `let rec` "
"明确表示。例如，反转列表的一种方法涉及递归辅助函数，如下所示："

#: src/getting-to-know/conveniences.md:128
#, fuzzy
msgid ""
"The helper function walks down the input list, moving one entry at a time "
"over to `soFar`. When it reaches the end of the input list, `soFar` contains"
" a reversed version of the input."
msgstr "辅助函数遍历输入列表，一次将一个条目移动到 `soFar`。当它到达输入列表的末尾时，`soFar` 包含输入的反转版本。"

#: src/getting-to-know/conveniences.md:132
#, fuzzy
msgid "Type Inference"
msgstr "类型推断"

#: src/getting-to-know/conveniences.md:134
#, fuzzy
msgid ""
"In many situations, Lean can automatically determine an expression's type. "
"In these cases, explicit types may be omitted from both top-level "
"definitions (with `def`) and local definitions (with `let`). For instance, "
"the recursive call to `unzip` does not need an annotation:"
msgstr ""
"在许多情况下，Lean 可以自动确定表达式的类型。在这些情况下，可以从顶级定义（使用 `def`）和局部定义（使用 `let`）中省略显式类型。例如，对"
" `unzip` 的递归调用不需要注释："

#: src/getting-to-know/conveniences.md:145
#, fuzzy
msgid ""
"As a rule of thumb, omitting the types of literal values (like strings and "
"numbers) usually works, although Lean may pick a type for literal numbers "
"that is more specific than the intended type. Lean can usually determine a "
"type for a function application, because it already knows the argument types"
" and the return type. Omitting return types for function definitions will "
"often work, but function arguments typically require annotations. "
"Definitions that are not functions, like `unzipped` in the example, do not "
"need type annotations if their bodies do not need type annotations, and the "
"body of this definition is a function application."
msgstr ""
"根据经验，省略文字值（如字符串和数字）的类型通常有效，尽管 Lean 可能会为文字数字选择比预期类型更具体的类型。Lean "
"通常可以确定函数应用程序的类型，因为它已经知道参数类型和返回类型。省略函数定义的返回类型通常有效，但函数参数通常需要注释。不是函数的定义（如示例中的 "
"`unzipped`）不需要类型标注，如果它们的正文不需要类型标注，并且此定义的正文是函数应用程序。"

#: src/getting-to-know/conveniences.md:150
#, fuzzy
msgid ""
"Omitting the return type for `unzip` is possible when using an explicit "
"`match` expression:"
msgstr "在使用显式 `match` 表达式时，可以省略 `unzip` 的返回类型："

#: src/getting-to-know/conveniences.md:161
#, fuzzy
msgid ""
"Generally speaking, it is a good idea to err on the side of too many, rather"
" than too few, type annotations. First off, explicit types communicate "
"assumptions about the code to readers. Even if Lean can determine the type "
"on its own, it can still be easier to read code without having to repeatedly"
" query Lean for type information. Secondly, explicit types help localize "
"errors. The more explicit a program is about its types, the more informative"
" the error messages can be. This is especially important in a language like "
"Lean that has a very expressive type system. Thirdly, explicit types make it"
" easier to write the program in the first place. The type is a "
"specification, and the compiler's feedback can be a helpful tool in writing "
"a program that meets the specification. Finally, Lean's type inference is a "
"best-effort system. Because Lean's type system is so expressive, there is no"
" \"best\" or most general type to find for all expressions. This means that "
"even if you get a type, there's no guarantee that it's the _right_ type for "
"a given application. For instance, `14` can be a `Nat` or an `Int`:"
msgstr ""
"一般来说，宁可多加类型标注，也不要太少。首先，显式类型向读者传达了对代码的假设。即使 Lean 可以自行确定类型，但无需反复查询 Lean "
"以获取类型信息，代码仍然更容易阅读。其次，显式类型有助于定位错误。程序对其类型越明确，错误消息就越有信息量。这在 Lean "
"这样的具有非常丰富的类型系统的语言中尤为重要。第三，显式类型使编写程序变得更容易。类型是一种规范，编译器的反馈可以成为编写符合规范的程序的有用工具。最后，Lean"
" 的类型推断是一种尽力而为的系统。由于 Lean "
"的类型系统非常丰富，因此无法为所有表达式找到「最佳」或最通用的类型。这意味着即使你得到了一个类型，也不能保证它是给定应用程序的「正确」类型。例如，`14`"
" 可以是 `Nat` 或 `Int`："

#: src/getting-to-know/conveniences.md:186
#, fuzzy
msgid ""
"Missing type annotations can give confusing error messages. Omitting all "
"types from the definition of `unzip`:"
msgstr "缺少类型标注可能会导致令人困惑的错误消息。从 `unzip` 的定义中省略所有类型："

#: src/getting-to-know/conveniences.md:196
#, fuzzy
msgid "leads to a message about the `match` expression:"
msgstr "导致有关 `match` 表达式的消息："

#: src/getting-to-know/conveniences.md:201
#, fuzzy
msgid ""
"This is because `match` needs to know the type of the value being inspected,"
" but that type was not available. A \"metavariable\" is an unknown part of a"
" program, written `?m.XYZ` in error messages—they are described in the "
"[section on Polymorphism](polymorphism.md). In this program, the type "
"annotation on the argument is required."
msgstr ""
"这是因为 `match` 需要知道正在检查的值的类型，但该类型不可用。「元变量」是程序中未知的部分，在错误消息中写为 `?m.XYZ`——它们在 "
"[多态性](polymorphism.md) 一节中进行了描述。在此程序中，参数上的类型标注是必需的。"

#: src/getting-to-know/conveniences.md:205
#, fuzzy
msgid ""
"Even some very simple programs require type annotations. For instance, the "
"identity function just returns whatever argument it is passed. With argument"
" and type annotations, it looks like this:"
msgstr "即使一些非常简单的程序也需要类型标注。例如，恒等函数只返回传递给它的任何参数。使用参数和类型标注，它看起来像这样："

#: src/getting-to-know/conveniences.md:211
#, fuzzy
msgid "Lean is capable of determining the return type on its own:"
msgstr "Lean 能够自行确定返回类型："

#: src/getting-to-know/conveniences.md:215
#, fuzzy
msgid "Omitting the argument type, however, causes an error:"
msgstr "然而，省略参数类型会导致错误："

#: src/getting-to-know/conveniences.md:223
#, fuzzy
msgid ""
"In general, messages that say something like \"failed to infer\" or that "
"mention metavariables are often a sign that more type annotations are "
"necessary. Especially while still learning Lean, it is useful to provide "
"most types explicitly."
msgstr "一般来说，类似于「无法推断」或提及元变量的消息通常表示需要更多类型标注。特别是在学习 Lean 时，显式提供大多数类型是有用的。"

#: src/getting-to-know/conveniences.md:226
#, fuzzy
msgid "Simultaneous Matching"
msgstr "同时匹配"

#: src/getting-to-know/conveniences.md:228
#, fuzzy
msgid ""
"Pattern-matching expressions, just like pattern-matching definitions, can "
"match on multiple values at once. Both the expressions to be inspected and "
"the patterns that they match against are written with commas between them, "
"similarly to the syntax used for definitions. Here is a version of `drop` "
"that uses simultaneous matching:"
msgstr ""
"模式匹配表达式，就像模式匹配定义一样，可以一次匹配多个值。要检查的表达式和它们匹配的模式都用逗号分隔，类似于用于定义的语法。以下是使用同时匹配的 "
"`drop` 版本："

#: src/getting-to-know/conveniences.md:239
#, fuzzy
msgid "Natural Number Patterns"
msgstr "自然数模式"

#: src/getting-to-know/conveniences.md:241
#, fuzzy
msgid ""
"In the section on [datatypes and patterns](datatypes-and-patterns.md), "
"`even` was defined like this:"
msgstr "在 [数据类型和模式](datatypes-and-patterns.md) 一节中，`even` 被定义为："

#: src/getting-to-know/conveniences.md:248
#, fuzzy
msgid ""
"Just as there is special syntax to make list patterns more readable than "
"using `List.cons` and `List.nil` directly, natural numbers can be matched "
"using literal numbers and `+`. For instance, `even` can also be defined like"
" this:"
msgstr ""
"就像有特殊语法使列表模式比直接使用 `List.cons` 和 `List.nil` 更具可读性一样，自然数可以使用字面数字和 `+` "
"进行匹配。例如，`even` 也可以这样定义："

#: src/getting-to-know/conveniences.md:256
#, fuzzy
msgid ""
"In this notation, the arguments to the `+` pattern serve different roles. "
"Behind the scenes, the left argument (`n` above) becomes an argument to some"
" number of `Nat.succ` patterns, and the right argument (`1` above) "
"determines how many `Nat.succ`s to wrap around the pattern. The explicit "
"patterns in `halve`, which divides a `Nat` by two and drops the remainder:"
msgstr ""
"在此表示法中，`+` 模式的参数扮演着不同的角色。在幕后，左参数（上面的 `n`）成为一些 `Nat.succ` 模式的参数，右参数（上面的 "
"`1`）确定围绕模式包装多少个 `Nat.succ`。`halve` 中的显式模式，它将 `Nat` 除以二并丢弃余数："

#: src/getting-to-know/conveniences.md:265
#, fuzzy
msgid "can be replaced by numeric literals and `+`:"
msgstr ""
"幕后，这两个定义完全等价。记住：`halve n + 1` 等价于 `(halve n) + 1`，而不是 `halve (n + 1)`。"

#: src/getting-to-know/conveniences.md:272
#, fuzzy
msgid ""
"Behind the scenes, both definitions are completely equivalent. Remember: "
"`halve n + 1` is equivalent to `(halve n) + 1`, not `halve (n + 1)`."
msgstr "使用此语法时，`+` 的第二个参数应始终为文字 `Nat`。即使加法是可交换的，在模式中翻转参数也会导致以下错误："

#: src/getting-to-know/conveniences.md:275
#, fuzzy
msgid ""
"When using this syntax, the second argument to `+` should always be a "
"literal `Nat`. Even though addition is commutative, flipping the arguments "
"in a pattern can result in errors like the following:"
msgstr "此限制使 Lean 能够将模式中所有 `+` 符号的用法转换为底层 `Nat.succ` 的用法，从而在幕后使语言更简单。"

#: src/getting-to-know/conveniences.md:287
#, fuzzy
msgid ""
"This restriction enables Lean to transform all uses of the `+` notation in a"
" pattern into uses of the underlying `Nat.succ`, keeping the language "
"simpler behind the scenes."
msgstr "匿名函数"

#: src/getting-to-know/conveniences.md:289
#, fuzzy
msgid "Anonymous Functions"
msgstr ""
"Lean 中的函数不必在顶层定义。作为表达式，函数使用 `fun` 语法生成。函数表达式以关键字 `fun` 开头，后跟一个或多个参数，这些参数使用 "
"`=>` 与返回表达式分隔。例如，可以编写一个将数字加 1 的函数："

#: src/getting-to-know/conveniences.md:291
#, fuzzy
msgid ""
"Functions in Lean need not be defined at the top level. As expressions, "
"functions are produced with the `fun` syntax. Function expressions begin "
"with the keyword `fun`, followed by one or more arguments, which are "
"separated from the return expression using `=>`. For instance, a function "
"that adds one to a number can be written:"
msgstr "类型标注的编写方式与 `def` 相同，使用括号和冒号："

#: src/getting-to-know/conveniences.md:301
#, fuzzy
msgid ""
"Type annotations are written the same way as on `def`, using parentheses and"
" colons:"
msgstr "同样，隐式参数可以用大括号编写："

#: src/getting-to-know/conveniences.md:308
#, fuzzy
msgid "Similarly, implicit arguments may be written with curly braces:"
msgstr ""
"这种匿名函数表达式风格通常称为 _lambda 表达式_，因为编程语言的数学描述中使用的典型符号在 Lean 中使用关键字 `fun` "
"的地方使用了希腊字母 λ（lambda）。即使 Lean 允许使用 `λ` 代替 `fun`，但最常见的是编写 `fun`。"

#: src/getting-to-know/conveniences.md:315
#, fuzzy
msgid ""
"This style of anonymous function expression is often referred to as a "
"_lambda expression_, because the typical notation used in mathematical "
"descriptions of programming languages uses the Greek letter λ (lambda) where"
" Lean has the keyword `fun`. Even though Lean does permit `λ` to be used "
"instead of `fun`, it is most common to write `fun`."
msgstr "匿名函数还支持 `def` 中使用的多模式样式。例如，可以编写一个返回自然数的前驱（如果存在）的函数："

#: src/getting-to-know/conveniences.md:318
#, fuzzy
msgid ""
"Anonymous functions also support the multiple-pattern style used in `def`. "
"For instance, a function that returns the predecessor of a natural number if"
" it exists can be written:"
msgstr "匿名函数也支持 `def` 中使用的多模式样式。例如，可以编写一个返回自然数的前驱（如果存在）的函数："

#: src/getting-to-know/conveniences.md:331
#, fuzzy
msgid ""
"Note that Lean's own description of the function has a named argument and a "
"`match` expression. Many of Lean's convenient syntactic shorthands are "
"expanded to simpler syntax behind the scenes, and the abstraction sometimes "
"leaks."
msgstr ""
"注意，Lean 函数的描述本身有一个命名参数和一个 `match` 表达式。Lean 的许多便捷语法缩写都扩展为幕后的更简单的语法，并且抽象有时会泄漏。"

#: src/getting-to-know/conveniences.md:334
#, fuzzy
msgid ""
"Definitions using `def` that take arguments may be rewritten as function "
"expressions. For instance, a function that doubles its argument can be "
"written as follows:"
msgstr "使用 `def` 定义的参数可以重写为函数表达式。例如，可以将将参数加倍的函数写成如下形式："

#: src/getting-to-know/conveniences.md:342
#, fuzzy
msgid ""
"When an anonymous function is very simple, like `fun x => x + 1`, the syntax"
" for creating the function can be fairly verbose. In that particular "
"example, six non-whitespace characters are used to introduce the function, "
"and its body consists of only three non-whitespace characters. For these "
"simple cases, Lean provides a shorthand. In an expression surrounded by "
"parentheses, a centered dot character `·` can stand for an argument, and the"
" expression inside the parentheses becomes the function's body. That "
"particular function can also be written `(· + 1)`."
msgstr ""
"当匿名函数非常简单时，例如 `fun x => x + "
"1`，创建函数的语法可能相当冗长。在那个特定的示例中，六个非空白字符用于引入函数，其主体仅包含三个非空白字符。对于这些简单的情况，Lean "
"提供了一个简写。在括号包围的表达式中，居中的点字符 `·` 可以表示一个参数，括号内的表达式成为函数的主体。那个特定的函数也可以写成 `(· + "
"1)`。"

#: src/getting-to-know/conveniences.md:348
#, fuzzy
msgid ""
"The centered dot always creates a function out of the _closest_ surrounding "
"set of parentheses. For instance, `(· + 5, 3)` is a function that returns a "
"pair of numbers, while `((· + 5), 3)` is a pair of a function and a number. "
"If multiple dots are used, then they become arguments from left to right:"
msgstr ""
"居中的点总是从 _最接近_ 的一组括号中创建函数。例如，`(· + 5, 3)` 是返回一对数字的函数，而 `((· + 5), 3)` "
"是一个函数和一个数字的元组。如果使用多个点，则它们从左到右成为参数："

#: src/getting-to-know/conveniences.md:359
#, fuzzy
msgid ""
"Anonymous functions can be applied in precisely the same way as functions "
"defined using `def` or `let`. The command `#eval (fun x => x + x) 5` results"
" in:"
msgstr ""
"匿名函数可以与使用 `def` 或 `let` 定义的函数完全相同的方式应用。命令 `#eval (fun x => x + x) 5` 的结果是："

#: src/getting-to-know/conveniences.md:364
#, fuzzy
msgid "while `#eval (· * 2) 5` results in:"
msgstr "而 `#eval (· * 2) 5` 的结果是："

#: src/getting-to-know/conveniences.md:369
#, fuzzy
msgid "Namespaces"
msgstr "命名空间"

#: src/getting-to-know/conveniences.md:371
#, fuzzy
msgid ""
"Each name in Lean occurs in a _namespace_, which is a collection of names. "
"Names are placed in namespaces using `.`, so `List.map` is the name `map` in"
" the `List` namespace. Names in different namespaces do not conflict with "
"each other, even if they are otherwise identical. This means that `List.map`"
" and `Array.map` are different names. Namespaces may be nested, so "
"`Project.Frontend.User.loginTime` is the name `loginTime` in the nested "
"namespace `Project.Frontend.User`."
msgstr ""
"Lean 中的每个名称都出现在一个 _命名空间_ 中，这是一个名称集合。名称使用 `.` 放在命名空间中，因此 `List.map` 是 `List` "
"命名空间中的名称 `map`。不同命名空间中的名称不会相互冲突，即使它们在其他方面是相同的。这意味着 `List.map` 和 `Array.map` "
"是不同的名称。命名空间可以嵌套，因此 `Project.Frontend.User.loginTime` 是嵌套命名空间 "
"`Project.Frontend.User` 中的名称 `loginTime`。"

#: src/getting-to-know/conveniences.md:377
#, fuzzy
msgid ""
"Names can be directly defined within a namespace. For instance, the name "
"`double` can be defined in the `Nat` namespace:"
msgstr "命名空间中可以直接定义名称。例如，名称 `double` 可以定义在 `Nat` 命名空间中："

#: src/getting-to-know/conveniences.md:382
#, fuzzy
msgid ""
"Because `Nat` is also the name of a type, dot notation is available to call "
"`Nat.double` on expressions with type `Nat`:"
msgstr "由于 `Nat` 也是一个类型的名称，因此可以使用点表示法对类型为 `Nat` 的表达式调用 `Nat.double`："

#: src/getting-to-know/conveniences.md:390
#, fuzzy
msgid ""
"In addition to defining names directly in a namespace, a sequence of "
"declarations can be placed in a namespace using the `namespace` and `end` "
"commands. For instance, this defines `triple` and `quadruple` in the "
"namespace `NewNamespace`:"
msgstr ""
"除了直接在命名空间中定义名称外，还可以使用 `namespace` 和 `end` 命令将一系列声明放在命名空间中。例如，这在 "
"`NewNamespace` 命名空间中定义了 `triple` 和 `quadruple`："

#: src/getting-to-know/conveniences.md:398
#, fuzzy
msgid "To refer to them, prefix their names with `NewNamespace.`:"
msgstr "要引用它们，请在其名称前加上 `NewNamespace.`："

#: src/getting-to-know/conveniences.md:412
#, fuzzy
msgid ""
"Namespaces may be _opened_, which allows the names in them to be used "
"without explicit qualification. Writing `open MyNamespace in` before an "
"expression causes the contents of `MyNamespace` to be available in the "
"expression. For example, `timesTwelve` uses both `quadruple` and `triple` "
"after opening `NewNamespace`:"
msgstr ""
"命名空间可以「打开」，这允许在不显式限定的情况下使用其中的名称。在表达式之前编写 `open MyNamespace in` 会导致 "
"`MyNamespace` 的内容在表达式中可用。例如，`timesTwelve` 在打开 `NewNamespace` 后同时使用了 "
"`quadruple` 和 `triple`："

#: src/getting-to-know/conveniences.md:420
#, fuzzy
msgid ""
"Namespaces can also be opened prior to a command. This allows all parts of "
"the command to refer to the contents of the namespace, rather than just a "
"single expression. To do this, place the `open ... in` prior to the command."
msgstr ""
"命名空间也可以在命令之前打开。这允许命令的所有部分引用命名空间的内容，而不仅仅是一个表达式。为此，请在命令之前放置 `open ... in`。"

#: src/getting-to-know/conveniences.md:430
#, fuzzy
msgid ""
"Function signatures show the name's full namespace. Namespaces may "
"additionally be opened for _all_ following commands for the rest of the "
"file. To do this, simply omit the `in` from a top-level usage of `open`."
msgstr "函数签名显示名称的完整命名空间。还可以为文件其余部分的所有后续命令打开命名空间。为此，只需从 `open` 的顶级用法中省略 `in`。"

#: src/getting-to-know/conveniences.md:434
#, fuzzy
msgid "if let"
msgstr "if let"

#: src/getting-to-know/conveniences.md:436
#, fuzzy
msgid ""
"When consuming values that have a sum type, it is often the case that only a"
" single constructor is of interest. For instance, given this type that "
"represents a subset of Markdown inline elements:"
msgstr "在使用具有和类型的值时，通常只对一个构造子感兴趣。例如，给定表示 Markdown 内联元素子集的类型："

#: src/getting-to-know/conveniences.md:445
#, fuzzy
msgid ""
"a function that recognizes string elements and extracts their contents can "
"be written:"
msgstr "可以编写一个识别字符串元素并提取其内容的函数："

#: src/getting-to-know/conveniences.md:452
#, fuzzy
msgid ""
"An alternative way of writing this function's body uses `if` together with "
"`let`:"
msgstr "另一种编写此函数主体的方法是将 `if` 与 `let` 一起使用："

#: src/getting-to-know/conveniences.md:459
#, fuzzy
msgid ""
"This is very much like the pattern-matching `let` syntax. The difference is "
"that it can be used with sum types, because a fallback is provided in the "
"`else` case. In some contexts, using `if let` instead of `match` can make "
"code easier to read."
msgstr ""
"这与模式匹配 `let` 语法非常相似。不同之处在于它可以与和类型一起使用，因为在 `else` 情况下提供了后备。在某些情况下，使用 `if let`"
" 代替 `match` 可以使代码更易于阅读。"

#: src/getting-to-know/conveniences.md:463
#, fuzzy
msgid "Positional Structure Arguments"
msgstr "位置结构体参数"

#: src/getting-to-know/conveniences.md:465
#, fuzzy
msgid ""
"The [section on structures](structures.md) presents two ways of constructing"
" structures:"
msgstr "[结构体部分](structures.md)介绍了构建结构体的两种方法："

#: src/getting-to-know/conveniences.md:466
#, fuzzy
msgid "The constructor can be called directly, as in `Point.mk 1 2`."
msgstr "构造子可以直接调用，如 `Point.mk 1 2`。"

#: src/getting-to-know/conveniences.md:467
#, fuzzy
msgid "Brace notation can be used, as in `{ x := 1, y := 2 }`."
msgstr "可以使用大括号表示法，如 `{ x := 1, y := 2 }`。"

#: src/getting-to-know/conveniences.md:469
#, fuzzy
msgid ""
"In some contexts, it can be convenient to pass arguments positionally, "
"rather than by name, but without naming the constructor directly. For "
"instance, defining a variety of similar structure types can help keep domain"
" concepts separate, but the natural way to read the code may treat each of "
"them as being essentially a tuple. In these contexts, the arguments can be "
"enclosed in angle brackets `⟨` and `⟩`. A `Point` can be written `⟨1, 2⟩`. "
"Be careful! Even though they look like the less-than sign `<` and greater-"
"than sign `>`, these brackets are different. They can be input using `\\<` "
"and `\\>`, respectively."
msgstr ""
"在某些情况下，按位置传递参数而不是按名称传递参数可能很方便，但无需直接命名构造子。例如，定义各种相似的结构体类型有助于保持域概念分离，但阅读代码的自然方式可能将它们中的每一个都视为本质上是一个元组。在这些情况下，参数可以用尖括号"
" `⟨` 和 `⟩` 括起来。`Point` 可以写成 `⟨1, 2⟩`。小心！即使它们看起来像小于号 `<` 和大于号 "
"`>`，这些括号也不同。它们可以使用 `\\<` 和 `\\>` 分别输入。"

#: src/getting-to-know/conveniences.md:477
#, fuzzy
msgid ""
"Just as with the brace notation for named constructor arguments, this "
"positional syntax can only be used in a context where Lean can determine the"
" structure's type, either from a type annotation or from other type "
"information in the program. For instance, `#eval ⟨1, 2⟩` yields the "
"following error:"
msgstr ""
"与命名构造子参数的大括号表示法一样，此位置语法只能在 Lean 可以从类型标注或程序中其他类型信息确定结构体类型的上下文中使用。例如，`#eval "
"⟨1, 2⟩` 会产生以下错误："

#: src/getting-to-know/conveniences.md:483
#, fuzzy
msgid ""
"The metavariable in the error is because there is no type information "
"available. Adding an annotation, such as in `#eval (⟨1, 2⟩ : Point)`, solves"
" the problem:"
msgstr "错误中的元变量是因为没有可用的类型信息。添加注释，例如 `#eval (⟨1, 2⟩ : Point)`，可以解决此问题："

#: src/getting-to-know/conveniences.md:490
#, fuzzy
msgid "String Interpolation"
msgstr "字符串插值"

#: src/getting-to-know/conveniences.md:492
#, fuzzy
msgid ""
"In Lean, prefixing a string with `s!` triggers _interpolation_, where "
"expressions contained in curly braces inside the string are replaced with "
"their values. This is similar to `f`\\-strings in Python and `$`\\-prefixed "
"strings in C#. For instance,"
msgstr ""
"在 Lean 中，在字符串前加上 `s!` 会触发 _插值_，其中字符串中大括号内的表达式会被其值替换。这类似于 Python 中的 `f` 字符串和 "
"C# 中以 `$` 为前缀的字符串。例如，"

#: src/getting-to-know/conveniences.md:495
#, fuzzy
msgid ""
"```lean\n"
"#eval s!\"three fives is {NewNamespace.triple 5}\"\n"
"```"
msgstr ""
"```lean\n"
"#eval s!\"three fives is {NewNamespace.triple 5}\"\n"
"```"

#: src/getting-to-know/conveniences.md:498
#: src/getting-to-know/conveniences.md:508
#, fuzzy
msgid "yields the output"
msgstr "会产生输出"

#: src/getting-to-know/conveniences.md:499
#, fuzzy
msgid ""
"```output info\n"
"\"three fives is 15\"\n"
"```"
msgstr ""
"```output info\n"
"\"three fives is 15\"\n"
"```"

#: src/getting-to-know/conveniences.md:503
#, fuzzy
msgid ""
"Not all expressions can be interpolated into a string. For instance, "
"attempting to interpolate a function results in an error."
msgstr "并非所有表达式都可以插值到字符串中。例如，尝试插值一个函数会导致错误。"

#: src/getting-to-know/conveniences.md:505
#, fuzzy
msgid ""
"```lean\n"
"#check s!\"three fives is {NewNamespace.triple}\"\n"
"```"
msgstr ""
"```lean\n"
"#check s!\"three fives is {NewNamespace.triple}\"\n"
"```"

#: src/getting-to-know/conveniences.md:513
#, fuzzy
msgid ""
"This is because there is no standard way to convert functions into strings. "
"The Lean compiler maintains a table that describes how to convert values of "
"various types into strings, and the message `failed to synthesize instance` "
"means that the Lean compiler didn't find an entry in this table for the "
"given type. This uses the same language feature as the `deriving Repr` "
"syntax that was described in the [section on structures](structures.md)."
msgstr ""
"这是因为没有将函数转换为字符串的标准方法。Lean 编译器维护了一个表，描述如何将各种类型的值转换为字符串，而消息 `failed to "
"synthesize instance` 意味着 Lean 编译器未在此表中找到给定类型的条目。这使用了与 "
"[结构体部分](structures.md)中描述的 `deriving Repr` 语法相同的语言特性。"

#: src/getting-to-know/summary.md:5
#, fuzzy
msgid ""
"In Lean, computation occurs when expressions are evaluated. This follows the"
" usual rules of mathematical expressions: sub-expressions are replaced by "
"their values following the usual order of operations, until the entire "
"expression has become a value. When evaluating an `if` or a `match`, the "
"expressions in the branches are not evaluated until the value of the "
"condition or the match subject has been found."
msgstr ""
"在 Lean 中，计算发生在求值表达式时。这遵循数学表达式的通常规则：子表达式按照通常的操作顺序替换为其值，直到整个表达式变为一个值。在求值 `if` "
"或 `match` 时，分支中的表达式不会被求值，直到找到条件或匹配主题的值。"

#: src/getting-to-know/summary.md:9
#, fuzzy
msgid ""
"Once they have been given a value, variables never change. Similarly to "
"mathematics but unlike most programming languages, Lean variables are simply"
" placeholders for values, rather than addresses to which new values can be "
"written. Variables' values may come from global definitions with `def`, "
"local definitions with `let`, as named arguments to functions, or from "
"pattern matching."
msgstr ""
"一旦变量被赋予值，它们就不会改变。与数学类似，但与大多数编程语言不同，Lean 变量只是值的占位符，而不是可以写入新值的位置。变量的值可能来自带有 "
"`def` 的全局定义、带有 `let` 的局部定义、作为函数的命名参数或模式匹配。"

#: src/getting-to-know/summary.md:13
#, fuzzy
msgid "Functions"
msgstr "函数"

#: src/getting-to-know/summary.md:15
#, fuzzy
msgid ""
"Functions in Lean are first-class values, meaning that they can be passed as"
" arguments to other functions, saved in variables, and used like any other "
"value. Every Lean function takes exactly one argument. To encode a function "
"that takes more than one argument, Lean uses a technique called currying, "
"where providing the first argument returns a function that expects the "
"remaining arguments. To encode a function that takes no arguments, Lean uses"
" the `Unit` type, which is the least informative possible argument."
msgstr ""
"Lean 中的函数是一等值，这意味着它们可以作为参数传递给其他函数，保存在变量中，并像任何其他值一样使用。每个 Lean "
"函数只接受一个参数。为了对接受多个参数的函数进行编码，Lean "
"使用了一种称为柯里化的技术，其中提供第一个参数会返回一个期望剩余参数的函数。为了对不接受任何参数的函数进行编码，Lean 使用 `Unit` "
"类型，这是最不具信息性的可能参数。"

#: src/getting-to-know/summary.md:20
#, fuzzy
msgid "There are three primary ways of creating functions:"
msgstr "创建函数有三种主要方法："

#: src/getting-to-know/summary.md:21
#, fuzzy
msgid ""
"Anonymous functions are written using `fun`. For instance, a function that "
"swaps the fields of a `Point` can be written `fun (point : Point) => { x := "
"point.y, y := point.x : Point }`"
msgstr ""
"匿名函数使用 `fun` 编写。例如，一个交换 `Point` 字段的函数可以写成 `fun (point : Point) => { x := "
"point.y, y := point.x : Point }`"

#: src/getting-to-know/summary.md:23
#, fuzzy
msgid ""
"Very simple anonymous functions are written by placing one or more centered "
"dots `·` inside of parentheses. Each centered dot becomes an argument to the"
" function, and the parentheses delimit its body. For instance, a function "
"that subtracts one from its argument can be written as `(· - 1)` instead of "
"as `fun x => x - 1`."
msgstr ""
"非常简单的匿名函数通过在括号内放置一个或多个居中的点 `·` 来编写。每个居中的点都成为函数的一个参数，括号限定其主体。例如，一个从其参数中减去 1 "
"的函数可以写成 `(· - 1)`，而不是 `fun x => x - 1`。"

#: src/getting-to-know/summary.md:26
#, fuzzy
msgid ""
"Functions can be defined using `def` or `let` by adding an argument list or "
"by using pattern-matching notation."
msgstr "函数可以使用 `def` 或 `let` 定义，方法是添加参数列表或使用模式匹配符号。"

#: src/getting-to-know/summary.md:30
#, fuzzy
msgid ""
"Lean checks that every expression has a type. Types, such as `Int`, `Point`,"
" `{α : Type} → Nat → α → List α`, and `Option (String ⊕ (Nat × String))`, "
"describe the values that may eventually be found for an expression. Like "
"other languages, types in Lean can express lightweight specifications for "
"programs that are checked by the Lean compiler, obviating the need for "
"certain classes of unit test. Unlike most languages, Lean's types can also "
"express arbitrary mathematics, unifying the worlds of programming and "
"theorem proving. While using Lean for proving theorems is mostly out of "
"scope for this book, _[Theorem Proving in Lean "
"4](https://leanprover.github.io/theorem_proving_in_lean4/)_ contains more "
"information on this topic."
msgstr ""
"Lean 检查每个表达式是否具有类型。类型（例如 `Int`、`Point`、`{α : Type} → Nat → α → List α` 和 "
"`Option (String ⊕ (Nat × String))`）描述最终可能为表达式找到的值。与其他语言一样，Lean 中的类型可以表示由 "
"Lean 编译器检查的程序的轻量级规范，从而消除了对某些类单元测试的需求。与大多数语言不同，Lean "
"的类型还可以表示任意数学，统一了编程和定理证明的世界。虽然将 Lean 用于证明定理在很大程度上超出了本书的范围，但 _[Theorem Proving"
" in Lean 4](https://leanprover.github.io/theorem_proving_in_lean4/)_ "
"包含有关此主题的更多信息。"

#: src/getting-to-know/summary.md:36
#, fuzzy
msgid ""
"Some expressions can be given multiple types. For instance, `3` can be an "
"`Int` or a `Nat`. In Lean, this should be understood as two separate "
"expressions, one with type `Nat` and one with type `Int`, that happen to be "
"written in the same way, rather than as two different types for the same "
"thing."
msgstr ""
"某些表达式可以赋予多种类型。例如，`3` 可以是 `Int` 或 `Nat`。在 Lean 中，这应理解为两个独立的表达式，一个类型为 "
"`Nat`，另一个类型为 `Int`，碰巧以相同的方式编写，而不是同一事物的两种不同类型。"

#: src/getting-to-know/summary.md:40
#, fuzzy
msgid ""
"Lean is sometimes able to determine types automatically, but types must "
"often be provided by the user. This is because Lean's type system is so "
"expressive. Even when Lean can find a type, it may not find the desired "
"type—`3` could be intended to be used as an `Int`, but Lean will give it the"
" type `Nat` if there are no further constraints. In general, it is a good "
"idea to write most types explicitly, only letting Lean fill out the very "
"obvious types. This improves Lean's error messages and helps make programmer"
" intent more clear."
msgstr ""
"Lean 有时能够自动确定类型，但类型通常必须由用户提供。这是因为 Lean 的类型系统非常具有表现力。即使 Lean "
"可以找到一种类型，它也可能找不到所需的类型——`3` 可能打算用作 `Int`，但如果没有任何进一步的约束，Lean 将赋予它 `Nat` "
"类型。一般来说，最好显式地编写大多数类型，只让 Lean 填写非常明显的类型。这改进了 Lean 的错误消息，并有助于使程序员的意图更加清晰。"

#: src/getting-to-know/summary.md:46
#, fuzzy
msgid ""
"Some functions or datatypes take types as arguments. They are called "
"_polymorphic_. Polymorphism allows programs such as one that calculates the "
"length of a list without caring what type the entries in the list have. "
"Because types are first class in Lean, polymorphism does not require any "
"special syntax, so types are passed just like other arguments. Giving an "
"argument a name in a function type allows later types to mention that "
"argument, and the type of applying that function to an argument is found by "
"replacing the argument's name with the argument's value."
msgstr ""
"某些函数或数据类型将类型作为参数。它们被称为 _多态_。多态性允许程序（例如计算列表长度的程序）而不关心列表中条目的类型。由于类型在 Lean "
"中是一等公民，因此多态性不需要任何特殊语法，因此类型就像其他参数一样传递。在函数类型中为参数指定名称允许稍后的类型提及该参数，并且通过将参数的名称替换为参数的值来找到将该函数应用于参数的类型。"

#: src/getting-to-know/summary.md:52
#, fuzzy
msgid "Structures and Inductive Types"
msgstr "结构体和归纳类型"

#: src/getting-to-know/summary.md:54
#, fuzzy
msgid ""
"Brand new datatypes can be introduced to Lean using the `structure` or "
"`inductive` features. These new types are not considered to be equivalent to"
" any other type, even if their definitions are otherwise identical. "
"Datatypes have _constructors_ that explain the ways in which their values "
"can be constructed, and each constructor takes some number of arguments. "
"Constructors in Lean are not the same as constructors in object-oriented "
"languages: Lean's constructors are inert holders of data, rather than active"
" code that initializes an allocated object."
msgstr ""
"可以使用 `structure` 或 `inductive` 特性向 Lean "
"引入全新的数据类型。即使它们的定义在其他方面相同，这些新类型也不被认为等同于任何其他类型。数据类型具有 "
"_构造子_，解释了可以构造其值的方式，每个构造子都采用一些参数。Lean 中的构造子与面向对象语言中的构造子不同：Lean "
"的构造子是数据的惰性持有者，而不是初始化已分配对象的活动代码。"

#: src/getting-to-know/summary.md:59
#, fuzzy
msgid ""
"Typically, `structure` is used to introduce a product type (that is, a type "
"with just one constructor that takes any number of arguments), while "
"`inductive` is used to introduce a sum type (that is, a type with many "
"distinct constructors). Datatypes defined with `structure` are provided with"
" one accessor function for each of the constructor's arguments. Both "
"structures and inductive datatypes may be consumed with pattern matching, "
"which exposes the values stored inside of constructors using a subset of the"
" syntax used to call said constructors. Pattern matching means that knowing "
"how to create a value implies knowing how to consume it."
msgstr ""
"通常，`structure` 用于引入乘积类型（即，只有一个构造子且该构造子可以接受任意数量参数的类型），而 `inductive` "
"用于引入和类型（即，具有多个不同构造子的类型）。使用 `structure` "
"定义的数据类型为构造子的每个参数提供一个访问器函数。结构体和归纳数据类型都可以使用模式匹配来使用，模式匹配使用调用所述构造子的语法的一个子集来公开存储在构造子中的值。模式匹配意味着知道如何创建值就意味着知道如何使用它。"

#: src/getting-to-know/summary.md:65
msgid "Recursion"
msgstr "递归"

#: src/getting-to-know/summary.md:67
#, fuzzy
msgid ""
"A definition is recursive when the name being defined is used in the "
"definition itself. Because Lean is an interactive theorem prover in addition"
" to being a programming language, there are certain restrictions placed on "
"recursive definitions. In Lean's logical side, circular definitions could "
"lead to logical inconsistency."
msgstr ""
"当正在定义的名称在定义本身中使用时，定义就是递归的。由于 Lean 除了是一种编程语言之外，还是一个交互式定理证明器，因此对递归定义施加了某些限制。在 "
"Lean 的逻辑方面，循环定义可能导致逻辑不一致。"

#: src/getting-to-know/summary.md:71
#, fuzzy
msgid ""
"In order to ensure that recursive definitions do not undermine the logical "
"side of Lean, Lean must be able to prove that all recursive functions "
"terminate, no matter what arguments they are called with. In practice, this "
"means either that recursive calls are all performed on a structurally-"
"smaller piece of the input, which ensures that there is always progress "
"towards a base case, or that users must provide some other evidence that the"
" function always terminates. Similarly, recursive inductive types are not "
"allowed to have a constructor that takes a function _from_ the type as an "
"argument, because this would make it possible to encode non-terminating "
"functions."
msgstr ""
"为了确保递归定义不会破坏 Lean 的逻辑方面，Lean "
"必须能够证明所有递归函数都会终止，无论使用什么参数调用它们。在实践中，这意味着递归调用都执行在输入的结构体上更小的部分上，这确保了始终朝着基本情况进行，或者用户必须提供一些其他证据来证明函数始终终止。类似地，递归归纳类型不允许具有将函数从类型作为参数的构造子，因为这将使编码非终止函数成为可能。"
# TODO(OlingCat)

#: src/hello-world.md:3
#, fuzzy
msgid ""
"While Lean has been designed to have a rich interactive environment in which"
" programmers can get quite a lot of feedback from the language without "
"leaving the confines of their favorite text editor, it is also a language in"
" which real programs can be written. This means that it also has a batch-"
"mode compiler, a build system, a package manager, and all the other tools "
"that are necessary for writing programs."
msgstr ""
"虽然 Lean "
"被设计为一个丰富的交互式环境，程序员可以在不离开他们最喜欢的文本编辑器的范围内从语言中获得相当多的反馈，但它也是一门可以编写真实程序的语言。这意味着它还具有批处理模式编译器、构建系统、包管理器以及编写程序所需的所有其他工具。"

#: src/hello-world.md:6
#, fuzzy
msgid ""
"While the [previous chapter](./getting-to-know.md) presented the basics of "
"functional programming in Lean, this chapter explains how to start a "
"programming project, compile it, and run the result. Programs that run and "
"interact with their environment (e.g. by reading input from standard input "
"or creating files) are difficult to reconcile with the understanding of "
"computation as the evaluation of mathematical expressions. In addition to a "
"description of the Lean build tools, this chapter also provides a way to "
"think about functional programs that interact with the world."
msgstr ""
"虽然 [上一章](./getting-to-know.md) 介绍了 Lean "
"中函数式编程的基础知识，但本章解释了如何启动一个编程项目、编译它并运行结果。运行并与其环境交互的程序（例如通过读取标准输入或创建文件）很难与将计算理解为数学表达式的求值相协调。除了对"
" Lean 构建工具的描述之外，本章还提供了一种思考与世界交互的函数式程序的方法。"

#: src/hello-world/running-a-program.md:3
#, fuzzy
msgid ""
"The simplest way to run a Lean program is to use the `--run` option to the "
"Lean executable. Create a file called `Hello.lean` and enter the following "
"contents:"
msgstr ""
"运行 Lean 程序最简单的方法是使用 Lean 可执行文件的 `--run` 选项。创建一个名为 `Hello.lean` 的文件并输入以下内容："

#: src/hello-world/running-a-program.md:5
#, fuzzy
msgid ""
"```lean\n"
"def main : IO Unit := IO.println \"Hello, world!\"\n"
"```"
msgstr ""
"```lean\n"
"def main : IO Unit := IO.println \"Hello, world!\"\n"
"```"

#: src/hello-world/running-a-program.md:8
#, fuzzy
msgid "Then, from the command line, run:"
msgstr "然后，从命令行运行："

#: src/hello-world/running-a-program.md:12
#, fuzzy
msgid "The program displays `Hello, world!` and exits."
msgstr "该程序显示 `Hello, world!` 并退出。"

#: src/hello-world/running-a-program.md:14
#, fuzzy
msgid "Anatomy of a Greeting"
msgstr "问候的解剖"

#: src/hello-world/running-a-program.md:16
#, fuzzy
msgid ""
"When Lean is invoked with the `--run` option, it invokes the program's "
"`main` definition. In programs that do not take command-line arguments, "
"`main` should have type `IO Unit`. This means that `main` is not a function,"
" because there are no arrows (`→`) in its type. Instead of being a function "
"that has side effects, `main` consists of a description of effects to be "
"carried out."
msgstr ""
"当使用 `--run` 选项调用 Lean 时，它会调用程序的 `main` 定义。在不接受命令行参数的程序中，`main` 的类型应该是 `IO "
"Unit`。这意味着 `main` 不是一个函数，因为它的类型中没有箭头 (`→`)。`main` "
"不是一个具有副作用的函数，而是由要执行的效果描述组成。"

#: src/hello-world/running-a-program.md:21
#, fuzzy
msgid ""
"As discussed in [the preceding chapter](../getting-to-know/polymorphism.md),"
" `Unit` is the simplest inductive type. It has a single constructor called "
"`unit` that takes no arguments. Languages in the C tradition have a notion "
"of a `void` function that does not return any value at all. In Lean, all "
"functions take an argument and return a value, and the lack of interesting "
"arguments or return values can be signaled by using the `Unit` type instead."
" If `Bool` represents a single bit of information, `Unit` represents zero "
"bits of information."
msgstr ""
"如 [上一章](../getting-to-know/polymorphism.md) 所述，`Unit` 是最简单的归纳类型。它有一个名为 "
"`unit` 的构造子，不接受任何参数。C 语言传统中的语言有一个 `void` 函数的概念，它不返回任何值。在 Lean "
"中，所有函数都接受一个参数并返回一个值，而使用 `Unit` 类型可以表示没有有趣参数或返回值。如果 `Bool` 表示一个比特的信息，那么 "
"`Unit` 表示零比特的信息。"

#: src/hello-world/running-a-program.md:27
#, fuzzy
msgid ""
"`IO α` is the type of a program that, when executed, will either throw an "
"exception or return a value of type `α`. During execution, this program may "
"have side effects. These programs are referred to as `IO` _actions_. Lean "
"distinguishes between _evaluation_ of expressions, which strictly adheres to"
" the mathematical model of substitution of values for variables and "
"reduction of sub-expressions without side effects, and _execution_ of `IO` "
"actions, which rely on an external system to interact with the world. "
"`IO.println` is a function from strings to `IO` actions that, when executed,"
" write the given string to standard output. Because this action doesn't read"
" any interesting information from the environment in the process of emitting"
" the string, `IO.println` has type `String → IO Unit`. If it did return "
"something interesting, then that would be indicated by the `IO` action "
"having a type other than `Unit`."
msgstr ""
"`IO α` 是一个程序的类型，当执行时，它要么抛出一个异常，要么返回一个类型为 `α` 的值。在执行期间，此程序可能会产生副作用。这些程序被称为 "
"`IO` _动作_。Lean 区分表达式的 _求值_（严格遵循用变量值替换值和无副作用地约简子表达式的数学模型）和 `IO` 动作的 "
"_执行_（依赖于外部系统与世界交互）。`IO.println` 是一个从字符串到 `IO` "
"动作的函数，当执行时，它将给定的字符串写入标准输出。由于此动作在发出字符串的过程中不会从环境中读取任何有趣的信息，因此 `IO.println` "
"的类型为 `String → IO Unit`。如果它确实返回了一些有趣的东西，那么这将通过 `IO` 动作具有 `Unit` 以外的类型来表示。"

#: src/hello-world/running-a-program.md:36
#, fuzzy
msgid "Functional Programming vs Effects"
msgstr "函数式编程与副作用"

#: src/hello-world/running-a-program.md:38
#, fuzzy
msgid ""
"Lean's model of computation is based on the evaluation of mathematical "
"expressions, in which variables are given exactly one value that does not "
"change over time. The result of evaluating an expression does not change, "
"and evaluating the same expression again will always yield the same result."
msgstr ""
"Lean 的计算模型基于数学表达式的求值，其中变量被赋予一个不会随时间变化的精确值。求值表达式的结果不会改变，再次求值相同的表达式将始终产生相同的结果。"

#: src/hello-world/running-a-program.md:41
#, fuzzy
msgid ""
"On the other hand, useful programs must interact with the world. A program "
"that performs neither input nor output can't ask a user for data, create "
"files on disk, or open network connections. Lean is written in itself, and "
"the Lean compiler certainly reads files, creates files, and interacts with "
"text editors. How can a language in which the same expression always yields "
"the same result support programs that read files from disk, when the "
"contents of these files might change over time?"
msgstr ""
"另一方面，有用的程序必须与世界交互。既不进行输入也不进行输出的程序无法向用户询问数据、创建磁盘文件或打开网络连接。Lean 是用它自己编写的，而 "
"Lean "
"编译器当然会读取文件、创建文件并与文本编辑器交互。当这些文件的内容可能随时间而改变时，一种语言中相同的表达式总是产生相同结果，它如何支持从磁盘读取文件的程序？"

#: src/hello-world/running-a-program.md:46
#, fuzzy
msgid ""
"This apparent contradiction can be resolved by thinking a bit differently "
"about side effects. Imagine a café that sells coffee and sandwiches. This "
"café has two employees: a cook who fulfills orders, and a worker at the "
"counter who interacts with customers and places order slips. The cook is a "
"surly person, who really prefers not to have any contact with the world "
"outside, but who is very good at consistently delivering the food and drinks"
" that the café is known for. In order to do this, however, the cook needs "
"peace and quiet, and can't be disturbed with conversation. The counter "
"worker is friendly, but completely incompetent in the kitchen. Customers "
"interact with the counter worker, who delegates all actual cooking to the "
"cook. If the cook has a question for a customer, such as clarifying an "
"allergy, they send a little note to the counter worker, who interacts with "
"the customer and passes a note back to the cook with the result."
msgstr ""
"通过对副作用进行一些不同的思考，可以解决这种明显的矛盾。想象一家出售咖啡和三明治的咖啡馆。这家咖啡馆有两个员工：一名厨师负责完成订单，一名柜台工作人员负责与顾客互动并下订单。厨师是一个脾气暴躁的人，他真的更喜欢不与外界有任何接触，但他非常擅长始终如一地提供咖啡馆著名的食物和饮料。然而，为了做到这一点，厨师需要安静，不能被打扰谈话。柜台工作人员很友好，但在厨房里完全没有能力。顾客与柜台工作人员互动，后者将所有实际烹饪委托给厨师。如果厨师对顾客有疑问，例如澄清过敏，他们会给柜台工作人员发一张小纸条，柜台工作人员与顾客互动，并将一张写有结果的纸条传回给厨师。"

#: src/hello-world/running-a-program.md:55
#, fuzzy
msgid ""
"In this analogy, the cook is the Lean language. When provided with an order,"
" the cook faithfully and consistently delivers what is requested. The "
"counter worker is the surrounding run-time system that interacts with the "
"world and can accept payments, dispense food, and have conversations with "
"customers. Working together, the two employees serve all the functions of "
"the restaurant, but their responsibilities are divided, with each performing"
" the tasks that they're best at. Just as keeping customers away allows the "
"cook to focus on making truly excellent coffee and sandwiches, Lean's lack "
"of side effects allows programs to be used as part of formal mathematical "
"proofs. It also helps programmers understand the parts of the program in "
"isolation from each other, because there are no hidden state changes that "
"create subtle coupling between components. The cook's notes represent `IO` "
"actions that are produced by evaluating Lean expressions, and the counter "
"worker's replies are the values that are passed back from effects."
msgstr ""
"在这个类比中，厨师是 Lean "
"语言。当收到订单时，厨师会忠实且始终如一地提供所要求的内容。柜台工作人员是与世界交互的周围运行时系统，它可以接受付款、分发食物并与顾客交谈。这两名员工共同承担了餐厅的所有职能，但他们的职责是分开的，每个人都执行自己最擅长的任务。就像让顾客远离可以让厨师专注于制作真正美味的咖啡和三明治一样，Lean"
" "
"缺乏副作用可以让程序用作形式化数学证明的一部分。它还有助于程序员独立理解程序的各个部分，因为没有隐藏的状态更改会在组件之间创建微妙的耦合。厨师的笔记表示通过求值"
" Lean 表达式产生的 `IO` 操作，而柜台工作人员的回复是通过效果传递回来的值。"

#: src/hello-world/running-a-program.md:63
#, fuzzy
msgid ""
"This model of side effects is quite similar to how the overall aggregate of "
"the Lean language, its compiler, and its run-time system (RTS) work. "
"Primitives in the run-time system, written in C, implement all the basic "
"effects. When running a program, the RTS invokes the `main` action, which "
"returns new `IO` actions to the RTS for execution. The RTS executes these "
"actions, delegating to the user's Lean code to carry out computations. From "
"the internal perspective of Lean, programs are free of side effects, and "
"`IO` actions are just descriptions of tasks to be carried out. From the "
"external perspective of the program's user, there is a layer of side effects"
" that create an interface to the program's core logic."
msgstr ""
"这种副作用模型与 Lean 语言、编译器和运行时系统 (RTS) 的整体聚合工作方式非常相似。运行时系统中的基元（用 C "
"语言编写）实现了所有基本副作用。在运行程序时，RTS 调用 `main` 动作，该动作将新的 `IO` 动作返回给 RTS 以执行。RTS "
"执行这些动作，委托给用户的 Lean 代码来执行计算。从 Lean 的内部角度来看，程序没有副作用，而 `IO` "
"动作只是要执行的任务的描述。从程序用户的外部角度来看，有一层副作用，它创建了一个与程序核心逻辑的接口。"

#: src/hello-world/running-a-program.md:71
#, fuzzy
msgid "Real-World Functional Programming"
msgstr "现实世界的函数式编程"

#: src/hello-world/running-a-program.md:73
#, fuzzy
msgid ""
"The other useful way to think about side effects in Lean is by considering "
"`IO` actions to be functions that take the entire world as an argument and "
"return a value paired with a new world. In this case, reading a line of text"
" from standard input _is_ a pure function, because a different world is "
"provided as an argument each time. Writing a line of text to standard output"
" is a pure function, because the world that the function returns is "
"different from the one that it began with. Programs do need to be careful to"
" never re-use the world, nor to fail to return a new world—this would amount"
" to time travel or the end of the world, after all. Careful abstraction "
"boundaries can make this style of programming safe. If every primitive `IO` "
"action accepts one world and returns a new one, and they can only be "
"combined with tools that preserve this invariant, then the problem cannot "
"occur."
msgstr ""
"考虑 `IO` 动作是将整个世界作为参数并返回一个值和一个新世界的函数，这是思考 Lean "
"中副作用的另一种有用的方式。在这种情况下，从标准输入读取一行文本 _是_ "
"一个纯函数，因为每次都提供一个不同的世界作为参数。向标准输出写入一行文本是一个纯函数，因为函数返回的世界与它开始的世界不同。程序确实需要小心，不要重复使用世界，也不要未能返回一个新世界——毕竟，这将相当于时间旅行或世界末日。小心的抽象边界可以使这种编程风格变得安全。如果每个基元"
" `IO` 动作接受一个世界并返回一个新世界，并且它们只能与保留此不变性的工具结合使用，那么问题就不会发生。"

#: src/hello-world/running-a-program.md:80
#, fuzzy
msgid ""
"This model cannot be implemented. After all, the entire universe cannot be "
"turned into a Lean value and placed into memory. However, it is possible to "
"implement a variation of this model with an abstract token that stands for "
"the world. When the program is started, it is provided with a world token. "
"This token is then passed on to the IO primitives, and their returned tokens"
" are similarly passed to the next step. At the end of the program, the token"
" is returned to the operating system."
msgstr ""
"这种模型无法实现。毕竟，整个世界无法变成 Lean "
"值并放入内存中。然而，可以实现一个带有代表世界的抽象令牌的此模型的变体。当程序启动时，它会提供一个世界令牌。然后将此令牌传递给 IO "
"原语，并且它们的返回令牌类似地传递到下一步。在程序结束时，令牌将返回给操作系统。"

#: src/hello-world/running-a-program.md:87
#, fuzzy
msgid ""
"This model of side effects is a good description of how `IO` actions as "
"descriptions of tasks to be carried out by the RTS are represented "
"internally in Lean. The actual functions that transform the real world are "
"behind an abstraction barrier. But real programs typically consist of a "
"sequence of effects, rather than just one. To enable programs to use "
"multiple effects, there is a sub-language of Lean called `do` notation that "
"allows these primitive `IO` actions to be safely composed into a larger, "
"useful program."
msgstr ""
"这种副作用模型很好地描述了 `IO` 动作作为 RTS 要执行的任务描述如何在 Lean "
"中内部表示。转换现实世界的实际函数位于抽象障碍之后。但实际程序通常由一系列效果组成，而不仅仅是一个效果。为了使程序能够使用多个效果，Lean "
"中有一个称为 `do` 表示法的子语言，它允许将这些原始 `IO` 动作安全地组合成一个更大、更有用的程序。"

#: src/hello-world/running-a-program.md:92
#, fuzzy
msgid "Combining `IO` Actions"
msgstr "组合 `IO` 动作"

#: src/hello-world/running-a-program.md:94
#, fuzzy
msgid ""
"Most useful programs accept input in addition to producing output. "
"Furthermore, they may take decisions based on input, using the input data as"
" part of a computation. The following program, called `HelloName.lean`, asks"
" the user for their name and then greets them:"
msgstr ""
"大多数有用的程序除了产生输出外还接受输入。此外，它们可以根据输入做出决策，将输入数据用作计算的一部分。以下程序名为 "
"`HelloName.lean`，它向用户询问他们的姓名，然后向他们问好："

#: src/hello-world/running-a-program.md:97
#, fuzzy
msgid ""
"```lean\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/running-a-program.md:109
#, fuzzy
msgid ""
"In this program, the `main` action consists of a `do` block. This block "
"contains a sequence of _statements_, which can be both local variables "
"(introduced using `let`) and actions that are to be executed. Just as SQL "
"can be thought of as a special-purpose language for interacting with "
"databases, the `do` syntax can be thought of as a special-purpose sub-"
"language within Lean that is dedicated to modeling imperative programs. `IO`"
" actions that are built with a `do` block are executed by executing the "
"statements in order."
msgstr ""
"在这个程序中，`main` 动作由一个 `do` 块组成。此块包含一系列的 _语句_，它们既可以是局部变量（使用 `let` "
"引入），也可以是要执行的动作。正如 SQL 可以被认为是与数据库交互的专用语言一样，`do` 语法可以被认为是 Lean "
"中的一个专用子语言，专门用于建模命令式程序。使用 `do` 块构建的 `IO` 动作通过按顺序执行语句来执行。"

#: src/hello-world/running-a-program.md:114
#, fuzzy
msgid "This program can be run in the same manner as the prior program:"
msgstr "此程序可以与之前的程序以相同的方式运行："

#: src/hello-world/running-a-program.md:118
#, fuzzy
msgid ""
"If the user responds with `David`, a session of interaction with the program"
" reads:"
msgstr "如果用户响应 `David`，则与程序交互的会话读取："

#: src/hello-world/running-a-program.md:125
#, fuzzy
msgid "The type signature line is just like the one for `Hello.lean`:"
msgstr "类型签名行与 `Hello.lean` 的类型签名行一样："

#: src/hello-world/running-a-program.md:129
#, fuzzy
msgid ""
"The only difference is that it ends with the keyword `do`, which initiates a"
" sequence of commands. Each indented line following the keyword `do` is part"
" of the same sequence of commands."
msgstr "唯一的区别是它以关键字 `do` 结尾，该关键字启动一系列命令。关键字 `do` 后面的每一行缩进都是同一系列命令的一部分。"

#: src/hello-world/running-a-program.md:132
#, fuzzy
msgid "The first two lines, which read:"
msgstr "前两行，读取："

#: src/hello-world/running-a-program.md:137
#, fuzzy
msgid ""
"retrieve the `stdin` and `stdout` handles by executing the library actions "
"`IO.getStdin` and `IO.getStdout`, respectively. In a `do` block, `let` has a"
" slightly different meaning than in an ordinary expression. Ordinarily, the "
"local definition in a `let` can be used in just one expression, which "
"immediately follows the local definition. In a `do` block, local bindings "
"introduced by `let` are available in all statements in the remainder of the "
"`do` block, rather than just the next one. Additionally, `let` typically "
"connects the name being defined to its definition using `:=`, while some "
"`let` bindings in `do` use a left arrow (`←` or `<-`) instead. Using an "
"arrow means that the value of the expression is an `IO` action that should "
"be executed, with the result of the action saved in the local variable. In "
"other words, if the expression to the right of the arrow has type `IO α`, "
"then the variable has type `α` in the remainder of the `do` block. "
"`IO.getStdin` and `IO.getStdout` are `IO` actions in order to allow `stdin` "
"and `stdout` to be locally overridden in a program, which can be convenient."
" If they were global variables as in C, then there would be no meaningful "
"way to override them, but `IO` actions can return different values each time"
" they are executed."
msgstr ""
"分别通过执行库动作 `IO.getStdin` 和 `IO.getStdout` 检索 `stdin` 和 `stdout` 句柄。在 `do` "
"块中，`let` 的含义与在普通表达式中略有不同。通常，`let` 中的局部定义只能在一个表达式中使用，该表达式紧跟在局部定义之后。在 `do` "
"块中，由 `let` 引入的局部绑定在 `do` 块其余部分的所有语句中都可用，而不仅仅是下一个语句。此外，`let` 通常使用 `:=` "
"将要定义的名称与其定义连接起来，而 `do` 中的一些 `let` 绑定则使用向左箭头（`←` 或 `<-`）代替。使用箭头表示表达式的值是一个 "
"`IO` 动作，该动作应该被执行，动作的结果保存在局部变量中。换句话说，如果箭头右侧的表达式的类型为 `IO α`，那么该变量在 `do` "
"块的其余部分中的类型为 `α`。`IO.getStdin` 和 `IO.getStdout` 是 `IO` 动作，以便允许在程序中局部覆盖 "
"`stdin` 和 `stdout`，这很方便。如果它们是像 C 中那样的全局变量，那么将没有有意义的方法来覆盖它们，但是 `IO` "
"动作每次执行时都可以返回不同的值。"

#: src/hello-world/running-a-program.md:147
#, fuzzy
msgid ""
"The next part of the `do` block is responsible for asking the user for their"
" name:"
msgstr "`do` 块的下一部分负责询问用户姓名："

#: src/hello-world/running-a-program.md:148
#, fuzzy
msgid ""
"```lean\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"```"
msgstr ""
"```lean\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"```"

#: src/hello-world/running-a-program.md:153
#, fuzzy
msgid ""
"The first line writes the question to `stdout`, the second line requests "
"input from `stdin`, and the third line removes the trailing newline (plus "
"any other trailing whitespace) from the input line. The definition of `name`"
" uses `:=`, rather than `←`, because `String.dropRightWhile` is an ordinary "
"function on strings, rather than an `IO` action."
msgstr ""
"第一行将问题写入 `stdout`，第二行从 `stdin` 请求输入，第三行从输入行中删除尾随换行符（以及任何其他尾随空格）。`name` 的定义使用"
" `:=` 而不是 `←`，因为 `String.dropRightWhile` 是字符串上的普通函数，而不是 `IO` 操作。"

#: src/hello-world/running-a-program.md:156
#, fuzzy
msgid "Finally, the last line in the program is:"
msgstr "最后，程序中的最后一行是："

#: src/hello-world/running-a-program.md:157
#, fuzzy
msgid ""
"```\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/running-a-program.md:160
#, fuzzy
msgid ""
"It uses [string interpolation](../getting-to-know/conveniences.md#string-"
"interpolation) to insert the provided name into a greeting string, writing "
"the result to `stdout`."
msgstr ""
"它使用 [字符串插值](../getting-to-know/conveniences.md#string-interpolation) "
"将提供的名称插入到问候字符串中，并将结果写入 `stdout`。"

#: src/hello-world/step-by-step.md:3
#, fuzzy
msgid ""
"A `do` block can be executed one line at a time. Start with the program from"
" the prior section:"
msgstr "`do` 块可以逐行执行。从上一节的程序开始："

#: src/hello-world/step-by-step.md:5
#, fuzzy
msgid ""
"```lean\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:14
#, fuzzy
msgid "Standard IO"
msgstr "标准 IO"

#: src/hello-world/step-by-step.md:16
#, fuzzy
msgid "The first line is `  let stdin ← IO.getStdin`, while the remainder is:"
msgstr "第一行是 `  let stdin ← IO.getStdin`，其余部分是："

#: src/hello-world/step-by-step.md:17
#, fuzzy
msgid ""
"```lean\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"  let stdout ← IO.getStdout\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:24
#, fuzzy
msgid ""
"To execute a `let` statement that uses a `←`, start by evaluating the "
"expression to the right of the arrow (in this case, `IO.getStdIn`). Because "
"this expression is just a variable, its value is looked up. The resulting "
"value is a built-in primitive `IO` action. The next step is to execute this "
"`IO` action, resulting in a value that represents the standard input stream,"
" which has type `IO.FS.Stream`. Standard input is then associated with the "
"name to the left of the arrow (here `stdin`) for the remainder of the `do` "
"block."
msgstr ""
"要执行使用 `←` 的 `let` 语句，首先求值箭头右侧的表达式（在本例中为 "
"`IO.getStdIn`）。因为这个表达式只是一个变量，所以查找它的值。结果值是一个内置的原始 `IO` 操作。下一步是执行此 `IO` "
"操作，结果是一个表示标准输入流的值，其类型为 `IO.FS.Stream`。然后将标准输入与箭头左侧的名称（此处为 `stdin`）关联，以用于 "
"`do` 块的其余部分。"

#: src/hello-world/step-by-step.md:30
#, fuzzy
msgid ""
"Executing the second line, `  let stdout ← IO.getStdout`, proceeds "
"similarly. First, the expression `IO.getStdout` is evaluated, yielding an "
"`IO` action that will return the standard output. Next, this action is "
"executed, actually returning the standard output. Finally, this value is "
"associated with the name `stdout` for the remainder of the `do` block."
msgstr ""
"执行第二行 `let stdout ← IO.getStdout` 的过程类似。首先，求值表达式 `IO.getStdout`，得到一个 `IO` "
"动作，该动作将返回标准输出。接下来，执行此动作，实际返回标准输出。最后，将此值与 `do` 块的其余部分关联起来，并命名为 `stdout`。"

#: src/hello-world/step-by-step.md:35
#, fuzzy
msgid "Asking a Question"
msgstr "提问"

#: src/hello-world/step-by-step.md:37
#, fuzzy
msgid ""
"Now that `stdin` and `stdout` have been found, the remainder of the block "
"consists of a question and an answer:"
msgstr "现在已经找到了 `stdin` 和 `stdout`，该块的其余部分包括一个问题和一个答案："

#: src/hello-world/step-by-step.md:38
#, fuzzy
msgid ""
"```lean\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let input ← stdin.getLine\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:45
#, fuzzy
msgid ""
"The first statement in the block, `  stdout.putStrLn \"How would you like to"
" be addressed?\"`, consists of an expression. To execute an expression, it "
"is first evaluated. In this case, `IO.FS.Stream.putStrLn` has type "
"`IO.FS.Stream → String → IO Unit`. This means that it is a function that "
"accepts a stream and a string, returning an `IO` action. The expression uses"
" [accessor notation](../getting-to-know/structures.md#behind-the-scenes) for"
" a function call. This function is applied to two arguments: the standard "
"output stream and a string. The value of the expression is an `IO` action "
"that will write the string and a newline character to the output stream. "
"Having found this value, the next step is to execute it, which causes the "
"string and newline to actually be written to `stdout`. Statements that "
"consist only of expressions do not introduce any new variables."
msgstr ""
"该块中的第一个语句 `stdout.putStrLn \"How would you like to be addressed?\"` "
"由一个表达式组成。要执行一个表达式，首先要对其求值。在这种情况下，`IO.FS.Stream.putStrLn` 的类型为 `IO.FS.Stream "
"→ String → IO Unit`。这意味着它是一个接受流和字符串并返回 `IO` 动作的函数。该表达式使用 "
"[访问器表示法](../getting-to-know/structures.md#behind-the-scenes) "
"进行函数调用。此函数应用于两个参数：标准输出流和字符串。表达式的值为一个 `IO` "
"动作，该动作将字符串和换行符写入输出流。找到此值后，下一步是执行它，这会导致字符串和换行符实际写入 "
"`stdout`。仅由表达式组成的语句不会引入任何新变量。"

#: src/hello-world/step-by-step.md:55
#, fuzzy
msgid ""
"The next statement in the block is `  let input ← stdin.getLine`. "
"`IO.FS.Stream.getLine` has type `IO.FS.Stream → IO String`, which means that"
" it is a function from a stream to an `IO` action that will return a string."
" Once again, this is an example of accessor notation. This `IO` action is "
"executed, and the program waits until the user has typed a complete line of "
"input. Assume the user writes \"`David`\". The resulting line "
"(`\"David\\n\"`) is associated with `input`, where the escape sequence `\\n`"
" denotes the newline character."
msgstr ""
"下一条语句是 `let input ← stdin.getLine`。`IO.FS.Stream.getLine` 的类型是 `IO.FS.Stream"
" → IO String`，这意味着它是一个从流到 `IO` 操作的函数，该操作将返回一个字符串。同样，这也是访问器表示法的示例。此 `IO` "
"操作被执行，程序等待用户键入一行完整的输入。假设用户输入了「`David`」。结果行（「`David\\n`」）与 `input` 关联，其中转义序列 "
"`\\n` 表示换行符。"

#: src/hello-world/step-by-step.md:62
#, fuzzy
msgid ""
"```lean\n"
"  let name := input.dropRightWhile Char.isWhitespace\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"let name := input.dropRightWhile Char.isWhitespace\n"
"stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:67
#, fuzzy
msgid ""
"The next line, `  let name := input.dropRightWhile Char.isWhitespace`, is a "
"`let` statement. Unlike the other `let` statements in this program, it uses "
"`:=` instead of `←`. This means that the expression will be evaluated, but "
"the resulting value need not be an `IO` action and will not be executed. In "
"this case, `String.dropRightWhile` takes a string and a predicate over "
"characters and returns a new string from which all the characters at the end"
" of the string that satisfy the predicate have been removed. For example,"
msgstr ""
"下一行 `let name := input.dropRightWhile Char.isWhitespace` 是一个 `let` "
"语句。与本程序中的其他 `let` 语句不同，它使用 `:=` 而不是 `←`。这意味着将计算表达式，但结果值不必是 `IO` "
"操作，并且不会执行。在这种情况下，`String.dropRightWhile` "
"接受一个字符串和一个字符谓词，并返回一个新字符串，其中字符串末尾满足谓词的所有字符都被删除。例如，"

#: src/hello-world/step-by-step.md:72
#, fuzzy
msgid ""
"```lean\n"
"#eval \"Hello!!!\".dropRightWhile (· == '!')\n"
"```"
msgstr ""
"```lean\n"
"#eval \"Hello!!!\".dropRightWhile (· == '!')\n"
"```"

#: src/hello-world/step-by-step.md:75 src/hello-world/step-by-step.md:83
#: src/type-classes/out-params.md:165
#, fuzzy
msgid "yields"
msgstr "产生"

#: src/hello-world/step-by-step.md:76 src/hello-world/step-by-step.md:84
#, fuzzy
msgid ""
"```output info\n"
"\"Hello\"\n"
"```"
msgstr ""
"```output info\n"
"\"Hello\"\n"
"```"

#: src/hello-world/step-by-step.md:80
#, fuzzy
msgid ""
"```lean\n"
"#eval \"Hello...   \".dropRightWhile (fun c => not (c.isAlphanum))\n"
"```"
msgstr ""
"```lean\n"
"#eval \"Hello...   \".dropRightWhile (fun c => not (c.isAlphanum))\n"
"```"

#: src/hello-world/step-by-step.md:87
#, fuzzy
msgid ""
"in which all non-alphanumeric characters have been removed from the right "
"side of the string. In the current line of the program, whitespace "
"characters (including the newline) are removed from the right side of the "
"input string, resulting in `\"David\"`, which is associated with `name` for "
"the remainder of the block."
msgstr ""
"其中所有非字母数字字符已从字符串的右侧删除。在程序的当前行中，空格字符（包括换行符）从输入字符串的右侧删除，得到 「`David`」，它在块的剩余部分与"
" `name` 关联。"

#: src/hello-world/step-by-step.md:91
#, fuzzy
msgid "Greeting the User"
msgstr "向用户问好"

#: src/hello-world/step-by-step.md:93
#, fuzzy
msgid ""
"All that remains to be executed in the `do` block is a single statement:"
msgstr "`do` 块中剩余要执行的只有一条语句："

#: src/hello-world/step-by-step.md:94
#, fuzzy
msgid ""
"```lean\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/step-by-step.md:97
#, fuzzy
msgid ""
"The string argument to `putStrLn` is constructed via string interpolation, "
"yielding the string `\"Hello, David!\"`. Because this statement is an "
"expression, it is evaluated to yield an `IO` action that will print this "
"string with a newline to standard output. Once the expression has been "
"evaluated, the resulting `IO` action is executed, resulting in the greeting."
msgstr ""
"传递给 `putStrLn` 的字符串参数通过字符串插值构建，生成字符串 `\"Hello, "
"David!\"`。由于此语句是一个表达式，因此它被求值以生成一个 `IO` "
"动作，该动作将使用换行符将此字符串打印到标准输出。表达式求值后，将执行生成的 `IO` 动作，从而生成问候语。"

#: src/hello-world/step-by-step.md:101
#, fuzzy
msgid "`IO` Actions as Values"
msgstr "`IO` 动作作为值"

#: src/hello-world/step-by-step.md:103
#, fuzzy
msgid ""
"In the above description, it can be difficult to see why the distinction "
"between evaluating expressions and executing `IO` actions is necessary. "
"After all, each action is executed immediately after it is produced. Why not"
" simply carry out the effects during evaluation, as is done in other "
"languages?"
msgstr ""
"在上述描述中，可能很难看出为什么需要区分求值表达式和执行 `IO` "
"动作。毕竟，每个动作在生成后都会立即执行。为什么不干脆在求值期间执行效果，就像在其他语言中所做的那样呢？"

#: src/hello-world/step-by-step.md:107
#, fuzzy
msgid ""
"The answer is twofold. First off, separating evaluation from execution means"
" that programs must be explicit about which functions can have side effects."
" Because the parts of the program that do not have effects are much more "
"amenable to mathematical reasoning, whether in the heads of programmers or "
"using Lean's facilities for formal proof, this separation can make it easier"
" to avoid bugs. Secondly, not all `IO` actions need be executed at the time "
"that they come into existence. The ability to mention an action without "
"carrying it out allows ordinary functions to be used as control structures."
msgstr ""
"答案有两个。首先，将求值与执行分开意味着程序必须明确说明哪些函数可以产生副作用。由于没有副作用的程序部分更适合数学推理，无论是在程序员的头脑中还是使用 "
"Lean 的形式化证明工具，这种分离可以更容易地避免错误。其次，并非所有 `IO` "
"动作都需要在它们产生时执行。在不执行动作的情况下提及动作的能力允许将普通函数用作控制结构体。"

#: src/hello-world/step-by-step.md:113
#, fuzzy
msgid ""
"For instance, the function `twice` takes an `IO` action as its argument, "
"returning a new action that will execute the first one twice."
msgstr "例如，函数 `twice` 将 `IO` 动作作为其参数，返回一个新的动作，该动作将第一个动作执行两次。"

#: src/hello-world/step-by-step.md:119
#, fuzzy
msgid "For instance, executing"
msgstr "例如，执行"

#: src/hello-world/step-by-step.md:120
#, fuzzy
msgid ""
"```lean\n"
"twice (IO.println \"shy\")\n"
"```"
msgstr ""
"```lean\n"
"twice (IO.println \"shy\")\n"
"```"

#: src/hello-world/step-by-step.md:123
#: src/type-classes/standard-classes.md:266 src/monads/io.md:22
#: src/monads/io.md:34
#, fuzzy
msgid "results in"
msgstr "会打印"

#: src/hello-world/step-by-step.md:128
#, fuzzy
msgid ""
"being printed. This can be generalized to a version that runs the underlying"
" action any number of times:"
msgstr "。这可以推广到一个版本，它可以运行底层操作任意次："

#: src/hello-world/step-by-step.md:137
#, fuzzy
msgid ""
"In the base case for `Nat.zero`, the result is `pure ()`. The function "
"`pure` creates an `IO` action that has no side effects, but returns `pure`'s"
" argument, which in this case is the constructor for `Unit`. As an action "
"that does nothing and returns nothing interesting, `pure ()` is at the same "
"time utterly boring and very useful. In the recursive step, a `do` block is "
"used to create an action that first executes `action` and then executes the "
"result of the recursive call. Executing `nTimes (IO.println \"Hello\") 3` "
"causes the following output:"
msgstr ""
"在 `Nat.zero` 的基本情况下，结果是 `pure ()`。函数 `pure` 创建一个没有副作用的 `IO` 操作，但返回 `pure` "
"的参数，在本例中是 `Unit` 的构造子。作为不执行任何操作且不返回任何有趣内容的操作，`pure ()` "
"既非常无聊又非常有用。在递归步骤中，`do` 块用于创建一个操作，该操作首先执行 `action`，然后执行递归调用的结果。执行 `nTimes "
"(IO.println \"Hello\") 3` 会导致以下输出："

#: src/hello-world/step-by-step.md:148
#, fuzzy
msgid ""
"In addition to using functions as control structures, the fact that `IO` "
"actions are first-class values means that they can be saved in data "
"structures for later execution. For instance, the function `countdown` takes"
" a `Nat` and returns a list of unexecuted `IO` actions, one for each `Nat`:"
msgstr ""
"除了将函数用作控制结构体之外，`IO` 操作是一等值的事实意味着它们可以保存在数据结构体中以供以后执行。例如，函数 `countdown` 接受一个 "
"`Nat` 并返回一个未执行的 `IO` 操作列表，每个 `Nat` 一个："

#: src/hello-world/step-by-step.md:150
#, fuzzy
msgid ""
"```lean\n"
"def countdown : Nat → List (IO Unit)\n"
"  | 0 => [IO.println \"Blast off!\"]\n"
"  | n + 1 => IO.println s!\"{n + 1}\" :: countdown n\n"
"```"
msgstr ""
"```lean\n"
"def countdown : Nat → List (IO Unit)\n"
"  | 0 => [IO.println \"Blast off!\"]\n"
"  | n + 1 => IO.println s!\"{n + 1}\" :: countdown n\n"
"```"

#: src/hello-world/step-by-step.md:155
#, fuzzy
msgid ""
"This function has no side effects, and does not print anything. For example,"
" it can be applied to an argument, and the length of the resulting list of "
"actions can be checked:"
msgstr "此函数没有副作用，并且不打印任何内容。例如，它可以应用于一个参数，并且可以检查结果操作列表的长度："

#: src/hello-world/step-by-step.md:160
#, fuzzy
msgid ""
"This list contains six elements (one for each number, plus a `\"Blast "
"off!\"` action for zero):"
msgstr "此列表包含六个元素（每个数字一个，外加一个零的 `\"Blast off!\"` 操作）："

#: src/hello-world/step-by-step.md:168
#, fuzzy
msgid ""
"The function `runActions` takes a list of actions and constructs a single "
"action that runs them all in order:"
msgstr "函数 `runActions` 接受一个操作列表，并构造一个按顺序运行所有操作的单个操作："

#: src/hello-world/step-by-step.md:176
#, fuzzy
msgid ""
"Its structure is essentially the same as that of `nTimes`, except instead of"
" having one action that is executed for each `Nat.succ`, the action under "
"each `List.cons` is to be executed. Similarly, `runActions` does not itself "
"run the actions. It creates a new action that will run them, and that action"
" must be placed in a position where it will be executed as a part of `main`:"
msgstr ""
"其结构体本质上与 `nTimes` 相同，只是没有一个对每个 `Nat.succ` 执行的动作，而是在每个 `List.cons` "
"下的动作将被执行。类似地，`runActions` 本身不会运行这些动作。它创建一个将运行这些动作的新动作，并且该动作必须放置在将作为 `main` "
"的一部分执行的位置："

#: src/hello-world/step-by-step.md:182
#, fuzzy
msgid "Running this program results in the following output:"
msgstr "运行此程序会产生以下输出："

#: src/hello-world/step-by-step.md:192
#, fuzzy
msgid ""
"What happens when this program is run? The first step is to evaluate `main`."
" That occurs as follows:"
msgstr "当运行此程序时会发生什么？第一步是评估 `main`。它发生如下："

#: src/hello-world/step-by-step.md:194
#, fuzzy
msgid ""
"```lean\n"
"main\n"
"===>\n"
"runActions from5\n"
"===>\n"
"runActions (countdown 5)\n"
"===>\n"
"runActions\n"
"  [IO.println \"5\",\n"
"   IO.println \"4\",\n"
"   IO.println \"3\",\n"
"   IO.println \"2\",\n"
"   IO.println \"1\",\n"
"   IO.println \"Blast off!\"]\n"
"===>\n"
"do IO.println \"5\"\n"
"   IO.println \"4\"\n"
"   IO.println \"3\"\n"
"   IO.println \"2\"\n"
"   IO.println \"1\"\n"
"   IO.println \"Blast off!\"\n"
"   pure ()\n"
"```"
msgstr ""
"```lean\n"
"main\n"
"===>\n"
"runActions from5\n"
"===>\n"
"runActions (countdown 5)\n"
"===>\n"
"runActions\n"
"  [IO.println \"5\",\n"
"   IO.println \"4\",\n"
"   IO.println \"3\",\n"
"   IO.println \"2\",\n"
"   IO.println \"1\",\n"
"   IO.println \"Blast off!\"]\n"
"===>\n"
"do IO.println \"5\"\n"
"   IO.println \"4\"\n"
"   IO.println \"3\"\n"
"   IO.println \"2\"\n"
"   IO.println \"1\"\n"
"   IO.println \"Blast off!\"\n"
"   pure ()\n"
"```"

#: src/hello-world/step-by-step.md:217
#, fuzzy
msgid ""
"The resulting `IO` action is a `do` block. Each step of the `do` block is "
"then executed, one at a time, yielding the expected output. The final step, "
"`pure ()`, does not have any effects, and it is only present because the "
"definition of `runActions` needs a base case."
msgstr ""
"结果的 `IO` 动作是一个 `do` 块。然后逐个执行 `do` 块的每个步骤，产生预期的输出。最后一步 `pure ()` "
"没有产生任何效果，它只存在是因为 `runActions` 的定义需要一个基本情况。"

#: src/hello-world/step-by-step.md:221 src/hello-world/cat.md:226
#: src/programs-proofs/tail-recursion-proofs.md:464
#: src/programs-proofs/fin.md:41 src/programs-proofs/special-types.md:51
#, fuzzy
msgid "Exercise"
msgstr "练习"

#: src/hello-world/step-by-step.md:223
#, fuzzy
msgid ""
"Step through the execution of the following program on a piece of paper:"
msgstr "在纸上逐步执行以下程序："

#: src/hello-world/step-by-step.md:224
#, fuzzy
msgid ""
"```lean\n"
"def main : IO Unit := do\n"
"  let englishGreeting := IO.println \"Hello!\"\n"
"  IO.println \"Bonjour!\"\n"
"  englishGreeting\n"
"```"
msgstr ""
"```lean\n"
"def main : IO Unit := do\n"
"  let englishGreeting := IO.println \"Hello!\"\n"
"  IO.println \"Bonjour!\"\n"
"  englishGreeting\n"
"```"

#: src/hello-world/step-by-step.md:230
#, fuzzy
msgid ""
"While stepping through the program's execution, identify when an expression "
"is being evaluated and when an `IO` action is being executed. When executing"
" an `IO` action results in a side effect, write it down. After doing this, "
"run the program with Lean and double-check that your predictions about the "
"side effects were correct."
msgstr ""
"在逐步执行程序时，识别何时正在评估表达式以及何时正在执行 `IO` 动作。当执行 `IO` 动作导致副作用时，将其写下来。执行此操作后，使用 Lean "
"运行程序，并仔细检查你对副作用的预测是否正确。"

#: src/hello-world/starting-a-project.md:3
#, fuzzy
msgid ""
"As a program written in Lean becomes more serious, an ahead-of-time "
"compiler-based workflow that results in an executable becomes more "
"attractive. Like other languages, Lean has tools for building multiple-file "
"packages and managing dependencies. The standard Lean build tool is called "
"Lake (short for \"Lean Make\"), and it is configured in Lean. Just as Lean "
"contains a special-purpose language for writing programs with effects (the "
"`do` language), Lake contains a special-purpose language for configuring "
"builds. These languages are referred to as _embedded domain-specific "
"languages_ (or sometimes _domain-specific embedded languages_, abbreviated "
"EDSL or DSEL). They are _domain-specific_ in the sense that they are used "
"for a particular purpose, with concepts from some sub-domain, and they are "
"typically not suitable for general-purpose programming. They are _embedded_ "
"because they occur inside another language's syntax. While Lean contains "
"rich facilities for creating EDSLs, they are beyond the scope of this book."
msgstr ""
"随着 Lean 中编写的程序变得越来越复杂，基于提前编译器的工作流变得更具吸引力，因为它可以生成可执行文件。与其他语言类似，Lean "
"具有构建多文件包和管理依赖项的工具。标准的 Lean 构建工具称为 Lake（「Lean Make」的缩写），它在 Lean 中进行配置。正如 Lean"
" 包含一门用于编写带效果程序的特殊语言（`do` 语言）一样，Lake 也包含一门用于配置构建的特殊语言。这些语言被称为 "
"_嵌入式领域特定语言_（或有时称为 _领域特定嵌入式语言_，缩写为 EDSL 或 DSEL）。它们是 _领域特定_ "
"的，因为它们用于特定目的，包含来自某个子领域的术语，并且通常不适用于通用编程。它们是 _嵌入式_ 的，因为它们出现在另一种语言的语法中。虽然 Lean "
"包含丰富的用于创建 EDSL 的工具，但它们超出了本书的范围。"

#: src/hello-world/starting-a-project.md:12
#, fuzzy
msgid "First steps"
msgstr "入门"

#: src/hello-world/starting-a-project.md:14
#, fuzzy
msgid ""
"To get started with a project that uses Lake, use the command `lake new "
"greeting` in a directory that does not already contain a file or directory "
"called `greeting`. This creates a directory called `greeting` that contains "
"the following files:"
msgstr ""
"要开始使用一个使用 Lake 的项目，请在尚未包含名为 `greeting` 的文件或目录的目录中使用命令 `lake new "
"greeting`。这将创建一个名为 `greeting` 的目录，其中包含以下文件："

#: src/hello-world/starting-a-project.md:17
#, fuzzy
msgid ""
"`Main.lean` is the file in which the Lean compiler will look for the `main` "
"action."
msgstr "`Main.lean` 是 Lean 编译器将查找 `main` 操作的文件。"

#: src/hello-world/starting-a-project.md:18
#, fuzzy
msgid ""
"`Greeting.lean` and `Greeting/Basic.lean` are the scaffolding of a support "
"library for the program."
msgstr "`Greeting.lean` 和 `Greeting/Basic.lean` 是程序支持库的脚手架。"

#: src/hello-world/starting-a-project.md:19
#, fuzzy
msgid ""
"`lakefile.lean` contains the configuration that `lake` needs to build the "
"application."
msgstr "`lakefile.lean` 包含 `lake` 构建应用程序所需的配置。"

#: src/hello-world/starting-a-project.md:20
#, fuzzy
msgid ""
"`lean-toolchain` contains an identifier for the specific version of Lean "
"that is used for the project."
msgstr "`lean-toolchain` 包含用于项目的特定 Lean 版本的标识符。"

#: src/hello-world/starting-a-project.md:22
#, fuzzy
msgid ""
"Additionally, `lake new` initializes the project as a Git repository and "
"configures its `.gitignore` file to ignore intermediate build products. "
"Typically, the majority of the application logic will be in a collection of "
"libraries for the program, while `Main.lean` will contain a small wrapper "
"around these pieces that does things like parsing command lines and "
"executing the central application logic. To create a project in an already-"
"existing directory, run `lake init` instead of `lake new`."
msgstr ""
"此外，`lake new` 将项目初始化为 Git 存储库，并配置其 `.gitignore` "
"文件以忽略中间构建产品。通常，应用程序逻辑的大部分将位于程序的库集合中，而 `Main.lean` "
"将包含这些部分周围的一个小包装，它执行诸如解析命令行和执行中央应用程序逻辑之类的操作。要在已存在的目录中创建项目，请运行 `lake init` 而不是"
" `lake new`。"

#: src/hello-world/starting-a-project.md:26
#, fuzzy
msgid ""
"By default, the library file `Greeting/Basic.lean` contains a single "
"definition:"
msgstr "默认情况下，库文件 `Greeting/Basic.lean` 包含一个定义："

#: src/hello-world/starting-a-project.md:27
#, fuzzy
msgid ""
"```lean\n"
"def hello := \"world\"\n"
"```"
msgstr ""
"```lean\n"
"def hello := \"world\"\n"
"```"

#: src/hello-world/starting-a-project.md:30
#, fuzzy
msgid "The library file `Greeting.lean` imports `Greeting/Basic.lean`:"
msgstr "库文件 `Greeting.lean` 导入 `Greeting/Basic.lean`："

#: src/hello-world/starting-a-project.md:36
#, fuzzy
msgid ""
"This means that everything defined in `Greetings/Basic.lean` is also "
"available to files that import `Greetings.lean`. In `import` statements, "
"dots are interpreted as directories on disk. Placing guillemets around a "
"name, as in `«Greeting»`, allow it to contain spaces or other characters "
"that are normally not allowed in Lean names, and it allows reserved keywords"
" such as `if` or `def` to be used as ordinary names by writing `«if»` or "
"`«def»`. This prevents issues when the package name provided to `lake new` "
"contains such characters."
msgstr ""
"这意味着在 `Greetings/Basic.lean` 中定义的所有内容也对导入 `Greetings.lean` 的文件可用。在 `import` "
"语句中，点被解释为磁盘上的目录。在名称周围放置引号，如 `«Greeting»`，允许它包含空格或其他通常不允许在 Lean "
"名称中出现的字符，并且它允许通过编写 `«if»` 或 `«def»` 将保留关键字（如 `if` 或 `def`）用作普通名称。当提供给 `lake "
"new` 的包名称包含此类字符时，这可以防止出现问题。"

#: src/hello-world/starting-a-project.md:41
#, fuzzy
msgid "The executable source `Main.lean` contains:"
msgstr "可执行源 `Main.lean` 包含："

#: src/hello-world/starting-a-project.md:42
#, fuzzy
msgid ""
"```lean\n"
"import «Greeting»\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}!\"\n"
"```"
msgstr ""
"```lean\n"
"import «Greeting»\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}!\"\n"
"```"

#: src/hello-world/starting-a-project.md:48
#, fuzzy
msgid ""
"Because `Main.lean` imports `Greetings.lean` and `Greetings.lean` imports "
"`Greetings/Basic.lean`, the definition of `hello` is available in `main`."
msgstr ""
"因为 `Main.lean` 导入 `Greetings.lean`，而 `Greetings.lean` 导入 "
"`Greetings/Basic.lean`，所以 `hello` 的定义在 `main` 中可用。"

#: src/hello-world/starting-a-project.md:50
msgid ""
"To build the package, run the command `lake build`. After a number of build "
"commands scroll by, the resulting binary has been placed in `build/bin`. "
"Running `./build/bin/greeting` results in `Hello, world!`."
msgstr ""
"要构建包，运行命令 `lake build`。在滚动显示一些构建命令后，结果二进制文件已放置在 `build/bin` 中。运行 "
"`./build/bin/greeting` 会生成 `Hello, world!`。"

#: src/hello-world/starting-a-project.md:54
msgid "Lakefiles"
msgstr "Lakefile"

#: src/hello-world/starting-a-project.md:56
msgid ""
"A `lakefile.lean` describes a _package_, which is a coherent collection of "
"Lean code for distribution, analogous to an `npm` or `nuget` package or a "
"Rust crate. A package may contain any number of libraries or executables. "
"While the [documentation for "
"Lake](https://github.com/leanprover/lean4/blob/master/src/lake/README.md) "
"describes the available options in a lakefile, it makes use of a number of "
"Lean features that have not yet been described here. The generated "
"`lakefile.lean` contains the following:"
msgstr ""
"`lakefile.lean` 描述了一个 _包_，它是一个连贯的 Lean 代码集合，用于分发，类似于 `npm` 或 `nuget` 包或 Rust"
" 箱子。一个包可以包含任意数量的库或可执行文件。虽然 [Lake "
"文档](https://github.com/leanprover/lean4/blob/master/src/lake/README.md) 描述了 "
"lakefile 中的可用选项，但它使用了此处尚未描述的许多 Lean 特性。生成的 `lakefile.lean` 包含以下内容："

#: src/hello-world/starting-a-project.md:79
msgid "This initial Lakefile consists of three items:"
msgstr "这个初始 Lakefile 由三项组成："

#: src/hello-world/starting-a-project.md:80
msgid "a _package_ declaration, named `greeting`,"
msgstr "一个名为 `greeting` 的 _包_声明，"

#: src/hello-world/starting-a-project.md:81
msgid "a _library_ declaration, named `Greeting`, and"
msgstr "一个名为 `Greeting` 的 _库_声明，以及"

#: src/hello-world/starting-a-project.md:82
msgid "an _executable_, also named `greeting`."
msgstr "一个也名为 `greeting` 的 _可执行文件_。"

#: src/hello-world/starting-a-project.md:84
msgid ""
"Each of these names is enclosed in guillemets to allow users more freedom in"
" picking package names."
msgstr "这些名称中的每一个都用引号括起来，以允许用户在选择包名称时有更大的自由度。"

#: src/hello-world/starting-a-project.md:86
msgid ""
"Each Lakefile will contain exactly one package, but any number of libraries "
"or executables. Additionally, Lakefiles may contain _external libraries_, "
"which are libraries not written in Lean to be statically linked with the "
"resulting executable, _custom targets_, which are build targets that don't "
"fit naturally into the library/executable taxonomy, _dependencies_, which "
"are declarations of other Lean packages (either locally or from remote Git "
"repositories), and _scripts_, which are essentially `IO` actions (similar to"
" `main`), but that additionally have access to metadata about the package "
"configuration. The items in the Lakefile allow things like source file "
"locations, module hierarchies, and compiler flags to be configured. "
"Generally speaking, however, the defaults are reasonable."
msgstr ""
"每个 Lakefile 将只包含一个包，但可以包含任意数量的库或可执行文件。此外，Lakefile 可能包含 _外部库_（不是用 Lean "
"编写的库，将与结果可执行文件静态链接）、_自定义目标_（不自然地适合于库/可执行文件分类的构建目标）、_依赖项_（其他 Lean "
"包的声明（在本地或来自远程 Git 存储库））、以及 _脚本_（本质上是 `IO` 操作（类似于 "
"`main`），但还可以访问有关包配置的元数据）。Lakefile 中的项允许配置源文件位置、模块层次结构体和编译器标志。然而，一般来说，默认值是合理的。"

#: src/hello-world/starting-a-project.md:91
#, fuzzy
msgid ""
"Libraries, executables, and custom targets are all called _targets_. By "
"default, `lake build` builds those targets that are annotated with "
"`@[default_target]`. This annotation is an _attribute_, which is metadata "
"that can be associated with a Lean declaration. Attributes are similar to "
"Java annotations or C# and Rust attributes. They are used pervasively "
"throughout Lean. To build a target that is not annotated with "
"`@[default_target]`, specify the target's name as an argument after `lake "
"build`."
msgstr ""
"库、可执行文件和自定义目标统称为「目标」。默认情况下，`lake build` 会构建那些标注了 `@[default_target]` "
"的目标。此标注是一个「属性」，它是一种可以与 Lean 声明关联的元数据。属性类似于 Java 标注或 C# 和 Rust 属性。它们在 Lean "
"中被广泛使用。要构建未标注 `@[default_target]` 的目标，请在 `lake build` 后指定目标名称作为参数。"

#: src/hello-world/starting-a-project.md:98
#, fuzzy
msgid "Libraries and Imports"
msgstr "库和导入"

#: src/hello-world/starting-a-project.md:100
#, fuzzy
msgid ""
"A Lean library consists of a hierarchically organized collection of source "
"files from which names can be imported, called _modules_. By default, a "
"library has a single root file that matches its name. In this case, the root"
" file for the library `Greeting` is `Greeting.lean`. The first line of "
"`Main.lean`, which is `import Greeting`, makes the contents of "
"`Greeting.lean` available in `Main.lean`."
msgstr ""
"一个 Lean 库由一个分层组织的源文件集合组成，可以从中导入名称，称为「模块」。默认情况下，一个库有一个与它的名称匹配的单一根文件。在这种情况下，库 "
"`Greeting` 的根文件是 `Greeting.lean`。`Main.lean` 的第一行是 `import Greeting`，它使 "
"`Greeting.lean` 的内容在 `Main.lean` 中可用。"

#: src/hello-world/starting-a-project.md:105
#, fuzzy
msgid ""
"Additional module files may be added to the library by creating a directory "
"called `Greeting` and placing them inside. These names can be imported by "
"replacing the directory separator with a dot. For instance, creating the "
"file `Greeting/Smile.lean` with the contents:"
msgstr ""
"可以通过创建一个名为 `Greeting` 的目录并将它们放在里面来向库中添加额外的模块文件。可以通过用点替换目录分隔符来导入这些名称。例如，创建文件 "
"`Greeting/Smile.lean`，其内容为："

#: src/hello-world/starting-a-project.md:108
#, fuzzy
msgid ""
"```lean\n"
"def expression : String := \"a big smile\"\n"
"```"
msgstr ""
"```lean\n"
"def expression : String := \"a big smile\"\n"
"```"

#: src/hello-world/starting-a-project.md:111
#, fuzzy
msgid "means that `Main.lean` can use the definition as follows:"
msgstr "这意味着 `Main.lean` 可以使用如下定义："

#: src/hello-world/starting-a-project.md:112
#, fuzzy
msgid ""
"```lean\n"
"import Greeting\n"
"import Greeting.Smile\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}, with {expression}!\"\n"
"```"
msgstr ""
"```lean\n"
"import Greeting\n"
"import Greeting.Smile\n"
"\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, {hello}, with {expression}!\"\n"
"```"

#: src/hello-world/starting-a-project.md:120
#, fuzzy
msgid ""
"The module name hierarchy is decoupled from the namespace hierarchy. In "
"Lean, modules are units of code distribution, while namespaces are units of "
"code organization. That is, names defined in the module `Greeting.Smile` are"
" not automatically in a corresponding namespace `Greeting.Smile`. Modules "
"may place names into any namespace they like, and the code that imports them"
" may `open` the namespace or not. `import` is used to make the contents of a"
" source file available, while `open` makes names from a namespace available "
"in the current context without prefixes. In the Lakefile, the line `import "
"Lake` makes the contents of the `Lake` module available, while the line "
"`open Lake DSL` makes the contents of the `Lake` and `Lake.DSL` namespaces "
"available without any prefixes. `Lake.DSL` is opened because opening `Lake` "
"makes `Lake.DSL` available as just `DSL`, just like all other names in the "
"`Lake` namespace. The `Lake` module places names into both the `Lake` and "
"`Lake.DSL` namespaces."
msgstr ""
"模块名称层次结构体与命名空间层次结构体是分离的。在 Lean 中，模块是代码分发单元，而命名空间是代码组织单元。也就是说，在模块 "
"`Greeting.Smile` 中定义的名称不会自动出现在相应的命名空间 `Greeting.Smile` "
"中。模块可以将名称放入他们喜欢的任何命名空间中，而导入它们的代码可以 `open` 命名空间也可以不 `open`。`import` "
"用于使源文件的内容可用，而 `open` 使命名空间中的名称在当前上下文中可用，而无需前缀。在 Lakefile 中，行 `import Lake` 使"
" `Lake` 模块的内容可用，而行 `open Lake DSL` 使 `Lake` 和 `Lake.DSL` "
"命名空间的内容可用，而无需任何前缀。`Lake.DSL` 被打开，因为打开 `Lake` 使 `Lake.DSL` 可用，就像 `Lake` "
"命名空间中的所有其他名称一样。`Lake` 模块将名称放入 `Lake` 和 `Lake.DSL` 命名空间中。"

#: src/hello-world/starting-a-project.md:129
#, fuzzy
msgid ""
"Namespaces may also be opened _selectively_, making only some of their names"
" available without explicit prefixes. This is done by writing the desired "
"names in parentheses. For example, `Nat.toFloat` converts a natural number "
"to a `Float`. It can be made available as `toFloat` using `open Nat "
"(toFloat)`."
msgstr ""
"命名空间也可以进行_选择性_打开，只公开部分名称而无需显式前缀。这可以通过在括号中编写所需名称来完成。例如，`Nat.toFloat` 将自然数转换为 "
"`Float`。可以使用 `open Nat (toFloat)` 将其公开为 `toFloat`。"

#: src/hello-world/cat.md:3
#, fuzzy
msgid ""
"The standard Unix utility `cat` takes a number of command-line options, "
"followed by zero or more input files. If no files are provided, or if one of"
" them is a dash (`-`), then it takes the standard input as the corresponding"
" input instead of reading a file. The contents of the inputs are written, "
"one after the other, to the standard output. If a specified input file does "
"not exist, this is noted on standard error, but `cat` continues "
"concatenating the remaining inputs. A non-zero exit code is returned if any "
"of the input files do not exist."
msgstr ""
"标准 Unix 实用程序 `cat` 接受多个命令行选项，后跟零个或多个输入文件。如果没有提供文件，或者其中一个文件是破折号 "
"(`-`)，则它将标准输入作为相应的输入，而不是读取文件。输入的内容将按顺序写入标准输出。如果指定的输入文件不存在，则会在标准错误中注明，但 `cat`"
" 会继续连接剩余的输入。如果任何输入文件不存在，则返回非零退出代码。"

#: src/hello-world/cat.md:9
#, fuzzy
msgid ""
"This section describes a simplified version of `cat`, called `feline`. "
"Unlike commonly-used versions of `cat`, `feline` has no command-line options"
" for features such as numbering lines, indicating non-printing characters, "
"or displaying help text. Furthermore, it cannot read more than once from a "
"standard input that's associated with a terminal device."
msgstr ""
"本节介绍了 `cat` 的简化版本，称为 `feline`。与 `cat` 的常用版本不同，`feline` "
"没有用于诸如对行编号、指示不可打印字符或显示帮助文本等功能的命令行选项。此外，它无法从与终端设备关联的标准输入中读取多次。"

#: src/hello-world/cat.md:13
#, fuzzy
msgid ""
"To get the most benefit from this section, follow along yourself. It's OK to"
" copy-paste the code examples, but it's even better to type them in by hand."
" This makes it easier to learn the mechanical process of typing in code, "
"recovering from mistakes, and interpreting feedback from the compiler."
msgstr ""
"要充分利用本节，请自己动手操作。复制粘贴代码示例是可以的，但最好手动输入它们。这使得学习输入代码、从错误中恢复以及解释编译器反馈的机械过程变得更加容易。"

#: src/hello-world/cat.md:17
#, fuzzy
msgid "Getting started"
msgstr "开始"

#: src/hello-world/cat.md:19
#, fuzzy
msgid ""
"The first step in implementing `feline` is to create a package and decide "
"how to organize the code. In this case, because the program is so simple, "
"all the code will be placed in `Main.lean`. The first step is to run `lake "
"new feline`. Edit the Lakefile to remove the library, and delete the "
"generated library code and the reference to it from `Main.lean`. Once this "
"has been done, `lakefile.lean` should contain:"
msgstr ""
"第一步是创建包并决定如何组织代码。在本例中，由于程序非常简单，所有代码都将放在 `Main.lean` 中。第一步是运行 `lake new "
"feline`。编辑 `Lakefile` 以删除库，并删除生成的库代码及其在 `Main.lean` 中的引用。完成后，`lakefile.lean`"
" 应包含："

#: src/hello-world/cat.md:39
#, fuzzy
msgid "and `Main.lean` should contain something like:"
msgstr "`Main.lean` 应包含类似以下内容："

#: src/hello-world/cat.md:40
#, fuzzy
msgid ""
"```lean\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, cats!\"\n"
"```"
msgstr ""
"```lean\n"
"def main : IO Unit :=\n"
"  IO.println s!\"Hello, cats!\"\n"
"```"

#: src/hello-world/cat.md:44
#, fuzzy
msgid ""
"Alternatively, running `lake new feline exe` instructs `lake` to use a "
"template that does not include a library section, making it unnecessary to "
"edit the file."
msgstr "或者，运行 `lake new feline exe` 指示 `lake` 使用不包含库部分的模板，从而无需编辑文件。"

#: src/hello-world/cat.md:46
#, fuzzy
msgid "Ensure that the code can be built by running `lake build`."
msgstr "通过运行 `lake build` 确保可以构建代码。"

#: src/hello-world/cat.md:49
#, fuzzy
msgid "Concatenating Streams"
msgstr "连接流"

#: src/hello-world/cat.md:51
#, fuzzy
msgid ""
"Now that the basic skeleton of the program has been built, it's time to "
"actually enter the code. A proper implementation of `cat` can be used with "
"infinite IO streams, such as `/dev/random`, which means that it can't read "
"its input into memory before outputting it. Furthermore, it should not work "
"one character at a time, as this leads to frustratingly slow performance. "
"Instead, it's better to read contiguous blocks of data all at once, "
"directing the data to the standard output one block at a time."
msgstr ""
"现在已经构建了程序的基本框架，是时候实际输入代码了。`cat` 的正确实现可以与无限 IO 流（例如 "
"`/dev/random`）一起使用，这意味着它不能在输出之前将其输入读入内存。此外，它不应一次处理一个字符，因为这会导致令人沮丧的缓慢性能。相反，最好一次读取连续的数据块，一次将数据定向到标准输出。"

#: src/hello-world/cat.md:56
#, fuzzy
msgid ""
"The first step is to decide how big of a block to read. For the sake of "
"simplicity, this implementation uses a conservative 20 kilobyte block. "
"`USize` is analogous to `size_t` in C—it's an unsigned integer type that is "
"big enough to represent all valid array sizes."
msgstr ""
"第一步是确定要读取的块的大小。为了简单起见，此实现使用保守的 20 千字节块。`USize` 类似于 C 中的 "
"`size_t`——它是一个无符号整数类型，足够大以表示所有有效的数组大小。"

#: src/hello-world/cat.md:63
#, fuzzy
msgid "Streams"
msgstr "流"

#: src/hello-world/cat.md:65
#, fuzzy
msgid ""
"The main work of `feline` is done by `dump`, which reads input one block at "
"a time, dumping the result to standard output, until the end of the input "
"has been reached:"
msgstr "`feline` 的主要工作由 `dump` 完成，它一次读取一个块的输入，将结果转储到标准输出，直到达到输入的末尾："

#: src/hello-world/cat.md:76
#, fuzzy
msgid ""
"The `dump` function is declared `partial`, because it calls itself "
"recursively on input that is not immediately smaller than an argument. When "
"a function is declared to be partial, Lean does not require a proof that it "
"terminates. On the other hand, partial functions are also much less amenable"
" to proofs of correctness, because allowing infinite loops in Lean's logic "
"would make it unsound. However, there is no way to prove that `dump` "
"terminates, because infinite input (such as from `/dev/random`) would mean "
"that it does not, in fact, terminate. In cases like this, there is no "
"alternative to declaring the function `partial`."
msgstr ""
"`dump` 函数被声明为 `partial`，因为它在输入上递归调用自身，该输入不会立即小于一个参数。当一个函数被声明为 `partial` "
"时，Lean 不要求证明它会终止。另一方面，`partial` 函数也不太适合正确性证明，因为允许在 Lean "
"的逻辑中进行无限循环会使其不健全。然而，没有办法证明 `dump` 会终止，因为无限输入（例如来自 "
"`/dev/random`）意味着它实际上不会终止。在这种情况下，除了将函数声明为 `partial` 之外别无选择。"

#: src/hello-world/cat.md:82
#, fuzzy
msgid ""
"The type `IO.FS.Stream` represents a POSIX stream. Behind the scenes, it is "
"represented as a structure that has one field for each POSIX stream "
"operation. Each operation is represented as an IO action that provides the "
"corresponding operation:"
msgstr ""
"类型 `IO.FS.Stream` 表示一个 POSIX 流。在幕后，它被表示为一个结构体，它为每个 POSIX 流操作有一个字段。每个操作都表示为一个 "
"IO 操作，它提供了相应的操作："

#: src/hello-world/cat.md:93
#, fuzzy
msgid ""
"The Lean compiler contains `IO` actions (such as `IO.getStdout`, which is "
"called in `dump`) to get streams that represent standard input, standard "
"output, and standard error. These are `IO` actions rather than ordinary "
"definitions because Lean allows these standard POSIX streams to be replaced "
"in a process, which makes it easier to do things like capturing the output "
"from a program into a string by writing a custom `IO.FS.Stream`."
msgstr ""
"Lean 编译器包含 `IO` 操作（例如 `IO.getStdout`，它在 `dump` "
"中被调用）以获取表示标准输入、标准输出和标准错误的流。这些是 `IO` 操作，而不是普通定义，因为 Lean 允许在进程中替换这些标准 POSIX "
"流，这使得通过编写自定义 `IO.FS.Stream` 将程序的输出捕获到字符串中变得更容易。"

#: src/hello-world/cat.md:96
#, fuzzy
msgid ""
"The control flow in `dump` is essentially a `while` loop. When `dump` is "
"called, if the stream has reached the end of the file, `pure ()` terminates "
"the function by returning the constructor for `Unit`. If the stream has not "
"yet reached the end of the file, one block is read, and its contents are "
"written to `stdout`, after which `dump` calls itself directly. The recursive"
" calls continue until `stream.read` returns an empty byte array, which "
"indicates that the end of the file has been reached."
msgstr ""
"`dump` 中的控制流本质上是一个 `while` 循环。当调用 `dump` 时，如果流已达到文件末尾，`pure ()` 通过返回 `Unit` "
"的构造子来终止函数。如果流尚未达到文件末尾，则读取一个块，并将它的内容写入 `stdout`，之后 `dump` 直接调用自身。递归调用会一直持续到 "
"`stream.read` 返回一个空字节数组，这表示已达到文件末尾。"

#: src/hello-world/cat.md:101
#, fuzzy
msgid ""
"When an `if` expression occurs as a statement in a `do`, as in `dump`, each "
"branch of the `if` is implicitly provided with a `do`. In other words, the "
"sequence of steps following the `else` are treated as a sequence of `IO` "
"actions to be executed, just as if they had a `do` at the beginning. Names "
"introduced with `let` in the branches of the `if` are visible only in their "
"own branches, and are not in scope outside of the `if`."
msgstr ""
"当 `if` 表达式作为 `do` 中的语句出现时，如 `dump` 中，`if` 的每个分支都会隐式地提供一个 `do`。换句话说，跟在 `else`"
" 之后的步骤序列被视为要执行的 `IO` 动作序列，就像它们在开头有一个 `do` 一样。在 `if` 分支中用 `let` "
"引入的名称只在其自己的分支中可见，并且不在 `if` 之外的范围内。"

#: src/hello-world/cat.md:105
#, fuzzy
msgid ""
"There is no danger of running out of stack space while calling `dump` "
"because the recursive call happens as the very last step in the function, "
"and its result is returned directly rather than being manipulated or "
"computed with. This kind of recursion is called _tail recursion_, and it is "
"described in more detail [later in this book](../programs-proofs/tail-"
"recursion.md). Because the compiled code does not need to retain any state, "
"the Lean compiler can compile the recursive call to a jump."
msgstr ""
"在调用 `dump` 时，不会出现耗尽堆栈空间的危险，因为递归调用发生在函数的最后一步，并且其结果被直接返回，而不是被操作或计算。这种递归称为 "
"_尾递归_，将在 [本书后面](../programs-proofs/tail-recursion.md) "
"详细描述。由于编译后的代码不需要保留任何状态，因此 Lean 编译器可以将递归调用编译为跳转。"

#: src/hello-world/cat.md:109
#, fuzzy
msgid ""
"If `feline` only redirected standard input to standard output, then `dump` "
"would be sufficient. However, it also needs to be able to open files that "
"are provided as command-line arguments and emit their contents. When its "
"argument is the name of a file that exists, `fileStream` returns a stream "
"that reads the file's contents. When the argument is not a file, "
"`fileStream` emits an error and returns `none`."
msgstr ""
"如果 `feline` 只将标准输入重定向到标准输出，那么 `dump` "
"就足够了。但是，它还需要能够打开作为命令行参数提供的文件并输出其内容。当其参数是存在的文件名时，`fileStream` "
"返回读取文件内容的流。当参数不是文件时，`fileStream` 发出错误并返回 `none`。"

#: src/hello-world/cat.md:113
#, fuzzy
msgid ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do\n"
"  let fileExists ← filename.pathExists\n"
"  if not fileExists then\n"
"    let stderr ← IO.getStderr\n"
"    stderr.putStrLn s!\"File not found: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"
msgstr ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do\n"
"  let fileExists ← filename.pathExists\n"
"  if not fileExists then\n"
"    let stderr ← IO.getStderr\n"
"    stderr.putStrLn s!\"File not found: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"

#: src/hello-world/cat.md:124
#, fuzzy
msgid ""
"Opening a file as a stream takes two steps. First, a file handle is created "
"by opening the file in read mode. A Lean file handle tracks an underlying "
"file descriptor. When there are no references to the file handle value, a "
"finalizer closes the file descriptor. Second, the file handle is given the "
"same interface as a POSIX stream using `IO.FS.Stream.ofHandle`, which fills "
"each field of the `Stream` structure with the corresponding `IO` action that"
" works on file handles."
msgstr ""
"打开一个文件作为流需要两个步骤。首先，通过以读取模式打开文件来创建一个文件句柄。Lean "
"文件句柄跟踪底层文件描述符。当没有对文件句柄值进行引用时，终结器会关闭文件描述符。其次，使用 `IO.FS.Stream.ofHandle` "
"为文件句柄提供与 POSIX 流相同的接口，该接口使用在文件句柄上工作的相应 `IO` 操作填充 `Stream` 结构体的每个字段。"

#: src/hello-world/cat.md:130
#, fuzzy
msgid "Handling Input"
msgstr "处理输入"

#: src/hello-world/cat.md:132
#, fuzzy
msgid ""
"The main loop of `feline` is another tail-recursive function, called "
"`process`. In order to return a non-zero exit code if any of the inputs "
"could not be read, `process` takes an argument `exitCode` that represents "
"the current exit code for the whole program. Additionally, it takes a list "
"of input files to be processed."
msgstr ""
"`feline` 的主循环是另一个尾递归函数，称为 `process`。为了在无法读取任何输入时返回非零退出代码，`process` 采用一个参数 "
"`exitCode`，该参数表示整个程序的当前退出代码。此外，它采用一个要处理的输入文件列表。"

#: src/hello-world/cat.md:135
#, fuzzy
msgid ""
"```lean\n"
"def process (exitCode : UInt32) (args : List String) : IO UInt32 := do\n"
"  match args with\n"
"  | [] => pure exitCode\n"
"  | \"-\" :: args =>\n"
"    let stdin ← IO.getStdin\n"
"    dump stdin\n"
"    process exitCode args\n"
"  | filename :: args =>\n"
"    let stream ← fileStream ⟨filename⟩\n"
"    match stream with\n"
"    | none =>\n"
"      process 1 args\n"
"    | some stream =>\n"
"      dump stream\n"
"      process exitCode args\n"
"```"
msgstr ""
"```lean\n"
"def process (exitCode : UInt32) (args : List String) : IO UInt32 := do\n"
"  match args with\n"
"  | [] => pure exitCode\n"
"  | \"-\" :: args =>\n"
"    let stdin ← IO.getStdin\n"
"    dump stdin\n"
"    process exitCode args\n"
"  | filename :: args =>\n"
"    let stream ← fileStream ⟨filename⟩\n"
"    match stream with\n"
"    | none =>\n"
"      process 1 args\n"
"    | some stream =>\n"
"      dump stream\n"
"      process exitCode args\n"
"```"

#: src/hello-world/cat.md:152
#, fuzzy
msgid ""
"Just as with `if`, each branch of a `match` that is used as a statement in a"
" `do` is implicitly provided with its own `do`."
msgstr "就像 `if` 一样，用作 `do` 中语句的 `match` 的每个分支都隐式地提供了自己的 `do`。"

#: src/hello-world/cat.md:154
#, fuzzy
msgid ""
"There are three possibilities. One is that no more files remain to be "
"processed, in which case `process` returns the error code unchanged. Another"
" is that the specified filename is `\"-\"`, in which case `process` dumps "
"the contents of the standard input and then processes the remaining "
"filenames. The final possibility is that an actual filename was specified. "
"In this case, `fileStream` is used to attempt to open the file as a POSIX "
"stream. Its argument is encased in `⟨ ... ⟩` because a `FilePath` is a "
"single-field structure that contains a string. If the file could not be "
"opened, it is skipped, and the recursive call to `process` sets the exit "
"code to `1`. If it could, then it is dumped, and the recursive call to "
"`process` leaves the exit code unchanged."
msgstr ""
"有三种可能性。一种是没有更多文件需要处理，在这种情况下，`process` 返回未更改的错误代码。另一种是指定的文件名为 `\"-\"`, "
"在这种情况下，`process` 转储标准输入的内容，然后处理剩余的文件名。最后一种可能性是指定了实际文件名。在这种情况下，`fileStream` "
"用于尝试将文件作为 POSIX 流打开。它的参数被封装在 `⟨ ... ⟩` 中，因为 `FilePath` "
"是一个包含字符串的单字段结构体。如果无法打开文件，则跳过该文件，并且对 `process` 的递归调用将退出代码设置为 "
"`1`。如果可以，则将其转储，并且对 `process` 的递归调用将使退出代码保持不变。"

#: src/hello-world/cat.md:163
#, fuzzy
msgid ""
"`process` does not need to be marked `partial` because it is structurally "
"recursive. Each recursive call is provided with the tail of the input list, "
"and all Lean lists are finite. Thus, `process` does not introduce any non-"
"termination."
msgstr ""
"`process` 无需标记为 `partial`，因为它在结构体上是递归的。每次递归调用都会提供输入列表的尾部，并且所有 Lean "
"列表都是有限的。因此，`process` 不会引入任何非终止。"

#: src/hello-world/cat.md:167
#, fuzzy
msgid "Main"
msgstr "Main"

#: src/hello-world/cat.md:169
#, fuzzy
msgid ""
"The final step is to write the `main` action. Unlike prior examples, `main` "
"in `feline` is a function. In Lean, `main` can have one of three types:"
msgstr ""
"最后一步是编写 `main` 动作。与之前的示例不同，`feline` 中的 `main` 是一个函数。在 Lean 中，`main` "
"可以有三种类型之一："

#: src/hello-world/cat.md:172
#, fuzzy
msgid ""
"`main : IO Unit` corresponds to programs that cannot read their command-line"
" arguments and always indicate success with an exit code of `0`,"
msgstr "`main : IO Unit` 对应于无法读取其命令行参数并始终以退出代码 `0` 表示成功的程序，"

#: src/hello-world/cat.md:173
#, fuzzy
msgid ""
"`main : IO UInt32` corresponds to `int main(void)` in C, for programs "
"without arguments that return exit codes, and"
msgstr "`main : IO UInt32` 对应于 C 中的 `int main(void)`，用于没有参数且返回退出代码的程序，"

#: src/hello-world/cat.md:174
#, fuzzy
msgid ""
"`main : List String → IO UInt32` corresponds to `int main(int argc, char "
"**argv)` in C, for programs that take arguments and signal success or "
"failure."
msgstr ""
"`main : List String → IO UInt32` 对应于 C 中的 `int main(int argc, char "
"**argv)`，用于获取参数并发出成功或失败信号的程序。"

#: src/hello-world/cat.md:176
#, fuzzy
msgid ""
"If no arguments were provided, `feline` should read from standard input as "
"if it were called with a single `\"-\"` argument. Otherwise, the arguments "
"should be processed one after the other."
msgstr "如果没有提供参数，`feline` 应从标准输入读取，就像使用单个 `\"-\"` 参数调用它一样。否则，应依次处理参数。"

#: src/hello-world/cat.md:178
#, fuzzy
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 :=\n"
"  match args with\n"
"  | [] => process 0 [\"-\"]\n"
"  | _ =>  process 0 args\n"
"```"
msgstr ""
"```lean\n"
"def main (args : List String) : IO UInt32 :=\n"
"  match args with\n"
"  | [] => process 0 [\"-\"]\n"
"  | _ =>  process 0 args\n"
"```"

#: src/hello-world/cat.md:186
#, fuzzy
msgid "Meow!"
msgstr "喵！"

#: src/hello-world/cat.md:188
#, fuzzy
msgid ""
"To check whether `feline` works, the first step is to build it with `lake "
"build`. First off, when called without arguments, it should emit what it "
"receives from standard input. Check that"
msgstr ""
"要检查 `feline` 是否工作，第一步是用 `lake build` "
"构建它。首先，在没有参数的情况下调用它时，它应该发出从标准输入接收到的内容。检查"

#: src/hello-world/cat.md:191
#, fuzzy
msgid ""
"```\n"
"echo \"It works!\" | ./build/bin/feline\n"
"```"
msgstr ""
"```\n"
"echo \"It works!\" | ./build/bin/feline\n"
"```"

#: src/hello-world/cat.md:194
#, fuzzy
msgid "emits `It works!`."
msgstr "发出 `It works!`。"

#: src/hello-world/cat.md:196
#, fuzzy
msgid ""
"Secondly, when called with files as arguments, it should print them. If the "
"file `test1.txt` contains"
msgstr "其次，当使用文件作为参数调用它时，它应该打印它们。如果文件 `test1.txt` 包含"

#: src/hello-world/cat.md:201
#, fuzzy
msgid "and `test2.txt` contains"
msgstr "而 `test2.txt` 包含"

#: src/hello-world/cat.md:205
#, fuzzy
msgid "then the command"
msgstr "那么命令"

#: src/hello-world/cat.md:209
#, fuzzy
msgid "should emit"
msgstr "最终，`-` 参数应得到适当处理。"

#: src/hello-world/cat.md:215
msgid "Finally, the `-` argument should be handled appropriately."
msgstr "最终，`-` 参数应得到适当处理。"

#: src/hello-world/cat.md:216
msgid ""
"```\n"
"echo \"and purr\" | ./build/bin/feline test1.txt - test2.txt\n"
"```"
msgstr ""
"```\n"
"echo \"and purr\" | ./build/bin/feline test1.txt - test2.txt\n"
"```"

#: src/hello-world/cat.md:219 src/type-classes/out-params.md:188
msgid "should yield"
msgstr "应产生"

#: src/hello-world/cat.md:228
msgid ""
"Extend `feline` with support for usage information. The extended version "
"should accept a command-line argument `--help` that causes documentation "
"about the available command-line options to be written to standard output."
msgstr "扩展 `feline` 以支持使用信息。扩展版本应接受命令行参数 `--help`，该参数会导致有关可用命令行选项的文档被写入标准输出。"

#: src/hello-world/conveniences.md:4
msgid "Nested Actions"
msgstr "嵌套操作"

#: src/hello-world/conveniences.md:6
msgid ""
"Many of the functions in `feline` exhibit a repetitive pattern in which an "
"`IO` action's result is given a name, and then used immediately and only "
"once. For instance, in `dump`:"
msgstr ""
"`feline` 中的许多函数都表现出一种重复模式，其中 `IO` 操作的结果被赋予一个名称，然后立即且仅使用一次。例如，在 `dump` 中："

#: src/hello-world/conveniences.md:18
msgid "the pattern occurs for `stdout`:"
msgstr "模式发生在 `stdout` 中："

#: src/hello-world/conveniences.md:23
msgid "Similarly, `fileStream` contains the following snippet:"
msgstr "同样，`fileStream` 包含以下代码段："

#: src/hello-world/conveniences.md:29
msgid ""
"When Lean is compiling a `do` block, expressions that consist of a left "
"arrow immediately under parentheses are lifted to the nearest enclosing "
"`do`, and their results are bound to a unique name. This unique name "
"replaces the origin of the expression. This means that `dump` can also be "
"written as follows:"
msgstr ""
"当 Lean 编译 `do` 块时，由括号下方的左箭头组成的表达式会被提升到最近的封闭 `do` "
"中，并且其结果会被绑定到一个唯一名称。这个唯一名称替换了表达式的来源。这意味着 `dump` 也可以写成如下形式："

#: src/hello-world/conveniences.md:41
msgid ""
"This version of `dump` avoids introducing names that are used only once, "
"which can greatly simplify a program. `IO` actions that Lean lifts from a "
"nested expression context are called _nested actions_."
msgstr ""
"此版本的 `dump` 避免了引入仅使用一次的名称，这可以极大地简化程序。Lean 从嵌套表达式上下文中提升的 `IO` 操作称为 _嵌套操作_。"

#: src/hello-world/conveniences.md:44
msgid "`fileStream` can be simplified using the same technique:"
msgstr "`fileStream` 可以使用相同的技术进行简化："

#: src/hello-world/conveniences.md:45
msgid ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do\n"
"  if not (← filename.pathExists) then\n"
"    (← IO.getStderr).putStrLn s!\"File not found: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"
msgstr ""
"```lean\n"
"def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do\n"
"  if not (← filename.pathExists) then\n"
"    (← IO.getStderr).putStrLn s!\"文件未找到: {filename}\"\n"
"    pure none\n"
"  else\n"
"    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read\n"
"    pure (some (IO.FS.Stream.ofHandle handle))\n"
"```"

#: src/hello-world/conveniences.md:54
#, fuzzy
msgid ""
"In this case, the local name of `handle` could also have been eliminated "
"using nested actions, but the resulting expression would have been long and "
"complicated. Even though it's often good style to use nested actions, it can"
" still sometimes be helpful to name intermediate results."
msgstr ""
"在这种情况下，局部名称「handle」也可以使用嵌套操作来消除，但由此产生的表达式会很长且复杂。尽管使用嵌套操作通常是一种良好的风格，但有时对中间结果进行命名仍然很有帮助。"

#: src/hello-world/conveniences.md:57
#, fuzzy
msgid ""
"It is important to remember, however, that nested actions are only a shorter"
" notation for `IO` actions that occur in a surrounding `do` block. The side "
"effects that are involved in executing them still occur in the same order, "
"and execution of side effects is not interspersed with the evaluation of "
"expressions. For an example of where this might be confusing, consider the "
"following helper definitions that return data after announcing to the world "
"that they have been executed:"
msgstr ""
"然而，重要的是要记住，嵌套操作只是对包围在「do」块中的「IO」操作的一种更短的表示法。执行它们所涉及的副作用仍然按相同的顺序发生，并且副作用的执行不会与表达式的求值交错进行。对于可能令人困惑的示例，请考虑以下返回数据的帮助程序定义，在向世界宣布它们已执行后："

#: src/hello-world/conveniences.md:60
#, fuzzy
msgid ""
"```lean\n"
"def getNumA : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"A\"\n"
"  pure 5\n"
"\n"
"def getNumB : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"B\"\n"
"  pure 7\n"
"```"
msgstr ""
"```lean\n"
"def getNumA : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"A\"\n"
"  pure 5\n"
"\n"
"def getNumB : IO Nat := do\n"
"  (← IO.getStdout).putStrLn \"B\"\n"
"  pure 7\n"
"```"

#: src/hello-world/conveniences.md:69
#, fuzzy
msgid ""
"These definitions are intended to stand in for more complicated `IO` code "
"that might validate user input, read a database, or open a file."
msgstr "这些定义旨在代表更复杂的「IO」代码，这些代码可能验证用户输入、读取数据库或打开文件。"

#: src/hello-world/conveniences.md:71
#, fuzzy
msgid ""
"A program that prints `0` when number A is five, or number `B` otherwise, "
"can be written as follows:"
msgstr "当数字 A 为 5 时打印「0」，否则打印数字「B」的程序可以写成如下形式："

#: src/hello-world/conveniences.md:72
#, fuzzy
msgid ""
"```lean\n"
"def test : IO Unit := do\n"
"  let a : Nat := if (← getNumA) == 5 then 0 else (← getNumB)\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"
msgstr ""
"```lean\n"
"def test : IO Unit := do\n"
"  let a : Nat := if (← getNumA) == 5 then 0 else (← getNumB)\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"

#: src/hello-world/conveniences.md:77
#, fuzzy
msgid ""
"However, this program probably has more side effects (such as prompting for "
"user input or reading a database) than was intended. The definition of "
"`getNumA` makes it clear that it will always return `5`, and thus the "
"program should not read number B. However, running the program results in "
"the following output:"
msgstr ""
"但是，此程序可能具有比预期更多的副作用（例如提示用户输入或读取数据库）。`getNumA` 的定义明确指出它将始终返回「5」，因此程序不应读取数字 "
"B。但是，运行程序会产生以下输出："

#: src/hello-world/conveniences.md:85
#, fuzzy
msgid ""
"`getNumB` was executed because `test` is equivalent to this definition:"
msgstr "`getNumB` 被执行是因为 `test` 等价于这个定义："

#: src/hello-world/conveniences.md:86
#, fuzzy
msgid ""
"```lean\n"
"def test : IO Unit := do\n"
"  let x ← getNumA\n"
"  let y ← getNumB\n"
"  let a : Nat := if x == 5 then 0 else y\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"
msgstr ""
"```lean\n"
"def test : IO Unit := do\n"
"  let x ← getNumA\n"
"  let y ← getNumB\n"
"  let a : Nat := if x == 5 then 0 else y\n"
"  (← IO.getStdout).putStrLn s!\"The answer is {a}\"\n"
"```"

#: src/hello-world/conveniences.md:93
#, fuzzy
msgid ""
"This is due to the rule that nested actions are lifted to the _closest "
"enclosing_ `do` block. The branches of the `if` were not implicitly wrapped "
"in `do` blocks because the `if` is not itself a statement in the `do` "
"block—the statement is the `let` that defines `a`. Indeed, they could not be"
" wrapped this way, because the type of the conditional expression is `Nat`, "
"not `IO Nat`."
msgstr ""
"这是因为嵌套动作被提升到最接近的包含 `do` 块的规则。`if` 的分支没有被隐式地包装在 `do` 块中，因为 `if` 本身不是 `do` "
"块中的语句——语句是定义 `a` 的 `let`。事实上，它们不能这样包装，因为条件表达式的类型是 `Nat`，而不是 `IO Nat`。"

#: src/hello-world/conveniences.md:97
#, fuzzy
msgid "Flexible Layouts for `do`"
msgstr "`do` 的灵活布局"

#: src/hello-world/conveniences.md:99
#, fuzzy
msgid ""
"In Lean, `do` expressions are whitespace-sensitive. Each `IO` action or "
"local binding in the `do` is expected to start on its own line, and they "
"should all have the same indentation. Almost all uses of `do` should be "
"written this way. In some rare contexts, however, manual control over "
"whitespace and indentation may be necessary, or it may be convenient to have"
" multiple small actions on a single line. In these cases, newlines can be "
"replaced with a semicolon and indentation can be replaced with curly braces."
msgstr ""
"在 Lean 中，`do` 表达式对空格敏感。`do` 中的每个 `IO` 动作或局部绑定都应该从自己的行开始，并且它们都应该有相同的缩进。几乎所有 "
"`do` "
"的用法都应该这样写。然而，在一些罕见的情况下，可能需要手动控制空格和缩进，或者在单行上有多个小动作可能很方便。在这些情况下，换行符可以用分号替换，缩进可以用花括号替换。"

#: src/hello-world/conveniences.md:105
#, fuzzy
msgid "For instance, all of the following programs are equivalent:"
msgstr "例如，以下所有程序都是等价的："

#: src/hello-world/conveniences.md:106
#, fuzzy
msgid ""
"```lean\n"
"-- This version uses only whitespace-sensitive layout\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"\n"
"-- This version is as explicit as possible\n"
"def main : IO Unit := do {\n"
"  let stdin ← IO.getStdin;\n"
"  let stdout ← IO.getStdout;\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\";\n"
"  let name := (← stdin.getLine).trim;\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"}\n"
"\n"
"-- This version uses a semicolon to put two actions on the same line\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin; let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"
msgstr ""
"```lean\n"
"-- 这个版本只使用空格敏感的布局\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"\n"
"-- 这个版本尽可能明确\n"
"def main : IO Unit := do {\n"
"  let stdin ← IO.getStdin;\n"
"  let stdout ← IO.getStdout;\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\";\n"
"  let name := (← stdin.getLine).trim;\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"}\n"
"\n"
"-- 这个版本使用分号将两个动作放在同一行\n"
"def main : IO Unit := do\n"
"  let stdin ← IO.getStdin; let stdout ← IO.getStdout\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  let name := (← stdin.getLine).trim\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"```"

#: src/hello-world/conveniences.md:135
#, fuzzy
msgid "Idiomatic Lean code uses curly braces with `do` very rarely."
msgstr "Idiomatic Lean 代码极少使用带有 `do` 的大括号。"

#: src/hello-world/conveniences.md:137
#, fuzzy
msgid "Running `IO` Actions With `#eval`"
msgstr "使用 `#eval` 运行 `IO` 动作"

#: src/hello-world/conveniences.md:139
#, fuzzy
msgid ""
"Lean's `#eval` command can be used to execute `IO` actions, rather than just"
" evaluating them. Normally, adding a `#eval` command to a Lean file causes "
"Lean to evaluate the provided expression, convert the resulting value to a "
"string, and provide that string as a tooltip and in the info window. Rather "
"than failing because `IO` actions can't be converted to strings, `#eval` "
"executes them, carrying out their side effects. If the result of execution "
"is the `Unit` value `()`, then no result string is shown, but if it is a "
"type that can be converted to a string, then Lean displays the resulting "
"value."
msgstr ""
"Lean 的 `#eval` 命令可用于执行 `IO` 动作，而不仅仅是评估它们。通常，向 Lean 文件添加 `#eval` 命令会导致 Lean "
"评估提供的表达式，将结果值转换为字符串，并在工具提示和信息窗口中提供该字符串。`#eval` 不会因为 `IO` "
"动作无法转换为字符串而失败，而是执行它们，执行它们的副作用。如果执行结果是 `Unit` 值 "
"`()`，则不显示结果字符串，但如果它是可以转换为字符串的类型，则 Lean 会显示结果值。"

#: src/hello-world/conveniences.md:144
#, fuzzy
msgid ""
"This means that, given the prior definitions of `countdown` and "
"`runActions`,"
msgstr "这意味着，给定 `countdown` 和 `runActions` 的先前定义，"

#: src/hello-world/conveniences.md:148
#, fuzzy
msgid "displays"
msgstr "显示"

#: src/hello-world/conveniences.md:155
#, fuzzy
msgid ""
"This is the output produced by running the `IO` action, rather than some "
"opaque representation of the action itself. In other words, for `IO` "
"actions, `#eval` both _evaluates_ the provided expression and _executes_ the"
" resulting action value."
msgstr ""
"这是运行 `IO` 动作产生的输出，而不是动作本身的不透明表示。换句话说，对于 `IO` 动作，`#eval` "
"既_评估_提供的表达式，又_执行_结果动作值。"

#: src/hello-world/conveniences.md:158
#, fuzzy
msgid ""
"Quickly testing `IO` actions with `#eval` can be much more convenient that "
"compiling and running whole programs. However, there are some limitations. "
"For instance, reading from standard input simply returns empty input. "
"Additionally, the `IO` action is re-executed whenever Lean needs to update "
"the diagnostic information that it provides to users, and this can happen at"
" unpredictable times. An action that reads and writes files, for instance, "
"may do so at inconvenient times."
msgstr ""
"使用 `#eval` 快速测试 `IO` 动作比编译和运行整个程序方便得多。但是，有一些限制。例如，从标准输入读取只会返回空输入。此外，每当 Lean "
"需要更新它提供给用户的诊断信息时，`IO` 动作都会重新执行，这可能会在不可预测的时间发生。例如，读取和写入文件的动作可能会在不方便的时间执行。"

#: src/hello-world/summary.md:3
#, fuzzy
msgid "Evaluation vs Execution"
msgstr "评估与执行"

#: src/hello-world/summary.md:5
msgid ""
"Side effects are aspects of program execution that go beyond the evaluation "
"of mathematical expressions, such as reading files, throwing exceptions, or "
"triggering industrial machinery. While most languages allow side effects to "
"occur during evaluation, Lean does not. Instead, Lean has a type called `IO`"
" that represents _descriptions_ of programs that use side effects. These "
"descriptions are then executed by the language's run-time system, which "
"invokes the Lean expression evaluator to carry out specific computations. "
"Values of type `IO α` are called _`IO` actions_. The simplest is `pure`, "
"which returns its argument and has no actual side effects."
msgstr ""
"副作用是程序执行中超出数学表达式求值范围的部分，例如读取文件、抛出异常或触发工业机械。虽然大多数语言允许在求值期间发生副作用，但 Lean "
"不会。相反，Lean 有一个名为 `IO` 的类型，它表示使用副作用的程序的 _描述_。然后由语言的运行时系统执行这些描述，该系统调用 Lean "
"表达式求值器来执行特定计算。类型为 `IO α` 的值称为 _`IO` 操作_。最简单的是 `pure`，它返回其参数并且没有实际副作用。"

#: src/hello-world/summary.md:12
msgid ""
"`IO` actions can also be understood as functions that take the whole world "
"as an argument and return a new world in which the side effect has occurred."
" Behind the scenes, the `IO` library ensures that the world is never "
"duplicated, created, or destroyed. While this model of side effects cannot "
"actually be implemented, as the whole universe is too big to fit in memory, "
"the real world can be represented by a token that is passed around through "
"the program."
msgstr ""
"`IO` 操作还可以理解为将整个世界作为参数并返回一个副作用已经发生的全新世界的函数。在幕后，`IO` "
"库确保世界永远不会被复制、创建或销毁。虽然这种副作用模型实际上无法实现，因为整个宇宙太大而无法放入内存，但现实世界可以用一个在程序中传递的令牌来表示。"

#: src/hello-world/summary.md:16
msgid ""
"An `IO` action `main` is executed when the program starts. `main` can have "
"one of three types:"
msgstr "当程序启动时，将执行 `IO` 操作 `main`。`main` 可以有三种类型之一："

#: src/hello-world/summary.md:18
msgid ""
"`main : IO Unit` is used for simple programs that cannot read their command-"
"line arguments and always return exit code `0`,"
msgstr "`main : IO Unit` 用于无法读取其命令行参数且始终返回退出代码 `0` 的简单程序，"

#: src/hello-world/summary.md:19
msgid ""
"`main : IO UInt32` is used for programs without arguments that may signal "
"success or failure, and"
msgstr "`main : IO UInt32` 用于没有参数的程序，该程序可能会发出成功或失败信号，"

#: src/hello-world/summary.md:20
msgid ""
"`main : List String → IO UInt32` is used for programs that take command-line"
" arguments and signal success or failure."
msgstr "`main : List String → IO UInt32` 用于获取命令行参数并发出成功或失败信号的程序。"

#: src/hello-world/summary.md:23
#, fuzzy
msgid "`do` Notation"
msgstr "`do` 语法"

#: src/hello-world/summary.md:25
#, fuzzy
msgid ""
"The Lean standard library provides a number of basic `IO` actions that "
"represent effects such as reading from and writing to files and interacting "
"with standard input and standard output. These base `IO` actions are "
"composed into larger `IO` actions using `do` notation, which is a built-in "
"domain-specific language for writing descriptions of programs with side "
"effects. A `do` expression contains a sequence of _statements_, which may "
"be:"
msgstr ""
"Lean 标准库提供了许多基本 `IO` 操作，表示诸如读写文件以及与标准输入和标准输出交互之类的效果。这些基本 `IO` 操作使用 `do` "
"语法组合成更大的 `IO` 操作，`do` 语法是用于编写具有副作用的程序描述的内置领域特定语言。`do` 表达式包含一系列 _语句_，这些语句可以是："

#: src/hello-world/summary.md:28
#, fuzzy
msgid "expressions that represent `IO` actions,"
msgstr "表示 `IO` 操作的表达式，"

#: src/hello-world/summary.md:29
#, fuzzy
msgid ""
"ordinary local definitions with `let` and `:=`, where the defined name "
"refers to the value of the provided expression, or"
msgstr "使用 `let` 和 `:=` 的普通局部定义，其中定义的名称引用所提供表达式的值，或者"

#: src/hello-world/summary.md:30
#, fuzzy
msgid ""
"local definitions with `let` and `←`, where the defined name refers to the "
"result of executing the value of the provided expression."
msgstr "使用 `let` 和 `←` 的局部定义，其中定义的名称引用执行所提供表达式的结果值。"

#: src/hello-world/summary.md:32
#, fuzzy
msgid ""
"`IO` actions that are written with `do` are executed one statement at a "
"time."
msgstr "使用 `do` 编写的 `IO` 操作一次执行一个语句。"

#: src/hello-world/summary.md:34
#, fuzzy
msgid ""
"Furthermore, `if` and `match` expressions that occur immediately under a "
"`do` are implicitly considered to have their own `do` in each branch. Inside"
" of a `do` expression, _nested actions_ are expressions with a left arrow "
"immediately under parentheses. The Lean compiler implicitly lifts them to "
"the nearest enclosing `do`, which may be implicitly part of a branch of a "
"`match` or `if` expression, and gives them a unique name. This unique name "
"then replaces the origin site of the nested action."
msgstr ""
"此外，直接出现在 `do` 下面的 `if` 和 `match` 表达式隐式地被认为在每个分支中都有自己的 `do`。在 `do` "
"表达式内部，_嵌套操作_ 是括号下紧跟左箭头的表达式。Lean 编译器会隐式地将它们提升到最近的封闭 `do`，该 `do` 可能隐式地是 "
"`match` 或 `if` 表达式分支的一部分，并为它们提供一个唯一名称。然后，此唯一名称将替换嵌套操作的原始位置。"

#: src/hello-world/summary.md:40
#, fuzzy
msgid "Compiling and Running Programs"
msgstr "编译和运行程序"

#: src/hello-world/summary.md:42
#, fuzzy
msgid ""
"A Lean program that consists of a single file with a `main` definition can "
"be run using `lean --run FILE`. While this can be a nice way to get started "
"with a simple program, most programs will eventually graduate to a multiple-"
"file project that should be compiled before running."
msgstr ""
"一个由带 `main` 定义的单个文件组成的 Lean 程序可以使用 `lean --run FILE` "
"运行。虽然这可能是开始使用简单程序的好方法，但大多数程序最终都会升级为多文件项目，在运行之前应该对其进行编译。"

#: src/hello-world/summary.md:45
#, fuzzy
msgid ""
"Lean projects are organized into _packages_, which are collections of "
"libraries and executables together with information about dependencies and a"
" build configuration. Packages are described using Lake, a Lean build tool. "
"Use `lake new` to create a Lake package in a new directory, or `lake init` "
"to create one in the current directory. Lake package configuration is "
"another domain-specific language. Use `lake build` to build a project."
msgstr ""
"Lean 项目被组织成 _包_，它们是库和可执行文件的集合，以及有关依赖项和构建配置的信息。包使用 Lean 构建工具 Lake 来描述。使用 "
"`lake new` 在新目录中创建一个 Lake 包，或使用 `lake init` 在当前目录中创建一个。Lake "
"包配置是另一种特定于领域的语言。使用 `lake build` 构建项目。"

#: src/hello-world/summary.md:51
#, fuzzy
msgid "Partiality"
msgstr "部分性"

#: src/hello-world/summary.md:53
#, fuzzy
msgid ""
"One consequence of following the mathematical model of expression evaluation"
" is that every expression must have a value. This rules out both incomplete "
"pattern matches that fail to cover all constructors of a datatype and "
"programs that can fall into an infinite loop. Lean ensures that all `match` "
"expressions cover all cases, and that all recursive functions are either "
"structurally recursive or have an explicit proof of termination."
msgstr ""
"遵循表达式求值数学模型的一个后果是每个表达式都必须有一个值。这排除了不完全模式匹配（无法覆盖数据类型的全部构造子）和可能陷入无限循环的程序。Lean "
"确保所有 `match` 表达式涵盖所有情况，并且所有递归函数要么是结构体递归，要么具有明确的终止证明。"

#: src/hello-world/summary.md:57
#, fuzzy
msgid ""
"However, some real programs require the possibility of looping infinitely, "
"because they handle potentially-infinite data, such as POSIX streams. Lean "
"provides an escape hatch: functions whose definition is marked `partial` are"
" not required to terminate. This comes at a cost. Because types are a first-"
"class part of the Lean language, functions can return types. Partial "
"functions, however, are not evaluated during type checking, because an "
"infinite loop in a function could cause the type checker to enter an "
"infinite loop. Furthermore, mathematical proofs are unable to inspect the "
"definitions of partial functions, which means that programs that use them "
"are much less amenable to formal proof."
msgstr ""
"然而，一些实际程序需要无限循环的可能性，因为它们处理潜在的无限数据，例如 POSIX 流。Lean 提供了一个逃生舱口：标记为 `partial` "
"的函数定义不需要终止。这是有代价的。因为类型是 Lean "
"语言的一等部分，所以函数可以返回类型。然而，部分函数在类型检查期间不会被求值，因为函数中的无限循环可能导致类型检查器进入无限循环。此外，数学证明无法检查部分函数的定义，这意味着使用它们的程序更难进行形式化证明。"
# TODO(OlingCat)

#: src/props-proofs-indexing.md:3
#, fuzzy
msgid ""
"Like many languages, Lean uses square brackets for indexing into arrays and "
"lists. For instance, if `woodlandCritters` is defined as follows:"
msgstr "与许多语言一样，Lean 使用方括号对数组和列表进行索引。例如，如果 `woodlandCritters` 定义如下："

#: src/props-proofs-indexing.md:5
#, fuzzy
msgid ""
"```lean\n"
"def woodlandCritters : List String :=\n"
"  [\"hedgehog\", \"deer\", \"snail\"]\n"
"```"
msgstr ""
"```lean\n"
"def woodlandCritters : List String :=\n"
"  [\"hedgehog\", \"deer\", \"snail\"]\n"
"```"

#: src/props-proofs-indexing.md:9
#, fuzzy
msgid "then the individual components can be extracted:"
msgstr "那么可以提取各个组件："

#: src/props-proofs-indexing.md:15
#, fuzzy
msgid ""
"However, attempting to extract the fourth element results in a compile-time "
"error, rather than a run-time error:"
msgstr "但是，尝试提取第四个元素会导致编译时错误，而不是运行时错误："

#: src/props-proofs-indexing.md:27
#, fuzzy
msgid ""
"This error message is saying Lean tried to automatically mathematically "
"prove that `3 < List.length woodlandCritters`, which would mean that the "
"lookup was safe, but that it could not do so. Out-of-bounds errors are a "
"common class of bugs, and Lean uses its dual nature as a programming "
"language and a theorem prover to rule out as many as possible."
msgstr ""
"此错误消息表明 Lean 尝试自动数学证明 `3 < List.length "
"woodlandCritters`，这意味着查找是安全的，但它无法做到。越界错误是一类常见的错误，而 Lean "
"使用其作为编程语言和定理证明器的双重特性来排除尽可能多的错误。"

#: src/props-proofs-indexing.md:30
#, fuzzy
msgid ""
"Understanding how this works requires an understanding of three key ideas: "
"propositions, proofs, and tactics."
msgstr "要理解这是如何工作的，需要理解三个关键概念：命题、证明和策略。"

#: src/props-proofs-indexing.md:32
#, fuzzy
msgid "Propositions and Proofs"
msgstr "命题和证明"

#: src/props-proofs-indexing.md:34
#, fuzzy
msgid ""
"A _proposition_ is a statement that can be true or false. All of the "
"following are propositions:"
msgstr "_命题_ 是可以为真或为假的说法。以下所有都是命题："

#: src/props-proofs-indexing.md:37
#, fuzzy
msgid "1 + 1 = 2"
msgstr "1 + 1 = 2"

#: src/props-proofs-indexing.md:38
#, fuzzy
msgid "Addition is commutative"
msgstr "加法是可交换的"

#: src/props-proofs-indexing.md:39
#, fuzzy
msgid "There are infinitely many prime numbers"
msgstr "质数有无穷多个"

#: src/props-proofs-indexing.md:40
#, fuzzy
msgid "1 + 1 = 15"
msgstr "1 + 1 = 15"

#: src/props-proofs-indexing.md:41
#, fuzzy
msgid "Paris is the capital of France"
msgstr "巴黎是法国的首都"

#: src/props-proofs-indexing.md:42
#, fuzzy
msgid "Buenos Aires is the capital of South Korea"
msgstr "布宜诺斯艾利斯是韩国的首都"

#: src/props-proofs-indexing.md:43
#, fuzzy
msgid "All birds can fly"
msgstr "所有鸟都会飞"

#: src/props-proofs-indexing.md:45
#, fuzzy
msgid ""
"On the other hand, nonsense statements are not propositions. None of the "
"following are propositions:"
msgstr "另一方面，无意义的陈述不是命题。以下都不是命题："

#: src/props-proofs-indexing.md:48
#, fuzzy
msgid "1 + green = ice cream"
msgstr "1 + 绿色 = 冰淇淋"

#: src/props-proofs-indexing.md:49
#, fuzzy
msgid "All capital cities are prime numbers"
msgstr "所有首都都是质数"

#: src/props-proofs-indexing.md:50
#, fuzzy
msgid "At least one gorg is a fleep"
msgstr "至少有一个 gorg 是一个 fleep"

#: src/props-proofs-indexing.md:52
#, fuzzy
msgid ""
"Propositions come in two varieties: those that are purely mathematical, "
"relying only on our definitions of concepts, and those that are facts about "
"the world. Theorem provers like Lean are concerned with the former category,"
" and have nothing to say about the flight capabilities of penguins or the "
"legal status of cities."
msgstr ""
"命题有两种类型：纯粹的数学命题，仅依赖于我们对概念的定义；以及关于世界的事实。像 Lean "
"这样的定理证明器关注的是前一类，而对企鹅的飞行能力或城市的法律地位没有任何说法。"

#: src/props-proofs-indexing.md:55
#, fuzzy
msgid ""
"A _proof_ is a convincing argument that a proposition is true. For "
"mathematical propositions, these arguments make use of the definitions of "
"the concepts that are involved as well as the rules of logical "
"argumentation. Most proofs are written for people to understand, and leave "
"out many tedious details. Computer-aided theorem provers like Lean are "
"designed to allow mathematicians to write proofs while omitting many "
"details, and it is the software's responsibility to fill in the missing "
"explicit steps. This decreases the likelihood of oversights or mistakes."
msgstr ""
"证明是令人信服的论证，证明命题为真。对于数学命题，这些论证利用了所涉及概念的定义以及逻辑论证规则。大多数证明都是为人们理解而写的，并省略了许多繁琐的细节。像"
" Lean 这样的计算机辅助定理证明器旨在允许数学家在省略许多细节的情况下编写证明，而软件负责填写缺失的显式步骤。这降低了疏忽或错误的可能性。"

#: src/props-proofs-indexing.md:61
#, fuzzy
msgid ""
"In Lean, a program's type describes the ways it can be interacted with. For "
"instance, a program of type `Nat → List String` is a function that takes a "
"`Nat` argument and produces a list of strings. In other words, each type "
"specifies what counts as a program with that type."
msgstr ""
"在 Lean 中，程序的类型描述了与它交互的方式。例如，类型为 `Nat → List String` 的程序是一个函数，它接受一个 `Nat` "
"参数并生成一个字符串列表。换句话说，每个类型指定了具有该类型的程序的内容。"

#: src/props-proofs-indexing.md:65
#, fuzzy
msgid ""
"In Lean, propositions are in fact types. They specify what counts as "
"evidence that the statement is true. The proposition is proved by providing "
"this evidence. On the other hand, if the proposition is false, then it will "
"be impossible to construct this evidence."
msgstr ""
"在 Lean 中，命题实际上是类型。它们指定了作为该语句为真的证据的内容。通过提供此证据来证明命题。另一方面，如果命题为假，则不可能构造此证据。"

#: src/props-proofs-indexing.md:70
#, fuzzy
msgid ""
"For example, the proposition \"1 + 1 = 2\" can be written directly in Lean. "
"The evidence for this proposition is the constructor `rfl`, which is short "
"for _reflexivity_:"
msgstr "例如，命题「1 + 1 = 2」可以直接写在 Lean 中。此命题的证据是构造子 `rfl`，它是 _自反性_的缩写："

#: src/props-proofs-indexing.md:75
#, fuzzy
msgid ""
"On the other hand, `rfl` does not prove the false proposition \"1 + 1 = "
"15\":"
msgstr "另一方面，`rfl` 不能证明错误命题「1 + 1 = 15」："

#: src/props-proofs-indexing.md:87
#, fuzzy
msgid ""
"This error message indicates that `rfl` can prove that two expressions are "
"equal when both sides of the equality statement are already the same number."
" Because `1 + 1` evaluates directly to `2`, they are considered to be the "
"same, which allows `onePlusOneIsTwo` to be accepted. Just as `Type` "
"describes types such as `Nat`, `String`, and `List (Nat × String × (Int → "
"Float))` that represent data structures and functions, `Prop` describes "
"propositions."
msgstr ""
"此错误消息表明，当等式语句的两边已经是相同的数字时，`rfl` 可以证明两个表达式相等。因为 `1 + 1` 直接计算为 "
"`2`，所以它们被认为是相同的，这允许接受 `onePlusOneIsTwo`。就像 `Type` 描述表示数据结构体和函数的类型（例如 "
"`Nat`、`String` 和 `List (Nat × String × (Int → Float))`）一样，`Prop` 描述命题。"

#: src/props-proofs-indexing.md:91
#, fuzzy
msgid ""
"When a proposition has been proven, it is called a _theorem_. In Lean, it is"
" conventional to declare theorems with the `theorem` keyword instead of "
"`def`. This helps readers see which declarations are intended to be read as "
"mathematical proofs, and which are definitions. Generally speaking, with a "
"proof, what matters is that there is evidence that a proposition is true, "
"but it's not particularly important _which_ evidence was provided. With "
"definitions, on the other hand, it matters very much which particular value "
"is selected—after all, a definition of addition that always returns `0` is "
"clearly wrong."
msgstr ""
"当一个命题被证明后，它被称为一个 _定理_。在 Lean 中，惯例是用 `theorem` 关键字而不是 `def` "
"来声明定理。这有助于读者看出哪些声明旨在被解读为数学证明，哪些是定义。一般来说，对于一个证明，重要的是有证据表明一个命题是正确的，但提供 _哪_ "
"个证据并不特别重要。另一方面，对于定义，选择哪个特定值非常重要——毕竟，一个总是返回 `0` 的加法定义显然是错误的。"

#: src/props-proofs-indexing.md:97
#, fuzzy
msgid "The prior example could be rewritten as follows:"
msgstr "前面的例子可以改写如下："

#: src/props-proofs-indexing.md:104
#, fuzzy
msgid "Tactics"
msgstr "策略"

#: src/props-proofs-indexing.md:106
#, fuzzy
msgid ""
"Proofs are normally written using _tactics_, rather than by providing "
"evidence directly. Tactics are small programs that construct evidence for a "
"proposition. These programs run in a _proof state_ that tracks the statement"
" that is to be proved (called the _goal_) along with the assumptions that "
"are available to prove it. Running a tactic on a goal results in a new proof"
" state that contains new goals. The proof is complete when all goals have "
"been proven."
msgstr ""
"证明通常使用 _策略_ 来编写，而不是直接提供证据。策略是为命题构建证据的小程序。这些程序在一个 _证明状态_ 中运行，该状态跟踪要证明的陈述（称为 "
"_目标_）以及可用于证明它的假设。在目标上运行策略会产生一个包含新目标的新证明状态。当所有目标都被证明后，证明就完成了。"

#: src/props-proofs-indexing.md:112
#, fuzzy
msgid ""
"To write a proof with tactics, begin the definition with `by`. Writing `by` "
"puts Lean into tactic mode until the end of the next indented block. While "
"in tactic mode, Lean provides ongoing feedback about the current proof "
"state. Written with tactics, `onePlusOneIsTwo` is still quite short:"
msgstr ""
"要使用策略编写证明，请以 `by` 开始定义。编写 `by` 会将 Lean 置于策略模式，直到下一个缩进块的末尾。在策略模式下，Lean "
"会持续提供有关当前证明状态的反馈。使用策略编写的 `onePlusOneIsTwo` 仍然很短："

#: src/props-proofs-indexing.md:120
#, fuzzy
msgid ""
"The `simp` tactic, short for \"simplify\", is the workhorse of Lean proofs. "
"It rewrites the goal to as simple a form as possible, taking care of parts "
"of the proof that are small enough. In particular, it proves simple equality"
" statements. Behind the scenes, a detailed formal proof is constructed, but "
"using `simp` hides this complexity."
msgstr ""
"`simp` 策略，即「简化」的缩写，是 Lean "
"证明的主力。它将目标重写为尽可能简单的形式，处理足够小的证明部分。特别是，它证明了简单的等式陈述。在幕后，构建了一个详细的形式化证明，但使用 "
"`simp` 隐藏了这种复杂性。"

#: src/props-proofs-indexing.md:125
#, fuzzy
msgid "Tactics are useful for a number of reasons:"
msgstr "战术在许多方面很有用："

#: src/props-proofs-indexing.md:126
#, fuzzy
msgid ""
"Many proofs are complicated and tedious when written out down to the "
"smallest detail, and tactics can automate these uninteresting parts."
msgstr "许多证明在写到最小的细节时都很复杂且乏味，而战术可以自动完成这些无趣的部分。"

#: src/props-proofs-indexing.md:127
#, fuzzy
msgid ""
"Proofs written with tactics are easier to maintain over time, because "
"flexible automation can paper over small changes to definitions."
msgstr "使用战术编写的证明更容易维护，因为灵活的自动化可以弥补定义的细微更改。"

#: src/props-proofs-indexing.md:128
#, fuzzy
msgid ""
"Because a single tactic can prove many different theorems, Lean can use "
"tactics behind the scenes to free users from writing proofs by hand. For "
"instance, an array lookup requires a proof that the index is in bounds, and "
"a tactic can typically construct that proof without the user needing to "
"worry about it."
msgstr ""
"因为一个战术可以证明许多不同的定理，Lean "
"可以使用幕后的战术来解放用户亲手写证明。例如，数组查找需要证明索引在范围内，而战术通常可以在用户无需担心它的情况下构造该证明。"

#: src/props-proofs-indexing.md:130
#, fuzzy
msgid ""
"Behind the scenes, indexing notation uses a tactic to prove that the user's "
"lookup operation is safe. This tactic is `simp`, configured to take certain "
"arithmetic identities into account."
msgstr "在幕后，索引符号使用战术来证明用户的查找操作是安全的。这个战术是 `simp`，配置为考虑某些算术恒等式。"

#: src/props-proofs-indexing.md:134
#, fuzzy
msgid "Connectives"
msgstr "连接词"

#: src/props-proofs-indexing.md:136
#, fuzzy
msgid ""
"The basic building blocks of logic, such as \"and\", \"or\", \"true\", "
"\"false\", and \"not\", are called _logical connectives_. Each connective "
"defines what counts as evidence of its truth. For example, to prove a "
"statement \"_A_ and _B_\", one must prove both _A_ and _B_. This means that "
"evidence for \"_A_ and _B_\" is a pair that contains both evidence for _A_ "
"and evidence for _B_. Similarly, evidence for \"_A_ or _B_\" consists of "
"either evidence for _A_ or evidence for _B_."
msgstr ""
"逻辑的基本构建块，例如「与」、「或」、「真」、「假」和「非」，称为 _逻辑连接词_。每个连接词定义了什么算作其真值的证据。例如，要证明一个陈述“_A_ "
"与 _B_”，必须证明 _A_ 和 _B_。这意味着「_A_ 与 _B_」的证据是一对，其中包含 _A_ 的证据和 _B_ 的证据。类似地，“_A_ 或"
" _B_”的证据由 _A_ 的证据或 _B_ 的证据组成。"

#: src/props-proofs-indexing.md:142
#, fuzzy
msgid ""
"In particular, most of these connectives are defined like datatypes, and "
"they have constructors. If `A` and `B` are propositions, then \"`A` and "
"`B`\" (written `A ∧ B`) is a proposition. Evidence for `A ∧ B` consists of "
"the constructor `And.intro`, which has the type `A → B → A ∧ B`. Replacing "
"`A` and `B` with concrete propositions, it is possible to prove `1 + 1 = 2 ∧"
" \"Str\".append \"ing\" = \"String\"` with `And.intro rfl rfl`. Of course, "
"`simp` is also powerful enough to find this proof:"
msgstr ""
"特别是，大多数这些连接词都像数据类型一样定义，并且它们有构造子。如果 `A` 和 `B` 是命题，那么「`A` 与 `B`」（写为 `A ∧ "
"B`）是一个命题。`A ∧ B` 的证据由构造子 `And.intro` 组成，其类型为 `A → B → A ∧ B`。用具体命题替换 `A` 和 "
"`B`，可以用 `And.intro rfl rfl` 证明 `1 + 1 = 2 ∧ \"Str\".append \"ing\" = "
"\"String\"`。当然，`simp` 也足够强大，可以找到这个证明："

#: src/props-proofs-indexing.md:147
msgid ""
"```leantac\n"
"theorem addAndAppend : 1 + 1 = 2 ∧ \"Str\".append \"ing\" = \"String\" := by simp\n"
"```"
msgstr ""
"定理 addAndAppend : 1 + 1 = 2 ∧ \"Str\".append \"ing\" = \"String\" := by simp\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"：\n"
"\n"
"连接词 | Lean 语法 | 证据\n"
"---|---|---\n"
"真 | `True` | `True.intro : True`\n"
"假 | `False` | 无证据\n"
"_A_ 和 _B_ | `A ∧ B` | `And.intro : A → B → A ∧ B`\n"
"_A_ 或 _B_ | `A ∨ B` | `Or.inl : A → A ∨ B` 或 `Or.inr : B → A ∨ B`\n"
"_A_ 蕴涵 _B_ | `A → B` | 将 _A_ 的证据转换为 _B_ 的证据的函数\n"
"非 _A_ | `¬A` | 将 _A_ 的证据转换为 `False` 的证据的函数\n"
"\n"
"`simp` 战术可以证明使用这些连接词的定理。例如：\n"
"\n"
"证据作为参数\n"
"\n"
"虽然 `simp` 在证明涉及特定数字的相等性和不等性的命题方面做得很好，但它在证明涉及变量的陈述方面并不是很好。例如，`simp` 可以证明 `4 < 15`，但它不能轻易地说明因为 `x < 4`，所以 `x < 15` 也是真的。因为索引表示在幕后使用 `simp` 来证明数组访问是安全的，所以它可能需要一些人工干预。"

#: src/props-proofs-indexing.md:151
msgid ""
"Similarly, \"`A` or `B`\" (written `A ∨ B`) has two constructors, because a "
"proof of \"`A` or `B`\" requires only that one of the two underlying "
"propositions be true. There are two constructors: `Or.inl`, with type `A → A"
" ∨ B`, and `Or.inr`, with type `B → A ∨ B`."
msgstr ""
"类似地，「`A` 或 `B`」（写为 `A ∨ B`）有两个构造子，因为“`A` 或 "
"`B`”的证明仅要求两个底层命题中的一个为真。有两个构造子：`Or.inl`，类型为 `A → A ∨ B`，和 `Or.inr`，类型为 `B → A"
" ∨ B`。"

#: src/props-proofs-indexing.md:154
msgid ""
"Implication (if _A_ then _B_) is represented using functions. In particular,"
" a function that transforms evidence for _A_ into evidence for _B_ is itself"
" evidence that _A_ implies _B_. This is different from the usual description"
" of implication, in which `A → B` is shorthand for `¬A ∨ B`, but the two "
"formulations are equivalent."
msgstr ""
"蕴涵（如果 _A_ 则 _B_）使用函数表示。特别是，将 _A_ 的证据转换为 _B_ 的证据的函数本身就是 _A_ 蕴涵 _B_ "
"的证据。这与蕴涵的通常描述不同，其中 `A → B` 是 `¬A ∨ B` 的简写，但这两个公式是等价的。"

#: src/props-proofs-indexing.md:158
msgid ""
"Because evidence for an \"and\" is a constructor, it can be used with "
"pattern matching. For instance, a proof that _A_ and _B_ implies _A_ or _B_ "
"is a function that pulls the evidence of _A_ (or of _B_) out of the evidence"
" for _A_ and _B_, and then uses this evidence to produce evidence of _A_ or "
"_B_:"
msgstr ""
"因为「与」的证据是一个构造子，所以它可以与模式匹配一起使用。例如，证明 _A_ 和 _B_ 蕴涵 _A_ 或 _B_ 的证明是一个函数，它从 _A_ 和"
" _B_ 的证据中提取 _A_（或 _B_）的证据，然后使用此证据来生成 _A_ 或 _B_ 的证据："

#: src/props-proofs-indexing.md:168
#, fuzzy
msgid "Connective"
msgstr "连接词"

#: src/props-proofs-indexing.md:168
#, fuzzy
msgid "Lean Syntax"
msgstr "Lean 语法"

#: src/props-proofs-indexing.md:168
#, fuzzy
msgid "Evidence"
msgstr "证据"

#: src/props-proofs-indexing.md:170
#, fuzzy
msgid "True"
msgstr "真"

#: src/props-proofs-indexing.md:170
#, fuzzy
msgid "`True`"
msgstr "`True`"

#: src/props-proofs-indexing.md:170
#, fuzzy
msgid "`True.intro : True`"
msgstr "`True.intro : True`"

#: src/props-proofs-indexing.md:171
#, fuzzy
msgid "False"
msgstr "假"

#: src/props-proofs-indexing.md:171
#, fuzzy
msgid "`False`"
msgstr "`False`"

#: src/props-proofs-indexing.md:171
#, fuzzy
msgid "No evidence"
msgstr "无证据"

#: src/props-proofs-indexing.md:172
#, fuzzy
msgid "_A_ and _B_"
msgstr "_A_ 与 _B_"

#: src/props-proofs-indexing.md:172
#, fuzzy
msgid "`A ∧ B`"
msgstr "`A ∧ B`"

#: src/props-proofs-indexing.md:172
#, fuzzy
msgid "`And.intro : A → B → A ∧ B`"
msgstr "`And.intro : A → B → A ∧ B`"

#: src/props-proofs-indexing.md:173
#, fuzzy
msgid "_A_ or _B_"
msgstr "_A_ 或 _B_"

#: src/props-proofs-indexing.md:173
#, fuzzy
msgid "`A ∨ B`"
msgstr "`A ∨ B`"

#: src/props-proofs-indexing.md:173
#, fuzzy
msgid "Either `Or.inl : A → A ∨ B` or `Or.inr : B → A ∨ B`"
msgstr "`Or.inl : A → A ∨ B` 或 `Or.inr : B → A ∨ B`"

#: src/props-proofs-indexing.md:174
#, fuzzy
msgid "_A_ implies _B_"
msgstr "_A_ 蕴含 _B_"

#: src/props-proofs-indexing.md:174
#, fuzzy
msgid "`A → B`"
msgstr "`A → B`"

#: src/props-proofs-indexing.md:174
#, fuzzy
msgid "A function that transforms evidence of _A_ into evidence of _B_"
msgstr "将 _A_ 的证据转换为 _B_ 证据的函数"

#: src/props-proofs-indexing.md:175
#, fuzzy
msgid "not _A_"
msgstr "非 _A_"

#: src/props-proofs-indexing.md:175
#, fuzzy
msgid "`¬A`"
msgstr "`¬A`"

#: src/props-proofs-indexing.md:175
#, fuzzy
msgid ""
"A function that would transform evidence of _A_ into evidence of `False`"
msgstr "将 _A_ 的证据转换为 `False` 证据的函数"

#: src/props-proofs-indexing.md:177
#, fuzzy
msgid ""
"The `simp` tactic can prove theorems that use these connectives. For "
"example:"
msgstr "`simp` 战术可以证明使用这些连接词的定理。例如："

#: src/props-proofs-indexing.md:187
#, fuzzy
msgid "Evidence as Arguments"
msgstr "证据作为参数"

#: src/props-proofs-indexing.md:189
#, fuzzy
msgid ""
"While `simp` does a great job proving propositions that involve equalities "
"and inequalities of specific numbers, it is not very good at proving "
"statements that involve variables. For instance, `simp` can prove that `4 < "
"15`, but it can't easily tell that because `x < 4`, it's also true that `x <"
" 15`. Because index notation uses `simp` behind the scenes to prove that "
"array access is safe, it can require a bit of hand-holding."
msgstr ""
"虽然 `simp` 在证明涉及特定数字的等式和不等式的命题时表现出色，但它在证明涉及变量的语句时效果不佳。例如，`simp` 可以证明 `4 < "
"15`，但它不能轻易地判断出因为 `x < 4`，所以 `x < 15` 也成立。由于索引表示法在幕后使用 `simp` "
"来证明数组访问是安全的，因此它可能需要一些人工干预。"

#: src/props-proofs-indexing.md:193
#, fuzzy
msgid ""
"One of the easiest ways to make indexing notation work well is to have the "
"function that performs a lookup into a data structure take the required "
"evidence of safety as an argument. For instance, a function that returns the"
" third entry in a list is not generally safe because lists might contain "
"zero, one, or two entries:"
msgstr ""
"索引符号要正常工作最简单的方法之一是让执行数据结构体查找的函数将所需的安全性证据作为参数。例如，返回列表中第三个条目的函数通常不安全，因为列表可能包含零、一或两个条目："

#: src/props-proofs-indexing.md:208
#, fuzzy
msgid ""
"However, the obligation to show that the list has at least three entries can"
" be imposed on the caller by adding an argument that consists of evidence "
"that the indexing operation is safe:"
msgstr "然而，可以通过添加一个参数来强制调用者证明列表至少有三个条目，该参数包含索引操作安全的证据："

#: src/props-proofs-indexing.md:212
#, fuzzy
msgid ""
"In this example, `xs.length > 2` is not a program that checks _whether_ `xs`"
" has more than 2 entries. It is a proposition that could be true or false, "
"and the argument `ok` must be evidence that it is true."
msgstr ""
"在这个例子中，`xs.length > 2` 不是一个检查 `xs` 是否有 2 个以上条目的程序。它是一个可能是真或假的命题，参数 `ok` "
"必须是它为真的证据。"

#: src/props-proofs-indexing.md:215
#, fuzzy
msgid ""
"When the function is called on a concrete list, its length is known. In "
"these cases, `by simp` can construct the evidence automatically:"
msgstr "当函数被调用到一个具体列表上时，它的长度是已知的。在这些情况下，`by simp` 可以自动构造证据："

#: src/props-proofs-indexing.md:220
#, fuzzy
msgid ""
"```output info\n"
"\"snail\"\n"
"```"
msgstr ""
"```output info\n"
"\"snail\"\n"
"```"

#: src/props-proofs-indexing.md:224
#, fuzzy
msgid "Indexing Without Evidence"
msgstr "无证据索引"

#: src/props-proofs-indexing.md:226
#, fuzzy
msgid ""
"In cases where it's not practical to prove that an indexing operation is in "
"bounds, there are other alternatives. Adding a question mark results in an "
"`Option`, where the result is `some` if the index is in bounds, and `none` "
"otherwise. For example:"
msgstr ""
"在无法证明索引操作在边界内的情况下，还有其他选择。添加一个问号会产生一个 `Option`，如果索引在边界内，结果为 `some`，否则为 "
"`none`。例如："

#: src/props-proofs-indexing.md:234
#, fuzzy
msgid ""
"```output info\n"
"some \"snail\"\n"
"```"
msgstr ""
"```output info\n"
"some \"snail\"\n"
"```"

#: src/props-proofs-indexing.md:237
#, fuzzy
msgid ""
"```lean\n"
"#eval thirdOption [\"only\", \"two\"]\n"
"```"
msgstr ""
"```lean\n"
"#eval thirdOption [\"only\", \"two\"]\n"
"```"

#: src/props-proofs-indexing.md:244
#, fuzzy
msgid ""
"There is also a version that crashes the program when the index is out of "
"bounds, rather than returning an `Option`:"
msgstr "还有一个版本，当索引超出边界时会使程序崩溃，而不是返回一个 `Option`："

#: src/props-proofs-indexing.md:248
#, fuzzy
msgid ""
"```output info\n"
"\"deer\"\n"
"```"
msgstr ""
"```output info\n"
"\"deer\"\n"
"```"

#: src/props-proofs-indexing.md:251
#, fuzzy
msgid ""
"Be careful! Because code that is run with `#eval` runs in the context of the"
" Lean compiler, selecting the wrong index can crash your IDE."
msgstr "小心！因为使用 `#eval` 运行的代码在 Lean 编译器的上下文中运行，选择错误的索引可能会使你的 IDE 崩溃。"

#: src/props-proofs-indexing.md:256
#, fuzzy
msgid ""
"In addition to the error that occurs when Lean is unable to find compile-"
"time evidence that an indexing operation is safe, polymorphic functions that"
" use unsafe indexing may produce the following message:"
msgstr "除了 Lean 无法找到编译时证据来证明索引操作是安全的时发生的错误之外，使用不安全索引的多态函数可能会产生以下消息："

#: src/props-proofs-indexing.md:264
#, fuzzy
msgid ""
"This is due to a technical restriction that is part of keeping Lean usable "
"as both a logic for proving theorems and a programming language. In "
"particular, only programs whose types contain at least one value are allowed"
" to crash. This is because a proposition in Lean is a kind of type that "
"classifies evidence of its truth. False propositions have no such evidence. "
"If a program with an empty type could crash, then that crashing program "
"could be used as a kind of fake evidence for a false proposition."
msgstr ""
"这是由于技术限制，该限制是将 Lean 同时用作证明定理的逻辑和编程语言的一部分。特别是，只有类型中至少包含一个值的程序才允许崩溃。这是因为 Lean "
"中的命题是一种对真值证据进行分类的类型。假命题没有这样的证据。如果具有空类型的程序可能崩溃，那么该崩溃程序可以用作对假命题的一种伪证据。"

#: src/props-proofs-indexing.md:270
#, fuzzy
msgid ""
"Internally, Lean contains a table of types that are known to have at least "
"one value. This error is saying that some arbitrary type `α` is not "
"necessarily in that table. The next chapter describes how to add to this "
"table, and how to successfully write functions like `unsafeThird`."
msgstr ""
"在内部，Lean 包含一个已知至少有一个值的类型的表。此错误表明某个任意类型 `α` 不一定在该表中。下一章描述如何向此表添加内容，以及如何成功编写诸如"
" `unsafeThird` 之类的函数。"

#: src/props-proofs-indexing.md:274
#, fuzzy
msgid ""
"Adding whitespace between a list and the brackets used for lookup can cause "
"another message:"
msgstr "在列表和用于查找的括号之间添加空格会导致另一条消息："

#: src/props-proofs-indexing.md:284
#, fuzzy
msgid ""
"Adding a space causes Lean to treat the expression as a function "
"application, and the index as a list that contains a single number. This "
"error message results from having Lean attempt to treat `woodlandCritters` "
"as a function."
msgstr ""
"添加空格会导致 Lean 将表达式视为函数应用，并将索引视为包含单个数字的列表。此错误消息是由 Lean 尝试将 `woodlandCritters` "
"视为函数而产生的。"

#: src/props-proofs-indexing.md:289
#, fuzzy
msgid ""
"Prove the following theorems using `rfl`: `2 + 3 = 5`, `15 - 8 = 7`, "
"`\"Hello, \".append \"world\" = \"Hello, world\"`. What happens if `rfl` is "
"used to prove `5 < 18`? Why?"
msgstr ""
"使用 `rfl` 证明以下定理：`2 + 3 = 5`、`15 - 8 = 7`、`\"Hello, \".append \"world\" = "
"\"Hello, world\"`。如果使用 `rfl` 证明 `5 < 18` 会发生什么？为什么？"

#: src/props-proofs-indexing.md:290
#, fuzzy
msgid ""
"Prove the following theorems using `by simp`: `2 + 3 = 5`, `15 - 8 = 7`, "
"`\"Hello, \".append \"world\" = \"Hello, world\"`, `5 < 18`."
msgstr ""
"使用 `by simp` 证明以下定理：`2 + 3 = 5`、`15 - 8 = 7`、`\"Hello, \".append \"world\" ="
" \"Hello, world\"`、`5 < 18`。"

#: src/props-proofs-indexing.md:291
#, fuzzy
msgid ""
"Write a function that looks up the fifth entry in a list. Pass the evidence "
"that this lookup is safe as an argument to the function."
msgstr "编写一个函数，用于查找列表中的第五个条目。将此查找安全的证据作为参数传递给函数。"

#: src/type-classes.md:3
#, fuzzy
msgid ""
"In many languages, the built-in datatypes get special treatment. For "
"example, in C and Java, `+` can be used to add `float`s and `int`s, but not "
"arbitrary-precision numbers from a third-party library. Similarly, numeric "
"literals can be used directly for the built-in types, but not for user-"
"defined number types. Other languages provide an _overloading_ mechanism for"
" operators, where the same operator can be given a meaning for a new type. "
"In these languages, such as C++ and C#, a wide variety of built-in operators"
" can be overloaded, and the compiler uses the type checker to select a "
"particular implementation."
msgstr ""
"在许多语言中，内置数据类型会得到特殊处理。例如，在 C 和 Java 中，`+` 可用于添加 `float` 和 "
"`int`，但不能用于第三方库中的任意精度数字。类似地，数字文字可以直接用于内置类型，但不能用于用户定义的数字类型。其他语言为运算符提供了一个 _重载_"
" 机制，其中同一个运算符可以赋予新类型一个含义。在这些语言中，例如 C++ 和 "
"C#，可以重载各种内置运算符，并且编译器使用类型检查器来选择一个特定的实现。"

#: src/type-classes.md:9
#, fuzzy
msgid ""
"In addition to numeric literals and operators, many languages allow "
"overloading of functions or methods. In C++, Java, C# and Kotlin, multiple "
"implementations of a method are allowed, with differing numbers and types of"
" arguments. The compiler uses the number of arguments and their types to "
"determine which overload was intended."
msgstr ""
"除了数字文字和运算符之外，许多语言还允许重载函数或方法。在 C++、Java、C# 和 Kotlin "
"中，允许一个方法有多个实现，并且参数的数量和类型不同。编译器使用参数的数量及其类型来确定预期的重载。"

#: src/type-classes.md:13
#, fuzzy
msgid ""
"Function and operator overloading has a key limitation: polymorphic "
"functions can't restrict their type arguments to types for which a given "
"overload exists. For example, an overloaded method might be defined for "
"strings, byte arrays, and file pointers, but there's no way to write a "
"second method that works for any of these. Instead, this second method must "
"itself be overloaded for each type that has an overload of the original "
"method, resulting in many boilerplate definitions instead of a single "
"polymorphic definition. Another consequence of this restriction is that some"
" operators (such as equality in Java) end up being defined for _every_ "
"combination of arguments, even when it is not necessarily sensible to do so."
" If programmers are not very careful, this can lead to programs that crash "
"at runtime or silently compute an incorrect result."
msgstr ""
"函数和运算符重载有一个关键限制：多态函数不能将其类型参数限制为存在给定重载的类型。例如，可以为字符串、字节数组和文件指针定义一个重载方法，但无法编写一个适用于其中任何一个的第二个方法。相反，这个第二个方法本身必须针对具有原始方法重载的每种类型进行重载，从而导致许多样板定义而不是一个多态定义。此限制的另一个后果是，一些运算符（例如"
" Java 中的相等性）最终被定义为参数的 _每个_ 组合，即使这样做不一定明智。如果程序员不够小心，这会导致在运行时崩溃或静默计算不正确结果的程序。"

#: src/type-classes.md:19
#, fuzzy
msgid ""
"Lean implements overloading using a mechanism called _type classes_, "
"pioneered in Haskell, that allows overloading of operators, functions, and "
"literals in a manner that works well with polymorphism. A type class "
"describes a collection of overloadable operations. To overload these "
"operations for a new type, an _instance_ is created that contains an "
"implementation of each operation for the new type. For example, a type class"
" named `Add` describes types that allow addition, and an instance of `Add` "
"for `Nat` provides an implementation of addition for `Nat`."
msgstr ""
"Lean 使用一种称为「类型类」的机制来实现重载，该机制最早由 Haskell "
"提出，它允许以与多态性相适应的方式重载运算符、函数和字面量。类型类描述了一组可重载的操作。要为新类型重载这些操作，需要创建一个「实例」，其中包含针对新类型实现的每项操作。例如，名为"
" `Add` 的类型类描述了允许加法的类型，而 `Nat` 的 `Add` 实例为 `Nat` 提供了加法的实现。"

#: src/type-classes.md:24
#, fuzzy
msgid ""
"The terms _class_ and _instance_ can be confusing for those who are used to "
"object-oriented languages, because they are not closely related to classes "
"and instances in object-oriented languages. However, they do share common "
"roots: in everyday language, the term \"class\" refers to a group that "
"shares some common attributes. While classes in object-oriented programming "
"certainly describe groups of objects with common attributes, the term "
"additionally refers to a specific mechanism in a programming language for "
"describing such a group. Type classes are also a means of describing types "
"that share common attributes (namely, implementations of certain "
"operations), but they don't really have anything else in common with classes"
" as found in object-oriented programming."
msgstr ""
"对于习惯了面向对象语言的人来说，「类」和「实例」这两个术语可能会令人困惑，因为它们与面向对象语言中的类和实例没有密切关系。然而，它们确实有共同的根源：在日常语言中，「类」一词指的是具有某些共同属性的群体。虽然面向对象编程中的类当然描述了具有共同属性的对象组，但该术语还指编程语言中描述此类组的特定机制。类型类也是描述具有共同属性（即某些操作的实现）的类型的工具，但它们实际上与面向对象编程中的类没有任何其他共同点。"

#: src/type-classes.md:29
#, fuzzy
msgid ""
"A Lean type class is much more analogous to a Java or C# _interface_. Both "
"type classes and interfaces describe a conceptually related set of "
"operations that are implemented for a type or collection of types. "
"Similarly, an instance of a type class is akin to the code in a Java or C# "
"class that is prescribed by the implemented interfaces, rather than an "
"instance of a Java or C# class. Unlike Java or C#'s interfaces, types can be"
" given instances for type classes that the author of the type does not have "
"access to. In this way, they are very similar to Rust traits."
msgstr ""
"Lean 类型类更类似于 Java 或 C# "
"「接口」。类型类和接口都描述了一组概念上相关的操作，这些操作针对类型或类型集合实现。类似地，类型类的实例类似于 Java 或 C# "
"类中由已实现的接口规定的代码，而不是 Java 或 C# 类的实例。与 Java 或 C# "
"的接口不同，可以为类型类提供作者无法访问的类型的实例。这样，它们与 Rust 特征非常相似。"

#: src/type-classes/pos.md:3
#, fuzzy
msgid ""
"In some applications, only positive numbers make sense. For example, "
"compilers and interpreters typically use one-indexed line and column numbers"
" for source positions, and a datatype that represents only non-empty lists "
"will never report a length of zero. Rather than relying on natural numbers, "
"and littering the code with assertions that the number is not zero, it can "
"be useful to design a datatype that represents only positive numbers."
msgstr ""
"在某些应用中，只有正数才有意义。例如，编译器和解释器通常使用从 1 "
"开始的行号和列号表示源代码位置，而表示非空列表的数据类型永远不会报告长度为零。与其依赖自然数并用断言来充斥代码以表明该数字不为零，不如设计一个仅表示正数的数据类型。"

#: src/type-classes/pos.md:7
#, fuzzy
msgid ""
"One way to represent positive numbers is very similar to `Nat`, except with "
"`one` as the base case instead of `zero`:"
msgstr "表示正数的一种方法与 `Nat` 非常相似，只是以 `one` 作为基本情况，而不是 `zero`："

#: src/type-classes/pos.md:13
#, fuzzy
msgid ""
"This datatype represents exactly the intended set of values, but it is not "
"very convenient to use. For example, numeric literals are rejected:"
msgstr "此数据类型准确表示预期值集，但使用起来不太方便。例如，数字字面量会被拒绝："

#: src/type-classes/pos.md:22
#, fuzzy
msgid "Instead, the constructors must be used directly:"
msgstr "相反，必须直接使用构造子："

#: src/type-classes/pos.md:28
#, fuzzy
msgid "Similarly, addition and multiplication are not easy to use:"
msgstr "同样，加法和乘法也不容易使用："

#: src/type-classes/pos.md:44
#, fuzzy
msgid ""
"Each of these error messages begins with `failed to synthesize instance`. "
"This indicates that the error is due to an overloaded operation that has not"
" been implemented, and it describes the type class that must be implemented."
msgstr "每个错误消息都以「未能合成实例」开头。这表明错误是由于未实现的重载操作引起的，并且描述了必须实现的类型类。"

#: src/type-classes/pos.md:47
#, fuzzy
msgid "Classes and Instances"
msgstr "类和实例"

#: src/type-classes/pos.md:49
#, fuzzy
msgid ""
"A type class consists of a name, some parameters, and a collection of "
"_methods_. The parameters describe the types for which overloadable "
"operations are being defined, and the methods are the names and type "
"signatures of the overloadable operations. Once again, there is a "
"terminology clash with object-oriented languages. In object-oriented "
"programming, a method is essentially a function that is connected to a "
"particular object in memory, with special access to the object's private "
"state. Objects are interacted with via their methods. In Lean, the term "
"\"method\" refers to an operation that has been declared to be overloadable,"
" with no special connection to objects or values or private fields."
msgstr ""
"类型类由名称、一些参数和一组_方法_组成。参数描述了为其定义可重载操作的类型，而方法是可重载操作的名称和类型签名。同样，这里与面向对象语言存在术语冲突。在面向对象编程中，方法本质上是一个连接到内存中特定对象的函数，可以特别访问对象的私有状态。通过方法与对象进行交互。在"
" Lean 中，「方法」一词是指已声明为可重载的操作，与对象、值或私有字段没有特殊连接。"

#: src/type-classes/pos.md:56
#, fuzzy
msgid ""
"One way to overload addition is to define a type class named `Plus`, with an"
" addition method named `plus`. Once an instance of `Plus` for `Nat` has been"
" defined, it becomes possible to add two `Nat`s using `Plus.plus`:"
msgstr ""
"一种重载加法的方法是定义一个名为 `Plus` 的类型类，其中包含一个名为 `plus` 的加法方法。一旦为 `Nat` 定义了 `Plus` "
"的实例，就可以使用 `Plus.plus` 来添加两个 `Nat`："

#: src/type-classes/pos.md:64
#, fuzzy
msgid ""
"Adding more instances allows `Plus.plus` to take more types of arguments."
msgstr "添加更多实例允许 `Plus.plus` 接受更多类型的参数。"

#: src/type-classes/pos.md:66
#, fuzzy
msgid ""
"In the following type class declaration, `Plus` is the name of the class, `α"
" : Type` is the only argument, and `plus : α → α → α` is the only method:"
msgstr "在以下类型类声明中，`Plus` 是类的名称，`α : Type` 是唯一参数，`plus : α → α → α` 是唯一方法："

#: src/type-classes/pos.md:71
#, fuzzy
msgid ""
"This declaration says that there is a type class `Plus` that overloads "
"operations with respect to a type `α`. In particular, there is one "
"overloaded operation called `plus` that takes two `α`s and returns an `α`."
msgstr ""
"此声明表示存在一个类型类 `Plus`，它针对类型 `α` 重载运算。特别是，有一个名为 `plus` 的重载运算，它接受两个 `α` 并返回一个 "
"`α`。"

#: src/type-classes/pos.md:74
#, fuzzy
msgid ""
"Type classes are first class, just as types are first class. In particular, "
"a type class is another kind of type. The type of `Plus` is `Type → Type`, "
"because it takes a type as an argument (`α`) and results in a new type that "
"describes the overloading of `Plus`'s operation for `α`."
msgstr ""
"类型类是一等公民，就像类型是一等公民一样。特别是，类型类是另一种类型的类型。`Plus` 的类型是 `Type → "
"Type`，因为它接受一个类型作为参数（`α`）并生成一个新类型，该类型描述 `Plus` 的运算针对 `α` 的重载。"

#: src/type-classes/pos.md:79
#, fuzzy
msgid "To overload `plus` for a particular type, write an instance:"
msgstr "要为特定类型重载 `plus`，请编写一个实例："

#: src/type-classes/pos.md:84
#, fuzzy
msgid ""
"The colon after `instance` indicates that `Plus Nat` is indeed a type. Each "
"method of class `Plus` should be assigned a value using `:=`. In this case, "
"there is only one method: `plus`."
msgstr ""
"`instance` 后面的冒号表示 `Plus Nat` 确实是一个类型。`Plus` 类的每个方法都应使用 `:=` "
"赋值。在这种情况下，只有一个方法：`plus`。"

#: src/type-classes/pos.md:88
#, fuzzy
msgid ""
"By default, type class methods are defined in a namespace with the same name"
" as the type class. It can be convenient to `open` the namespace so that "
"users don't need to type the name of the class first. Parentheses in an "
"`open` command indicate that only the indicated names from the namespace are"
" to be made accessible:"
msgstr ""
"默认情况下，类型类方法在与类型类同名的命名空间中定义。`open` 命名空间很方便，这样用户就不必先键入类的名称。`open` "
"命令中的括号表示仅使命名空间中指示的名称可访问："

#: src/type-classes/pos.md:100
#, fuzzy
msgid ""
"Defining an addition function for `Pos` and an instance of `Plus Pos` allows"
" `plus` to be used to add both `Pos` and `Nat` values:"
msgstr "为 `Pos` 定义一个加法函数和一个 `Plus Pos` 实例允许使用 `plus` 来添加 `Pos` 和 `Nat` 值："

#: src/type-classes/pos.md:112
#, fuzzy
msgid ""
"Because there is not yet an instance of `Plus Float`, attempting to add two "
"floating-point numbers with `plus` fails with a familiar message:"
msgstr "由于尚未定义 `Plus Float` 实例，尝试使用 `plus` 对两个浮点数进行加法运算时会失败，并出现一条熟悉的错误消息："

#: src/type-classes/pos.md:120
#, fuzzy
msgid ""
"These errors mean that Lean was unable to find an instance for a given type "
"class."
msgstr "这些错误意味着 Lean 无法找到给定类型类的实例。"

#: src/type-classes/pos.md:122
#, fuzzy
msgid "Overloaded Addition"
msgstr "重载加法"

#: src/type-classes/pos.md:124
#, fuzzy
msgid ""
"Lean's built-in addition operator is syntactic sugar for a type class called"
" `HAdd`, which flexibly allows the arguments to addition to have different "
"types. `HAdd` is short for _heterogeneous addition_. For example, an `HAdd` "
"instance can be written to allow a `Nat` to be added to a `Float`, resulting"
" in a new `Float`. When a programmer writes `x + y`, it is interpreted as "
"meaning `HAdd.hAdd x y`."
msgstr ""
"Lean 的内置加法运算符是类型类 `HAdd` 的语法糖，它灵活地允许加法运算符的参数具有不同的类型。`HAdd` 是 _异构加法_ "
"的缩写。例如，可以编写一个 `HAdd` 实例以允许将 `Nat` 添加到 `Float` 中，从而生成一个新的 `Float`。当程序员编写 `x +"
" y` 时，它被解释为 `HAdd.hAdd x y`。"

#: src/type-classes/pos.md:129
#, fuzzy
msgid ""
"While an understanding of the full generality of `HAdd` relies on features "
"that are discussed in [another section in this chapter](out-params.md), "
"there is a simpler type class called `Add` that does not allow the types of "
"the arguments to be mixed. The Lean libraries are set up so that an instance"
" of `Add` will be found when searching for an instance of `HAdd` in which "
"both arguments have the same type."
msgstr ""
"虽然对 `HAdd` 的全面理解依赖于 [本章另一部分](out-params.md) 中讨论的特性，但有一个更简单的类型类 "
"`Add`，它不允许混合参数的类型。Lean 库的设置方式是，在搜索两个参数具有相同类型的 `HAdd` 实例时，将找到 `Add` 的实例。"

#: src/type-classes/pos.md:132
#, fuzzy
msgid ""
"Defining an instance of `Add Pos` allows `Pos` values to use ordinary "
"addition syntax:"
msgstr "定义 `Add Pos` 的实例允许 `Pos` 值使用普通的加法语法："

#: src/type-classes/pos.md:140
#, fuzzy
msgid "Conversion to Strings"
msgstr "转换为字符串"

#: src/type-classes/pos.md:142
#, fuzzy
msgid ""
"Another useful built-in class is called `ToString`. Instances of `ToString` "
"provide a standard way of converting values from a given type into strings. "
"For example, a `ToString` instance is used when a value occurs in an "
"interpolated string, and it determines how the `IO.println` function used at"
" the [beginning of the description of `IO`](../hello-world/running-a-"
"program.html#running-a-program) will display a value."
msgstr ""
"另一个有用的内置类称为 `ToString`。`ToString` "
"的实例提供了一种将给定类型的值转换为字符串的标准方法。例如，当一个值出现在插值字符串中时，将使用 `ToString` 实例，并且它决定 [IO "
"描述开头](../hello-world/running-a-program.html#running-a-program) 中使用的 "
"`IO.println` 函数将如何显示一个值。"

#: src/type-classes/pos.md:146
#, fuzzy
msgid ""
"For example, one way to convert a `Pos` into a `String` is to reveal its "
"inner structure. The function `posToString` takes a `Bool` that determines "
"whether to parenthesize uses of `Pos.succ`, which should be `true` in the "
"initial call to the function and `false` in all recursive calls."
msgstr ""
"例如，将 `Pos` 转换为 `String` 的一种方法是揭示其内部结构体。函数 `posToString` 接受一个 `Bool`，该 `Bool` "
"确定是否对 `Pos.succ` 的使用进行括号化，在对该函数的初始调用中应为 `true`，在所有递归调用中应为 `false`。"

#: src/type-classes/pos.md:148
#, fuzzy
msgid ""
"```lean\n"
"def posToString (atTop : Bool) (p : Pos) : String :=\n"
"  let paren s := if atTop then s else \"(\" ++ s ++ \")\"\n"
"  match p with\n"
"  | Pos.one => \"Pos.one\"\n"
"  | Pos.succ n => paren s!\"Pos.succ {posToString false n}\"\n"
"```"
msgstr ""
"```lean\n"
"def posToString (atTop : Bool) (p : Pos) : String :=\n"
"  let paren s := if atTop then s else \"(\" ++ s ++ \")\"\n"
"  match p with\n"
"  | Pos.one => \"Pos.one\"\n"
"  | Pos.succ n => paren s!\"Pos.succ {posToString false n}\"\n"
"```"

#: src/type-classes/pos.md:155
#, fuzzy
msgid "Using this function for a `ToString` instance:"
msgstr "使用此函数作为 `ToString` 实例："

#: src/type-classes/pos.md:160
#, fuzzy
msgid "results in informative, yet overwhelming, output:"
msgstr "会产生内容丰富但令人不知所措的输出："

#: src/type-classes/pos.md:161
#, fuzzy
msgid ""
"```lean\n"
"#eval s!\"There are {seven}\"\n"
"```"
msgstr ""
"```lean\n"
"#eval s!\"There are {seven}\"\n"
"```"

#: src/type-classes/pos.md:164
#, fuzzy
msgid ""
"```output info\n"
"\"There are Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))\"\n"
"```"
msgstr ""
"```output info\n"
"\"There are Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))\"\n"
"```"

#: src/type-classes/pos.md:168
#, fuzzy
msgid ""
"On the other hand, every positive number has a corresponding `Nat`. "
"Converting it to a `Nat` and then using the `ToString Nat` instance (that "
"is, the overloading of `toString` for `Nat`) is a quick way to generate much"
" shorter output:"
msgstr ""
"另一方面，每个正数都有一个对应的 `Nat`。将其转换为 `Nat`，然后使用 `ToString Nat` 实例（即 `Nat` 的 "
"`toString` 重载）是生成更短输出的快速方法："

#: src/type-classes/pos.md:170
#, fuzzy
msgid ""
"```lean\n"
"def Pos.toNat : Pos → Nat\n"
"  | Pos.one => 1\n"
"  | Pos.succ n => n.toNat + 1\n"
"\n"
"instance : ToString Pos where\n"
"  toString x := toString (x.toNat)\n"
"\n"
"#eval s!\"There are {seven}\"\n"
"```"
msgstr ""
"```lean\n"
"def Pos.toNat : Pos → Nat\n"
"  | Pos.one => 1\n"
"  | Pos.succ n => n.toNat + 1\n"
"\n"
"instance : ToString Pos where\n"
"  toString x := toString (x.toNat)\n"
"\n"
"#eval s!\"There are {seven}\"\n"
"```"

#: src/type-classes/pos.md:180
#, fuzzy
msgid ""
"```output info\n"
"\"There are 7\"\n"
"```"
msgstr ""
"```output info\n"
"\"There are 7\"\n"
"```"

#: src/type-classes/pos.md:183
#, fuzzy
msgid ""
"When more than one instance is defined, the most recent takes precedence. "
"Additionally, if a type has a `ToString` instance, then it can be used to "
"display the result of `#eval` even if the type in question was not defined "
"with `deriving Repr`, so `#eval seven` outputs `7`."
msgstr ""
"当定义了多个实例时，最近的实例优先。此外，如果一个类型有一个 `ToString` 实例，那么它可以用来显示 `#eval` 的结果，即使该类型没有用 "
"`deriving Repr` 定义，所以 `#eval seven` 输出 `7`。"

#: src/type-classes/pos.md:186
#, fuzzy
msgid "Overloaded Multiplication"
msgstr "重载乘法"

#: src/type-classes/pos.md:188
#, fuzzy
msgid ""
"For multiplication, there is a type class called `HMul` that allows mixed "
"argument types, just like `HAdd`. Just as `x + y` is interpreted as "
"`HAdd.hAdd x y`, `x * y` is interpreted as `HMul.hMul x y`. For the common "
"case of multiplication of two arguments with the same type, a `Mul` instance"
" suffices."
msgstr ""
"对于乘法，有一个类型类称为 `HMul`，它允许混合参数类型，就像 `HAdd` 一样。正如 `x + y` 被解释为 `HAdd.hAdd x "
"y`，`x * y` 被解释为 `HMul.hMul x y`。对于两个具有相同类型的参数相乘的常见情况，`Mul` 实例就足够了。"

#: src/type-classes/pos.md:192
#, fuzzy
msgid ""
"An instance of `Mul` allows ordinary multiplication syntax to be used with "
"`Pos`:"
msgstr "`Mul` 实例允许使用普通乘法语法与 `Pos` 一起使用："

#: src/type-classes/pos.md:201
#, fuzzy
msgid "With this instance, multiplication works as expected:"
msgstr "有了这个实例，乘法按预期工作："

#: src/type-classes/pos.md:211
#, fuzzy
msgid "Literal Numbers"
msgstr "字面数字"

#: src/type-classes/pos.md:213
#, fuzzy
msgid ""
"It is quite inconvenient to write out a sequence of constructors for "
"positive numbers. One way to work around the problem would be to provide a "
"function to convert a `Nat` into a `Pos`. However, this approach has "
"downsides. First off, because `Pos` cannot represent `0`, the resulting "
"function would either convert a `Nat` to a bigger number, or it would return"
" `Option Pos`. Neither is particularly convenient for users. Secondly, the "
"need to call the function explicitly would make programs that use positive "
"numbers much less convenient to write than programs that use `Nat`. Having a"
" trade-off between precise types and convenient APIs means that the precise "
"types become less useful."
msgstr ""
"为正数写出一系列构造子非常不方便。解决这个问题的一种方法是提供一个将 `Nat` 转换为 `Pos` 的函数。然而，这种方法有缺点。首先，因为 "
"`Pos` 不能表示 `0`，所以结果函数要么将 `Nat` 转换为一个更大的数字，要么返回 `Option "
"Pos`。对于用户来说，这两种方式都不太方便。其次，需要显式调用函数会使使用正数的程序比使用 `Nat` 的程序更不方便编写。在精确类型和方便的 API"
" 之间进行权衡意味着精确类型变得不太有用。"

#: src/type-classes/pos.md:221
#, fuzzy
msgid ""
"In Lean, natural number literals are interpreted using a type class called "
"`OfNat`:"
msgstr "在 Lean 中，自然数文字使用名为 `OfNat` 的类型类进行解释："

#: src/type-classes/pos.md:226
#, fuzzy
msgid ""
"This type class takes two arguments: `α` is the type for which a natural "
"number is overloaded, and the unnamed `Nat` argument is the actual literal "
"number that was encountered in the program. The method `ofNat` is then used "
"as the value of the numeric literal. Because the class contains the `Nat` "
"argument, it becomes possible to define only instances for those values "
"where the number makes sense."
msgstr ""
"此类型类有两个参数：`α` 是自然数重载的类型，未命名的 `Nat` 参数是程序中遇到的实际文字数字。然后将 `ofNat` "
"方法用作数字文字的值。因为该类包含 `Nat` 参数，所以只为数字有意义的值定义实例成为可能。"

#: src/type-classes/pos.md:230
#, fuzzy
msgid ""
"`OfNat` demonstrates that the arguments to type classes do not need to be "
"types. Because types in Lean are first-class participants in the language "
"that can be passed as arguments to functions and given definitions with "
"`def` and `abbrev`, there is no barrier that prevents non-type arguments in "
"positions where a less-flexible language could not permit them. This "
"flexibility allows overloaded operations to be provided for particular "
"values as well as particular types."
msgstr ""
"`OfNat` 证明了类型类的参数不必是类型。因为 Lean 中的类型是语言中的一等参与者，可以作为参数传递给函数，并使用 `def` 和 "
"`abbrev` 给出定义，所以没有障碍可以阻止在不太灵活的语言不允许的位置使用非类型参数。这种灵活性允许为特定值和特定类型提供重载操作。"

#: src/type-classes/pos.md:234
#, fuzzy
msgid ""
"For example, a sum type that represents natural numbers less than four can "
"be defined as follows:"
msgstr "例如，一个表示小于 4 的自然数的和类型可以定义如下："

#: src/type-classes/pos.md:243
#, fuzzy
msgid ""
"While it would not make sense to allow _any_ literal number to be used for "
"this type, numbers less than four clearly make sense:"
msgstr "虽然允许 _任何_ 字面数字用于此类型毫无意义，但小于 4 的数字显然有意义："

#: src/type-classes/pos.md:257
#, fuzzy
msgid "With these instances, the following examples work:"
msgstr "有了这些实例，以下示例有效："

#: src/type-classes/pos.md:270
#, fuzzy
msgid "On the other hand, out-of-bounds literals are still not allowed:"
msgstr "另一方面，仍然不允许越界的字面量："

#: src/type-classes/pos.md:279
#, fuzzy
msgid ""
"For `Pos`, the `OfNat` instance should work for _any_ `Nat` other than "
"`Nat.zero`. Another way to phrase this is to say that for all natural "
"numbers `n`, the instance should work for `n + 1`. Just as names like `α` "
"automatically become implicit arguments to functions that Lean fills out on "
"its own, instances can take automatic implicit arguments. In this instance, "
"the argument `n` stands for any `Nat`, and the instance is defined for a "
"`Nat` that's one greater:"
msgstr ""
"对于 `Pos`，`OfNat` 实例应该适用于 _任何_ `Nat`，除了 `Nat.zero`。另一种说法是，对于所有自然数 "
"`n`，该实例应该适用于 `n + 1`。就像 `α` 等名称自动成为 Lean "
"自行填充的函数的隐式参数一样，实例可以采用自动隐式参数。在此实例中，参数 `n` 表示任何 `Nat`，并且该实例被定义为比用户编写的 `Nat` 大 "
"1："

#: src/type-classes/pos.md:291
#, fuzzy
msgid ""
"Because `n` stands for a `Nat` that's one less than what the user wrote, the"
" helper function `natPlusOne` returns a `Pos` that's one greater than its "
"argument. This makes it possible to use natural number literals for positive"
" numbers, but not for zero:"
msgstr ""
"因为 `n` 表示比用户编写的 `Nat` 小 1，所以辅助函数 `natPlusOne` 返回一个比其参数大 1 的 "
"`Pos`。这使得可以使用自然数字面量表示正数，但不能表示零："

#: src/type-classes/pos.md:305
#, fuzzy
msgid "Another Representation"
msgstr "另一种表示"

#: src/type-classes/pos.md:307
#, fuzzy
msgid ""
"An alternative way to represent a positive number is as the successor of "
"some `Nat`. Replace the definition of `Pos` with a structure whose "
"constructor is named `succ` that contains a `Nat`:"
msgstr ""
"表示正数的另一种方法是将其表示为某个 `Nat` 的后继。用一个构造子名为 `succ` 并包含一个 `Nat` 的结构体替换 `Pos` 的定义："

#: src/type-classes/pos.md:314
#, fuzzy
msgid ""
"Define instances of `Add`, `Mul`, `ToString`, and `OfNat` that allow this "
"version of `Pos` to be used conveniently."
msgstr "定义 `Add`、`Mul`、`ToString` 和 `OfNat` 的实例，以便方便地使用此版本的 `Pos`。"

#: src/type-classes/pos.md:316
#, fuzzy
msgid "Even Numbers"
msgstr "偶数"

#: src/type-classes/pos.md:318
#, fuzzy
msgid ""
"Define a datatype that represents only even numbers. Define instances of "
"`Add`, `Mul`, and `ToString` that allow it to be used conveniently. `OfNat` "
"requires a feature that is introduced in [the next "
"section](polymorphism.md)."
msgstr ""
"定义一个仅表示偶数的数据类型。定义 `Add`、`Mul` 和 `ToString` 的实例，以便方便地使用它。`OfNat` 需要 "
"[下一节](polymorphism.md) 中引入的一个特性。"

#: src/type-classes/pos.md:321
#, fuzzy
msgid "HTTP Requests"
msgstr "HTTP 请求"

#: src/type-classes/pos.md:323
#, fuzzy
msgid ""
"An HTTP request begins with an identification of a HTTP method, such as "
"`GET` or `POST`, along with a URI and an HTTP version. Define an inductive "
"type that represents an interesting subset of the HTTP methods, and a "
"structure that represents HTTP responses. Responses should have a `ToString`"
" instance that makes it possible to debug them. Use a type class to "
"associate different `IO` actions with each HTTP method, and write a test "
"harness as an `IO` action that calls each method and prints the result."
msgstr ""
"HTTP 请求以 HTTP 方法的标识符开头，例如 `GET` 或 `POST`，以及一个 URI 和一个 HTTP 版本。定义一个归纳类型来表示 "
"HTTP 方法的一个有趣子集，以及一个表示 HTTP 响应的结构体。响应应该有一个 `ToString` 实例，以便调试它们。使用类型类将不同的 `IO`"
" 操作与每个 HTTP 方法关联起来，并编写一个测试框架作为 `IO` 操作，调用每个方法并打印结果。"

#: src/type-classes/polymorphism.md:3
#, fuzzy
msgid ""
"It can be useful to write functions that work for _any_ overloading of a "
"given function. For instance, `IO.println` works for any type that has an "
"instance of `ToString`. This is indicated using square brackets around the "
"required instance: the type of `IO.println` is `{α : Type} → [ToString α] → "
"α → IO Unit`. This type says that `IO.println` accepts an argument of type "
"`α`, which Lean should determine automatically, and that there must be a "
"`ToString` instance available for `α`. It returns an `IO` action."
msgstr ""
"编写适用于给定函数的 _任何_ 重载的函数可能很有用。例如，`IO.println` 适用于具有 `ToString` "
"实例的任何类型。这使用方括号表示所需的实例：`IO.println` 的类型是 `{α : Type} → [ToString α] → α → IO "
"Unit`。此类型表示 `IO.println` 接受类型为 `α` 的参数，Lean 应自动确定该参数，并且必须为 `α` 提供 `ToString`"
" 实例。它返回一个 `IO` 操作。"

#: src/type-classes/polymorphism.md:10
#, fuzzy
msgid "Checking Polymorphic Functions' Types"
msgstr "检查多态函数的类型"

#: src/type-classes/polymorphism.md:12
#, fuzzy
msgid ""
"Checking the type of a function that takes implicit arguments or uses type "
"classes requires the use of some additional syntax. Simply writing"
msgstr "检查采用隐式参数或使用类型类的函数的类型需要使用一些附加语法。只需编写"

#: src/type-classes/polymorphism.md:17
#, fuzzy
msgid "yields a type with metavariables:"
msgstr "就会产生带有元变量的类型："

#: src/type-classes/polymorphism.md:21
#, fuzzy
msgid ""
"This is because Lean does its best to discover implicit arguments, and the "
"presence of metavariables indicates that it did not yet discover enough type"
" information to do so. To understand the signature of a function, this "
"feature can be suppressed with an at-sign (`@`) before the function's name:"
msgstr ""
"这是因为 Lean 尽力发现隐式参数，而元变量的存在表示它尚未发现足够的信息来这样做。为了理解函数的签名，可以在函数名称前使用 at 符号 (`@`) "
"来抑制此功能："

#: src/type-classes/polymorphism.md:29
#, fuzzy
msgid ""
"In this output, the instance itself has been given the name `inst`. "
"Additionally, there is a `u_1` after `Type`, which uses a feature of Lean "
"that has not yet been introduced. For now, ignore these parameters to "
"`Type`."
msgstr ""
"在该输出中，实例本身被赋予了名称 `inst`。此外，`Type` 后面有一个 `u_1`，它使用了 Lean 中尚未介绍的一个特性。现在，忽略 "
"`Type` 的这些参数。"

#: src/type-classes/polymorphism.md:33
#, fuzzy
msgid "Defining Polymorphic Functions with Instance Implicits"
msgstr "使用实例隐含参数定义多态函数"

#: src/type-classes/polymorphism.md:35
#, fuzzy
msgid ""
"A function that sums all entries in a list needs two instances: `Add` allows"
" the entries to be added, and an `OfNat` instance for `0` provides a "
"sensible value to return for the empty list:"
msgstr "求和列表中所有项的函数需要两个实例：`Add` 允许对项进行求和，`OfNat` 实例为 `0` 提供了一个合理的返回值，用于空列表："

#: src/type-classes/polymorphism.md:41
#, fuzzy
msgid "This function can be used for a list of `Nat`s:"
msgstr "此函数可用于 `Nat` 列表："

#: src/type-classes/polymorphism.md:50
#, fuzzy
msgid "but not for a list of `Pos` numbers:"
msgstr "但不能用于 `Pos` 数字列表："

#: src/type-classes/polymorphism.md:61
#, fuzzy
msgid ""
"Specifications of required instances in square brackets are called _instance"
" implicits_. Behind the scenes, every type class defines a structure that "
"has a field for each overloaded operation. Instances are values of that "
"structure type, with each field containing an implementation. At a call "
"site, Lean is responsible for finding an instance value to pass for each "
"instance implicit argument. The most important difference between ordinary "
"implicit arguments and instance implicits is the strategy that Lean uses to "
"find an argument value. In the case of ordinary implicit arguments, Lean "
"uses a technique called _unification_ to find a single unique argument value"
" that would allow the program to pass the type checker. This process relies "
"only on the specific types involved in the function's definition and the "
"call site. For instance implicits, Lean instead consults a built-in table of"
" instance values."
msgstr ""
"方括号中所需实例的规范称为 "
"_实例隐含参数_。在幕后，每个类型类都定义了一个结构体，该结构体为每个重载操作都有一个字段。实例是该结构体类型的值，每个字段都包含一个实现。在调用站点，Lean"
" 负责查找一个实例值来传递给每个实例隐含参数。普通隐含参数和实例隐含参数之间最重要的区别是 Lean 用于查找参数值的方法。对于普通隐含参数，Lean "
"使用称为 _统一_ "
"的技术来查找一个唯一的参数值，该值允许程序通过类型检查器。此过程仅依赖于函数定义和调用站点中涉及的特定类型。对于实例隐含参数，Lean "
"则查阅内置的实例值表。"

#: src/type-classes/polymorphism.md:70
#, fuzzy
msgid ""
"Just as the `OfNat` instance for `Pos` took a natural number `n` as an "
"automatic implicit argument, instances may also take instance implicit "
"arguments themselves. The [section on polymorphism](../getting-to-"
"know/polymorphism.md) presented a polymorphic point type:"
msgstr ""
"就像 `Pos` 的 `OfNat` 实例将自然数 `n` 作为自动隐含参数一样，实例本身也可以采用实例隐含参数。[多态性部分](../getting-"
"to-know/polymorphism.md) 介绍了一个多态点类型："

#: src/type-classes/polymorphism.md:78
#, fuzzy
msgid ""
"Addition of points should add the underlying `x` and `y` fields. Thus, an "
"`Add` instance for `PPoint` requires an `Add` instance for whatever type "
"these fields have. In other words, the `Add` instance for `PPoint` requires "
"a further `Add` instance for `α`:"
msgstr ""
"点相加应相加底层 `x` 和 `y` 字段。因此，`PPoint` 的 `Add` 实例需要这些字段的类型所对应的 `Add` "
"实例。换句话说，`PPoint` 的 `Add` 实例需要 `α` 的 `Add` 实例："

#: src/type-classes/polymorphism.md:85
#, fuzzy
msgid ""
"When Lean encounters an addition of two points, it searches for and finds "
"this instance. It then performs a further search for the `Add α` instance."
msgstr "当 Lean 遇到两个点的相加时，它会搜索并找到此实例。然后，它会进一步搜索 `Add α` 实例。"

#: src/type-classes/polymorphism.md:88
#, fuzzy
msgid ""
"The instance values that are constructed in this way are values of the type "
"class's structure type. A successful recursive instance search results in a "
"structure value that has a reference to another structure value. An instance"
" of `Add (PPoint Nat)` contains a reference to the instance of `Add Nat` "
"that was found."
msgstr ""
"通过这种方式构造的实例值是类型类结构体类型的值。成功的递归实例搜索会产生一个引用另一个结构体值的结构体值。`Add (PPoint Nat)` "
"的实例包含对找到的 `Add Nat` 实例的引用。"

#: src/type-classes/polymorphism.md:92
#, fuzzy
msgid ""
"This recursive search process means that type classes offer significantly "
"more power than plain overloaded functions. A library of polymorphic "
"instances is a set of code building blocks that the compiler will assemble "
"on its own, given nothing but the desired type. Polymorphic functions that "
"take instance arguments are latent requests to the type class mechanism to "
"assemble helper functions behind the scenes. The API's clients are freed "
"from the burden of plumbing together all of the necessary parts by hand."
msgstr ""
"这种递归搜索过程意味着类型类比普通重载函数提供了更大的功能。多态实例库是一组代码构建块，编译器将根据所需类型自行组装这些代码构建块。接受实例参数的多态函数是对类型类机制的潜在请求，要求其在幕后组装辅助函数。API"
" 的客户端无需手动组装所有必需的部分。"

#: src/type-classes/polymorphism.md:98
#, fuzzy
msgid "Methods and Implicit Arguments"
msgstr "方法和隐式参数"

#: src/type-classes/polymorphism.md:101
#, fuzzy
msgid ""
"The type of `@OfNat.ofNat` may be surprising. It is `{α : Type} → (n : Nat) "
"→ [OfNat α n] → α`, in which the `Nat` argument `n` occurs as an explicit "
"function argument. In the declaration of the method, however, `ofNat` simply"
" has type `α`. This seeming discrepancy is because declaring a type class "
"really results in the following:"
msgstr ""
"`@OfNat.ofNat` 的类型可能令人惊讶。它是 `{α : Type} → (n : Nat) → [OfNat α n] → α`，其中 "
"`Nat` 参数 `n` 作为显式函数参数出现。然而，在方法的声明中，`ofNat` 的类型只是 "
"`α`。这种表面的差异是因为声明类型类实际上会产生以下结果："

#: src/type-classes/polymorphism.md:106
#, fuzzy
msgid ""
"A structure type to contain the implementation of each overloaded operation"
msgstr "结构体类型包含每个重载操作的实现"

#: src/type-classes/polymorphism.md:107
#, fuzzy
msgid "A namespace with the same name as the class"
msgstr "与类同名的命名空间"

#: src/type-classes/polymorphism.md:108
#, fuzzy
msgid ""
"For each method, a function in the class's namespace that retrieves its "
"implementation from an instance"
msgstr "对于每个方法，类命名空间中的一个函数从实例中检索其实现"

#: src/type-classes/polymorphism.md:110
#, fuzzy
msgid ""
"This is analogous to the way that declaring a new structure also declares "
"accessor functions. The primary difference is that a structure's accessors "
"take the structure value as an explicit argument, while the type class "
"methods take the instance value as an instance implicit to be found "
"automatically by Lean."
msgstr ""
"这类似于声明新结构体也会声明访问器函数的方式。主要区别在于，结构体的访问器将结构体值作为显式参数，而类型类方法将实例值作为 Lean 自动找到的实例隐式参数。"

#: src/type-classes/polymorphism.md:113
#, fuzzy
msgid ""
"In order for Lean to find an instance, its arguments must be available. This"
" means that each argument to the type class must be an argument to the "
"method that occurs before the instance. It is most convenient when these "
"arguments are implicit, because Lean does the work of discovering their "
"values. For example, `@Add.add` has the type `{α : Type} → [Add α] → α → α →"
" α`. In this case, the type argument `α` can be implicit because the "
"arguments to `Add.add` provide information about which type the user "
"intended. This type can then be used to search for the `Add` instance."
msgstr ""
"为了让 Lean 找到实例，其参数必须可用。这意味着类型类的每个参数都必须是实例之前的方法的参数。当这些参数是隐式的时最方便，因为 Lean "
"会发现它们的值。例如，`@Add.add` 的类型为 `{α : Type} → [Add α] → α → α → α`。在这种情况下，类型参数 "
"`α` 可以是隐式的，因为 `Add.add` 的参数提供了有关用户意图类型的的信息。然后可以使用此类型搜索 `Add` 实例。"

#: src/type-classes/polymorphism.md:120
#, fuzzy
msgid ""
"In the case of `ofNat`, however, the particular `Nat` literal to be decoded "
"does not appear as part of any other argument. This means that Lean would "
"have no information to use when attempting to figure out the implicit "
"argument `n`. The result would be a very inconvenient API. Thus, in these "
"cases, Lean uses an explicit argument for the class's method."
msgstr ""
"然而，在 `ofNat` 的情况下，要解码的特定 `Nat` 文字不会作为任何其他参数的一部分出现。这意味着 Lean 在尝试找出隐式参数 `n` "
"时没有任何信息可以使用。结果将是一个非常不方便的 API。因此，在这些情况下，Lean 为类的函数使用显式参数。"

#: src/type-classes/polymorphism.md:129
#, fuzzy
msgid "Even Number Literals"
msgstr "偶数文字"

#: src/type-classes/polymorphism.md:131
#, fuzzy
msgid ""
"Write an instance of `OfNat` for the even number datatype from the [previous"
" section's exercises](pos.md#even-numbers) that uses recursive instance "
"search. For the base instance, it is necessary to write `OfNat Even "
"Nat.zero` instead of `OfNat Even 0`."
msgstr ""
"为 [上一节练习](pos.md#even-numbers) 中的偶数数据类型编写 `OfNat` "
"实例，该实例使用递归实例搜索。对于基本实例，有必要编写 `OfNat Even Nat.zero` 而不是 `OfNat Even 0`。"

#: src/type-classes/polymorphism.md:134
#, fuzzy
msgid "Recursive Instance Search Depth"
msgstr "递归实例搜索深度"

#: src/type-classes/polymorphism.md:136
#, fuzzy
msgid ""
"There is a limit to how many times the Lean compiler will attempt a "
"recursive instance search. This places a limit on the size of even number "
"literals defined in the previous exercise. Experimentally determine what the"
" limit is."
msgstr "Lean 编译器尝试递归实例搜索的次数有限制。这限制了前一个练习中定义的偶数文字的大小。通过实验确定限制是什么。"

#: src/type-classes/out-params.md:3
#, fuzzy
msgid ""
"An instance of the `Add` class is sufficient to allow two expressions with "
"type `Pos` to be conveniently added, producing another `Pos`. However, in "
"many cases, it can be useful to be more flexible and allow _heterogeneous_ "
"operator overloading, where the arguments may have different types. For "
"example, adding a `Nat` to a `Pos` or a `Pos` to a `Nat` will always yield a"
" `Pos`:"
msgstr ""
"`Add` 类的实例足以允许两个类型为 `Pos` 的表达式方便地相加，生成另一个 "
"`Pos`。然而，在许多情况下，更灵活并允许异构运算符重载可能很有用，其中参数可以具有不同的类型。例如，将 `Nat` 添加到 `Pos` 或将 "
"`Pos` 添加到 `Nat` 总是会产生 `Pos`："

#: src/type-classes/out-params.md:15
#, fuzzy
msgid ""
"These functions allow natural numbers to be added to positive numbers, but "
"they cannot be used with the `Add` type class, which expects both arguments "
"to `add` to have the same type."
msgstr "这些函数允许将自然数添加到正数，但不能与 `Add` 类型类一起使用，后者期望 `add` 的两个参数具有相同的类型。"

#: src/type-classes/out-params.md:17
#, fuzzy
msgid "Heterogeneous Overloadings"
msgstr "异构重载"

#: src/type-classes/out-params.md:19
#, fuzzy
msgid ""
"As mentioned in the section on [overloaded addition](pos.md#overloaded-"
"addition), Lean provides a type class called `HAdd` for overloading addition"
" heterogeneously. The `HAdd` class takes three type parameters: the two "
"argument types and the return type. Instances of `HAdd Nat Pos Pos` and "
"`HAdd Pos Nat Pos` allow ordinary addition notation to be used to mix the "
"types:"
msgstr ""
"正如 [重载加法](pos.md#overloaded-addition) 部分所述，Lean 提供了一个名为 `HAdd` "
"的类型类，用于异构地重载加法。`HAdd` 类采用三个类型参数：两个参数类型和返回类型。`HAdd Nat Pos Pos` 和 `HAdd Pos "
"Nat Pos` 的实例允许使用普通加法符号来混合类型："

#: src/type-classes/out-params.md:29
#, fuzzy
msgid "Given the above two instances, the following examples work:"
msgstr "给定以上两个实例，以下示例有效："

#: src/type-classes/out-params.md:43
#, fuzzy
msgid ""
"The definition of the `HAdd` type class is very much like the following "
"definition of `HPlus` with the corresponding instances:"
msgstr "`HAdd` 类型类的定义非常类似于以下带有相应实例的 `HPlus` 定义："

#: src/type-classes/out-params.md:54
#, fuzzy
msgid ""
"However, instances of `HPlus` are significantly less useful than instances "
"of `HAdd`. When attempting to use these instances with `#eval`, an error "
"occurs:"
msgstr "然而，`HPlus` 的实例远不如 `HAdd` 的实例有用。当尝试使用这些实例与 `#eval` 时，会发生错误："

#: src/type-classes/out-params.md:63
#, fuzzy
msgid ""
"This happens because there is a metavariable in the type, and Lean has no "
"way to solve it."
msgstr "这发生在类型中存在元变量时，而 Lean 无法解决它。"

#: src/type-classes/out-params.md:65
#, fuzzy
msgid ""
"As discussed in [the initial description of polymorphism](../getting-to-"
"know/polymorphism.md), metavariables represent unknown parts of a program "
"that could not be inferred. When an expression is written following `#eval`,"
" Lean attempts to determine its type automatically. In this case, it could "
"not. Because the third type parameter for `HPlus` was unknown, Lean couldn't"
" carry out type class instance search, but instance search is the only way "
"that Lean could determine the expression's type. That is, the `HPlus Pos Nat"
" Pos` instance can only apply if the expression should have type `Pos`, but "
"there's nothing in the program other than the instance itself to indicate "
"that it should have this type."
msgstr ""
"如 [多态性的初始描述](../getting-to-know/polymorphism.md) 中所述，元变量表示程序中无法推断的未知部分。当在 "
"`#eval` 后面写一个表达式时，Lean 会尝试自动确定其类型。在这种情况下，它无法确定。由于 `HPlus` 的第三个类型参数未知，Lean "
"无法执行类型类实例搜索，但实例搜索是 Lean 确定表达式类型的唯一方法。也就是说，`HPlus Pos Nat Pos` 实例只能在表达式应具有 "
"`Pos` 类型时应用，但程序中除了实例本身之外没有任何内容表明它应该具有此类型。"

#: src/type-classes/out-params.md:71
#, fuzzy
msgid ""
"One solution to the problem is to ensure that all three types are available "
"by adding a type annotation to the whole expression:"
msgstr "解决此问题的一种方法是通过向整个表达式添加类型标注来确保所有三个类型都可用："

#: src/type-classes/out-params.md:78
#, fuzzy
msgid ""
"However, this solution is not very convenient for users of the positive "
"number library."
msgstr "但是，对于正数库的用户来说，此解决方案不是很方便。"

#: src/type-classes/out-params.md:81
#, fuzzy
msgid "Output Parameters"
msgstr "输出参数"

#: src/type-classes/out-params.md:83
#, fuzzy
msgid ""
"This problem can also be solved by declaring `γ` to be an _output "
"parameter_. Most type class parameters are inputs to the search algorithm: "
"they are used to select an instance. For example, in an `OfNat` instance, "
"both the type and the natural number are used to select a particular "
"interpretation of a natural number literal. However, in some cases, it can "
"be convenient to start the search process even when some of the type "
"parameters are not yet known, and use the instances that are discovered in "
"the search to determine values for metavariables. The parameters that aren't"
" needed to start instance search are outputs of the process, which is "
"declared with the `outParam` modifier:"
msgstr ""
"还可以通过将 `γ` 声明为 _输出参数_ 来解决此问题。大多数类型类参数是搜索算法的输入：它们用于选择实例。例如，在 `OfNat` "
"实例中，类型和自然数都用于选择自然数文字的特定解释。然而，在某些情况下，即使某些类型参数尚未知道，也可以开始搜索过程，并使用在搜索中发现的实例来确定元变量的值。不需要开始实例搜索的参数是该过程的输出，该过程使用"
" `outParam` 修饰符声明："

#: src/type-classes/out-params.md:93
#, fuzzy
msgid ""
"With this output parameter, type class instance search is able to select an "
"instance without knowing `γ` in advance. For instance:"
msgstr "通过输出参数，类型类实例搜索能够在不提前知道 `γ` 的情况下选择一个实例。例如："

#: src/type-classes/out-params.md:102
#, fuzzy
msgid ""
"It might be helpful to think of output parameters as defining a kind of "
"function. Any given instance of a type class that has one or more output "
"parameters provides Lean with instructions for determining the outputs from "
"the inputs. The process of searching for an instance, possibly recursively, "
"ends up being more powerful than mere overloading. Output parameters can "
"determine other types in the program, and instance search can assemble a "
"collection of underlying instances into a program that has this type."
msgstr ""
"将输出参数视为定义一种函数可能会有所帮助。任何具有一个或多个输出参数的类型类的给定实例都为 Lean "
"提供了确定从输入到输出的说明。搜索实例的过程（可能递归）最终比单纯的重载更强大。输出参数可以确定程序中的其他类型，并且实例搜索可以将底层实例集合组装成具有此类型的程序。"

#: src/type-classes/out-params.md:107
#, fuzzy
msgid "Default Instances"
msgstr "默认实例"

#: src/type-classes/out-params.md:109
#, fuzzy
msgid ""
"Deciding whether a parameter is an input or an output controls the "
"circumstances under which Lean will initiate type class search. In "
"particular, type class search does not occur until all inputs are known. "
"However, in some cases, output parameters are not enough, and instance "
"search should also occur when some inputs are unknown. This is a bit like "
"default values for optional function arguments in Python or Kotlin, except "
"default _types_ are being selected."
msgstr ""
"决定一个参数是输入还是输出控制了 Lean "
"将启动类型类搜索的情况。特别是，在所有输入都已知之前，不会发生类型类搜索。但是，在某些情况下，输出参数还不够，并且在某些输入未知时也应该进行实例搜索。这有点像"
" Python 或 Kotlin 中可选函数参数的默认值，除了正在选择默认 _类型_。"

#: src/type-classes/out-params.md:114
#, fuzzy
msgid ""
"_Default instances_ are instances that are available for instance search "
"_even when not all their inputs are known_. When one of these instances can "
"be used, it will be used. This can cause programs to successfully type "
"check, rather than failing with errors related to unknown types and "
"metavariables. On the other hand, default instances can make instance "
"selection less predictable. In particular, if an undesired default instance "
"is selected, then an expression may have a different type than expected, "
"which can cause confusing type errors to occur elsewhere in the program. Be "
"selective about where default instances are used!"
msgstr ""
"_默认实例_ "
"是可用于实例搜索的实例，_即使并非其所有输入都已知_。当可以使用其中一个实例时，将使用它。这会导致程序成功类型检查，而不是因与未知类型和元变量相关的错误而失败。另一方面，默认实例会使实例选择变得不那么可预测。特别是，如果选择了不需要的默认实例，那么表达式的类型可能与预期不同，这会导致程序中其他位置出现令人困惑的类型错误。要谨慎选择使用默认实例的位置！"

#: src/type-classes/out-params.md:121
#, fuzzy
msgid ""
"One example of where default instances can be useful is an instance of "
"`HPlus` that can be derived from an `Add` instance. In other words, ordinary"
" addition is a special case of heterogeneous addition in which all three "
"types happen to be the same. This can be implemented using the following "
"instance:"
msgstr ""
"一个默认实例有用的例子是，可以从 `Add` 实例派生的 `HPlus` "
"实例。换句话说，普通加法是异构加法的一个特例，其中所有三种类型恰好相同。这可以使用以下实例实现："

#: src/type-classes/out-params.md:128
#, fuzzy
msgid ""
"With this instance, `hPlus` can be used for any addable type, like `Nat`:"
msgstr "有了这个实例，`hPlus` 可以用于任何可加类型，例如 `Nat`："

#: src/type-classes/out-params.md:136
#, fuzzy
msgid ""
"However, this instance will only be used in situations where the types of "
"both arguments are known. For example,"
msgstr "然而，此实例仅在已知两个参数的类型的情况下使用。例如，"

#: src/type-classes/out-params.md:141
#, fuzzy
msgid "yields the type"
msgstr "产生类型"

#: src/type-classes/out-params.md:145
#, fuzzy
msgid "as expected, but"
msgstr "如预期的那样，但"

#: src/type-classes/out-params.md:149
#, fuzzy
msgid ""
"yields a type that contains two metavariables, one for the remaining "
"argument and one for the return type:"
msgstr "产生一个包含两个元变量的类型，一个用于剩余参数，一个用于返回类型："

#: src/type-classes/out-params.md:154
#, fuzzy
msgid ""
"In the vast majority of cases, when someone supplies one argument to "
"addition, the other argument will have the same type. To make this instance "
"into a default instance, apply the `default_instance` attribute:"
msgstr ""
"在绝大多数情况下，当有人向加法提供一个参数时，另一个参数将具有相同的类型。要将此实例变成默认实例，请应用 `default_instance` 属性："

#: src/type-classes/out-params.md:161
#, fuzzy
msgid "With this default instance, the example has a more useful type:"
msgstr "有了这个默认实例，示例具有更有用的类型："

#: src/type-classes/out-params.md:170
#, fuzzy
msgid ""
"Each operator that exists in overloadable heterogeneous and homogeneous "
"versions follows the pattern of a default instance that allows the "
"homogeneous version to be used in contexts where the heterogeneous is "
"expected. The infix operator is replaced with a call to the heterogeneous "
"version, and the homogeneous default instance is selected when possible."
msgstr ""
"每个在可重载异构和同构版本中存在的运算符都遵循默认实例的模式，允许在预期异构的情况下使用同构版本。中缀运算符被替换为对异构版本的调用，并在可能的情况下选择同构默认实例。"

#: src/type-classes/out-params.md:173
#, fuzzy
msgid ""
"Similarly, simply writing `5` gives a `Nat` rather than a type with a "
"metavariable that is waiting for more information in order to select an "
"`OfNat` instance. This is because the `OfNat` instance for `Nat` is a "
"default instance."
msgstr ""
"类似地，简单地写 `5` 会给出一个 `Nat`，而不是一个带有元变量的类型，等待更多信息以选择一个 `OfNat` 实例。这是因为 `Nat` 的 "
"`OfNat` 实例是一个默认实例。"

#: src/type-classes/out-params.md:176
#, fuzzy
msgid ""
"Default instances can also be assigned _priorities_ that affect which will "
"be chosen in situations where more than one might apply. For more "
"information on default instance priorities, please consult the Lean manual."
msgstr "默认实例还可以分配 _优先级_，这会影响在可能应用多个实例的情况下选择哪个实例。有关默认实例优先级的更多信息，请查阅 Lean 手册。"

#: src/type-classes/out-params.md:182
#, fuzzy
msgid ""
"Define an instance of `HMul (PPoint α) α (PPoint α)` that multiplies both "
"projections by the scalar. It should work for any type `α` for which there "
"is a `Mul α` instance. For example,"
msgstr ""
"定义 `HMul (PPoint α) α (PPoint α)` 的一个实例，将两个投影乘以标量。它应该适用于任何具有 `Mul α` 实例的类型 "
"`α`。例如，"

#: src/type-classes/indexing.md:3
#, fuzzy
msgid ""
"The [Interlude](../props-proofs-indexing.md) describes how to use indexing "
"notation in order to look up entries in a list by their position. This "
"syntax is also governed by a type class, and it can be used for a variety of"
" different types."
msgstr ""
"[插曲](../props-proofs-indexing.md) "
"描述了如何使用索引符号根据位置查找列表中的条目。此语法也受类型类的约束，并且可用于各种不同的类型。"

#: src/type-classes/indexing.md:6
#, fuzzy
msgid "Arrays"
msgstr "数组"

#: src/type-classes/indexing.md:7
#, fuzzy
msgid ""
"For instance, Lean arrays are much more efficient than linked lists for most"
" purposes. In Lean, the type `Array α` is a dynamically-sized array holding "
"values of type `α`, much like a Java `ArrayList`, a C++ `std::vector`, or a "
"Rust `Vec`. Unlike `List`, which has a pointer indirection on each use of "
"the `cons` constructor, arrays occupy a contiguous region of memory, which "
"is much better for processor caches. Also, looking up a value in an array "
"takes constant time, while lookup in a linked list takes time proportional "
"to the index being accessed."
msgstr ""
"例如，对于大多数目的，Lean 数组比链表的效率要高得多。在 Lean 中，类型 `Array α` 是一个动态大小的数组，它保存类型为 `α` "
"的值，很像 Java 中的 `ArrayList`、C++ 中的 `std::vector` 或 Rust 中的 `Vec`。与 `List` "
"不同，`List` 在每次使用 `cons` "
"构造子时都有一个指针间接，而数组占据一个连续的内存区域，这对于处理器缓存来说要好得多。此外，在数组中查找一个值需要恒定时间，而在链表中查找则需要与被访问的索引成正比的时间。"

#: src/type-classes/indexing.md:12
#, fuzzy
msgid ""
"In pure functional languages like Lean, it is not possible to mutate a given"
" position in a data structure. Instead, a copy is made that has the desired "
"modifications. When using an array, the Lean compiler and runtime contain an"
" optimization that can allow modifications to be implemented as mutations "
"behind the scenes when there is only a single unique reference to an array."
msgstr ""
"在 Lean 这样的纯函数式语言中，不可能改变数据结构体中的给定位置。相反，会创建一个具有所需修改的副本。在使用数组时，Lean "
"编译器和运行时包含一个优化，当数组只有一个唯一引用时，该优化可以允许将修改实现为幕后的变异。"

#: src/type-classes/indexing.md:16
#, fuzzy
msgid "Arrays are written similarly to lists, but with a leading `#`:"
msgstr "数组的编写方式与列表类似，但前面有一个 `#`："

#: src/type-classes/indexing.md:17
#, fuzzy
msgid ""
"```lean\n"
"def northernTrees : Array String :=\n"
"  #[\"sloe\", \"birch\", \"elm\", \"oak\"]\n"
"```"
msgstr ""
"```lean\n"
"def northernTrees : Array String :=\n"
"  #[\"sloe\", \"birch\", \"elm\", \"oak\"]\n"
"```"

#: src/type-classes/indexing.md:21
#, fuzzy
msgid ""
"The number of values in an array can be found using `Array.size`. For "
"instance, `northernTrees.size` evaluates to `4`. For indices that are "
"smaller than an array's size, indexing notation can be used to find the "
"corresponding value, just as with lists. That is, `northernTrees[2]` "
"evaluates to `\"elm\"`. Similarly, the compiler requires a proof that an "
"index is in bounds, and attempting to look up a value outside the bounds of "
"the array results in a compile-time error, just as with lists. For instance,"
" `northernTrees[8]` results in:"
msgstr ""
"数组中值的个数可以通过 `Array.size` 找到。例如，`northernTrees.size` 计算结果为 "
"`4`。对于小于数组大小的索引，可以使用索引符号来查找相应的值，就像列表一样。也就是说，`northernTrees[2]` 计算结果为 "
"`\"elm\"`。同样，编译器需要一个证明，即索引在范围内，并且尝试查找数组范围之外的值会导致编译时错误，就像列表一样。例如，`northernTrees[8]`"
" 的结果是："

#: src/type-classes/indexing.md:36
#, fuzzy
msgid "Non-Empty Lists"
msgstr "非空列表"

#: src/type-classes/indexing.md:38
#, fuzzy
msgid ""
"A datatype that represents non-empty lists can be defined as a structure "
"with a field for the head of the list and a field for the tail, which is an "
"ordinary, potentially empty list:"
msgstr "可以将表示非空列表的数据类型定义为一个结构体，其中有一个字段表示列表的头部，另一个字段表示尾部，它是一个普通的、可能为空的列表："

#: src/type-classes/indexing.md:44
#, fuzzy
msgid ""
"For example, the non-empty list `idahoSpiders` (which contains some spider "
"species native to the US state of Idaho) consists of `\"Banded Garden "
"Spider\"` followed by four other spiders, for a total of five spiders:"
msgstr ""
"例如，非空列表 `idahoSpiders`（其中包含一些原产于美国爱达荷州的蜘蛛物种）由 `\"Banded Garden Spider\"` "
"后跟其他四种蜘蛛组成，总共五种蜘蛛："

#: src/type-classes/indexing.md:45
#, fuzzy
msgid ""
"```lean\n"
"def idahoSpiders : NonEmptyList String := {\n"
"  head := \"Banded Garden Spider\",\n"
"  tail := [\n"
"    \"Long-legged Sac Spider\",\n"
"    \"Wolf Spider\",\n"
"    \"Hobo Spider\",\n"
"    \"Cat-faced Spider\"\n"
"  ]\n"
"}\n"
"```"
msgstr ""
"```lean\n"
"def idahoSpiders : NonEmptyList String := {\n"
"  head := \"Banded Garden Spider\",\n"
"  tail := [\n"
"    \"Long-legged Sac Spider\",\n"
"    \"Wolf Spider\",\n"
"    \"Hobo Spider\",\n"
"    \"Cat-faced Spider\"\n"
"  ]\n"
"}\n"
"```"

#: src/type-classes/indexing.md:57
#, fuzzy
msgid ""
"Looking up the value at a specific index in this list with a recursive "
"function should consider three possibilities:"
msgstr "使用递归函数查找此列表中特定索引处的值时，应考虑三种可能性："

#: src/type-classes/indexing.md:58
#, fuzzy
msgid ""
"The index is `0`, in which case the head of the list should be returned."
msgstr "索引为 `0`，在这种情况下应返回列表的头部。"

#: src/type-classes/indexing.md:59
#, fuzzy
msgid ""
"The index is `n + 1` and the tail is empty, in which case the index is out "
"of bounds."
msgstr "索引为 `n + 1` 且尾部为空，在这种情况下索引超出范围。"

#: src/type-classes/indexing.md:60
#, fuzzy
msgid ""
"The index is `n + 1` and the tail is non-empty, in which case the function "
"can be called recursively on the tail and `n`."
msgstr "索引为 `n + 1` 且尾部非空，在这种情况下可以在尾部和 `n` 上递归调用该函数。"

#: src/type-classes/indexing.md:62
#, fuzzy
msgid ""
"For example, a lookup function that returns an `Option` can be written as "
"follows:"
msgstr "例如，一个返回 `Option` 的查找函数可以写成如下形式："

#: src/type-classes/indexing.md:69
#, fuzzy
msgid ""
"Each case in the pattern match corresponds to one of the possibilities "
"above. The recursive call to `get?` does not require a `NonEmptyList` "
"namespace qualifier because the body of the definition is implicitly in the "
"definition's namespace. Another way to write this function uses `get?` for "
"lists when the index is greater than zero:"
msgstr ""
"模式匹配中的每个 case 对应于上述的一种可能性。对 `get?` 的递归调用不需要 `NonEmptyList` "
"命名空间限定符，因为定义的主体隐式地位于定义的命名空间中。另一种编写此函数的方法是当索引大于零时对列表使用 `get?`："

#: src/type-classes/indexing.md:78
#, fuzzy
msgid ""
"If the list contains one entry, then only `0` is a valid index. If it "
"contains two entries, then both `0` and `1` are valid indices. If it "
"contains three entries, then `0`, `1`, and `2` are valid indices. In other "
"words, the valid indices into a non-empty list are natural numbers that are "
"strictly less than the length of the list, which are less than or equal to "
"the length of the tail."
msgstr ""
"如果列表包含一个条目，则只有 `0` 是有效的索引。如果它包含两个条目，则 `0` 和 `1` 都是有效的索引。如果它包含三个条目，则 `0`、`1` "
"和 `2` 是有效的索引。换句话说，非空列表中的有效索引是严格小于列表长度的自然数，它们小于或等于尾部的长度。"

#: src/type-classes/indexing.md:83
#, fuzzy
msgid ""
"The definition of what it means for an index to be in bounds should be "
"written as an `abbrev` because the tactics used to find evidence that "
"indices are acceptable are able to solve inequalities of numbers, but they "
"don't know anything about the name `NonEmptyList.inBounds`:"
msgstr ""
"对于索引处于界内意味着什么的定义应该写成一个 `abbrev`，因为用于查找索引是否可接受的证据的策略能够解决数字的不等式，但它们对名称 "
"`NonEmptyList.inBounds` 一无所知："

#: src/type-classes/indexing.md:88
#, fuzzy
msgid ""
"This function returns a proposition that might be true or false. For "
"instance, `2` is in bounds for `idahoSpiders`, while `5` is not:"
msgstr "此函数返回一个可能是真或假的命题。例如，`2` 对于 `idahoSpiders` 处于界内，而 `5` 则不处于界内："

#: src/type-classes/indexing.md:95
#, fuzzy
msgid ""
"The logical negation operator has a very low precedence, which means that "
"`¬idahoSpiders.inBounds 5` is equivalent to `¬(idahoSpiders.inBounds 5)`."
msgstr ""
"逻辑否定运算符的优先级非常低，这意味着 `¬idahoSpiders.inBounds 5` 等价于 `¬(idahoSpiders.inBounds "
"5)`。"

#: src/type-classes/indexing.md:98
#, fuzzy
msgid ""
"This fact can be used to write a lookup function that requires evidence that"
" the index is valid, and thus need not return `Option`, by delegating to the"
" version for lists that checks the evidence at compile time:"
msgstr "此事实可用于编写一个查找函数，该函数需要证据证明索引有效，因此不必返回 `Option`，方法是委托给在编译时检查证据的列表版本："

#: src/type-classes/indexing.md:105
#, fuzzy
msgid ""
"It is, of course, possible to write this function to use the evidence "
"directly, rather than delegating to a standard library function that happens"
" to be able to use the same evidence. This requires techniques for working "
"with proofs and propositions that are described later in this book."
msgstr "当然，也可以直接使用证据来编写此函数，而不是委托给碰巧能够使用相同证据的标准库函数。这需要使用本书后面描述的处理证明和命题的技术。"

#: src/type-classes/indexing.md:109
#, fuzzy
msgid "Overloading Indexing"
msgstr "重载索引"

#: src/type-classes/indexing.md:111
#, fuzzy
msgid ""
"Indexing notation for a collection type can be overloaded by defining an "
"instance of the `GetElem` type class. For the sake of flexiblity, `GetElem` "
"has four parameters:"
msgstr "可以通过定义`GetElem`类型类的实例来重载集合类型的索引表示法。为了灵活性，`GetElem`有四个参数："

#: src/type-classes/indexing.md:113
#, fuzzy
msgid "The type of the collection"
msgstr "集合的类型"

#: src/type-classes/indexing.md:114
#, fuzzy
msgid "The type of the index"
msgstr "索引的类型"

#: src/type-classes/indexing.md:115
#, fuzzy
msgid "The type of elements that are extracted from the collection"
msgstr "从集合中提取的元素的类型"

#: src/type-classes/indexing.md:116
#, fuzzy
msgid ""
"A function that determines what counts as evidence that the index is in "
"bounds"
msgstr "一个函数，用于确定索引在边界内的证据"

#: src/type-classes/indexing.md:118
#, fuzzy
msgid ""
"The element type and the evidence function are both output parameters. "
"`GetElem` has a single method, `getElem`, which takes a collection value, an"
" index value, and evidence that the index is in bounds as arguments, and "
"returns an element:"
msgstr ""
"元素类型和证据函数都是输出参数。`GetElem`有一个方法`getElem`，它以集合值、索引值和索引在边界内的证据作为参数，并返回一个元素："

#: src/type-classes/indexing.md:125
#, fuzzy
msgid "In the case of `NonEmptyList α`, these parameters are:"
msgstr "对于`NonEmptyList α`，这些参数是："

#: src/type-classes/indexing.md:126
#, fuzzy
msgid "The collection is `NonEmptyList α`"
msgstr "集合是`NonEmptyList α`"

#: src/type-classes/indexing.md:127
#, fuzzy
msgid "Indices have type `Nat`"
msgstr "索引的类型是`Nat`"

#: src/type-classes/indexing.md:128
#, fuzzy
msgid "The type of elements is `α`"
msgstr "元素的类型是`α`"

#: src/type-classes/indexing.md:129
#, fuzzy
msgid ""
"An index is in bounds if it is less than or equal to the length of the tail"
msgstr "如果索引小于或等于尾部的长度，则索引在边界内"

#: src/type-classes/indexing.md:131
#, fuzzy
msgid ""
"In fact, the `GetElem` instance can delegate directly to `NonEmptyList.get`:"
msgstr "事实上，`GetElem`实例可以直接委托给`NonEmptyList.get`："

#: src/type-classes/indexing.md:136
#, fuzzy
msgid ""
"With this instance, `NonEmptyList` becomes just as convenient to use as "
"`List`. Evaluating `idahoSpiders[0]` yields `\"Banded Garden Spider\"`, "
"while `idahoSpiders[9]` leads to the compile-time error:"
msgstr ""
"有了这个实例，`NonEmptyList`的使用就和`List`一样方便了。求值`idahoSpiders[0]`得到`\"Banded Garden "
"Spider\"，而`idahoSpiders[9]`导致编译时错误："

#: src/type-classes/indexing.md:147
#, fuzzy
msgid ""
"Because both the collection type and the index type are input parameters to "
"the `GetElem` type class, new types can be used to index into existing "
"collections. The positive number type `Pos` is a perfectly reasonable index "
"into a `List`, with the caveat that it cannot point at the first entry. The "
"follow instance of `GetElem` allows `Pos` to be used just as conveniently as"
" `Nat` to find a list entry:"
msgstr ""
"因为集合类型和索引类型都是`GetElem`类型类的输入参数，所以可以使用新类型来索引现有集合。正数类型`Pos`是`List`中一个非常合理的索引，但它不能指向第一个条目。`GetElem`的以下实例允许`Pos`像`Nat`一样方便地用于查找列表条目："

#: src/type-classes/indexing.md:155
#, fuzzy
msgid ""
"Indexing can also make sense for non-numeric indices. For example, `Bool` "
"can be used to select between the fields in a point, with `false` "
"corresponding to `x` and `true` corresponding to `y`:"
msgstr "索引也可以用于非数字索引。例如，`Bool` 可用于选择点中的字段，其中 `false` 对应于 `x`，`true` 对应于 `y`："

#: src/type-classes/indexing.md:162
#, fuzzy
msgid ""
"In this case, both Booleans are valid indices. Because every possible `Bool`"
" is in bounds, the evidence is simply the true proposition `True`."
msgstr "在这种情况下，两个布尔值都是有效的索引。因为每个可能的 `Bool` 都在范围内，所以证据只是真命题 `True`。"

#: src/type-classes/standard-classes.md:3
#, fuzzy
msgid ""
"This section presents a variety of operators and functions that can be "
"overloaded using type classes in Lean. Each operator or function corresponds"
" to a method of a type class. Unlike C++, infix operators in Lean are "
"defined as abbreviations for named functions; this means that overloading "
"them for new types is not done using the operator itself, but rather using "
"the underlying name (such as `HAdd.hAdd`)."
msgstr ""
"本节介绍了可以在 Lean 中使用类型类重载的各种运算符和函数。每个运算符或函数都对应于类型类的某个方法。与 C++ 不同，Lean "
"中的前缀运算符被定义为命名函数的缩写；这意味着为新类型重载它们不是使用运算符本身，而是使用底层名称（例如 `HAdd.hAdd`）。"

#: src/type-classes/standard-classes.md:7
#, fuzzy
msgid "Arithmetic"
msgstr "算术"

#: src/type-classes/standard-classes.md:9
#, fuzzy
msgid ""
"Most arithmetic operators are available in a heterogeneous form, where the "
"arguments may have different type and an output parameter decides the type "
"of the resulting expression. For each heterogeneous operator, there is a "
"corresponding homogeneous version that can found by removing the letter `h`,"
" so that `HAdd.hAdd` becomes `Add.add`. The following arithmetic operators "
"are overloaded:"
msgstr ""
"大多数算术运算符都以异构形式提供，其中参数可以有不同的类型，输出参数决定结果表达式的类型。对于每个异构运算符，都有一个相应的同构版本，可以通过删除字母 "
"`h` 来找到，因此 `HAdd.hAdd` 变为 `Add.add`。重载了以下算术运算符："

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98 src/monad-transformers/do.md:424
#: src/programs-proofs/arrays-termination.md:19
#, fuzzy
msgid "Expression"
msgstr "表达式"

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98
#: src/programs-proofs/arrays-termination.md:19
#, fuzzy
msgid "Desugaring"
msgstr "去糖"

#: src/type-classes/standard-classes.md:13
#: src/type-classes/standard-classes.md:31
#: src/type-classes/standard-classes.md:98
#: src/programs-proofs/arrays-termination.md:19
#, fuzzy
msgid "Class Name"
msgstr "类名"

#: src/type-classes/standard-classes.md:15
#, fuzzy
msgid "`x + y`"
msgstr "`x + y`"

#: src/type-classes/standard-classes.md:15
#, fuzzy
msgid "`HAdd.hAdd x y`"
msgstr "`HAdd.hAdd x y`"

#: src/type-classes/standard-classes.md:15
#, fuzzy
msgid "`HAdd`"
msgstr "`HAdd`"

#: src/type-classes/standard-classes.md:16
#, fuzzy
msgid "`x - y`"
msgstr "`x - y`"

#: src/type-classes/standard-classes.md:16
#, fuzzy
msgid "`HSub.hSub x y`"
msgstr "`HSub.hSub x y`"

#: src/type-classes/standard-classes.md:16
#, fuzzy
msgid "`HSub`"
msgstr "`HSub`"

#: src/type-classes/standard-classes.md:17
#, fuzzy
msgid "`x * y`"
msgstr "`x * y`"

#: src/type-classes/standard-classes.md:17
#, fuzzy
msgid "`HMul.hMul x y`"
msgstr "`HMul.hMul x y`"

#: src/type-classes/standard-classes.md:17
#, fuzzy
msgid "`HMul`"
msgstr "`HMul`"

#: src/type-classes/standard-classes.md:18
#, fuzzy
msgid "`x / y`"
msgstr "`x / y`"

#: src/type-classes/standard-classes.md:18
#, fuzzy
msgid "`HDiv.hDiv x y`"
msgstr "`HDiv.hDiv x y`"

#: src/type-classes/standard-classes.md:18
#, fuzzy
msgid "`HDiv`"
msgstr "`HDiv`"

#: src/type-classes/standard-classes.md:19
#, fuzzy
msgid "`x % y`"
msgstr "`x % y`"

#: src/type-classes/standard-classes.md:19
#, fuzzy
msgid "`HMod.hMod x y`"
msgstr "`HMod.hMod x y`"

#: src/type-classes/standard-classes.md:19
#, fuzzy
msgid "`HMod`"
msgstr "`HMod`"

#: src/type-classes/standard-classes.md:20
#, fuzzy
msgid "`x ^ y`"
msgstr "`x ^ y`"

#: src/type-classes/standard-classes.md:20
#, fuzzy
msgid "`HPow.hPow x y`"
msgstr "`HPow.hPow x y`"

#: src/type-classes/standard-classes.md:20
#, fuzzy
msgid "`HPow`"
msgstr "`HPow`"

#: src/type-classes/standard-classes.md:21
#, fuzzy
msgid "`(- x)`"
msgstr "`(- x)`"

#: src/type-classes/standard-classes.md:21
#, fuzzy
msgid "`Neg.neg x`"
msgstr "`Neg.neg x`"

#: src/type-classes/standard-classes.md:21
#, fuzzy
msgid "`Neg`"
msgstr "`Neg`"

#: src/type-classes/standard-classes.md:24
#, fuzzy
msgid "Bitwise Operators"
msgstr "位运算符"

#: src/type-classes/standard-classes.md:26
#, fuzzy
msgid ""
"Lean contains a number of standard bitwise operators that are overloaded "
"using type classes. There are instances for fixed-width types such as "
"`UInt8`, `UInt16`, `UInt32`, `UInt64`, and `USize`. The latter is the size "
"of words on the current platform, typically 32 or 64 bits. The following "
"bitwise operators are overloaded:"
msgstr ""
"Lean 包含许多使用类型类重载的标准位运算符。有针对固定宽度类型（如 `UInt8`、`UInt16`、`UInt32`、`UInt64` 和 "
"`USize`）的实例。后者是当前平台上字的大小，通常为 32 或 64 位。重载了以下位运算符："

#: src/type-classes/standard-classes.md:33
#, fuzzy
msgid "`x &&& y`"
msgstr "`x &&& y`"

#: src/type-classes/standard-classes.md:33
#, fuzzy
msgid "`HAnd.hAnd x y`"
msgstr "`HAnd.hAnd x y`"

#: src/type-classes/standard-classes.md:33
#, fuzzy
msgid "`HAnd`"
msgstr "`HAnd`"

#: src/type-classes/standard-classes.md:34
#, fuzzy
msgid "x \\|\\|\\| y "
msgstr "x \\|\\|\\| y "

#: src/type-classes/standard-classes.md:34
#, fuzzy
msgid "`HOr.hOr x y`"
msgstr "`HOr.hOr x y`"

#: src/type-classes/standard-classes.md:34
#, fuzzy
msgid "`HOr`"
msgstr "`HOr`"

#: src/type-classes/standard-classes.md:35
#, fuzzy
msgid "`x ^^^ y`"
msgstr "`x ^^^ y`"

#: src/type-classes/standard-classes.md:35
#, fuzzy
msgid "`HXor.hXor x y`"
msgstr "`HXor.hXor x y`"

#: src/type-classes/standard-classes.md:35
#, fuzzy
msgid "`HXor`"
msgstr "`HXor`"

#: src/type-classes/standard-classes.md:36
#, fuzzy
msgid "`~~~ x`"
msgstr "`~~~ x`"

#: src/type-classes/standard-classes.md:36
#, fuzzy
msgid "`Complement.complement x`"
msgstr "`Complement.complement x`"

#: src/type-classes/standard-classes.md:36
#, fuzzy
msgid "`Complement`"
msgstr "`Complement`"

#: src/type-classes/standard-classes.md:37
#, fuzzy
msgid "`x >>> y`"
msgstr "`x >>> y`"

#: src/type-classes/standard-classes.md:37
#, fuzzy
msgid "`HShiftRight.hShiftRight x y`"
msgstr "`HShiftRight.hShiftRight x y`"

#: src/type-classes/standard-classes.md:37
#, fuzzy
msgid "`HShiftRight`"
msgstr "`HShiftRight`"

#: src/type-classes/standard-classes.md:38
#, fuzzy
msgid "`x <<< y`"
msgstr "`x <<< y`"

#: src/type-classes/standard-classes.md:38
#, fuzzy
msgid "`HShiftLeft.hShiftLeft x y`"
msgstr "`HShiftLeft.hShiftLeft x y`"

#: src/type-classes/standard-classes.md:38
#, fuzzy
msgid "`HShiftLeft`"
msgstr "`HShiftLeft`"

#: src/type-classes/standard-classes.md:40
#, fuzzy
msgid ""
"Because the names `And` and `Or` are already taken as the names of logical "
"connectives, the homogeneous versions of `HAnd` and `HOr` are called `AndOp`"
" and `OrOp` rather than `And` and `Or`."
msgstr ""
"由于 `And` 和 `Or` 已被用作逻辑连接符的名称，因此 `HAnd` 和 `HOr` 的同构版本被称为 `AndOp` 和 `OrOp`，而不是"
" `And` 和 `Or`。"

#: src/type-classes/standard-classes.md:42
#, fuzzy
msgid "Equality and Ordering"
msgstr "相等性和排序"

#: src/type-classes/standard-classes.md:44
#, fuzzy
msgid ""
"Testing equality of two values typically uses the `BEq` class, which is "
"short for \"Boolean equality\". Due to Lean's use as a theorem prover, there"
" are really two kinds of equality operators in Lean:"
msgstr ""
"测试两个值的相等性通常使用 `BEq` 类，它是「布尔相等性」的缩写。由于 Lean 用作定理证明器，因此 Lean 中实际上有两种相等性运算符："

#: src/type-classes/standard-classes.md:46
#, fuzzy
msgid ""
"_Boolean equality_ is the same kind of equality that is found in other "
"programming languages. It is a function that takes two values and returns a "
"`Bool`. Boolean equality is written with two equals signs, just as in Python"
" and C#. Because Lean is a pure functional language, there's no separate "
"notions of reference vs value equality—pointers cannot be observed directly."
msgstr ""
"_布尔相等性_与其他编程语言中发现的相等性类型相同。它是一个函数，它接受两个值并返回一个 `Bool`。布尔相等性用两个等号编写，就像在 Python "
"和 C# 中一样。由于 Lean 是一种纯函数式语言，因此没有引用相等与值相等的单独概念——指针不能直接观察到。"

#: src/type-classes/standard-classes.md:47
#, fuzzy
msgid ""
"_Propositional equality_ is the mathematical statement that two things are "
"equal. Propositional equality is not a function; rather, it is a "
"mathematical statement that admits proof. It is written with a single equals"
" sign. A statement of propositional equality is like a type that classifies "
"evidence of this equality."
msgstr ""
"_命题相等性_是两个事物相等的数学陈述。命题相等性不是一个函数；相反，它是一个承认证明的数学陈述。它用一个等号编写。命题相等性的陈述就像一个类型，它对这种相等性的证据进行分类。"

#: src/type-classes/standard-classes.md:49
#, fuzzy
msgid ""
"Both notions of equality are important, and used for different purposes. "
"Boolean equality is useful in programs, when a decision needs to be made "
"about whether two values are equal. For example, `\"Octopus\" ==  "
"\"Cuttlefish\"` evaluates to `false`, and `\"Octopodes\" ==  \"Octo\".append"
" \"podes\"` evaluates to `true`. Some values, such as functions, cannot be "
"checked for equality. For example, `(fun (x : Nat) => 1 + x) == (Nat.succ "
"·)` yields the error:"
msgstr ""
"这两种相等性的概念都很重要，并且用于不同的目的。布尔相等性在程序中很有用，当需要决定两个值是否相等时。例如，`\"Octopus\" ==  "
"\"Cuttlefish\"` 求值为 `false`，而 `\"Octopodes\" ==  \"Octo\".append \"podes\"` "
"求值为 `true`。某些值（例如函数）无法检查相等性。例如，`fun (x : Nat) => 1 + x) == (Nat.succ ·)` "
"会产生错误："

#: src/type-classes/standard-classes.md:58
#, fuzzy
msgid ""
"As this message indicates, `==` is overloaded using a type class. The "
"expression `x == y` is actually shorthand for `BEq.beq x y`."
msgstr "如该消息所示，`==` 使用类型类进行重载。表达式 `x == y` 实际上是 `BEq.beq x y` 的简写。"

#: src/type-classes/standard-classes.md:61
#, fuzzy
msgid ""
"Propositional equality is a mathematical statement rather than an invocation"
" of a program. Because propositions are like types that describe evidence "
"for some statement, propositional equality has more in common with types "
"like `String` and `Nat → List Int` than it does with Boolean equality. This "
"means that it can't automatically be checked. However, the equality of any "
"two expressions can be stated in Lean, so long as they have the same type. "
"The statement `(fun (x : Nat) => 1 + x) = (Nat.succ ·)` is a perfectly "
"reasonable statement. From the perspective of mathematics, two functions are"
" equal if they map equal inputs to equal outputs, so this statement is even "
"true, though it requires a two-line proof to convince Lean of this fact."
msgstr ""
"命题等价是一个数学陈述，而不是程序调用。由于命题类似于描述某个陈述证据的类型，因此命题等价与 `String` 和 `Nat → List Int` "
"等类型有更多共同点，而不是与布尔等价。这意味着它无法自动检查。但是，只要两个表达式的类型相同，就可以在 Lean 中陈述它们的等价性。陈述 `(fun "
"(x : Nat) => 1 + x) = (Nat.succ ·)` "
"是一个完全合理的陈述。从数学角度来看，如果两个函数将相等的输入映射到相等的输出，则这两个函数相等，因此该陈述甚至为真，尽管需要两行证明才能使 Lean "
"信服这一事实。"

#: src/type-classes/standard-classes.md:68
#, fuzzy
msgid ""
"Generally speaking, when using Lean as a programming language, it's easiest "
"to stick to Boolean functions rather than propositions. However, as the "
"names `true` and `false` for `Bool`'s constructors suggest, this difference "
"is sometimes blurred. Some propositions are _decidable_, which means that "
"they can be checked just like a Boolean function. The function that checks "
"whether the proposition is true or false is called a _decision procedure_, "
"and it returns _evidence_ of the truth or falsity of the proposition. Some "
"examples of decidable propositions include equality and inequality of "
"natural numbers, equality of strings, and \"ands\" and \"ors\" of "
"propositions that are themselves decidable."
msgstr ""
"一般来说，在将 Lean 用作编程语言时，最简单的方法是坚持使用布尔函数，而不是命题。但是，正如 `Bool` 构造子的名称 `true` 和 "
"`false` 所示，这种差异有时会变得模糊。一些命题是 _可判定的_，这意味着它们可以像布尔函数一样被检查。检查命题真假的功能称为 "
"_判定程序_，它返回命题真假性的 _证据_。可判定的命题的一些示例包括自然数的相等性和不等性、字符串的相等性以及本身可判定的命题的「与」和「或」。"

#: src/type-classes/standard-classes.md:74
#, fuzzy
msgid ""
"In Lean, `if` works with decidable propositions. For example, `2 < 4` is a "
"proposition:"
msgstr "在 Lean 中，`if` 适用于可判定命题。例如，`2 < 4` 是一个命题："

#: src/type-classes/standard-classes.md:82
#, fuzzy
msgid ""
"Nonetheless, it is perfectly acceptable to write it as the condition in an "
"`if`. For example, `if 2 < 4 then 1 else 2` has type `Nat` and evaluates to "
"`1`."
msgstr ""
"尽管如此，将其作为 `if` 中的条件来编写是完全可以接受的。例如，`if 2 < 4 then 1 else 2` 的类型为 `Nat`，并求值为 "
"`1`。"

#: src/type-classes/standard-classes.md:86
#, fuzzy
msgid ""
"Not all propositions are decidable. If they were, then computers would be "
"able to prove any true proposition just by running the decision procedure, "
"and mathematicians would be out of a job. More specifically, decidable "
"propositions have an instance of the `Decidable` type class which has a "
"method that is the decision procedure. Trying to use a proposition that "
"isn't decidable as if it were a `Bool` results in a failure to find the "
"`Decidable` instance. For example, `if (fun (x : Nat) => 1 + x) = (Nat.succ "
"·) then \"yes\" else \"no\"` results in:"
msgstr ""
"并非所有命题都是可判定的。如果它们是可判定的，那么计算机将能够通过运行判定过程来证明任何真命题，而数学家将失业。更具体地说，可判定命题具有 "
"`Decidable` 类型类的实例，该实例具有作为判定过程的方法。尝试将不可判定的命题用作 `Bool` 会导致找不到 `Decidable` "
"实例。例如，`if (fun (x : Nat) => 1 + x) = (Nat.succ ·) then \"yes\" else \"no\"` "
"会导致："

#: src/type-classes/standard-classes.md:96
#, fuzzy
msgid ""
"The following propositions, that are usually decidable, are overloaded with "
"type classes:"
msgstr "以下命题通常是可判定的，它们与类型类重载："

#: src/type-classes/standard-classes.md:100
#: src/programs-proofs/arrays-termination.md:21
#, fuzzy
msgid "`x < y`"
msgstr "`x < y`"

#: src/type-classes/standard-classes.md:100
#: src/programs-proofs/arrays-termination.md:21
#, fuzzy
msgid "`LT.lt x y`"
msgstr "`LT.lt x y`"

#: src/type-classes/standard-classes.md:100
#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:21
#: src/programs-proofs/arrays-termination.md:23
#, fuzzy
msgid "`LT`"
msgstr "`LT`"

#: src/type-classes/standard-classes.md:101
#: src/programs-proofs/arrays-termination.md:22
#, fuzzy
msgid "`x ≤ y`"
msgstr "`x ≤ y`"

#: src/type-classes/standard-classes.md:101
#: src/programs-proofs/arrays-termination.md:22
#, fuzzy
msgid "`LE.le x y`"
msgstr "`LE.le x y`"

#: src/type-classes/standard-classes.md:101
#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:22
#: src/programs-proofs/arrays-termination.md:24
#, fuzzy
msgid "`LE`"
msgstr "`LE`"

#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:23
#, fuzzy
msgid "`x > y`"
msgstr "`x > y`"

#: src/type-classes/standard-classes.md:102
#: src/programs-proofs/arrays-termination.md:23
#, fuzzy
msgid "`LT.lt y x`"
msgstr "`LT.lt y x`"

#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:24
#, fuzzy
msgid "`x ≥ y`"
msgstr "`x ≥ y`"

#: src/type-classes/standard-classes.md:103
#: src/programs-proofs/arrays-termination.md:24
#, fuzzy
msgid "`LE.le y x`"
msgstr "`LE.le y x`"

#: src/type-classes/standard-classes.md:105
#, fuzzy
msgid ""
"Because defining new propositions hasn't yet been demonstrated, it may be "
"difficult to define new instances of `LT` and `LE`."
msgstr "由于尚未演示定义新命题，因此可能难以定义 `LT` 和 `LE` 的新实例。"

#: src/type-classes/standard-classes.md:107
#, fuzzy
msgid ""
"Additionally, comparing values using `<`, `==`, and `>` can be inefficient. "
"Checking first whether one value is less than another, and then whether they"
" are equal, can require two traversals over large data structures. To solve "
"this problem, Java and C# have standard `compareTo` and `CompareTo` methods "
"(respectively) that can be overridden by a class in order to implement all "
"three operations at the same time. These methods return a negative integer "
"if the receiver is less than the argument, zero if they are equal, and a "
"positive integer if the receiver is greater than the argument. Rather than "
"overload the meaning of integers, Lean has a built-in inductive type that "
"describes these three possibilities:"
msgstr ""
"此外，使用 `<`、`==` 和 `>` "
"比较值可能是低效的。首先检查一个值是否小于另一个值，然后检查它们是否相等，可能需要遍历大型数据结构体两次。为了解决这个问题，Java 和 C# "
"分别具有标准的 `compareTo` 和 `CompareTo` "
"方法，可以由类重写以同时实现所有三个操作。如果接收者小于参数，则这些方法返回负整数；如果它们相等，则返回零；如果接收者大于参数，则返回正整数。Lean "
"并没有重载整数的含义，而是内置了一个归纳类型来描述这三种可能性："

#: src/type-classes/standard-classes.md:118
#, fuzzy
msgid ""
"The `Ord` type class can be overloaded to produce these comparisons. For "
"`Pos`, an implementation can be:"
msgstr "`Ord` 类型类可以被重载以产生这些比较。对于 `Pos`，实现可以是："

#: src/type-classes/standard-classes.md:130
#, fuzzy
msgid ""
"In situations where `compareTo` would be the right approach in Java, use "
"`Ord.compare` in Lean."
msgstr "在 Java 中 `compareTo` 是正确方法的情况下，在 Lean 中使用 `Ord.compare`。"

#: src/type-classes/standard-classes.md:132
#, fuzzy
msgid "Hashing"
msgstr "哈希"

#: src/type-classes/standard-classes.md:134
#, fuzzy
msgid ""
"Java and C# have `hashCode` and `GetHashCode` methods, respectively, that "
"compute a hash of a value for use in data structures such as hash tables. "
"The Lean equivalent is a type class called `Hashable`:"
msgstr ""
"Java 和 C# 分别具有 `hashCode` 和 `GetHashCode` "
"方法，它们计算值的哈希，以便在诸如哈希表之类的数据结构体中使用。Lean 等效项是一个称为 `Hashable` 的类型类："

#: src/type-classes/standard-classes.md:140
#, fuzzy
msgid ""
"If two values are considered equal according to a `BEq` instance for their "
"type, then they should have the same hashes. In other words, if `x == y` "
"then `hash x == hash y`. If `x ≠ y`, then `hash x` won't necessarily differ "
"from `hash y` (after all, there are infinitely more `Nat` values than there "
"are `UInt64` values), but data structures built on hashing will have better "
"performance if unequal values are likely to have unequal hashes. This is the"
" same expectation as in Java and C#."
msgstr ""
"如果根据类型的 `BEq` 实例将两个值视为相等，则它们应具有相同的哈希值。换句话说，如果 `x == y`，则 `hash x == hash "
"y`。如果 `x ≠ y`，则 `hash x` 不一定与 `hash y` 不同（毕竟，`Nat` 值比 `UInt64` "
"值多得多），但是如果不相等的值可能具有不相等的哈希值，则基于哈希构建的数据结构体将具有更好的性能。这与 Java 和 C# 中的期望相同。"

#: src/type-classes/standard-classes.md:145
#, fuzzy
msgid ""
"The standard library contains a function `mixHash` with type `UInt64 → "
"UInt64 → UInt64` that can be used to combine hashes for different fields for"
" a constructor. A reasonable hash function for an inductive datatype can be "
"written by assigning a unique number to each constructor, and then mixing "
"that number with the hashes of each field. For example, a `Hashable` "
"instance for `Pos` can be written:"
msgstr ""
"标准库包含一个类型为 `UInt64 → UInt64 → UInt64` 的函数 "
"`mixHash`，该函数可用于组合构造子的不同字段的哈希值。可以通过为每个构造子分配一个唯一数字，然后将该数字与每个字段的哈希值混合来编写归纳数据类型的合理哈希函数。例如，可以编写"
" `Pos` 的 `Hashable` 实例："

#: src/type-classes/standard-classes.md:156
#, fuzzy
msgid ""
"`Hashable` instances for polymorphic types can use recursive instance "
"search. Hashing a `NonEmptyList α` is only possible when `α` can be hashed:"
msgstr ""
"多态类型的 `Hashable` 实例可以使用递归实例搜索。仅当 `α` 可以被哈希时，才能对 `NonEmptyList α` 进行哈希："

#: src/type-classes/standard-classes.md:162
#, fuzzy
msgid ""
"Binary trees use both recursion and recursive instance search in the "
"implementations of `BEq` and `Hashable`:"
msgstr "二叉树在 `BEq` 和 `Hashable` 的实现中同时使用递归和递归实例搜索："

#: src/type-classes/standard-classes.md:190
#, fuzzy
msgid "Deriving Standard Classes"
msgstr "派生标准类"

#: src/type-classes/standard-classes.md:192
#, fuzzy
msgid ""
"Instance of classes like `BEq` and `Hashable` are often quite tedious to "
"implement by hand. Lean includes a feature called _instance deriving_ that "
"allows the compiler to automatically construct well-behaved instances of "
"many type classes. In fact, the `deriving Repr` phrase in the definition of "
"`Point` in the [section on structures](../getting-to-know/structures.md) is "
"an example of instance deriving."
msgstr ""
"`BEq` 和 `Hashable` 等类的实例通常很难手动实现。Lean 包含一个称为 _实例派生_ "
"的特性，允许编译器自动构建许多类型类的行为良好的实例。事实上，[结构体部分](../getting-to-know/structures.md) 中 "
"`Point` 定义中的 `deriving Repr` 短语就是实例派生的一个例子。"

#: src/type-classes/standard-classes.md:196
#, fuzzy
msgid ""
"Instances can be derived in two ways. The first can be used when defining a "
"structure or inductive type. In this case, add `deriving` to the end of the "
"type declaration followed by the names of the classes for which instances "
"should be derived. For a type that is already defined, a standalone "
"`deriving` command can be used. Write `deriving instance C1, C2, ... for T` "
"to derive instances of `C1, C2, ...` for the type `T` after the fact."
msgstr ""
"实例可以通过两种方式派生。第一种可以在定义结构体或归纳类型时使用。在这种情况下，在类型声明的末尾添加 "
"`deriving`，后跟应该派生实例的类的名称。对于已经定义的类型，可以使用独立的 `deriving` 命令。在 `T` 类型之后编写 "
"`deriving instance C1, C2, ... for T` 以派生 `C1, C2, ...` 的实例。"

#: src/type-classes/standard-classes.md:202
#, fuzzy
msgid ""
"`BEq` and `Hashable` instances can be derived for `Pos` and `NonEmptyList` "
"using a very small amount of code:"
msgstr "可以使用极少量的代码为 `Pos` 和 `NonEmptyList` 派生 `BEq` 和 `Hashable` 实例："

#: src/type-classes/standard-classes.md:208
#, fuzzy
msgid "Instances can be derived for at least the following classes:"
msgstr "至少可以为以下类派生实例："

#: src/type-classes/standard-classes.md:209
#, fuzzy
msgid "`Inhabited`"
msgstr "`Inhabited`"

#: src/type-classes/standard-classes.md:210
#, fuzzy
msgid "`BEq`"
msgstr "`BEq`"

#: src/type-classes/standard-classes.md:211
#, fuzzy
msgid "`Repr`"
msgstr "`Repr`"

#: src/type-classes/standard-classes.md:212
#, fuzzy
msgid "`Hashable`"
msgstr "`Hashable`"

#: src/type-classes/standard-classes.md:213
#, fuzzy
msgid "`Ord`"
msgstr "`Ord`"

#: src/type-classes/standard-classes.md:215
#, fuzzy
msgid ""
"In some cases, however, the derived `Ord` instance may not produce precisely"
" the ordering desired in an application. When this is the case, it's fine to"
" write an `Ord` instance by hand. The collection of classes for which "
"instances can be derived can be extended by advanced users of Lean."
msgstr ""
"然而，在某些情况下，派生的 `Ord` 实例可能无法产生应用程序中所需的精确排序。在这种情况下，手动编写 `Ord` 实例是可以的。高级 Lean "
"用户可以扩展可以派生实例的类的集合。"

#: src/type-classes/standard-classes.md:219
#, fuzzy
msgid ""
"Aside from the clear advantages in programmer productivity and code "
"readability, deriving instances also makes code easier to maintain, because "
"the instances are updated as the definitions of types evolve. Changesets "
"involving updates to datatypes are easier to read without line after line of"
" formulaic modifications to equality tests and hash computation."
msgstr ""
"除了在程序员生产力和代码可读性方面的明显优势之外，派生实例还使代码更容易维护，因为实例会随着类型定义的演变而更新。涉及数据类型更新的变更集更容易阅读，而无需对相等性测试和哈希计算进行逐行公式化修改。"

#: src/type-classes/standard-classes.md:222
#, fuzzy
msgid "Appending"
msgstr "追加"

#: src/type-classes/standard-classes.md:224
#, fuzzy
msgid ""
"Many datatypes have some sort of append operator. In Lean, appending two "
"values is overloaded with the type class `HAppend`, which is a heterogeneous"
" operation like that used for arithmetic operations:"
msgstr ""
"许多数据类型都有某种追加运算符。在 Lean 中，追加两个值使用类型类 `HAppend` 进行重载，这是一个异构操作，类似于用于算术操作的操作："

#: src/type-classes/standard-classes.md:230
#, fuzzy
msgid ""
"The syntax `xs ++ ys` desugars to `HAppend.hAppend xs ys`. For homogeneous "
"cases, it's enough to implement an instance of `Append`, which follows the "
"usual pattern:"
msgstr ""
"`xs ++ ys` 语法糖化为 `HAppend.hAppend xs ys`。对于同构情况，只需实现 `Append` "
"的一个实例，它遵循通常的模式："

#: src/type-classes/standard-classes.md:238
#, fuzzy
msgid "After defining the above instance,"
msgstr "定义上述实例后，"

#: src/type-classes/standard-classes.md:242
#, fuzzy
msgid "has the following output:"
msgstr "具有以下输出："

#: src/type-classes/standard-classes.md:243
#, fuzzy
msgid ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"tail := [\"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\",\n"
"         \"Banded Garden Spider\",\n"
"         \"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\"] }\n"
"```"
msgstr ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"tail := [\"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\",\n"
"         \"Banded Garden Spider\",\n"
"         \"Long-legged Sac Spider\",\n"
"         \"Wolf Spider\",\n"
"         \"Hobo Spider\",\n"
"         \"Cat-faced Spider\"] }\n"
"```"

#: src/type-classes/standard-classes.md:256
#, fuzzy
msgid ""
"Similarly, a definition of `HAppend` allows non-empty lists to be appended "
"to ordinary lists:"
msgstr "类似地，`HAppend` 的定义允许将非空列表追加到普通列表："

#: src/type-classes/standard-classes.md:262
#, fuzzy
msgid "With this instance available,"
msgstr "使用此实例，"

#: src/type-classes/standard-classes.md:263
#, fuzzy
msgid ""
"```lean\n"
"#eval idahoSpiders ++ [\"Trapdoor Spider\"]\n"
"```"
msgstr ""
"```lean\n"
"#eval idahoSpiders ++ [\"Trapdoor Spider\"]\n"
"```"

#: src/type-classes/standard-classes.md:267
#, fuzzy
msgid ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"  tail := [\"Long-legged Sac Spider\", \"Wolf Spider\", \"Hobo Spider\", \"Cat-faced Spider\", \"Trapdoor Spider\"] }\n"
"```"
msgstr ""
"```output info\n"
"{ head := \"Banded Garden Spider\",\n"
"  tail := [\"Long-legged Sac Spider\", \"Wolf Spider\", \"Hobo Spider\", \"Cat-faced Spider\", \"Trapdoor Spider\"] }\n"
"```"

#: src/type-classes/standard-classes.md:272 src/type-classes/summary.md:40
#, fuzzy
msgid "Functors"
msgstr "函子"

#: src/type-classes/standard-classes.md:274
#, fuzzy
msgid ""
"A polymorphic type is a _functor_ if it has an overload for a function named"
" `map` that transforms every element contained in it by a function. While "
"most languages use this terminology, C#'s equivalent to `map` is called "
"`System.Linq.Enumerable.Select`. For example, mapping a function over a list"
" constructs a new list in which each entry from the starting list has been "
"replaced by the result of the function on that entry. Mapping a function `f`"
" over an `Option` leaves `none` untouched, and replaces `some x` with `some "
"(f x)`."
msgstr ""
"如果多态类型具有名为 `map` 的函数的重载，该函数通过函数转换其中包含的每个元素，则该多态类型是一个 _函子_。虽然大多数语言都使用此术语，但 C#"
" 中等效于 `map` 的函数称为 "
"`System.Linq.Enumerable.Select`。例如，将函数映射到列表上会构造一个新列表，其中起始列表中的每个条目都已替换为该条目上函数的结果。将函数"
" `f` 映射到 `Option` 上会保留 `none` 不变，并将 `some x` 替换为 `some (f x)`。"

#: src/type-classes/standard-classes.md:279
#, fuzzy
msgid ""
"Here are some examples of functors and how their `Functor` instances "
"overload `map`:"
msgstr "以下是函子的示例，以及它们的 `Functor` 实例如何重载 `map`："

#: src/type-classes/standard-classes.md:280
#, fuzzy
msgid "`Functor.map (· + 5) [1, 2, 3]` evaluates to `[6, 7, 8]`"
msgstr "`Functor.map (· + 5) [1, 2, 3]` 计算结果为 `[6, 7, 8]`"

#: src/type-classes/standard-classes.md:281
#, fuzzy
msgid ""
"`Functor.map toString (some (List.cons 5 List.nil))` evaluates to `some "
"\"[5]\"`"
msgstr "`Functor.map toString (some (List.cons 5 List.nil))` 计算结果为 `some \"[5]\"`"

#: src/type-classes/standard-classes.md:282
#, fuzzy
msgid ""
"`Functor.map List.reverse [[1, 2, 3], [4, 5, 6]]` evaluates to `[[3, 2, 1], "
"[6, 5, 4]]`"
msgstr ""
"`Functor.map List.reverse [[1, 2, 3], [4, 5, 6]]` 计算结果为 `[[3, 2, 1], [6, 5, "
"4]]`"

#: src/type-classes/standard-classes.md:284
#, fuzzy
msgid ""
"Because `Functor.map` is a bit of a long name for this common operation, "
"Lean also provides an infix operator for mapping a function, namely `<$>`. "
"The prior examples can be rewritten as follows:"
msgstr ""
"由于 `Functor.map` 对于此常见操作而言名称有点长，因此 Lean 还提供了一个用于映射函数的中缀运算符，即 "
"`<$>`。前面的示例可以重写如下："

#: src/type-classes/standard-classes.md:286
#, fuzzy
msgid "`(· + 5) <$> [1, 2, 3]` evaluates to `[6, 7, 8]`"
msgstr "`(· + 5) <$> [1, 2, 3]` 计算结果为 `[6, 7, 8]`"

#: src/type-classes/standard-classes.md:287
#, fuzzy
msgid "`toString <$> (some (List.cons 5 List.nil))` evaluates to `some \"[5]\"`"
msgstr "`toString <$> (some (List.cons 5 List.nil))` 计算结果为 `some \"[5]\"`"

#: src/type-classes/standard-classes.md:288
#, fuzzy
msgid ""
"`List.reverse <$> [[1, 2, 3], [4, 5, 6]]` evaluates to `[[3, 2, 1], [6, 5, "
"4]]`"
msgstr ""
"`List.reverse <$> [[1, 2, 3], [4, 5, 6]]` 计算结果为 `[[3, 2, 1], [6, 5, 4]]`"

#: src/type-classes/standard-classes.md:290
#, fuzzy
msgid ""
"An instance of `Functor` for `NonEmptyList` requires specifying the `map` "
"function."
msgstr "`NonEmptyList` 的 `Functor` 实例需要指定 `map` 函数。"

#: src/type-classes/standard-classes.md:295
#, fuzzy
msgid ""
"Here, `map` uses the `Functor` instance for `List` to map the function over "
"the tail. This instance is defined for `NonEmptyList` rather than for "
"`NonEmptyList α` because the argument type `α` plays no role in resolving "
"the type class. A `NonEmptyList` can have a function mapped over it _no "
"matter what the type of entries is_. If `α` were a parameter to the class, "
"then it would be possible to make versions of `Functor` that only worked for"
" `NonEmptyList Nat`, but part of being a functor is that `map` works for any"
" entry type."
msgstr ""
"此处，`map` 使用 `List` 的 `Functor` 实例将函数映射到尾部。此实例针对 `NonEmptyList` 定义，而不是针对 "
"`NonEmptyList α` 定义，因为参数类型 `α` 在解析类型类时不起作用。`NonEmptyList` "
"可以映射一个函数，_无论条目类型是什么_。如果 `α` 是类的参数，那么可以制作仅适用于 `NonEmptyList Nat` 的 `Functor` "
"版本，但成为函子的部分原因是 `map` 适用于任何条目类型。"

#: src/type-classes/standard-classes.md:300
#, fuzzy
msgid "Here is an instance of `Functor` for `PPoint`:"
msgstr "以下是 `PPoint` 的 `Functor` 实例："

#: src/type-classes/standard-classes.md:305
#, fuzzy
msgid "In this case, `f` has been applied to both `x` and `y`."
msgstr "在这种情况下，`f` 已应用于 `x` 和 `y`。"

#: src/type-classes/standard-classes.md:307
#, fuzzy
msgid ""
"Even when the type contained in a functor is itself a functor, mapping a "
"function only goes down one layer. That is, when using `map` on a "
"`NonEmptyList (PPoint Nat)`, the function being mapped should take `PPoint "
"Nat` as its argument rather than `Nat`."
msgstr ""
"即使函子中包含的类型本身也是函子，映射函数也只向下移动一层。也就是说，在 `NonEmptyList (PPoint Nat)` 上使用 `map` "
"时，要映射的函数应以 `PPoint Nat` 作为其参数，而不是 `Nat`。"

#: src/type-classes/standard-classes.md:310
#, fuzzy
msgid ""
"The definition of the `Functor` class uses one more language feature that "
"has not yet been discussed: default method definitions. Normally, a class "
"will specify some minimal set of overloadable operations that make sense "
"together, and then use polymorphic functions with instance implicit "
"arguments that build on the overloaded operations to provide a larger "
"library of features. For example, the function `concat` can concatenate any "
"non-empty list whose entries are appendable:"
msgstr ""
"`Functor` "
"类的定义使用了另一项尚未讨论的语言特性：默认方法定义。通常，一个类会指定一些有意义的最小可重载操作集，然后使用具有实例隐式参数的多态函数，基于这些可重载操作构建一个更大的特性库。例如，函数"
" `concat` 可以连接任何非空列表，其条目可追加："

#: src/type-classes/standard-classes.md:320
#, fuzzy
msgid ""
"However, for some classes, there are operations that can be more efficiently"
" implemented with knowledge of the internals of a datatype."
msgstr "然而，对于某些类，有一些操作可以通过了解数据类型的内部结构体更有效地实现。"

#: src/type-classes/standard-classes.md:322
#, fuzzy
msgid ""
"In these cases, a default method definition can be provided. A default "
"method definition provides a default implementation of a method in terms of "
"the other methods. However, instance implementors may choose to override "
"this default with something more efficient. Default method definitions "
"contain `:=` in a `class` definition."
msgstr ""
"在这些情况下，可以提供默认方法定义。默认方法定义提供了方法的默认实现，该实现基于其他方法。但是，实例实现者可以选择用更有效的方法覆盖此默认值。默认方法定义在"
" `class` 定义中包含 `:=`。"

#: src/type-classes/standard-classes.md:327
#, fuzzy
msgid ""
"In the case of `Functor`, some types have a more efficient way of "
"implementing `map` when the function being mapped ignores its argument. "
"Functions that ignore their arguments are called _constant functions_ "
"because they always return the same value. Here is the definition of "
"`Functor`, in which `mapConst` has a default implementation:"
msgstr ""
"对于 `Functor`，当被映射的函数忽略其参数时，某些类型具有更有效的方法来实现 `map`。忽略其参数的函数称为 "
"_常量函数_，因为它们始终返回相同的值。以下是 `Functor` 的定义，其中 `mapConst` 具有默认实现："

#: src/type-classes/standard-classes.md:338
#, fuzzy
msgid ""
"Just as a `Hashable` instance that doesn't respect `BEq` is buggy, a "
"`Functor` instance that moves around the data as it maps the function is "
"also buggy. For example, a buggy `Functor` instance for `List` might throw "
"away its argument and always return the empty list, or it might reverse the "
"list. A bad instance for `PPoint` might place `f x` in both the `x` and the "
"`y` fields. Specifically, `Functor` instances should follow two rules:"
msgstr ""
"就像不遵守 `BEq` 的 `Hashable` 实例有缺陷一样，在映射函数时移动数据的 `Functor` 实例也有缺陷。例如，`List` "
"的一个有缺陷的 `Functor` 实例可能会丢弃其参数并始终返回空列表，或者它可能会反转列表。`PPoint` 的一个错误实例可能会将 `f x` "
"放在 `x` 和 `y` 字段中。具体来说，`Functor` 实例应遵循两条规则："

#: src/type-classes/standard-classes.md:342
#, fuzzy
msgid "Mapping the identity function should result in the original argument."
msgstr "映射恒等函数应产生原始参数。"

#: src/type-classes/standard-classes.md:343
#, fuzzy
msgid ""
"Mapping two composed functions should have the same effect as composing "
"their mapping."
msgstr "映射两个复合函数应与复合它们的映射具有相同的效果。"

#: src/type-classes/standard-classes.md:345
#, fuzzy
msgid ""
"More formally, the first rule says that `id <$> x` equals `x`. The second "
"rule says that `map (fun y => f (g y)) x` equals `map f (map g x)`. The "
"composition `fun y => f (g y)` can also be written `f ∘ g`. These rules "
"prevent implementations of `map` that move the data around or delete some of"
" it."
msgstr ""
"更正式地说，第一条规则指出 `id <$> x` 等于 `x`。第二条规则指出 `map (fun y => f (g y)) x` 等于 `map f"
" (map g x)`。复合 `fun y => f (g y)` 也可以写成 `f ∘ g`。这些规则阻止了移动数据或删除部分数据的 `map` "
"实现。"

#: src/type-classes/standard-classes.md:352
#, fuzzy
msgid ""
"Lean is not able to derive instances for all classes. For example, the code"
msgstr "Lean 无法为所有类派生实例。例如，代码"

#: src/type-classes/standard-classes.md:361
#, fuzzy
msgid ""
"Invoking `deriving instance` causes Lean to consult an internal table of "
"code generators for type class instances. If the code generator is found, "
"then it is invoked on the provided type to create the instance. This "
"message, however, means that no code generator was found for `ToString`."
msgstr ""
"调用 `deriving instance` 会导致 Lean "
"查找类型类实例的代码生成器内部表。如果找到代码生成器，则会调用它对提供的类型创建实例。然而，此消息表示未找到 `ToString` 的代码生成器。"

#: src/type-classes/standard-classes.md:367
#, fuzzy
msgid ""
"Write an instance of `HAppend (List α) (NonEmptyList α) (NonEmptyList α)` "
"and test it."
msgstr "编写 `HAppend (List α) (NonEmptyList α) (NonEmptyList α)` 的实例并对其进行测试。"

#: src/type-classes/standard-classes.md:368
#, fuzzy
msgid "Implement a `Functor` instance for the binary tree datatype."
msgstr "为二叉树数据类型实现一个 `Functor` 实例。"

#: src/type-classes/coercion.md:3
#, fuzzy
msgid ""
"In mathematics, it is common to use the same symbol to stand for different "
"aspects of some object in different contexts. For example, if a ring is "
"referred to in a context where a set is expected, then it is understood that"
" the ring's underlying set is what's intended. In programming languages, it "
"is common to have rules to automatically translate values of one type into "
"values of another type. For instance, Java allows a `byte` to be "
"automatically promoted to an `int`, and Kotlin allows a non-nullable type to"
" be used in a context that expects a nullable version of the type."
msgstr ""
"在数学中，通常使用相同的符号来表示不同上下文中某个对象的各个方面。例如，如果在需要集合的上下文中引用环，则理解为该环的底层集合是预期的。在编程语言中，通常有规则将一种类型的变量自动转换为另一种类型的变量。例如，Java"
" 允许将 `byte` 自动提升为 `int`，而 Kotlin 允许在需要该类型的可空版本上下文中使用不可空类型。"

#: src/type-classes/coercion.md:8
#, fuzzy
msgid ""
"In Lean, both purposes are served by a mechanism called _coercions_. When "
"Lean encounters an expression of one type in a context that expects a "
"different type, it will attempt to coerce the expression before reporting a "
"type error. Unlike Java, C, and Kotlin, the coercions are extensible by "
"defining instances of type classes."
msgstr ""
"在 Lean 中，这两种目的都由一种称为 _强制转换_ 的机制实现。当 Lean "
"在需要不同类型的上下文中遇到一种类型的表达式时，它将在报告类型错误之前尝试强制转换该表达式。与 Java、C 和 Kotlin "
"不同，强制转换可以通过定义类型类的实例进行扩展。"

#: src/type-classes/coercion.md:14
#, fuzzy
msgid ""
"For example, every positive number corresponds to a natural number. The "
"function `Pos.toNat` that was defined earlier converts a `Pos` to the "
"corresponding `Nat`:"
msgstr "例如，每个正数都对应一个自然数。前面定义的函数 `Pos.toNat` 将 `Pos` 转换为相应的 `Nat`："

#: src/type-classes/coercion.md:21
#, fuzzy
msgid ""
"The function `List.drop`, with type `{α : Type} → Nat → List α → List α`, "
"removes a prefix of a list. Applying `List.drop` to a `Pos`, however, leads "
"to a type error:"
msgstr ""
"函数 `List.drop`，类型为 `{α : Type} → Nat → List α → List α`，用于移除列表的前缀。然而，将 "
"`List.drop` 应用于 `Pos` 会导致类型错误："

#: src/type-classes/coercion.md:36
#, fuzzy
msgid ""
"Because the author of `List.drop` did not make it a method of a type class, "
"it can't be overridden by defining a new instance."
msgstr "由于 `List.drop` 的作者没有将其设为类型类的函数，因此无法通过定义新实例来重写它。"

#: src/type-classes/coercion.md:38
#, fuzzy
msgid ""
"The type class `Coe` describes overloaded ways of coercing from one type to "
"another:"
msgstr "类型类 `Coe` 描述了从一种类型强制转换为另一种类型的重载方式："

#: src/type-classes/coercion.md:43
#, fuzzy
msgid ""
"An instance of `Coe Pos Nat` is enough to allow the prior code to work:"
msgstr "`Coe Pos Nat` 的一个实例足以让之前的代码工作："

#: src/type-classes/coercion.md:53
#, fuzzy
msgid ""
"Using `#check` shows the result of the instance search that was used behind "
"the scenes:"
msgstr "使用 `#check` 显示了在后台使用的实例搜索结果："

#: src/type-classes/coercion.md:61
#, fuzzy
msgid "Chaining Coercions"
msgstr "链接强制转换"

#: src/type-classes/coercion.md:63
#, fuzzy
msgid ""
"When searching for coercions, Lean will attempt to assemble a coercion out "
"of a chain of smaller coercions. For example, there is already a coercion "
"from `Nat` to `Int`. Because of that instance, combined with the `Coe Pos "
"Nat` instance, the following code is accepted:"
msgstr ""
"在搜索强制转换时，Lean 将尝试从较小的强制转换链中组装一个强制转换。例如，已经存在从 `Nat` 到 `Int` 的强制转换。由于该实例与 `Coe"
" Pos Nat` 实例结合，因此接受以下代码："

#: src/type-classes/coercion.md:69
#, fuzzy
msgid ""
"This definition uses two coercions: from `Pos` to `Nat`, and then from `Nat`"
" to `Int`."
msgstr "此定义使用了两个强制转换：从 `Pos` 到 `Nat`，然后从 `Nat` 到 `Int`。"

#: src/type-classes/coercion.md:71
#, fuzzy
msgid ""
"The Lean compiler does not get stuck in the presence of circular coercions. "
"For example, even if two types `A` and `B` can be coerced to one another, "
"their mutual coercions can be used to find a path:"
msgstr ""
"Lean 编译器不会陷入循环强制转换的存在。例如，即使两个类型 `A` 和 `B` 可以相互强制转换，它们的相互强制转换也可以用来找到一条路径："

#: src/type-classes/coercion.md:91
#, fuzzy
msgid ""
"Remember: the double parentheses `()` is short for the constructor "
"`Unit.unit`. After deriving a `Repr B` instance,"
msgstr "记住：双括号 `()` 是构造子 `Unit.unit` 的缩写。在派生出 `Repr B` 实例后，"

#: src/type-classes/coercion.md:96 src/monad-transformers/conveniences.md:16
#, fuzzy
msgid "results in:"
msgstr "结果为："

#: src/type-classes/coercion.md:101
#, fuzzy
msgid ""
"The `Option` type can be used similarly to nullable types in C# and Kotlin: "
"the `none` constructor represents the absence of a value. The Lean standard "
"library defines a coercion from any type `α` to `Option α` that wraps the "
"value in `some`. This allows option types to be used in a manner even more "
"similar to nullable types, because `some` can be omitted. For instance, the "
"function `List.getLast?` that finds the last entry in a list can be written "
"without a `some` around the return value `x`:"
msgstr ""
"`Option` 类型可以类似于 C# 和 Kotlin 中的可空类型使用：`none` 构造子表示没有值。Lean 标准库定义了一个从任何类型 "
"`α` 到 `Option α` 的强制转换，它将值包装在 `some` 中。这允许以更类似于可空类型的方式使用选项类型，因为可以省略 "
"`some`。例如，查找列表中最后一个条目的函数 `List.getLast?` 可以编写，而无需在返回值 `x` 周围使用 `some`："

#: src/type-classes/coercion.md:111
#, fuzzy
msgid ""
"Instance search finds the coercion, and inserts a call to `coe`, which wraps"
" the argument in `some`. These coercions can be chained, so that nested uses"
" of `Option` don't require nested `some` constructors:"
msgstr ""
"实例搜索找到强制转换，并插入对 `coe` 的调用，该调用将参数包装在 `some` 中。这些强制转换可以链接，这样嵌套使用 `Option` "
"就不需要嵌套 `some` 构造子："

#: src/type-classes/coercion.md:113
#, fuzzy
msgid ""
"```lean\n"
"def perhapsPerhapsPerhaps : Option (Option (Option String)) :=\n"
"  \"Please don't tell me\"\n"
"```"
msgstr ""
"```lean\n"
"def perhapsPerhapsPerhaps : Option (Option (Option String)) :=\n"
"  \"Please don't tell me\"\n"
"```"

#: src/type-classes/coercion.md:118
#, fuzzy
msgid ""
"Coercions are only activated automatically when Lean encounters a mismatch "
"between an inferred type and a type that is imposed from the rest of the "
"program. In cases with other errors, coercions are not activated. For "
"example, if the error is that an instance is missing, coercions will not be "
"used:"
msgstr ""
"只有当 Lean "
"遇到推断类型与程序其余部分强加的类型不匹配时，强制转换才会自动激活。在其他错误的情况下，不会激活强制转换。例如，如果错误是缺少实例，则不会使用强制转换："

#: src/type-classes/coercion.md:130
#, fuzzy
msgid ""
"This can be worked around by manually indicating the desired type to be used"
" for `OfNat`:"
msgstr "可以通过手动指示要用于 `OfNat` 的所需类型来解决此问题："

#: src/type-classes/coercion.md:135
#, fuzzy
msgid "Additionally, coercions can be manually inserted using an up arrow:"
msgstr "此外，可以使用向上箭头手动插入强制转换："

#: src/type-classes/coercion.md:140
#, fuzzy
msgid ""
"In some cases, this can be used to ensure that Lean finds the right "
"instances. It can also make the programmer's intentions more clear."
msgstr "在某些情况下，这可用于确保 Lean 找到正确的实例。它还可以使程序员的意图更加清晰。"

#: src/type-classes/coercion.md:144
#, fuzzy
msgid "Non-Empty Lists and Dependent Coercions"
msgstr "非空列表和依赖强制转换"

#: src/type-classes/coercion.md:146
#, fuzzy
msgid ""
"An instance of `Coe α β` makes sense when the type `β` has a value that can "
"represent each value from the type `α`. Coercing from `Nat` to `Int` makes "
"sense, because the type `Int` contains all the natural numbers. Similarly, a"
" coercion from non-empty lists to ordinary lists makes sense because the "
"`List` type can represent every non-empty list:"
msgstr ""
"当类型 `β` 具有可以表示类型 `α` 中每个值的值时，`Coe α β` 的实例才有意义。从 `Nat` 强制转换为 `Int` 是有意义的，因为 "
"`Int` 类型包含所有自然数。类似地，从非空列表到普通列表的强制转换是有意义的，因为 `List` 类型可以表示每个非空列表："

#: src/type-classes/coercion.md:154
#, fuzzy
msgid "This allows non-empty lists to be used with the entire `List` API."
msgstr "这允许使用整个 `List` API 来处理非空列表。"

#: src/type-classes/coercion.md:156
#, fuzzy
msgid ""
"On the other hand, it is impossible to write an instance of `Coe (List α) "
"(NonEmptyList α)`, because there's no non-empty list that can represent the "
"empty list. This limitation can be worked around by using another version of"
" coercions, which are called _dependent coercions_. Dependent coercions can "
"be used when the ability to coerce from one type to another depends on which"
" particular value is being coerced. Just as the `OfNat` type class takes the"
" particular `Nat` being overloaded as a parameter, dependent coercion takes "
"the value being coerced as a parameter:"
msgstr ""
"另一方面，不可能编写 `Coe (List α) (NonEmptyList α)` 的实例，因为没有非空列表可以表示空列表。可以通过使用另一种称为 "
"_依赖强制转换_ 的强制转换版本来解决此限制。当从一种类型强制转换为另一种类型的可能性取决于要强制转换的特定值时，可以使用依赖强制转换。就像 "
"`OfNat` 类型类将作为参数重载的特定 `Nat` 作为参数一样，依赖强制转换将要强制转换的值作为参数："

#: src/type-classes/coercion.md:164
#, fuzzy
msgid ""
"This is a chance to select only certain values, either by imposing further "
"type class constraints on the value or by writing certain constructors "
"directly. For example, any `List` that is not actually empty can be coerced "
"to a `NonEmptyList`:"
msgstr ""
"通过施加进一步的类型类约束或直接编写某些构造子，可以选择仅选择某些值。例如，任何非空的 `List` 都可以强制转换为 `NonEmptyList`："

#: src/type-classes/coercion.md:171
#, fuzzy
msgid "Coercing to Types"
msgstr "强制转换为类型"

#: src/type-classes/coercion.md:173
#, fuzzy
msgid ""
"In mathematics, it is common to have a concept that consists of a set "
"equipped with additional structure. For example, a monoid is some set _S_, "
"an element _s_ of _S_, and an associative binary operator on _S_, such that "
"_s_ is neutral on the left and right of the operator. _S_ is referred to as "
"the \"carrier set\" of the monoid. The natural numbers with zero and "
"addition form a monoid, because addition is associative and adding zero to "
"any number is the identity. Similarly, the natural numbers with one and "
"multiplication also form a monoid. Monoids are also widely used in "
"functional programming: lists, the empty list, and the append operator form "
"a monoid, as do strings, the empty string, and string append:"
msgstr ""
"在数学中，通常有一个概念，它由一个带有附加结构体的集合组成。例如，一个幺半群是一些集合 _S_，_S_ 的元素 _s_ 和 _S_ "
"上的关联二元运算符，使得 _s_ 是运算符左右的单位元。_S_ "
"被称为幺半群的「载体集合」。带有零和加法的自然数形成一个幺半群，因为加法是关联的，并且将零加到任何数都是恒等式。类似地，带有乘法的自然数也形成一个幺半群。幺半群在函数式编程中也广泛使用：列表、空列表和追加运算符形成一个幺半群，字符串、空字符串和字符串追加也是如此："

#: src/type-classes/coercion.md:179
#, fuzzy
msgid ""
"```lean\n"
"structure Monoid where\n"
"  Carrier : Type\n"
"  neutral : Carrier\n"
"  op : Carrier → Carrier → Carrier\n"
"\n"
"def natMulMonoid : Monoid :=\n"
"  { Carrier := Nat, neutral := 1, op := (· * ·) }\n"
"\n"
"def natAddMonoid : Monoid :=\n"
"  { Carrier := Nat, neutral := 0, op := (· + ·) }\n"
"\n"
"def stringMonoid : Monoid :=\n"
"  { Carrier := String, neutral := \"\", op := String.append }\n"
"\n"
"def listMonoid (α : Type) : Monoid :=\n"
"  { Carrier := List α, neutral := [], op := List.append }\n"
"```"
msgstr ""
"```lean\n"
"structure Monoid where\n"
"  Carrier : Type\n"
"  neutral : Carrier\n"
"  op : Carrier → Carrier → Carrier\n"
"\n"
"def natMulMonoid : Monoid :=\n"
"  { Carrier := Nat, neutral := 1, op := (· * ·) }\n"
"\n"
"def natAddMonoid : Monoid :=\n"
"  { Carrier := Nat, neutral := 0, op := (· + ·) }\n"
"\n"
"def stringMonoid : Monoid :=\n"
"  { Carrier := String, neutral := \"\", op := String.append }\n"
"\n"
"def listMonoid (α : Type) : Monoid :=\n"
"  { Carrier := List α, neutral := [], op := List.append }\n"
"```"

#: src/type-classes/coercion.md:197
#, fuzzy
msgid ""
"Given a monoid, it is possible to write the `foldMap` function that, in a "
"single pass, transforms the entries in a list into a monoid's carrier set "
"and then combines them using the monoid's operator. Because monoids have a "
"neutral element, there is a natural result to return when the list is empty,"
" and because the operator is associative, clients of the function don't have"
" to care whether the recursive function combines elements from left to right"
" or from right to left."
msgstr ""
"给定一个幺半群，可以编写 `foldMap` "
"函数，它在一遍遍历中将列表中的条目转换为幺半群的载体集合，然后使用幺半群的运算符将它们组合起来。由于幺半群具有单位元，因此当列表为空时，可以返回一个自然结果，并且由于运算符是关联的，因此函数的客户端不必关心递归函数是从左到右还是从右到左组合元素。"

#: src/type-classes/coercion.md:207
#, fuzzy
msgid ""
"Even though a monoid consists of three separate pieces of information, it is"
" common to just refer to the monoid's name in order to refer to its set. "
"Instead of saying \"Let A be a monoid and let _x_ and _y_ be elements of its"
" carrier set\", it is common to say \"Let _A_ be a monoid and let _x_ and "
"_y_ be elements of _A_\". This practice can be encoded in Lean by defining a"
" new kind of coercion, from the monoid to its carrier set."
msgstr ""
"尽管幺半群由三部分独立的信息组成，但通常只引用幺半群的名称来引用其集合。通常不使用“令 A 为幺半群，令 x 和 y "
"为其载体集合的元素”这样的说法，而是使用「令 A 为幺半群，令 x 和 y 为 A 的元素」。可以通过定义从幺半群到其载体集合的新类型强制转换在 "
"Lean 中对这种做法进行编码。"

#: src/type-classes/coercion.md:211
#, fuzzy
msgid ""
"The `CoeSort` class is just like the `Coe` class, with the exception that "
"the target of the coercion must be a _sort_, namely `Type` or `Prop`. The "
"term _sort_ in Lean refers to these types that classify other types—`Type` "
"classifies types that themselves classify data, and `Prop` classifies "
"propositions that themselves classify evidence of their truth. Just as `Coe`"
" is checked when a type mismatch occurs, `CoeSort` is used when something "
"other than a sort is provided in a context where a sort would be expected."
msgstr ""
"`CoeSort` 类与 `Coe` 类类似，但强制转换的目标必须是 _类型_，即 `Type` 或 `Prop`。Lean 中的术语 _类型_ "
"指的是对其他类型进行分类的这些类型——`Type` 对对数据本身进行分类的类型进行分类，`Prop` "
"对对证据本身进行分类的命题进行分类。就像在发生类型不匹配时检查 `Coe` 一样，当在预期出现类型的地方提供了其他内容时，会使用 `CoeSort`。"

#: src/type-classes/coercion.md:215
#, fuzzy
msgid "The coercion from a monoid into its carrier set extracts the carrier:"
msgstr "从幺半群到其载体集合的强制转换提取载体："

#: src/type-classes/coercion.md:220
#, fuzzy
msgid "With this coercion, the type signatures become less bureaucratic:"
msgstr "有了这个强制转换，类型签名变得不那么官僚："

#: src/type-classes/coercion.md:229
#, fuzzy
msgid ""
"Another useful example of `CoeSort` is used to bridge the gap between `Bool`"
" and `Prop`. As discussed in [the section on ordering and "
"equality](standard-classes.md#equality-and-ordering), Lean's `if` expression"
" expects the condition to be a decidable proposition rather than a `Bool`. "
"Programs typically need to be able to branch based on Boolean values, "
"however. Rather than have two kinds of `if` expression, the Lean standard "
"library defines a coercion from `Bool` to the proposition that the `Bool` in"
" question is equal to `true`:"
msgstr ""
"`CoeSort` 的另一个有用的示例用于弥合 `Bool` 和 `Prop` 之间的差距。正如 [关于排序和相等性的章节](standard-"
"classes.md#equality-and-ordering) 中所讨论的，Lean 的 `if` 表达式期望条件是可判定的命题，而不是 "
"`Bool`。然而，程序通常需要能够根据布尔值进行分支。Lean 标准库没有定义两种 `if` 表达式，而是定义了从 `Bool` "
"到命题的强制转换，即有问题的 `Bool` 等于 `true`："

#: src/type-classes/coercion.md:237
#, fuzzy
msgid "In this case, the sort in question is `Prop` rather than `Type`."
msgstr "在这种情况下，讨论的类型是 `Prop` 而不是 `Type`。"

#: src/type-classes/coercion.md:239
#, fuzzy
msgid "Coercing to Functions"
msgstr "强制转换为函数"

#: src/type-classes/coercion.md:241
#, fuzzy
msgid ""
"Many datatypes that occur regularly in programming consist of a function "
"along with some extra information about it. For example, a function might be"
" accompanied by a name to show in logs or by some configuration data. "
"Additionally, putting a type in a field of a structure, similarly to the "
"`Monoid` example, can make sense in contexts where there is more than one "
"way to implement an operation and more manual control is needed than type "
"classes would allow. For example, the specific details of values emitted by "
"a JSON serializer may be important because another application expects a "
"particular format. Sometimes, the function itself may be derivable from just"
" the configuration data."
msgstr ""
"许多在编程中经常出现的类型包含一个函数以及一些关于它的额外信息。例如，一个函数可能带有用于显示在日志中的名称或一些配置数据。此外，将类型放入结构体的字段中，类似于"
" `Monoid` 示例，在有多种方法来实现操作并且需要比类型类允许的更多手动控制的情况下是有意义的。例如，JSON "
"序列化器发出的值的具体详细信息可能很重要，因为另一个应用程序需要特定的格式。有时，函数本身可能仅从配置数据中派生。"

#: src/type-classes/coercion.md:247
#, fuzzy
msgid ""
"A type class called `CoeFun` can transform values from non-function types to"
" function types. `CoeFun` has two parameters: the first is the type whose "
"values should be transformed into functions, and the second is an output "
"parameter that determines exactly which function type is being targeted."
msgstr ""
"一个名为 `CoeFun` 的类型类可以将值从非函数类型转换为函数类型。`CoeFun` "
"有两个参数：第一个是要将值转换为函数的类型，第二个是输出参数，用于确定要转换到的确切函数类型。"

#: src/type-classes/coercion.md:253
#, fuzzy
msgid ""
"The second parameter is itself a function that computes a type. In Lean, "
"types are first-class and can be passed to functions or returned from them, "
"just like anything else."
msgstr "第二个参数本身是一个计算类型的函数。在 Lean 中，类型是一等公民，可以传递给函数或从函数返回，就像其他任何东西一样。"

#: src/type-classes/coercion.md:256
#, fuzzy
msgid ""
"For example, a function that adds a constant amount to its argument can be "
"represented as a wrapper around the amount to add, rather than by defining "
"an actual function:"
msgstr "例如，一个将常量添加到其参数的函数可以表示为对要添加的量的包装，而不是通过定义实际函数："

#: src/type-classes/coercion.md:261
#, fuzzy
msgid ""
"A function that adds five to its argument has a `5` in the `howMuch` field:"
msgstr "将 5 添加到其参数的函数在 `howMuch` 字段中有一个 `5`："

#: src/type-classes/coercion.md:265
#, fuzzy
msgid ""
"This `Adder` type is not a function, and applying it to an argument results "
"in an error:"
msgstr "此 `Adder` 类型不是函数，并且将其应用于参数会导致错误："

#: src/type-classes/coercion.md:275
#, fuzzy
msgid ""
"Defining a `CoeFun` instance causes Lean to transform the adder into a "
"function with type `Nat → Nat`:"
msgstr "定义 `CoeFun` 实例会导致 Lean 将加法器转换为类型为 `Nat → Nat` 的函数："

#: src/type-classes/coercion.md:285
#, fuzzy
msgid ""
"Because all `Adder`s should be transformed into `Nat → Nat` functions, the "
"argument to `CoeFun`'s second parameter was ignored."
msgstr "由于所有 `Adder` 都应转换为 `Nat → Nat` 函数，因此忽略了 `CoeFun` 第二个参数的参数。"

#: src/type-classes/coercion.md:287
#, fuzzy
msgid ""
"When the value itself is needed to determine the right function type, then "
"`CoeFun`'s second parameter is no longer ignored. For example, given the "
"following representation of JSON values:"
msgstr "当需要值本身来确定正确的函数类型时，`CoeFun` 的第二个参数将不再被忽略。例如，给定以下 JSON 值表示："

#: src/type-classes/coercion.md:300
#, fuzzy
msgid ""
"a JSON serializer is a structure that tracks the type it knows how to "
"serialize along with the serialization code itself:"
msgstr "JSON 序列化器是一个结构体，它跟踪它知道如何序列化的类型以及序列化代码本身："

#: src/type-classes/coercion.md:306
#, fuzzy
msgid ""
"A serializer for strings need only wrap the provided string in the "
"`JSON.string` constructor:"
msgstr "字符串序列化器只需要将提供的字符串包装在 `JSON.string` 构造子中："

#: src/type-classes/coercion.md:313
#, fuzzy
msgid ""
"Viewing JSON serializers as functions that serialize their argument requires"
" extracting the inner type of serializable data:"
msgstr "将 JSON 序列化器视为序列化其参数的函数需要提取可序列化数据的内部类型："

#: src/type-classes/coercion.md:318
#, fuzzy
msgid ""
"Given this instance, a serializer can be applied directly to an argument:"
msgstr "给定此实例，序列化器可以直接应用于参数："

#: src/type-classes/coercion.md:319
#, fuzzy
msgid ""
"```lean\n"
"def buildResponse (title : String) (R : Serializer) (record : R.Contents) : JSON :=\n"
"  JSON.object [\n"
"    (\"title\", JSON.string title),\n"
"    (\"status\", JSON.number 200),\n"
"    (\"record\", R record)\n"
"  ]\n"
"```"
msgstr ""
"```lean\n"
"def buildResponse (title : String) (R : Serializer) (record : R.Contents) : JSON :=\n"
"  JSON.object [\n"
"    (\"title\", JSON.string title),\n"
"    (\"status\", JSON.number 200),\n"
"    (\"record\", R record)\n"
"  ]\n"
"```"

#: src/type-classes/coercion.md:327
#, fuzzy
msgid "The serializer can be passed directly to `buildResponse`:"
msgstr "序列化器可以直接传递给 `buildResponse`："

#: src/type-classes/coercion.md:328
#, fuzzy
msgid ""
"```lean\n"
"#eval buildResponse \"Functional Programming in Lean\" Str \"Programming is fun!\"\n"
"```"
msgstr ""
"```lean\n"
"#eval buildResponse \"Functional Programming in Lean\" Str \"Programming is fun!\"\n"
"```"

#: src/type-classes/coercion.md:331
#, fuzzy
msgid ""
"```output info\n"
"JSON.object\n"
"  [(\"title\", JSON.string \"Functional Programming in Lean\"),\n"
"   (\"status\", JSON.number 200.000000),\n"
"   (\"record\", JSON.string \"Programming is fun!\")]\n"
"```"
msgstr ""
"```output info\n"
"JSON.object\n"
"  [(\"title\", JSON.string \"Functional Programming in Lean\"),\n"
"   (\"status\", JSON.number 200.000000),\n"
"   (\"record\", JSON.string \"Programming is fun!\")]\n"
"```"

#: src/type-classes/coercion.md:338
#, fuzzy
msgid "Aside: JSON as a String"
msgstr "旁注：JSON 作为字符串"

#: src/type-classes/coercion.md:340
#, fuzzy
msgid ""
"It can be a bit difficult to understand JSON when encoded as Lean objects. "
"To help make sure that the serialized response was what was expected, it can"
" be convenient to write a simple converter from `JSON` to `String`. The "
"first step is to simplify the display of numbers. `JSON` doesn't distinguish"
" between integers and floating point numbers, and the type `Float` is used "
"to represent both. In Lean, `Float.toString` includes a number of trailing "
"zeros:"
msgstr ""
"将 JSON 编码为 Lean 对象时可能有点难以理解。为了确保序列化的响应符合预期，可以编写一个从 `JSON` 到 `String` "
"的简单转换器。第一步是简化数字的显示。`JSON` 不区分整数和小数，并且类型 `Float` 用于表示两者。在 Lean "
"中，`Float.toString` 包含许多尾随零："

#: src/type-classes/coercion.md:348
#, fuzzy
msgid ""
"```output info\n"
"\"5.000000\"\n"
"```"
msgstr "为了解决这个问题，我们编写了一个小函数，通过删除所有尾随零和尾随小数点来清理表示："

#: src/type-classes/coercion.md:351
#, fuzzy
msgid ""
"The solution is to write a little function that cleans up the presentation "
"by dropping all trailing zeros, followed by a trailing decimal point:"
msgstr ""
"有了这个定义，`#eval dropDecimals (5 : Float).toString` 会生成 `\"5\"`，而 `#eval "
"dropDecimals (5.2 : Float).toString` 会生成 `\"5.2\"`。"

#: src/type-classes/coercion.md:359
#, fuzzy
msgid ""
"With this definition, `#eval dropDecimals (5 : Float).toString` yields "
"`\"5\"`, and `#eval dropDecimals (5.2 : Float).toString` yields `\"5.2\"`."
msgstr "下一步是定义一个辅助函数，用分隔符连接一个字符串列表："

#: src/type-classes/coercion.md:361
#, fuzzy
msgid ""
"The next step is to define a helper function to append a list of strings "
"with a separator in between them:"
msgstr ""
"```lean\n"
"def String.separate (sep : String) (strings : List String) : String :=\n"
"  match strings with\n"
"  | [] => \"\"\n"
"  | x :: xs => String.join (x :: xs.map (sep ++ ·))\n"
"```"

#: src/type-classes/coercion.md:362
#, fuzzy
msgid ""
"```lean\n"
"def String.separate (sep : String) (strings : List String) : String :=\n"
"  match strings with\n"
"  | [] => \"\"\n"
"  | x :: xs => String.join (x :: xs.map (sep ++ ·))\n"
"```"
msgstr ""
"此函数可用于处理 JSON 数组和对象中的逗号分隔元素。`#eval \", \".separate [\"1\", \"2\"]` 会生成 `\"1,"
" 2\"`，`#eval \", \".separate [\"1\"]` 会生成 `\"1\"`，而 `#eval \", \".separate "
"[]` 会生成 `\"\"`。"

#: src/type-classes/coercion.md:368
#, fuzzy
msgid ""
"This function is useful to account for comma-separated elements in JSON "
"arrays and objects. `#eval \", \".separate [\"1\", \"2\"]` yields `\"1, "
"2\"`, `#eval \", \".separate [\"1\"]` yields `\"1\"`, and `#eval \", "
"\".separate []` yields `\"\"`."
msgstr ""
"最后，JSON 字符串需要一个字符串转义过程，以便包含 `\"Hello!\"` 的 Lean 字符串可以输出为 "
"`\"\\\"Hello!\\\"\"`。幸运的是，Lean 编译器已经包含了一个用于转义 JSON 字符串的内部函数，称为 "
"`Lean.Json.escape`。要访问此函数，请在文件开头添加 `import Lean`。"

#: src/type-classes/coercion.md:371
#, fuzzy
msgid ""
"Finally, a string escaping procedure is needed for JSON strings, so that the"
" Lean string containing `\"Hello!\"` can be output as `\"\\\"Hello!\\\"\"`. "
"Fortunately, the Lean compiler contains an internal function for escaping "
"JSON strings already, called `Lean.Json.escape`. To access this function, "
"add `import Lean` to the beginning of your file."
msgstr ""
"从 `JSON` 值发出字符串的函数被声明为 `partial`，因为 Lean 无法看出它会终止。这是因为对 `asString` 的递归调用发生在由"
" `List.map` 应用的函数中，并且这种递归模式非常复杂，以至于 Lean 无法看出递归调用实际上是在较小的值上执行的。在只需要生成 JSON "
"字符串且不需要对该过程进行数学推理的应用程序中，让函数成为 `partial` 不太可能导致问题。"

#: src/type-classes/coercion.md:375
#, fuzzy
msgid ""
"The function that emits a string from a `JSON` value is declared `partial` "
"because Lean cannot see that it terminates. This is because recursive calls "
"to `asString` occur in functions that are being applied by `List.map`, and "
"this pattern of recursion is complicated enough that Lean cannot see that "
"the recursive calls are actually being performed on smaller values. In an "
"application that just needs to produce JSON strings and doesn't need to "
"mathematically reason about the process, having the function be `partial` is"
" not likely to cause problems."
msgstr ""

#: src/type-classes/coercion.md:378
#, fuzzy
msgid ""
"```lean\n"
"partial def JSON.asString (val : JSON) : String :=\n"
"  match val with\n"
"  | true => \"true\"\n"
"  | false => \"false\"\n"
"  | null => \"null\"\n"
"  | string s => \"\\\"\" ++ Lean.Json.escape s ++ \"\\\"\"\n"
"  | number n => dropDecimals n.toString\n"
"  | object members =>\n"
"    let memberToString mem :=\n"
"      \"\\\"\" ++ Lean.Json.escape mem.fst ++ \"\\\": \" ++ asString mem.snd\n"
"    \"{\" ++ \", \".separate (members.map memberToString) ++ \"}\"\n"
"  | array elements =>\n"
"    \"[\" ++ \", \".separate (elements.map asString) ++ \"]\"\n"
"```"
msgstr ""
"```lean\n"
"partial def JSON.asString (val : JSON) : String :=\n"
"  match val with\n"
"  | true => \"true\"\n"
"  | false => \"false\"\n"
"  | null => \"null\"\n"
"  | string s => \"\\\"\" ++ Lean.Json.escape s ++ \"\\\"\"\n"
"  | number n => dropDecimals n.toString\n"
"  | object members =>\n"
"    let memberToString mem :=\n"
"      \"\\\"\" ++ Lean.Json.escape mem.fst ++ \"\\\": \" ++ asString mem.snd\n"
"    \"{\" ++ \", \".separate (members.map memberToString) ++ \"}\"\n"
"  | array elements =>\n"
"    \"[\" ++ \", \".separate (elements.map asString) ++ \"]\"\n"
"```"

#: src/type-classes/coercion.md:393
#, fuzzy
msgid "With this definition, the output of serialization is easier to read:"
msgstr ""
"\n"
"通过此定义，序列化输出更易于阅读："

#: src/type-classes/coercion.md:394
#, fuzzy
msgid ""
"```lean\n"
"#eval (buildResponse \"Functional Programming in Lean\" Str \"Programming is fun!\").asString\n"
"```"
msgstr ""
"```lean\n"
"#eval (buildResponse \"函数式编程 in Lean\" Str \"编程很有趣！\").asString\n"
"```"

#: src/type-classes/coercion.md:397
#, fuzzy
msgid ""
"```output info\n"
"\"{\\\\\"title\\\\\": \\\\\"Functional Programming in Lean\\\\\", \\\\\"status\\\\\": 200, \\\\\"record\\\\\": \\\\\"Programming is fun!\\\\\"}\"\n"
"```"
msgstr ""
"```output info\n"
"\"{\\\\\"title\\\\\": \\\\\"函数式编程 in Lean\\\\\", \\\\\"status\\\\\": 200, \\\\\"record\\\\\": \\\\\"编程很有趣！\\\\\"}\"\n"
"```"

#: src/type-classes/coercion.md:404
#, fuzzy
msgid ""
"Natural number literals are overloaded with the `OfNat` type class. Because "
"coercions fire in cases where types don't match, rather than in cases of "
"missing instances, a missing `OfNat` instance for a type does not cause a "
"coercion from `Nat` to be applied:"
msgstr ""
"自然数文字重载了 `OfNat` 类型类。由于类型不匹配时会触发强制转换，而不是在缺少实例的情况下，因此类型缺少 `OfNat` 实例不会导致从 "
"`Nat` 应用强制转换："

#: src/type-classes/coercion.md:415
#, fuzzy
msgid "Design Considerations"
msgstr "设计注意事项"

#: src/type-classes/coercion.md:417
#, fuzzy
msgid ""
"Coercions are a powerful tool that should be used responsibly. On the one "
"hand, they can allow an API to naturally follow the everyday rules of the "
"domain being modeled. This can be the difference between a bureaucratic mess"
" of manual conversion functions and a clear program. As Abelson and Sussman "
"wrote in the preface to _Structure and Interpretation of Computer Programs_ "
"(MIT Press, 1996),"
msgstr ""
"强制转换是一种功能强大的工具，应负责任地使用。一方面，它们可以让 API "
"自然地遵循所建模域的日常规则。这可能是官僚主义的手动转换函数混乱与清晰程序之间的区别。正如 Abelson 和 Sussman "
"在《计算机程序的结构体与解释》（麻省理工学院出版社，1996 年）的序言中所写，"

#: src/type-classes/coercion.md:422
#, fuzzy
msgid ""
"Programs must be written for people to read, and only incidentally for "
"machines to execute."
msgstr "程序必须写给人阅读，而机器执行只是顺便的事。"

#: src/type-classes/coercion.md:424
#, fuzzy
msgid ""
"Coercions, used wisely, are a valuable means of achieving readable code that"
" can serve as the basis for communication with domain experts. APIs that "
"rely heavily on coercions have a number of important limitations, however. "
"Think carefully about these limitations before using coercions in your own "
"libraries."
msgstr ""
"明智地使用强制转换是一种实现可读代码的有价值的手段，该代码可以作为与领域专家进行交流的基础。然而，严重依赖强制转换的 API "
"有一些重要的限制。在自己的库中使用强制转换之前，请仔细考虑这些限制。"

#: src/type-classes/coercion.md:428
#, fuzzy
msgid ""
"First off, coercions are only applied in contexts where enough type "
"information is available for Lean to know all of the types involved, because"
" there are no output parameters in the coercion type classes. This means "
"that a return type annotation on a function can be the difference between a "
"type error and a successfully applied coercion. For example, the coercion "
"from non-empty lists to lists makes the following program work:"
msgstr ""
"首先，强制转换仅应用于 Lean "
"具有足够类型信息以了解所有涉及类型的上下文中，因为强制转换类型类中没有输出参数。这意味着函数上的返回类型标注可能是类型错误和成功应用强制转换之间的区别。例如，从非空列表到列表的强制转换使以下程序正常工作："

#: src/type-classes/coercion.md:434
#, fuzzy
msgid ""
"On the other hand, if the type annotation is omitted, then the result type "
"is unknown, so Lean is unable to find the coercion:"
msgstr "另一方面，如果省略类型标注，则结果类型未知，因此 Lean 无法找到强制转换："

#: src/type-classes/coercion.md:449
#, fuzzy
msgid ""
"More generally, when a coercion is not applied for some reason, the user "
"receives the original type error, which can make it difficult to debug "
"chains of coercions."
msgstr "更一般地说，当由于某种原因未应用强制转换时，用户会收到原始类型错误，这可能使调试强制转换链变得困难。"

#: src/type-classes/coercion.md:451
#, fuzzy
msgid ""
"Finally, coercions are not applied in the context of field accessor "
"notation. This means that there is still an important difference between "
"expressions that need to be coerced and those that don't, and this "
"difference is visible to users of your API."
msgstr ""
"最后，强制转换不会应用于字段访问器符号的上下文中。这意味着需要强制转换的表达式与不需要强制转换的表达式之间仍然存在重要差异，并且此差异对您的 API "
"用户可见。"

#: src/type-classes/conveniences.md:3
#, fuzzy
msgid "Constructor Syntax for Instances"
msgstr "实例的构造子语法"

#: src/type-classes/conveniences.md:5
#, fuzzy
msgid ""
"Behind the scenes, type classes are structure types and instances are values"
" of these types. The only differences are that Lean stores additional "
"information about type classes, such as which parameters are output "
"parameters, and that instances are registered for searching. While values "
"that have structure types are typically defined using either `⟨...⟩` syntax "
"or with braces and fields, and instances are typically defined using "
"`where`, both syntaxes work for both kinds of definition."
msgstr ""
"在幕后，类型类是结构体类型，实例是这些类型的值。唯一的区别是 Lean "
"存储有关类型类的附加信息，例如哪些参数是输出参数，以及实例已注册用于搜索。虽然具有结构体类型的通常使用 `⟨...⟩` "
"语法或大括号和字段来定义值，并且实例通常使用 `where` 来定义，但两种语法都适用于两种类型的定义。"

#: src/type-classes/conveniences.md:9
#, fuzzy
msgid "For example, a forestry application might represent trees as follows:"
msgstr "例如，一个林业应用程序可能会如下表示树："

#: src/type-classes/conveniences.md:10
#, fuzzy
msgid ""
"```lean\n"
"structure Tree : Type where\n"
"  latinName : String\n"
"  commonNames : List String\n"
"\n"
"def oak : Tree :=\n"
"  ⟨\"Quercus robur\", [\"common oak\", \"European oak\"]⟩\n"
"\n"
"def birch : Tree :=\n"
"  { latinName := \"Betula pendula\",\n"
"    commonNames := [\"silver birch\", \"warty birch\"]\n"
"  }\n"
"\n"
"def sloe : Tree where\n"
"  latinName := \"Prunus spinosa\"\n"
"  commonNames := [\"sloe\", \"blackthorn\"]\n"
"```"
msgstr ""
"```lean\n"
"structure Tree : Type where\n"
"  latinName : String\n"
"  commonNames : List String\n"
"\n"
"def oak : Tree :=\n"
"  ⟨\"Quercus robur\", [\"common oak\", \"European oak\"]⟩\n"
"\n"
"def birch : Tree :=\n"
"  { latinName := \"Betula pendula\",\n"
"    commonNames := [\"silver birch\", \"warty birch\"]\n"
"  }\n"
"\n"
"def sloe : Tree where\n"
"  latinName := \"Prunus spinosa\"\n"
"  commonNames := [\"sloe\", \"blackthorn\"]\n"
"```"

#: src/type-classes/conveniences.md:27
#, fuzzy
msgid "All three syntaxes are equivalent."
msgstr "这三种语法是等价的。"

#: src/type-classes/conveniences.md:29
#, fuzzy
msgid ""
"Similarly, type class instances can be defined using all three syntaxes:"
msgstr "类似地，类型类实例可以使用这三种语法定义："

#: src/type-classes/conveniences.md:44
#, fuzzy
msgid ""
"Generally speaking, the `where` syntax should be used for instances, and the"
" curly-brace syntax should be used for structures. The `⟨...⟩` syntax can be"
" useful when emphasizing that a structure type is very much like a tuple in "
"which the fields happen to be named, but the names are not important at the "
"moment. However, there are situations where it can make sense to use other "
"alternatives. In particular, a library might provide a function that "
"constructs an instance value. Placing a call to this function after `:=` in "
"an instance declaration is the easiest way to use such a function."
msgstr ""
"一般来说，`where` 语法应该用于实例，而大括号语法应该用于结构体。当强调一个结构体类型非常像一个元组时，`⟨...⟩` "
"语法很有用，其中的字段恰好被命名，但这些名称目前并不重要。然而，在某些情况下，使用其他替代方案是有意义的。特别是，一个库可能提供一个构造实例值的函数。在实例声明中将对该函数的调用放在"
" `:=` 之后是使用此类函数的最简单方法。"

#: src/type-classes/conveniences.md:50
#, fuzzy
msgid "Examples"
msgstr "示例"

#: src/type-classes/conveniences.md:52
#, fuzzy
msgid ""
"When experimenting with Lean code, definitions can be more convenient to use"
" than `#eval` or `#check` commands. First off, definitions don't produce any"
" output, which can help keep the reader's focus on the most interesting "
"output. Secondly, it's easiest to write most Lean programs by starting with "
"a type signature, allowing Lean to provide more assistance and better error "
"messages while writing the program itself. On the other hand, `#eval` and "
"`#check` are easiest to use in contexts where Lean is able to determine the "
"type from the provided expression. Thirdly, `#eval` cannot be used with "
"expressions whose types don't have `ToString` or `Repr` instances, such as "
"functions. Finally, multi-step `do` blocks, `let`\\-expressions, and other "
"syntactic forms that take multiple lines are particularly difficult to write"
" with a type annotation in `#eval` or `#check`, simply because the required "
"parenthesization can be difficult to predict."
msgstr ""
"在使用 Lean 代码进行实验时，定义比 `#eval` 或 `#check` "
"命令更方便。首先，定义不会产生任何输出，这有助于读者专注于最有趣的输出。其次，最简单的编写大多数 Lean 程序的方法是从类型签名开始，允许 Lean "
"在编写程序本身时提供更多帮助和更好的错误消息。另一方面，`#eval` 和 `#check` 最容易在 Lean "
"能够从提供的表达式中确定类型的情况下使用。第三，`#eval` 不能用于类型没有 `ToString` 或 `Repr` "
"实例的表达式，例如函数。最后，多步 `do` 块、`let` 表达式和其他需要多行的语法形式在 `#eval` 或 `#check` "
"中特别难以用类型标注编写，仅仅是因为所需的括号很难预测。"

#: src/type-classes/conveniences.md:59
#, fuzzy
msgid ""
"To work around these issues, Lean supports the explicit indication of "
"examples in a source file. An example is like a definition without a name. "
"For instance, a non-empty list of birds commonly found in Copenhagen's green"
" spaces can be written:"
msgstr "为了解决这些问题，Lean 支持在源文件中明确指示示例。示例就像没有名称的定义。例如，可以编写在哥本哈根绿地中常见的非空鸟类列表："

#: src/type-classes/conveniences.md:62
#, fuzzy
msgid ""
"```lean\n"
"example : NonEmptyList String :=\n"
"  { head := \"Sparrow\",\n"
"    tail := [\"Duck\", \"Swan\", \"Magpie\", \"Eurasian coot\", \"Crow\"]\n"
"  }\n"
"```"
msgstr ""
"```lean\n"
"example : NonEmptyList String :=\n"
"  { head := \"Sparrow\",\n"
"    tail := [\"Duck\", \"Swan\", \"Magpie\", \"Eurasian coot\", \"Crow\"]\n"
"  }\n"
"```"

#: src/type-classes/conveniences.md:69
#, fuzzy
msgid "Examples may define functions by accepting arguments:"
msgstr "示例可以通过接受参数来定义函数："

#: src/type-classes/conveniences.md:74
#, fuzzy
msgid ""
"While this creates a function behind the scenes, this function has no name "
"and cannot be called. Nonetheless, this is useful for demonstrating how a "
"library can be used with arbitrary or unknown values of some given type. In "
"source files, `example` declarations are best paired with comments that "
"explain how the example illustrates the concepts of the library."
msgstr ""
"虽然这在幕后创建了一个函数，但此函数没有名称，并且无法被调用。尽管如此，这对于演示如何将库与给定类型的任意或未知值一起使用非常有用。在源文件中，`example`"
" 声明最好与解释示例如何说明库概念的注释配对。"

#: src/type-classes/summary.md:3
#, fuzzy
msgid "Type Classes and Overloading"
msgstr "类型类和重载"

#: src/type-classes/summary.md:5
#, fuzzy
msgid ""
"Type classes are Lean's mechanism for overloading functions and operators. A"
" polymorphic function can be used with multiple types, but it behaves in the"
" same manner no matter which type it is used with. For example, a "
"polymorphic function that appends two lists can be used no matter the type "
"of the entries in the list, but it is unable to have different behavior "
"depending on which particular type is found. An operation that is overloaded"
" with type classes, on the other hand, can also be used with multiple types."
" However, each type requires its own implementation of the overloaded "
"operation. This means that the behavior can vary based on which type is "
"provided."
msgstr ""
"类型类是 Lean "
"用于重载函数和运算符的机制。多态函数可以与多种类型一起使用，但无论与哪种类型一起使用，它的行为都是相同的。例如，附加两个列表的多态函数可以用于列表中条目的类型，但它无法根据找到的特定类型而具有不同的行为。另一方面，使用类型类重载的操作也可以与多种类型一起使用。但是，每种类型都需要重载操作的自己的实现。这意味着行为可以根据提供的类型而有所不同。"

#: src/type-classes/summary.md:12
#, fuzzy
msgid ""
"A _type class_ has a name, parameters, and a body that consists of a number "
"of names with types. The name is a way to refer to the overloaded "
"operations, the parameters determine which aspects of the definitions can be"
" overloaded, and the body provides the names and type signatures of the "
"overloadable operations. Each overloadable operation is called a _method_ of"
" the type class. Type classes may provide default implementations of some "
"methods in terms of the others, freeing implementors from defining each "
"overload by hand when it is not needed."
msgstr ""
"_类型类_ "
"有一个名称、参数和一个主体，主体由具有类型的一系列名称组成。名称是引用重载操作的方法，参数确定可以重载哪些方面的定义，主体提供重载操作的名称和类型签名。每个可重载操作称为类型类的_方法_。类型类可以根据其他方法提供某些方法的默认实现，从而使实现者不必在不需要时手动定义每个重载。"

#: src/type-classes/summary.md:17
#, fuzzy
msgid ""
"An _instance_ of a type class provides implementations of the methods for "
"given parameters. Instances may be polymorphic, in which case they can work "
"for a variety of parameters, and they may optionally provide more specific "
"implementations of default methods in cases where a more efficient version "
"exists for some particular type."
msgstr ""
"类型类的实例为给定参数提供方法的实现。实例可以是多态的，在这种情况下，它们可以适用于各种参数，并且它们可以选择性地提供默认方法的更具体实现，在某些特定类型存在更有效版本的情况下。"

#: src/type-classes/summary.md:20
#, fuzzy
msgid ""
"Type class parameters are either _input parameters_ (the default), or "
"_output parameters_ (indicated by an `outParam` modifier). Lean will not "
"begin searching for an instance until all input parameters are no longer "
"metavariables, while output parameters may be solved while searching for "
"instances. Parameters to a type class need not be types—they may also be "
"ordinary values. The `OfNat` type class, used to overload natural number "
"literals, takes the overloaded `Nat` itself as a parameter, which allows "
"instances to restrict the allowed numbers."
msgstr ""
"类型类参数要么是输入参数（默认），要么是输出参数（由 `outParam` 修饰符指示）。在所有输入参数不再是元变量之前，Lean "
"不会开始搜索实例，而输出参数可以在搜索实例时求解。类型类的参数不必是类型——它们也可以是普通值。用于重载自然数文字的 `OfNat` 类型类将重载的 "
"`Nat` 本身作为参数，这允许实例限制允许的数字。"

#: src/type-classes/summary.md:25
#, fuzzy
msgid ""
"Instances may be marked with a `@[default_instance]` attribute. When an "
"instance is a default instance, then it will be chosen as a fallback when "
"Lean would otherwise fail to find an instance due to the presence of "
"metavariables in the type."
msgstr ""
"实例可以用 `@[default_instance]` 属性标记。当一个实例是默认实例时，当 Lean "
"由于类型中存在元变量而无法找到实例时，它将被选为后备。"

#: src/type-classes/summary.md:28
#, fuzzy
msgid "Type Classes for Common Syntax"
msgstr "常见语法的类型类"

#: src/type-classes/summary.md:30
#, fuzzy
msgid ""
"Most infix operators in Lean are overridden with a type class. For instance,"
" the addition operator corresponds to a type class called `Add`. Most of "
"these operators have a corresponding heterogeneous version, in which the two"
" arguments need not have the same type. These heterogenous operators are "
"overloaded using a version of the class whose name starts with `H`, such as "
"`HAdd`."
msgstr ""
"Lean 中的大多数中缀运算符都用类型类重写。例如，加法运算符对应于一个名为 `Add` "
"的类型类。大多数这些运算符都有一个相应的异构版本，其中两个参数不必具有相同的类型。这些异构运算符使用类名的版本重载，该版本以 `H` 开头，例如 "
"`HAdd`。"

#: src/type-classes/summary.md:35
#, fuzzy
msgid ""
"Indexing syntax is overloaded using a type class called `GetElem`, which "
"involves proofs. `GetElem` has two output parameters, which are the type of "
"elements to be extracted from the collection and a function that can be used"
" to determine what counts as evidence that the index value is in bounds for "
"the collection. This evidence is described by a proposition, and Lean "
"attempts to prove this proposition when array indexing is used. When Lean is"
" unable to check that list or array access operations are in bounds at "
"compile time, the check can be deferred to run time by appending a `?` to "
"the indexing operation."
msgstr ""
"索引语法使用名为 `GetElem` 的类型类进行重载，其中涉及证明。`GetElem` "
"有两个输出参数，它们分别是集合中要提取的元素类型和一个函数，该函数可用于确定什么算作索引值在集合中处于界限内的证据。此证据由命题描述，并且在使用数组索引时，Lean"
" 会尝试证明此命题。当 Lean 无法在编译时检查列表或数组访问操作是否在界限内时，可以通过在索引操作后附加 `?` 来将检查推迟到运行时。"

#: src/type-classes/summary.md:42
#, fuzzy
msgid ""
"A functor is a polymorphic type that supports a mapping operation. This "
"mapping operation transforms all elements \"in place\", changing no other "
"structure. For instance, lists are functors and the mapping operation may "
"neither drop, duplicate, nor mix up entries in the list."
msgstr ""
"函子是一种多态类型，支持映射操作。此映射操作「就地」转换所有元素，不更改任何其他结构体。例如，列表是函子，并且映射操作既不会删除、也不会复制或混淆列表中的条目。"

#: src/type-classes/summary.md:46
#, fuzzy
msgid ""
"While functors are defined by having `map`, the `Functor` type class in Lean"
" contains an additional default method that is responsible for mapping the "
"constant function over a value, replacing all values whose type are given by"
" polymorphic type variable with the same new value. For some functors, this "
"can be done more efficiently than traversing the entire structure."
msgstr ""
"虽然函子通过具有 `map` 来定义，但 Lean 中的 `Functor` "
"类型类包含一个附加的默认方法，该方法负责将常量函数映射到某个值上，用相同的新值替换所有类型由多态类型变量给出的值。对于某些函子，这比遍历整个结构体可以更高效地完成。"

#: src/type-classes/summary.md:49
#, fuzzy
msgid "Deriving Instances"
msgstr "派生实例"

#: src/type-classes/summary.md:51
#, fuzzy
msgid ""
"Many type classes have very standard implementations. For instance, the "
"Boolean equality class `BEq` is usually implemented by first checking "
"whether both arguments are built with the same constructor, and then "
"checking whether all their arguments are equal. Instances for these classes "
"can be created _automatically_."
msgstr ""
"许多类型类具有非常标准的实现。例如，布尔相等类 `BEq` "
"通常通过首先检查两个参数是否由相同的构造子构建，然后检查它们的所有参数是否相等来实现。可以_自动_创建这些类的实例。"

#: src/type-classes/summary.md:55
#, fuzzy
msgid ""
"When defining an inductive type or a structure, a `deriving` clause at the "
"end of the declaration will cause instances to be created automatically. "
"Additionally, the `deriving instance ... for ...` command can be used "
"outside of the definition of a datatype to cause an instance to be "
"generated. Because each class for which instances can be derived requires "
"special handling, not all classes are derivable."
msgstr ""
"在定义归纳类型或结构体时，声明末尾的 `deriving` 子句将自动创建实例。此外，`deriving instance ... for ...` "
"命令可以在数据类型的定义之外使用，以生成实例。由于每个可以派生实例的类都需要特殊处理，因此并非所有类都是可派生的。"

#: src/type-classes/summary.md:61
#, fuzzy
msgid ""
"Coercions allow Lean to recover from what would normally be a compile-time "
"error by inserting a call to a function that transforms data from one type "
"to another. For example, the coercion from any type `α` to the type `Option "
"α` allows values to be written directly, rather than with the `some` "
"constructor, making `Option` work more like nullable types from object-"
"oriented languages."
msgstr ""
"强制转换允许 Lean 通过插入一个将数据从一种类型转换为另一种类型的函数调用来从通常是编译时错误中恢复。例如，从任何类型 `α` 到类型 "
"`Option α` 的强制转换允许直接写入值，而不是使用 `some` 构造子，从而使 `Option` 更像面向对象语言中的可空类型。"

#: src/type-classes/summary.md:64
#, fuzzy
msgid ""
"There are multiple kinds of coercion. They can recover from different kinds "
"of errors, and they are represented by their own type classes. The `Coe` "
"class is used to recover from type errors. When Lean has an expression of "
"type `α` in a context that expects something with type `β`, Lean first "
"attempts to string together a chain of coercions that can transform `α`s "
"into `β`s, and only displays the error when this cannot be done. The "
"`CoeDep` class takes the specific value being coerced as an extra parameter,"
" allowing either further type class search to be done on the value or "
"allowing constructors to be used in the instance to limit the scope of the "
"conversion. The `CoeFun` class intercepts what would otherwise be a \"not a "
"function\" error when compiling a function application, and allows the value"
" in the function position to be transformed into an actual function if "
"possible."
msgstr ""
"强制转换有多种类型。它们可以从不同类型的错误中恢复，并且由它们自己的类型类表示。`Coe` 类用于从类型错误中恢复。当 Lean 在期望类型为 `β` "
"的上下文中具有类型为 `α` 的表达式时，Lean 首先尝试将一系列强制转换串联在一起，这些强制转换可以将 `α` 转换为 "
"`β`，并且仅在此操作无法完成时才显示错误。`CoeDep` "
"类将被强制转换的特定值作为额外参数，允许对该值执行进一步的类型类搜索，或允许在实例中使用构造子来限制转换的范围。`CoeFun` "
"类拦截在编译函数应用程序时原本会出现的「不是函数」错误，并允许在可能的情况下将函数位置中的值转换为实际函数。"

#: src/monads.md:3
#, fuzzy
msgid ""
"In C# and Kotlin, the `?.` operator is a way to look up a property or call a"
" method on a potentially-null value. If the receiver is `null`, the whole "
"expression is null. Otherwise, the underlying non-`null` value receives the "
"call. Uses of `?.` can be chained, in which case the first `null` result "
"terminates the chain of lookups. Chaining null-checks like this is much more"
" convenient than writing and maintaining deeply nested `if`s."
msgstr ""
"在 C# 和 Kotlin 中，`?.` 运算符是一种在可能为 null 的值上查找属性或调用方法的方式。如果接收者为 `null`，则整个表达式为 "
"null。否则，基础非 `null` 值接收调用。`?.` 的用法可以链接，在这种情况下，第一个 `null` "
"结果将终止查找链。像这样链接空检查比编写和维护深度嵌套的 `if` 方便得多。"

#: src/monads.md:9
#, fuzzy
msgid ""
"Similarly, exceptions are significantly more convenient than manually "
"checking and propagating error codes. At the same time, logging is easiest "
"to accomplish by having a dedicated logging framework, rather than having "
"each function return both its log results and its return value. Chained null"
" checks and exceptions typically require language designers to anticipate "
"this use case, while logging frameworks typically make use of side effects "
"to decouple code that logs from the accumulation of the logs."
msgstr ""
"同样，异常比手动检查和传播错误代码方便得多。同时，通过使用专用日志记录框架（而不是让每个函数同时返回其日志结果和返回值）可以最轻松地完成日志记录。链接的空检查和异常通常要求语言设计者预见到此用例，而日志记录框架通常利用副作用将记录日志的代码与日志的累积解耦。"

#: src/monads.md:13
#, fuzzy
msgid ""
"All these features and more can be implemented in library code as instances "
"of a common API called `Monad`. Lean provides dedicated syntax that makes "
"this API convenient to use, but can also get in the way of understanding "
"what is going on behind the scenes. This chapter begins with the nitty-"
"gritty presentation of manually nesting null checks, and builds from there "
"to the convenient, general API. Please suspend your disbelief in the "
"meantime."
msgstr ""
"所有这些功能以及更多功能都可以作为通用 API `Monad` 的实例在库代码中实现。Lean 提供了专门的语法，使此 API "
"易于使用，但也会妨碍理解幕后发生的事情。本章从手动嵌套空检查的细节介绍开始，并由此构建到方便、通用的 API。在此期间，请暂时搁置你的怀疑。"

#: src/monads.md:18
#, fuzzy
msgid "Checking for `none`: Don't Repeat Yourself"
msgstr "检查 `none`：不要重复自己"

#: src/monads.md:20
#, fuzzy
msgid ""
"In Lean, pattern matching can be used to chain checks for null. Getting the "
"first entry from a list can just use the optional indexing notation:"
msgstr "在 Lean 中，模式匹配可用于链接空检查。从列表中获取第一个条目可以使用可选的索引表示法："

#: src/monads.md:26
#, fuzzy
msgid ""
"The result must be an `Option` because empty lists have no first entry. "
"Extracting the first and third entries requires a check that each is not "
"`none`:"
msgstr "结果必须是 `Option`，因为空列表没有第一个条目。提取第一个和第三个条目需要检查每个条目是否不是 `none`："

#: src/monads.md:38
#, fuzzy
msgid ""
"Similarly, extracting the first, third, and fifth entries requires more "
"checks that the values are not `none`:"
msgstr "同样，提取第一个、第三个和第五个条目需要更多检查，以确保这些值不是 `none`："

#: src/monads.md:52
#, fuzzy
msgid ""
"And adding the seventh entry to this sequence begins to become quite "
"unmanageable:"
msgstr "而将第七个条目添加到此序列中开始变得相当难以管理："

#: src/monads.md:71
#, fuzzy
msgid ""
"The fundamental problem with this code is that it addresses two concerns: "
"extracting the numbers and checking that all of them are present, but the "
"second concern is addressed by copying and pasting the code that handles the"
" `none` case. It is often good style to lift a repetitive segment into a "
"helper function:"
msgstr ""
"这段代码的基本问题在于它解决了两个问题：提取数字和检查它们是否全部存在，但第二个问题是通过复制和粘贴处理 `none` "
"情况的代码来解决的。通常，将重复的片段提升到辅助函数中是一种好风格："

#: src/monads.md:79
#, fuzzy
msgid ""
"This helper, which is used similarly to `?.` in C# and Kotlin, takes care of"
" propagating `none` values. It takes two arguments: an optional value and a "
"function to apply when the value is not `none`. If the first argument is "
"`none`, then the helper returns `none`. If the first argument is not `none`,"
" then the function is applied to the contents of the `some` constructor."
msgstr ""
"此辅助函数类似于 C# 和 Kotlin 中的 `?.`，用于处理 `none` 值。它接受两个参数：一个可选值和一个在该值不是 `none` "
"时应用的函数。如果第一个参数是 `none`，则辅助函数返回 `none`。如果第一个参数不是 `none`，则该函数将应用于 `some` "
"构造子的内容。"

#: src/monads.md:84
#, fuzzy
msgid ""
"Now, `firstThird` can be rewritten to use `andThen` instead of pattern "
"matching:"
msgstr "现在，`firstThird` 可以重写为使用 `andThen` 而不是模式匹配："

#: src/monads.md:91
#, fuzzy
msgid ""
"In Lean, functions don't need to be enclosed in parentheses when passed as "
"arguments. The following equivalent definition uses more parentheses and "
"indents the bodies of functions:"
msgstr "在 Lean 中，作为参数传递时，函数不需要用括号括起来。以下等效定义使用了更多的括号并缩进了函数的主体："

#: src/monads.md:99
#, fuzzy
msgid ""
"The `andThen` helper provides a sort of \"pipeline\" through which values "
"flow, and the version with the somewhat unusual indentation is more "
"suggestive of this fact. Improving the syntax used to write `andThen` can "
"make these computations even easier to understand."
msgstr ""
"`andThen` 辅助函数提供了一种值流经的「管道」，而具有有些不寻常缩进的版本更能说明这一事实。改进用于编写 `andThen` "
"的语法可以使这些计算更容易理解。"

#: src/monads.md:102
#, fuzzy
msgid "Infix Operators"
msgstr "中缀运算符"

#: src/monads.md:104
#, fuzzy
msgid ""
"In Lean, infix operators can be declared using the `infix`, `infixl`, and "
"`infixr` commands, which create (respectively) non-associative, left-"
"associative, and right-associative operators. When used multiple times in a "
"row, a _left associative_ operator stacks up the opening parentheses on the "
"left side of the expression. The addition operator `+` is left associative, "
"so `w + x + y + z` is equivalent to `(((w + x) + y) + z)`. The "
"exponentiation operator `^` is right associative, so `w ^ x ^ y ^ z` is "
"equivalent to `(w ^ (x ^ (y ^ z)))`. Comparison operators such as `<` are "
"non-associative, so `x < y < z` is a syntax error and requires manual "
"parentheses."
msgstr ""
"在 Lean 中，可以使用 `infix`、`infixl` 和 `infixr` "
"命令声明中缀运算符，它们分别创建（分别）非结合、左结合和右结合运算符。当连续多次使用时，_左结合_ 运算符会将左括号堆叠在表达式的左侧。加法运算符 "
"`+` 是左结合的，因此 `w + x + y + z` 等价于 `(((w + x) + y) + z)`。指数运算符 `^` 是右结合的，因此 `w"
" ^ x ^ y ^ z` 等价于 `(w ^ (x ^ (y ^ z)))`。比较运算符（如 `<`）是非结合的，因此 `x < y < z` "
"是一个语法错误，需要手动添加括号。"

#: src/monads.md:110
#, fuzzy
msgid "The following declaration makes `andThen` into an infix operator:"
msgstr "以下声明将 `andThen` 声明为中缀运算符："

#: src/monads.md:111
#, fuzzy
msgid ""
"```lean\n"
"infixl:55 \" ~~> \" => andThen\n"
"```"
msgstr ""
"```lean\n"
"infixl:55 \" ~~> \" => andThen\n"
"```"

#: src/monads.md:114
#, fuzzy
msgid ""
"The number following the colon declares the _precedence_ of the new infix "
"operator. In ordinary mathematical notation, `x + y * z` is equivalent to `x"
" + (y * z)` even though both `+` and `*` are left associative. In Lean, `+` "
"has precedence 65 and `*` has precedence 70. Higher-precedence operators are"
" applied before lower-precedence operators. According to the declaration of "
"`~~>`, both `+` and `*` have higher precedence, and thus apply first. "
"Typically, figuring out the most convenient precedences for a group of "
"operators requires some experimentation and a large collection of examples."
msgstr ""
"冒号后面的数字声明了新中缀运算符的_优先级_。在普通数学符号中，`x + y * z` 等价于 `x + (y * z)`，即使 `+` 和 `*` "
"都是左结合的。在 Lean 中，`+` 的优先级为 65，`*` 的优先级为 70。优先级更高的运算符在优先级较低的运算符之前应用。根据 `~~>` "
"的声明，`+` 和 `*` 都具有更高的优先级，因此首先应用。通常，找出最适合一组运算符的优先级需要一些实验和大量的示例。"

#: src/monads.md:121
#, fuzzy
msgid ""
"Following the new infix operator is a double arrow `=>`, which specifies the"
" named function to be used for the infix operator. Lean's standard library "
"uses this feature to define `+` and `*` as infix operators that point at "
"`HAdd.hAdd` and `HMul.hMul`, respectively, allowing type classes to be used "
"to overload the infix operators. Here, however, `andThen` is just an "
"ordinary function."
msgstr ""
"在新的中缀运算符后面是一个双箭头 `=>`，它指定要用于中缀运算符的命名函数。Lean 的标准库使用此功能将 `+` 和 `*` 定义为指向 "
"`HAdd.hAdd` 和 `HMul.hMul` 的中缀运算符，从而允许类型类用于重载中缀运算符。然而，这里 `andThen` 只是一个普通函数。"

#: src/monads.md:125
#, fuzzy
msgid ""
"Having defined an infix operator for `andThen`, `firstThird` can be "
"rewritten in a way that brings the \"pipeline\" feeling of `none`\\-checks "
"front and center:"
msgstr ""
"通过为 `andThen` 定义一个中缀运算符，`firstThird` 可以改写成一种将 `none` 检查的「管道」感觉置于首要位置的方式："

#: src/monads.md:132
#, fuzzy
msgid "This style is much more concise when writing larger functions:"
msgstr "这种风格在编写较大的函数时更加简洁："

#: src/monads.md:142
#, fuzzy
msgid "Propagating Error Messages"
msgstr "传播错误消息"

#: src/monads.md:144
#, fuzzy
msgid ""
"Pure functional languages such as Lean have no built-in exception mechanism "
"for error handling, because throwing or catching an exception is outside of "
"the step-by-step evaluation model for expressions. However, functional "
"programs certainly need to handle errors. In the case of "
"`firstThirdFifthSeventh`, it is likely relevant for a user to know just how "
"long the list was and where the lookup failed."
msgstr ""
"像 Lean 这样的纯函数式语言没有用于错误处理的内置异常机制，因为抛出或捕获异常超出了表达式逐步求值模型的范围。然而，函数式程序肯定需要处理错误。在 "
"`firstThirdFifthSeventh` 的情况下，用户很可能需要知道列表有多长以及查找失败的位置。"

#: src/monads.md:148
#, fuzzy
msgid ""
"This is typically accomplished by defining a datatype that can be either an "
"error or a result, and translating functions with exceptions into functions "
"that return this datatype:"
msgstr "这通常通过定义一个可以是错误或结果的数据类型，并将带有异常的函数转换为返回此数据类型的函数来实现："

#: src/monads.md:155
#, fuzzy
msgid ""
"The type variable `ε` stands for the type of errors that can be produced by "
"the function. Callers are expected to handle both errors and successes, "
"which makes the type variable `ε` play a role that is a bit like that of a "
"list of checked exceptions in Java."
msgstr ""
"类型变量 `ε` 表示函数可能产生的错误类型。调用者需要处理错误和成功，这使得类型变量 `ε` 扮演的角色有点像 Java 中受检异常列表的角色。"

#: src/monads.md:158
#, fuzzy
msgid ""
"Similarly to `Option`, `Except` can be used to indicate a failure to find an"
" entry in a list. In this case, the error type is a `String`:"
msgstr "类似于 `Option`，`Except` 可用于指示在列表中找不到条目的情况。在这种情况下，错误类型为 `String`："

#: src/monads.md:160
#, fuzzy
msgid ""
"```lean\n"
"def get (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => Except.error s!\"Index {i} not found (maximum is {xs.length - 1})\"\n"
"  | some x => Except.ok x\n"
"```"
msgstr ""
"```lean\n"
"def get (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => Except.error s!\"Index {i} not found (maximum is {xs.length - 1})\"\n"
"  | some x => Except.ok x\n"
"```"

#: src/monads.md:166
#, fuzzy
msgid "Looking up an in-bounds value yields an `Except.ok`:"
msgstr "查找一个界内值会产生一个 `Except.ok`："

#: src/monads.md:167
#, fuzzy
msgid ""
"```lean\n"
"def ediblePlants : List String :=\n"
"  [\"ramsons\", \"sea plantain\", \"sea buckthorn\", \"garden nasturtium\"]\n"
"\n"
"#eval get ediblePlants 2\n"
"```"
msgstr ""
"```lean\n"
"def ediblePlants : List String :=\n"
"  [\"ramsons\", \"sea plantain\", \"sea buckthorn\", \"garden nasturtium\"]\n"
"\n"
"#eval get ediblePlants 2\n"
"```"

#: src/monads.md:173
#, fuzzy
msgid ""
"```output info\n"
"Except.ok \"sea buckthorn\"\n"
"```"
msgstr ""
"```output info\n"
"Except.ok \"沙棘\"\n"
"```"

#: src/monads.md:176
#, fuzzy
msgid "Looking up an out-of-bounds value yields an `Except.error`:"
msgstr "查找越界值将产生 `Except.error`："

#: src/monads.md:180
#, fuzzy
msgid ""
"```output info\n"
"Except.error \"Index 4 not found (maximum is 3)\"\n"
"```"
msgstr ""
"```output info\n"
"Except.error \"索引 4 不存在（最大值为 3）\"\n"
"```"

#: src/monads.md:184
#, fuzzy
msgid "A single list lookup can conveniently return a value or an error:"
msgstr "单个列表查找可以方便地返回一个值或一个错误："

#: src/monads.md:189
#, fuzzy
msgid ""
"However, performing two list lookups requires handling potential failures:"
msgstr "然而，执行两个列表查找需要处理潜在的失败："

#: src/monads.md:200
#, fuzzy
msgid ""
"Adding another list lookup to the function requires still more error "
"handling:"
msgstr "向函数中添加另一个列表查找需要更多的错误处理："

#: src/monads.md:214
#, fuzzy
msgid "And one more list lookup begins to become quite unmanageable:"
msgstr "再添加一个列表查找开始变得相当难以管理："

#: src/monads.md:232
#, fuzzy
msgid ""
"Once again, a common pattern can be factored out into a helper. Each step "
"through the function checks for an error, and only proceeds with the rest of"
" the computation if the result was a success. A new version of `andThen` can"
" be defined for `Except`:"
msgstr ""
"同样，一个常见的模式可以分解为一个助手。函数中的每一步都检查错误，并且只有在结果成功的情况下才继续进行其余的计算。可以为 `Except` 定义 "
"`andThen` 的新版本："

#: src/monads.md:241
#, fuzzy
msgid ""
"Just as with `Option`, this version of `andThen` allows a more concise "
"definition of `firstThird`:"
msgstr "与 `Option` 一样，此版本的 `andThen` 允许更简洁地定义 `firstThird`："

#: src/monads.md:249
#, fuzzy
msgid ""
"In both the `Option` and `Except` case, there are two repeating patterns: "
"there is the checking of intermediate results at each step, which has been "
"factored out into `andThen`, and there is the final successful result, which"
" is `some` or `Except.ok`, respectively. For the sake of convenience, "
"success can be factored out into a helper called `ok`:"
msgstr ""
"在 `Option` 和 `Except` 情况下，都有两个重复的模式：每一步都有对中间结果的检查，该检查已分解为 "
"`andThen`，并且有最终的成功结果，分别是 `some` 或 `Except.ok`。为了方便起见，可以将成功分解为一个名为 `ok` 的助手："

#: src/monads.md:254
#, fuzzy
msgid "Similarly, failure can be factored out into a helper called `fail`:"
msgstr "同样，可以将失败分解为一个名为 `fail` 的助手："

#: src/monads.md:258
#, fuzzy
msgid "Using `ok` and `fail` makes `get` a little more readable:"
msgstr "使用 `ok` 和 `fail` 使得 `get` 更具可读性："

#: src/monads.md:259
#, fuzzy
msgid ""
"```lean\n"
"def get (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => fail s!\"Index {i} not found (maximum is {xs.length - 1})\"\n"
"  | some x => ok x\n"
"```"
msgstr ""
"```lean\n"
"def get (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => fail s!\"索引 {i} 不存在（最大值为 {xs.length - 1})\"\n"
"  | some x => ok x\n"
"```"

#: src/monads.md:267
#, fuzzy
msgid ""
"After adding the infix declaration for `andThen`, `firstThird` can be just "
"as concise as the version that returns an `Option`:"
msgstr "在为 `andThen` 添加中缀声明后，`firstThird` 可以与返回 `Option` 的版本一样简洁："

#: src/monads.md:268
#, fuzzy
msgid ""
"```lean\n"
"infixl:55 \" ~~> \" => andThen\n"
"\n"
"def firstThird (xs : List α) : Except String (α × α) :=\n"
"  get xs 0 ~~> fun first =>\n"
"  get xs 2 ~~> fun third =>\n"
"  ok (first, third)\n"
"```"
msgstr ""
"infixl:55 \" ~~> \" => andThen\n"
"\n"
"def firstThird (xs : List α) : Except String (α × α) :=\n"
"  get xs 0 ~~> fun first =>\n"
"  get xs 2 ~~> fun third =>\n"
"  ok (first, third)\n"

#: src/monads.md:276
#, fuzzy
msgid "The technique scales similarly to larger functions:"
msgstr ""
"\n"
"该技术同样适用于更大的函数："

#: src/monads.md:286
#, fuzzy
msgid "Logging"
msgstr "日志"

#: src/monads.md:288
#, fuzzy
msgid "A number is even if dividing it by 2 leaves no remainder:"
msgstr "一个数字是偶数，当它除以 2 时没有余数："

#: src/monads.md:293
#, fuzzy
msgid ""
"The function `sumAndFindEvens` computes the sum of a list while remembering "
"the even numbers encountered along the way:"
msgstr "函数 `sumAndFindEvens` 计算列表的和，同时记住沿途遇到的偶数："

#: src/monads.md:301
#, fuzzy
msgid ""
"This function is a simplified example of a common pattern. Many programs "
"need to traverse a data structure once, while both computing a main result "
"and accumulating some kind of tertiary extra result. One example of this is "
"logging: a program that is an `IO` action can always log to a file on disk, "
"but because the disk is outside of the mathematical world of Lean functions,"
" it becomes much more difficult to prove things about logs based on `IO`. "
"Another example is a function that computes the sum of all the nodes in a "
"tree with an inorder traversal, while simultaneously recording each nodes "
"visited:"
msgstr ""
"此函数是一个常见模式的简化示例。许多程序需要遍历一次数据结构体，同时计算一个主要结果和累积某种第三额外结果。一个例子是日志记录：一个 `IO` "
"动作的程序总是可以记录到磁盘上的一个文件中，但是由于磁盘在 Lean 函数的数学世界之外，因此基于 `IO` "
"证明日志变得困难得多。另一个例子是一个函数，它计算树中所有节点的和，同时按中序遍历记录每个访问的节点："

#: src/monads.md:315
#, fuzzy
msgid ""
"Both `sumAndFindEvens` and `inorderSum` have a common repetitive structure. "
"Each step of computation returns a pair that consists of a list of data that"
" have been saved along with the primary result. The lists are then appended,"
" and the primary result is computed and paired with the appended lists. The "
"common structure becomes more apparent with a small rewrite of "
"`sumAndFindEvens` that more cleanly separates the concerns of saving even "
"numbers and computing the sum:"
msgstr ""
"`sumAndFindEvens` 和 `inorderSum` "
"都具有共同的重复结构体。计算的每一步都返回一个对，该对由已保存的数据列表和主要结果组成。然后附加列表，并计算主要结果并与附加的列表配对。通过对 "
"`sumAndFindEvens` 进行小改写，更清晰地分离了保存偶数和计算和的关注点，共同的结构体变得更加明显："

#: src/monads.md:328
#, fuzzy
msgid ""
"For the sake of clarity, a pair that consists of an accumulated result "
"together with a value can be given its own name:"
msgstr "为了清晰起见，可以给由累积结果和值组成的对起一个自己的名字："

#: src/monads.md:334
#, fuzzy
msgid ""
"Similarly, the process of saving a list of accumulated results while passing"
" a value on to the next step of a computation can be factored out into a "
"helper, once again named `andThen`:"
msgstr "同样，在计算的下一步传递值时保存累积结果列表的过程可以分解为一个辅助函数，再次命名为 `andThen`："

#: src/monads.md:341
#, fuzzy
msgid ""
"In the case of errors, `ok` represents an operation that always succeeds. "
"Here, however, it is an operation that simply returns a value without "
"logging anything:"
msgstr "在错误的情况下，`ok` 表示一个总是成功的操作。然而，这里它是一个简单地返回一个值而不记录任何内容的操作："

#: src/monads.md:346
#, fuzzy
msgid ""
"Just as `Except` provides `fail` as a possibility, `WithLog` should allow "
"items to be added to a log. This has no interesting return value associated "
"with it, so it returns `Unit`:"
msgstr ""
"正如 `Except` 提供 `fail` 作为一种可能性，`WithLog` 应该允许将项添加到日志中。这没有与其关联的有趣返回值，所以它返回 "
"`Unit`："

#: src/monads.md:353
#, fuzzy
msgid ""
"`WithLog`, `andThen`, `ok`, and `save` can be used to separate the logging "
"concern from the summing concern in both programs:"
msgstr "`WithLog`、`andThen`、`ok` 和 `save` 可以用来将日志记录问题与两个程序中的求和问题分开："

#: src/monads.md:370
#, fuzzy
msgid ""
"And, once again, the infix operator helps put focus on the correct steps:"
msgstr "再次，中缀运算符有助于关注正确的步骤："

#: src/monads.md:371
#, fuzzy
msgid ""
"```lean\n"
"infixl:55 \" ~~> \" => andThen\n"
"\n"
"def sumAndFindEvens : List Int → WithLog Int Int\n"
"  | [] => ok 0\n"
"  | i :: is =>\n"
"    (if isEven i then save i else ok ()) ~~> fun () =>\n"
"    sumAndFindEvens is ~~> fun sum =>\n"
"    ok (i + sum)\n"
"\n"
"def inorderSum : BinTree Int → WithLog Int Int\n"
"  | BinTree.leaf => ok 0\n"
"  | BinTree.branch l x r =>\n"
"    inorderSum l ~~> fun leftSum =>\n"
"    save x ~~> fun () =>\n"
"    inorderSum r ~~> fun rightSum =>\n"
"    ok (leftSum + x + rightSum)\n"
"```"
msgstr ""
"```lean\n"
"infixl:55 \" ~~> \" => andThen\n"
"\n"
"def sumAndFindEvens : List Int → WithLog Int Int\n"
"  | [] => ok 0\n"
"  | i :: is =>\n"
"    (if isEven i then save i else ok ()) ~~> fun () =>\n"
"    sumAndFindEvens is ~~> fun sum =>\n"
"    ok (i + sum)\n"
"\n"
"def inorderSum : BinTree Int → WithLog Int Int\n"
"  | BinTree.leaf => ok 0\n"
"  | BinTree.branch l x r =>\n"
"    inorderSum l ~~> fun leftSum =>\n"
"    save x ~~> fun () =>\n"
"    inorderSum r ~~> fun rightSum =>\n"
"    ok (leftSum + x + rightSum)\n"
"```"

#: src/monads.md:390
#, fuzzy
msgid "Numbering Tree Nodes"
msgstr "对树节点编号"

#: src/monads.md:392
#, fuzzy
msgid ""
"An _inorder numbering_ of a tree associates each data point in the tree with"
" the step it would be visited at in an inorder traversal of the tree. For "
"example, consider `aTree`:"
msgstr "树的_中序编号_将树中的每个数据点与其在树的中序遍历中访问的步骤相关联。例如，考虑 `aTree`："

#: src/monads.md:394
#, fuzzy
msgid ""
"```lean\n"
"open BinTree in\n"
"def aTree :=\n"
"  branch\n"
"    (branch\n"
"       (branch leaf \"a\" (branch leaf \"b\" leaf))\n"
"       \"c\"\n"
"       leaf)\n"
"    \"d\"\n"
"    (branch leaf \"e\" leaf)\n"
"```"
msgstr ""
"```lean\n"
"open BinTree in\n"
"def aTree :=\n"
"  branch\n"
"    (branch\n"
"       (branch leaf \"a\" (branch leaf \"b\" leaf))\n"
"       \"c\"\n"
"       leaf)\n"
"    \"d\"\n"
"    (branch leaf \"e\" leaf)\n"
"```"

#: src/monads.md:405
#, fuzzy
msgid "Its inorder numbering is:"
msgstr "其中序编号为："

#: src/monads.md:406
#, fuzzy
msgid ""
"```output info\n"
"BinTree.branch\n"
"  (BinTree.branch\n"
"    (BinTree.branch (BinTree.leaf) (0, \"a\") (BinTree.branch (BinTree.leaf) (1, \"b\") (BinTree.leaf)))\n"
"    (2, \"c\")\n"
"    (BinTree.leaf))\n"
"  (3, \"d\")\n"
"  (BinTree.branch (BinTree.leaf) (4, \"e\") (BinTree.leaf))\n"
"```"
msgstr ""
"```output info\n"
"BinTree.branch\n"
"  (BinTree.branch\n"
"    (BinTree.branch (BinTree.leaf) (0, \"a\") (BinTree.branch (BinTree.leaf) (1, \"b\") (BinTree.leaf)))\n"
"    (2, \"c\")\n"
"    (BinTree.leaf))\n"
"  (3, \"d\")\n"
"  (BinTree.branch (BinTree.leaf) (4, \"e\") (BinTree.leaf))\n"
"```"

#: src/monads.md:416
#, fuzzy
msgid ""
"Trees are most naturally processed with recursive functions, but the usual "
"pattern of recursion on trees makes it difficult to compute an inorder "
"numbering. This is because the highest number assigned anywhere in the left "
"subtree is used to determine the numbering of a node's data value, and then "
"again to determine the starting point for numbering the right subtree. In an"
" imperative language, this issue can be worked around by using a mutable "
"variable that contains the next number to be assigned. The following Python "
"program computes an inorder numbering using a mutable variable:"
msgstr ""
"树最自然地用递归函数处理，但树上的通常递归模式使得计算中序编号变得困难。这是因为在左子树中分配的最高编号用于确定节点数据值的编号，然后再次用于确定对右子树进行编号的起始点。在命令式语言中，可以通过使用包含要分配的下一个编号的可变变量来解决此问题。以下"
" Python 程序使用可变变量计算中序编号："

#: src/monads.md:427
#, fuzzy
msgid "'Branch("
msgstr "'Branch("

#: src/monads.md:427
#, fuzzy
msgid ", left="
msgstr ", left="

#: src/monads.md:427
#, fuzzy
msgid ", right="
msgstr ", right="

#: src/monads.md:427
#, fuzzy
msgid ")'"
msgstr ")'"

#: src/monads.md:444
#, fuzzy
msgid "The numbering of the Python equivalent of `aTree` is:"
msgstr "`aTree` 的 Python 等效项的编号为："

#: src/monads.md:446
#, fuzzy
msgid "\"d\""
msgstr "\"d\""

#: src/monads.md:447
#, fuzzy
msgid "\"c\""
msgstr "\"c\""

#: src/monads.md:448
#, fuzzy
msgid "\"a\""
msgstr "\"a\""

#: src/monads.md:448
#, fuzzy
msgid "\"b\""
msgstr "\"b\""

#: src/monads.md:450
#, fuzzy
msgid "\"e\""
msgstr "\"e\""

#: src/monads.md:452
#, fuzzy
msgid "and its numbering is:"
msgstr "并且它的编号为："

#: src/monads.md:459
#, fuzzy
msgid ""
"Even though Lean does not have mutable variables, a workaround exists. From "
"the point of view of the rest of the world, the mutable variable can be "
"thought of as having two relevant aspects: its value when the function is "
"called, and its value when the function returns. In other words, a function "
"that uses a mutable variable can be seen as a function that takes the "
"mutable variable's starting value as an argument, returning a pair of the "
"variable's final value and the function's result. This final value can then "
"be passed as an argument to the next step."
msgstr ""
"尽管 Lean "
"没有可变变量，但存在一种解决方法。从世界其他地方的角度来看，可变变量可以被认为具有两个相关方面：函数调用时的值和函数返回时的值。换句话说，使用可变变量的函数可以看作是将可变变量的起始值作为参数的函数，返回变量的最终值和函数结果的元组。然后可以将此最终值作为参数传递给下一步。"

#: src/monads.md:464
#, fuzzy
msgid ""
"Just as the Python example uses an outer function that establishes a mutable"
" variable and an inner helper function that changes the variable, a Lean "
"version of the function uses an outer function that provides the variable's "
"starting value and explicitly returns the function's result along with an "
"inner helper function that threads the variable's value while computing the "
"numbered tree:"
msgstr ""
"正如 Python 示例使用建立可变变量的外部函数和更改变量的内部帮助函数一样，Lean "
"版本的函数使用提供变量起始值并明确返回函数结果的外部函数，以及在计算编号树时传递变量值的内部帮助函数："

#: src/monads.md:475
#, fuzzy
msgid ""
"This code, like the `none`\\-propagating `Option` code, the "
"`error`\\-propagating `Except` code, and the log-accumulating `WithLog` "
"code, commingles two concerns: propagating the value of the counter, and "
"actually traversing the tree to find the result. Just as in those cases, an "
"`andThen` helper can be defined to propagate state from one step of a "
"computation to another. The first step is to give a name to the pattern of "
"taking an input state as an argument and returning an output state together "
"with a value:"
msgstr ""
"此代码与不传播 `none` 的 `Option` 代码、传播 `error` 的 `Except` 代码和累积日志的 `WithLog` "
"代码一样，混杂了两个问题：传播计数器的值，以及实际遍历树以查找结果。与那些情况一样，可以定义一个 `andThen` "
"帮助器，以将状态从计算的一个步骤传播到另一个步骤。第一步是为以下模式命名：将输入状态作为参数并返回输出状态和值："

#: src/monads.md:483
#, fuzzy
msgid ""
"In the case of `State`, `ok` is a function that returns the input state "
"unchanged, along with the provided value:"
msgstr "在 `State` 的情况下，`ok` 是一个函数，它返回未更改的输入状态以及提供的值："

#: src/monads.md:488
#, fuzzy
msgid ""
"When working with a mutable variable, there are two fundamental operations: "
"reading the value and replacing it with a new one. Reading the current value"
" is accomplished with a function that places the input state unmodified into"
" the output state, and also places it into the value field:"
msgstr "在使用可变变量时，有两个基本操作：读取值并用新值替换它。读取当前值是使用将输入状态未修改地放入输出状态并将其放入值字段的函数来完成的："

#: src/monads.md:494
#, fuzzy
msgid ""
"Writing a new value consists of ignoring the input state, and placing the "
"provided new value into the output state:"
msgstr "写入新值包括忽略输入状态，并将提供的新值放入输出状态："

#: src/monads.md:499
#, fuzzy
msgid ""
"Finally, two computations that use state can be sequenced by finding both "
"the output state and return value of the first function, then passing them "
"both into the next function:"
msgstr "最后，可以通过找到第一个函数的输出状态和返回值，然后将它们都传递到下一个函数中，对使用状态的两个计算进行排序："

#: src/monads.md:500
msgid ""
"```lean\n"
"def andThen (first : State σ α) (next : α → State σ β) : State σ β :=\n"
"  fun s =>\n"
"    let (s', x) := first s\n"
"    next x s'\n"
"\n"
"infixl:55 \" ~~> \" => andThen\n"
"```"
msgstr ""
"```lean\n"
"def andThen (first : State σ α) (next : α → State σ β) : State σ β :=\n"
"  fun s =>\n"
"    let (s', x) := first s\n"
"    next x s'\n"
"\n"
"infixl:55 \" ~~> \" => andThen\n"
"```"

#: src/monads.md:509
#, fuzzy
msgid "Using `State` and its helpers, local mutable state can be simulated:"
msgstr "`State` 和它的辅助函数可以模拟局部可变状态："

#: src/monads.md:522
#, fuzzy
msgid ""
"Because `State` simulates only a single local variable, `get` and `set` "
"don't need to refer to any particular variable name."
msgstr "因为 `State` 只模拟了一个局部变量，所以 `get` 和 `set` 不需要引用任何特定的变量名。"

#: src/monads.md:524
#, fuzzy
msgid "Monads: A Functional Design Pattern"
msgstr "单子：一种函数式设计模式"

#: src/monads.md:526
#, fuzzy
msgid "Each of these examples has consisted of:"
msgstr "每个示例都包含："

#: src/monads.md:527
#, fuzzy
msgid ""
"A polymorphic type, such as `Option`, `Except ε`, `WithLog logged`, or "
"`State σ`"
msgstr "一个多态类型，例如 `Option`、`Except ε`、`WithLog logged` 或 `State σ`"

#: src/monads.md:528
#, fuzzy
msgid ""
"An operator `andThen` that takes care of some repetitive aspect of "
"sequencing programs that have this type"
msgstr "一个运算符 `andThen`，它处理具有此类型的程序序列的一些重复方面"

#: src/monads.md:529
#, fuzzy
msgid ""
"An operator `ok` that is (in some sense) the most boring way to use the type"
msgstr "一个运算符 `ok`，它（在某种意义上）是使用该类型最无聊的方式"

#: src/monads.md:530
#, fuzzy
msgid ""
"A collection of other operations, such as `none`, `fail`, `save`, and `get`,"
" that name ways of using the type"
msgstr "一系列其他操作，例如 `none`、`fail`、`save` 和 `get`，它们命名了使用该类型的方法"

#: src/monads.md:532
#, fuzzy
msgid ""
"This style of API is called a _monad_. While the idea of monads is derived "
"from a branch of mathematics called category theory, no understanding of "
"category theory is needed in order to use them for programming. The key idea"
" of monads is that each monad encodes a particular kind of side effect using"
" the tools provided by the pure functional language Lean. For example, "
"`Option` represents programs that can fail by returning `none`, `Except` "
"represents programs that can throw exceptions, `WithLog` represents programs"
" that accumulate a log while running, and `State` represents programs with a"
" single mutable variable."
msgstr ""
"这种风格的 API 称为 "
"_单子_。虽然单子的思想源自于一门称为范畴论的数学分支，但为了将它们用于编程，并不需要理解范畴论。单子的关键思想是，每个单子都使用纯函数式语言 Lean"
" 提供的工具对特定类型的副作用进行编码。例如，`Option` 表示可能通过返回 `none` 而失败的程序，`Except` "
"表示可能抛出异常的程序，`WithLog` 表示在运行时累积日志的程序，`State` 表示具有单个可变变量的程序。"

#: src/monads/class.md:3
#, fuzzy
msgid ""
"Rather than having to import an operator like `ok` or `andThen` for each "
"type that is a monad, the Lean standard library contains a type class that "
"allow them to be overloaded, so that the same operators can be used for "
"_any_ monad. Monads have two operations, which are the equivalent of `ok` "
"and `andThen`:"
msgstr ""
"无需为每个单子类型导入像 `ok` 或 `andThen` 这样的运算符，Lean 标准库包含一个类型类，允许它们被重载，以便相同的运算符可用于 "
"_任何_ 单子。单子有两个操作，它们相当于 `ok` 和 `andThen`："

#: src/monads/class.md:10
#, fuzzy
msgid ""
"This definition is slightly simplified. The actual definition in the Lean "
"library is somewhat more involved, and will be presented later."
msgstr "这个定义略微简化了。Lean 库中的实际定义更复杂一些，稍后会介绍。"

#: src/monads/class.md:13
#, fuzzy
msgid ""
"The `Monad` instances for `Option` and `Except` can be created by adapting "
"the definitions of their respective `andThen` operations:"
msgstr "`Option` 和 `Except` 的 `Monad` 实例可以通过调整它们各自的 `andThen` 操作的定义来创建："

#: src/monads/class.md:30
#, fuzzy
msgid ""
"As an example, `firstThirdFifthSeventh` was defined separately for `Option "
"α` and `Except String α` return types. Now, it can be defined "
"polymorphically for _any_ monad. It does, however, require a lookup function"
" as an argument, because different monads might fail to find a result in "
"different ways. The infix version of `bind` is `>>=`, which plays the same "
"role as `~~>` in the examples."
msgstr ""
"例如，`firstThirdFifthSeventh` 针对 `Option α` 和 `Except String α` "
"返回类型分别定义。现在，它可以针对 _任何_ monad 多态定义。但是，它需要一个查找函数作为参数，因为不同的 monad "
"可能以不同的方式找不到结果。`bind` 的中缀版本是 `>>=`, 它在示例中扮演与 `~~>` 相同的角色。"

#: src/monads/class.md:43
#, fuzzy
msgid ""
"Given example lists of slow mammals and fast birds, this implementation of "
"`firstThirdFifthSeventh` can be used with `Option`:"
msgstr "给定慢哺乳动物和快鸟的示例列表，`firstThirdFifthSeventh` 的此实现可与 `Option` 一起使用："

#: src/monads/class.md:44
#, fuzzy
msgid ""
"```lean\n"
"def slowMammals : List String :=\n"
"  [\"Three-toed sloth\", \"Slow loris\"]\n"
"\n"
"def fastBirds : List String := [\n"
"  \"Peregrine falcon\",\n"
"  \"Saker falcon\",\n"
"  \"Golden eagle\",\n"
"  \"Gray-headed albatross\",\n"
"  \"Spur-winged goose\",\n"
"  \"Swift\",\n"
"  \"Anna's hummingbird\"\n"
"]\n"
"\n"
"#eval firstThirdFifthSeventh (fun xs i => xs[i]?) slowMammals\n"
"```"
msgstr ""
"```lean\n"
"def slowMammals : List String :=\n"
"  [\"Three-toed sloth\", \"Slow loris\"]\n"
"\n"
"def fastBirds : List String := [\n"
"  \"Peregrine falcon\",\n"
"  \"Saker falcon\",\n"
"  \"Golden eagle\",\n"
"  \"Gray-headed albatross\",\n"
"  \"Spur-winged goose\",\n"
"  \"Swift\",\n"
"  \"Anna's hummingbird\"\n"
"]\n"
"\n"
"#eval firstThirdFifthSeventh (fun xs i => xs[i]?) slowMammals\n"
"```"

#: src/monads/class.md:66
#, fuzzy
msgid ""
"```output info\n"
"some (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", \"Anna's hummingbird\")\n"
"```"
msgstr ""
"```output info\n"
"some (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", \"Anna's hummingbird\")\n"
"```"

#: src/monads/class.md:70
#, fuzzy
msgid ""
"After renaming `Except`'s lookup function `get` to something more specific, "
"the very same  implementation of `firstThirdFifthSeventh` can be used with "
"`Except` as well:"
msgstr ""
"在将 `Except` 的查找函数 `get` 重命名为更具体的内容后，`firstThirdFifthSeventh` 的相同实现也可以与 "
"`Except` 一起使用："

#: src/monads/class.md:71
#, fuzzy
msgid ""
"```lean\n"
"def getOrExcept (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => Except.error s!\"Index {i} not found (maximum is {xs.length - 1})\"\n"
"  | some x => Except.ok x\n"
"\n"
"#eval firstThirdFifthSeventh getOrExcept slowMammals\n"
"```"
msgstr ""
"```lean\n"
"def getOrExcept (xs : List α) (i : Nat) : Except String α :=\n"
"  match xs[i]? with\n"
"  | none => Except.error s!\"Index {i} not found (maximum is {xs.length - 1})\"\n"
"  | some x => Except.ok x\n"
"\n"
"#eval firstThirdFifthSeventh getOrExcept slowMammals\n"
"```"

#: src/monads/class.md:79
msgid ""
"```output info\n"
"Except.error \"Index 2 not found (maximum is 1)\"\n"
"```"
msgstr ""
"```output info\n"
"Except.error \"Index 2 not found (maximum is 1)\"\n"
"```"

#: src/monads/class.md:85
msgid ""
"```output info\n"
"Except.ok (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", \"Anna's hummingbird\")\n"
"```"
msgstr ""
"```output info\n"
"Except.ok (\"Peregrine falcon\", \"Golden eagle\", \"Spur-winged goose\", \"Anna's hummingbird\")\n"
"```"

#: src/monads/class.md:88
msgid ""
"The fact that `m` must have a `Monad` instance means that the `>>=` and "
"`pure` operations are available."
msgstr "`m` 必须有 `Monad` 实例，这意味着可以使用 `>>=` 和 `pure` 操作。"

#: src/monads/class.md:91
msgid "General Monad Operations"
msgstr "通用 Monad 操作"

#: src/monads/class.md:93
msgid ""
"Because many different types are monads, functions that are polymorphic over"
" _any_ monad are very powerful. For example, the function `mapM` is a "
"version of `map` that uses a `Monad` to sequence and combine the results of "
"applying a function:"
msgstr ""
"由于许多不同类型都是 monad，因此在 _任何_ monad 上多态的函数非常强大。例如，函数 `mapM` 是 `map` 的一个版本，它使用 "
"`Monad` 对应用函数的结果进行排序和组合："

#: src/monads/class.md:103
msgid ""
"The return type of the function argument `f` determines which `Monad` "
"instance will be used. In other words, `mapM` can be used for functions that"
" produce logs, for functions that can fail, or for functions that use "
"mutable state. Because `f`'s type determines the available effects, they can"
" be tightly controlled by API designers."
msgstr ""
"函数参数 `f` 的返回类型决定了将使用哪个 `Monad` 实例。换句话说，`mapM` "
"可用于生成日志的函数、可能失败的函数或使用可变状态的函数。由于 `f` 的类型决定了可用的效果，因此 API 设计人员可以对其进行严格控制。"

#: src/monads/class.md:107
msgid ""
"As described in [this chapter's introduction](../monads.md#numbering-tree-"
"nodes), `State σ α` represents programs that make use of a mutable variable "
"of type `σ` and return a value of type `α`. These programs are actually "
"functions from a starting state to a pair of a value and a final state. The "
"`Monad` class requires that its parameter expect a single type argument—that"
" is, it should be a `Type → Type`. This means that the instance for `State` "
"should mention the state type `σ`, which becomes a parameter to the "
"instance:"
msgstr ""
"如 [本章简介](../monads.md#numbering-tree-nodes) 所述，`State σ α` 表示使用类型为 `σ` "
"的可变变量并返回类型为 `α` 的值的程序。这些程序实际上是从起始状态到值和最终状态对的函数。`Monad` 类要求其参数期望单个类型参数，即它应该是 "
"`Type → Type`。这意味着 `State` 的实例应提及状态类型 `σ`，它成为实例的参数："

#: src/monads/class.md:119
msgid ""
"This means that the type of the state cannot change between calls to `get` "
"and `set` that are sequenced using `bind`, which is a reasonable rule for "
"stateful computations. The operator `increment` increases a saved state by a"
" given amount, returning the old value:"
msgstr ""
"这意味着在使用 `bind` 对 `get` 和 `set` 进行排序时，状态的类型不能更改，这是有状态计算的合理规则。运算符 `increment` "
"将保存的状态增加给定量，并返回旧值："

#: src/monads/class.md:128
#, fuzzy
msgid ""
"Using `mapM` with `increment` results in a program that computes the sum of "
"the entries in a list. More specifically, the mutable variable contains the "
"sum so far, while the resulting list contains a running sum. In other words,"
" `mapM increment` has type `List Int → State Int (List Int)`, and expanding "
"the definition of `State` yields `List Int → Int → (Int × List Int)`. It "
"takes an initial sum as an argument, which should be `0`:"
msgstr ""
"使用 `mapM` 和 `increment` "
"会生成一个计算列表中条目和的程序。更具体地说，可变变量包含到目前为止的和，而结果列表包含一个运行和。换句话说，`mapM increment` 的类型为"
" `List Int → State Int (List Int)`，展开 `State` 的定义会得到 `List Int → Int → (Int "
"× List Int)`。它将初始和作为参数，该参数应为 `0`："

#: src/monads/class.md:139
#, fuzzy
msgid ""
"A [logging effect](../monads.md#logging) can be represented using `WithLog`."
" Just like `State`, its `Monad` instance is polymorphic with respect to the "
"type of the logged data:"
msgstr ""
"可以使用 `WithLog` 表示 [日志记录效果](../monads.md#logging)。就像 `State` 一样，它的 `Monad` "
"实例对于已记录数据的类型是多态的："

#: src/monads/class.md:149
#, fuzzy
msgid ""
"`saveIfEven` is a function that logs even numbers but returns its argument "
"unchanged:"
msgstr "`saveIfEven` 是一个记录偶数但返回其参数不变的函数："

#: src/monads/class.md:157
#, fuzzy
msgid ""
"Using this function with `mapM` results in a log containing even numbers "
"paired with an unchanged input list:"
msgstr "使用 `mapM` 和此函数会生成一个包含偶数和未更改输入列表的日志："

#: src/monads/class.md:167
#, fuzzy
msgid "The Identity Monad"
msgstr "Identity Monad"

#: src/monads/class.md:169
#, fuzzy
msgid ""
"Monads encode programs with effects, such as failure, exceptions, or "
"logging, into explicit representations as data and functions. Sometimes, "
"however, an API will be written to use a monad for flexibility, but the "
"API's client may not require any encoded effects. The _identity monad_ is a "
"monad that has no effects, and allows pure code to be used with monadic "
"APIs:"
msgstr ""
"Monad 将具有效果的程序（例如失败、异常或日志记录）编码为数据和函数的显式表示。然而，有时会编写 API 以使用 monad 来提高灵活性，但 "
"API 的客户端可能不需要任何编码效果。_identity monad_ 是一个没有效果的 monad，允许将纯代码与 monadic API "
"一起使用："

#: src/monads/class.md:179
#, fuzzy
msgid ""
"The type of `pure` should be `α → Id α`, but `Id α` reduces to just `α`. "
"Similarly, the type of `bind` should be `α → (α → Id β) → Id β`. Because "
"this reduces to `α → (α → β) → β`, the second argument can be applied to the"
" first to find the result."
msgstr ""
"`pure` 的类型应为 `α → Id α`，但 `Id α` 简化为 `α`。类似地，`bind` 的类型应为 `α → (α → Id β) → "
"Id β`。由于这简化为 `α → (α → β) → β`，因此可以将第二个参数应用于第一个参数以找到结果。"

#: src/monads/class.md:183
#, fuzzy
msgid ""
"With the identity monad, `mapM` becomes equivalent to `map`. To call it this"
" way, however, Lean requires a hint that the intended monad is `Id`:"
msgstr ""
"使用 identity monad，`mapM` 等同于 `map`。但是，要以这种方式调用它，Lean 需要一个提示，表明目标 monad 是 "
"`Id`："

#: src/monads/class.md:191
#, fuzzy
msgid "Omitting the hint results in an error:"
msgstr "省略提示会导致错误："

#: src/monads/class.md:199
#, fuzzy
msgid ""
"In this error, the application of one metavariable to another indicates that"
" Lean doesn't run the type-level computation backwards. The return type of "
"the function is expected to be the monad applied to some other type. "
"Similarly, using `mapM` with a function whose type doesn't provide any "
"specific hints about which monad is to be used results in an \"instance "
"problem stuck\" message:"
msgstr ""
"在此错误中，一个元变量应用于另一个元变量表明 Lean 不会反向运行类型级计算。函数的返回类型应为应用于其他类型的单子。类似地，使用 `mapM` "
"和其类型未提供要使用哪个单子的任何特定提示的函数会导致「实例问题卡住」消息："

#: src/monads/class.md:211
#, fuzzy
msgid "The Monad Contract"
msgstr "单子契约"

#: src/monads/class.md:212
#, fuzzy
msgid ""
"Just as every pair of instances of `BEq` and `Hashable` should ensure that "
"any two equal values have the same hash, there is a contract that each "
"instance of `Monad` should obey. First, `pure` should be a left identity of "
"`bind`. That is, `bind (pure v) f` should be the same as `f v`. Secondly, "
"`pure` should be a right identity of `bind`, so `bind v pure` is the same as"
" `v`. Finally, `bind` should be associative, so `bind (bind v f) g` is the "
"same as `bind v (fun x => bind (f x) g)`."
msgstr ""
"正如 `BEq` 和 `Hashable` 的每一对实例都应确保任何两个相等的值具有相同的哈希值，`Monad` "
"的每个实例都应遵守契约。首先，`pure` 应为 `bind` 的左单位。即，`bind (pure v) f` 应与 `f v` "
"相同。其次，`pure` 应为 `bind` 的右单位，因此 `bind v pure` 与 `v` 相同。最后，`bind` 应为结合的，因此 "
"`bind (bind v f) g` 与 `bind v (fun x => bind (f x) g)` 相同。"

#: src/monads/class.md:218
#, fuzzy
msgid ""
"This contract specifies the expected properties of programs with effects "
"more generally. Because `pure` has no effects, sequencing its effects with "
"`bind` shouldn't change the result. The associative property of `bind` "
"basically says that the sequencing bookkeeping itself doesn't matter, so "
"long as the order in which things are happening is preserved."
msgstr ""
"此契约指定了具有效果的程序的预期属性。由于 `pure` 没有效果，因此将其效果与 `bind` 顺序执行不应改变结果。`bind` "
"的结合属性基本上表示顺序记账本身无关紧要，只要保留事情发生的顺序即可。"

#: src/monads/class.md:224
#, fuzzy
msgid "Mapping on a Tree"
msgstr "映射树"

#: src/monads/class.md:226
#, fuzzy
msgid ""
"Define a function `BinTree.mapM`. By analogy to `mapM` for lists, this "
"function should apply a monadic function to each data entry in a tree, as a "
"preorder traversal. The type signature should be:"
msgstr ""
"定义函数 `BinTree.mapM`。通过类比列表的 `mapM`，此函数应将单子函数应用于树中的每个数据项，作为前序遍历。类型签名应为："

#: src/monads/class.md:234
#, fuzzy
msgid "The Option Monad Contract"
msgstr "选项单子契约"

#: src/monads/class.md:236
#, fuzzy
msgid ""
"First, write a convincing argument that the `Monad` instance for `Option` "
"satisfies the monad contract. Then, consider the following instance:"
msgstr "首先，写一个令人信服的论证，证明 `Option` 的 `Monad` 实例满足 monad 契约。然后，考虑以下实例："

#: src/monads/class.md:243
#, fuzzy
msgid ""
"Both methods have the correct type. Why does this instance violate the monad"
" contract?"
msgstr "这两个方法都有正确的类型。为什么这个实例违反了 monad 契约？"

#: src/monads/arithmetic.md:3
#, fuzzy
msgid ""
"Monads are a way of encoding programs with side effects into a language that"
" does not have them. It would be easy to read this as a sort of admission "
"that pure functional programs are missing something important, requiring "
"programmers to jump through hoops just to write a normal program. However, "
"while using the `Monad` API does impose a syntactic cost on a program, it "
"brings two important benefits:"
msgstr ""
"Monad "
"是一种将具有副作用的程序编码到没有副作用的语言中的方式。很容易将此解读为一种承认，纯函数式程序缺少一些重要的东西，要求程序员跳过障碍才能编写一个普通的程序。然而，虽然使用"
" `Monad` API 确实给程序带来了语法成本，但它带来了两个重要的优点："

#: src/monads/arithmetic.md:6
#, fuzzy
msgid ""
"Programs must be honest about which effects they use in their types. A quick"
" glance at a type signature describes _everything_ that the program can do, "
"rather than just what it accepts and what it returns."
msgstr "程序必须诚实地说明它们在类型中使用的效果。快速浏览类型签名描述了程序可以做的一切，而不仅仅是它接受什么和返回什么。"

#: src/monads/arithmetic.md:7
#, fuzzy
msgid ""
"Not every language provides the same effects. For example, only some "
"language have exceptions. Other languages have unique, exotic effects, such "
"as [Icon's searching over multiple "
"values](https://www2.cs.arizona.edu/icon/) and Scheme or Ruby's "
"continuations. Because monads can encode _any_ effect, programmers can "
"choose which ones are the best fit for a given application, rather than "
"being stuck with what the language developers provided."
msgstr ""
"并非每种语言都提供相同的效果。例如，只有某些语言有异常。其他语言具有独特的新奇效果，例如 [Icon "
"对多个值进行搜索](https://www2.cs.arizona.edu/icon/) 以及 Scheme 或 Ruby 的延续。由于 monad "
"可以编码任何效果，因此程序员可以选择最适合给定应用程序的效果，而不是局限于语言开发者提供的效果。"

#: src/monads/arithmetic.md:9
#, fuzzy
msgid ""
"One example of a program that can make sense in a variety of monads is an "
"evaluator for arithmetic expressions."
msgstr "一个可以在各种 monad 中有意义的程序示例是算术表达式的求值器。"

#: src/monads/arithmetic.md:11
#, fuzzy
msgid "Arithmetic Expressions"
msgstr "算术表达式"

#: src/monads/arithmetic.md:13
#, fuzzy
msgid ""
"An arithmetic expression is either a literal integer or a primitive binary "
"operator applied to two expressions. The operators are addition, "
"subtraction, multiplication, and division:"
msgstr "算术表达式要么是字面整数，要么是应用于两个表达式的原始二元运算符。运算符是加法、减法、乘法和除法："

#: src/monads/arithmetic.md:26
#, fuzzy
msgid "The expression `2 + 3` is represented:"
msgstr "表达式 `2 + 3` 表示为："

#: src/monads/arithmetic.md:33
#, fuzzy
msgid "and `14 / (45 - 5 * 9)` is represented:"
msgstr "而 `14 / (45 - 5 * 9)` 表示为："

#: src/monads/arithmetic.md:43
#, fuzzy
msgid ""
"Because expressions include division, and division by zero is undefined, "
"evaluation might fail. One way to represent failure is to use `Option`:"
msgstr "由于表达式包含除法，而除以零是未定义的，因此求值可能会失败。表示失败的一种方法是使用 `Option`："

#: src/monads/arithmetic.md:57
#, fuzzy
msgid ""
"This definition uses the `Monad Option` instance to propagate failures from "
"evaluating both branches of a binary operator. However, the function mixes "
"two concerns: evaluating subexpressions and applying a binary operator to "
"the results. It can be improved by splitting it into two functions:"
msgstr ""
"此定义使用 `Monad Option` "
"实例来传播从二元运算符的两个分支求值产生的失败。但是，该函数混合了两个问题：求值子表达式和将二元运算符应用于结果。可以通过将其拆分为两个函数来改进它："

#: src/monads/arithmetic.md:75
#, fuzzy
msgid ""
"Running `#eval evaluateOption fourteenDivided` yields `none`, as expected, "
"but this is not a very useful error message. Because the code was written "
"using `>>=` rather than by explicitly handling the `none` constructor, only "
"a small modification is required for it to provide an error message on "
"failure:"
msgstr ""
"运行 `#eval evaluateOption fourteenDivided` 会产生 "
"`none`，正如预期的那样，但这不是一个非常有用的错误消息。由于代码是使用 `>>=` 编写的，而不是显式处理 `none` "
"构造子，因此只需进行少量修改即可在失败时提供错误消息："

#: src/monads/arithmetic.md:77
#, fuzzy
msgid ""
"```lean\n"
"def applyPrim : Arith → Int → Int → Except String Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"\n"
"def evaluateExcept : Expr Arith → Except String Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateExcept e1 >>= fun v1 =>\n"
"    evaluateExcept e2 >>= fun v2 =>\n"
"    applyPrim p v1 v2\n"
"```"
msgstr ""
"```lean\n"
"def applyPrim : Arith → Int → Int → Except String Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"\n"
"def evaluateExcept : Expr Arith → Except String Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateExcept e1 >>= fun v1 =>\n"
"    evaluateExcept e2 >>= fun v2 =>\n"
"    applyPrim p v1 v2\n"
"```"

#: src/monads/arithmetic.md:95
#, fuzzy
msgid ""
"The only difference is that the type signature mentions `Except String` "
"instead of `Option`, and the failing case uses `Except.error` instead of "
"`none`. By making `evaluate` polymorphic over its monad and passing it "
"`applyPrim` as an argument, a single evaluator becomes capable of both forms"
" of error reporting:"
msgstr ""
"唯一的区别是类型签名提到 `Except String` 而不是 `Option`，并且失败的情况使用 `Except.error` 而不是 "
"`none`。通过使 `evaluate` 在其单子上多态并将其作为参数传递给 `applyPrim`，单个求值器能够以两种形式进行错误报告："

#: src/monads/arithmetic.md:97
#, fuzzy
msgid ""
"```lean\n"
"def applyPrimOption : Arith → Int → Int → Option Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      none\n"
"    else pure (x / y)\n"
"\n"
"def applyPrimExcept : Arith → Int → Int → Except String Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def evaluateM [Monad m] (applyPrim : Arith → Int → Int → m Int): Expr Arith → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applyPrim e1 >>= fun v1 =>\n"
"    evaluateM applyPrim e2 >>= fun v2 =>\n"
"    applyPrim p v1 v2\n"
"```"
msgstr "**applyPrimOption** 函数与 `evaluate` 的第一个版本类似，使用它时效果相同。"

#: src/monads/arithmetic.md:123
#, fuzzy
msgid ""
"Using it with `applyPrimOption` works just like the first version of "
"`evaluate`:"
msgstr "同样，使用 **applyPrimExcept** 函数时效果与带有错误消息的版本相同："

#: src/monads/arithmetic.md:130
#, fuzzy
msgid ""
"Similarly, using it with `applyPrimExcept` works just like the version with "
"error messages:"
msgstr ""
"```output info\n"
"Except.error \"尝试将 14 除以零\"\n"
"```"

#: src/monads/arithmetic.md:134
#, fuzzy
msgid ""
"```output info\n"
"Except.error \"Tried to divide 14 by zero\"\n"
"```"
msgstr ""
"代码仍有改进空间。**applyPrimOption** 和 **applyPrimExcept** "
"函数仅在除法处理上有所不同，可以将其提取到求值器的另一个参数中："

#: src/monads/arithmetic.md:138
#, fuzzy
msgid ""
"The code can still be improved. The functions `applyPrimOption` and "
"`applyPrimExcept` differ only in their treatment of division, which can be "
"extracted into another parameter to the evaluator:"
msgstr ""
"```lean\n"
"def applyDivOption (x : Int) (y : Int) : Option Int :=\n"
"    如果 y == 0 则\n"
"      无\n"
"    否则\n"
"      纯 (x / y)\n"
"\n"
"def applyDivExcept (x : Int) (y : Int) : Except String Int :=\n"
"    如果 y == 0 则\n"
"      Except.error s!\"尝试将 {x} 除以零\"\n"
"    否则\n"
"      纯 (x / y)\n"
"\n"
"def applyPrim [Monad m] (applyDiv : Int → Int → m Int) : Arith → Int → Int → m Int\n"
"  | Arith.plus, x, y => 纯 (x + y)\n"
"  | Arith.minus, x, y => 纯 (x - y)\n"
"  | Arith.times, x, y => 纯 (x * y)\n"
"  | Arith.div, x, y => applyDiv x y\n"
"\n"
"def evaluateM [Monad m] (applyDiv : Int → Int → m Int): Expr Arith → m Int\n"
"  | Expr.const i => 纯 i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applyDiv e1 >>= fun v1 =>\n"
"    evaluateM applyDiv e2 >>= fun v2 =>\n"
"    applyPrim applyDiv p v1 v2\n"
"```"

#: src/monads/arithmetic.md:140
msgid ""
"```lean\n"
"def applyDivOption (x : Int) (y : Int) : Option Int :=\n"
"    if y == 0 then\n"
"      none\n"
"    else pure (x / y)\n"
"\n"
"def applyDivExcept (x : Int) (y : Int) : Except String Int :=\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def applyPrim [Monad m] (applyDiv : Int → Int → m Int) : Arith → Int → Int → m Int\n"
"  | Arith.plus, x, y => pure (x + y)\n"
"  | Arith.minus, x, y => pure (x - y)\n"
"  | Arith.times, x, y => pure (x * y)\n"
"  | Arith.div, x, y => applyDiv x y\n"
"\n"
"def evaluateM [Monad m] (applyDiv : Int → Int → m Int): Expr Arith → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applyDiv e1 >>= fun v1 =>\n"
"    evaluateM applyDiv e2 >>= fun v2 =>\n"
"    applyPrim applyDiv p v1 v2\n"
"```"
msgstr ""

#: src/monads/arithmetic.md:165
#, fuzzy
msgid ""
"In this refactored code, the fact that the two code paths differ only in "
"their treatment of failure has been made fully apparent."
msgstr "在重构后的代码中，两个代码路径仅在对失败的处理上有所不同，这一事实已完全显而易见。"

#: src/monads/arithmetic.md:167
#, fuzzy
msgid "Further Effects"
msgstr "其他影响"

#: src/monads/arithmetic.md:169
#, fuzzy
msgid ""
"Failure and exceptions are not the only kinds of effects that can be "
"interesting when working with an evaluator. While division's only side "
"effect is failure, adding other primitive operators to the expressions make "
"it possible to express other effects."
msgstr "在使用求值器时，失败和异常并不是唯一可能引起兴趣的影响类型。虽然除法的唯一副作用是失败，但将其他原始运算符添加到表达式中可以表达其他影响。"

#: src/monads/arithmetic.md:172
#, fuzzy
msgid ""
"The first step is an additional refactoring, extracting division from the "
"datatype of primitives:"
msgstr "第一步是进行额外的重构，从原始数据类型中提取除法："

#: src/monads/arithmetic.md:183
#, fuzzy
msgid ""
"The name `CanFail` suggests that the effect introduced by division is "
"potential failure."
msgstr "名称 `CanFail` 表明除法引入的影响是潜在的失败。"

#: src/monads/arithmetic.md:185
#, fuzzy
msgid ""
"The second step is to broaden the scope of the division handler argument to "
"`evaluateM` so that it can process any special operator:"
msgstr "第二步是将除法处理程序参数的作用域扩展到 `evaluateM`，以便它可以处理任何特殊运算符："

#: src/monads/arithmetic.md:186
#, fuzzy
msgid ""
"```lean\n"
"def divOption : CanFail → Int → Int → Option Int\n"
"  | CanFail.div, x, y => if y == 0 then none else pure (x / y)\n"
"\n"
"def divExcept : CanFail → Int → Int → Except String Int\n"
"  | CanFail.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def applyPrim [Monad m] (applySpecial : special → Int → Int → m Int) : Prim special → Int → Int → m Int\n"
"  | Prim.plus, x, y => pure (x + y)\n"
"  | Prim.minus, x, y => pure (x - y)\n"
"  | Prim.times, x, y => pure (x * y)\n"
"  | Prim.other op, x, y => applySpecial op x y\n"
"\n"
"def evaluateM [Monad m] (applySpecial : special → Int → Int → m Int): Expr (Prim special) → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applySpecial e1 >>= fun v1 =>\n"
"    evaluateM applySpecial e2 >>= fun v2 =>\n"
"    applyPrim applySpecial p v1 v2\n"
"```"
msgstr ""
"```lean\n"
"def divOption : CanFail → Int → Int → Option Int\n"
"  | CanFail.div, x, y => if y == 0 then none else pure (x / y)\n"
"\n"
"def divExcept : CanFail → Int → Int → Except String Int\n"
"  | CanFail.div, x, y =>\n"
"    if y == 0 then\n"
"      Except.error s!\"Tried to divide {x} by zero\"\n"
"    else pure (x / y)\n"
"\n"
"def applyPrim [Monad m] (applySpecial : special → Int → Int → m Int) : Prim special → Int → Int → m Int\n"
"  | Prim.plus, x, y => pure (x + y)\n"
"  | Prim.minus, x, y => pure (x - y)\n"
"  | Prim.times, x, y => pure (x * y)\n"
"  | Prim.other op, x, y => applySpecial op x y\n"
"\n"
"def evaluateM [Monad m] (applySpecial : special → Int → Int → m Int): Expr (Prim special) → m Int\n"
"  | Expr.const i => pure i\n"
"  | Expr.prim p e1 e2 =>\n"
"    evaluateM applySpecial e1 >>= fun v1 =>\n"
"    evaluateM applySpecial e2 >>= fun v2 =>\n"
"    applyPrim applySpecial p v1 v2\n"
"```"

#: src/monads/arithmetic.md:210
#, fuzzy
msgid "No Effects"
msgstr "无副作用"

#: src/monads/arithmetic.md:212
#, fuzzy
msgid ""
"The type `Empty` has no constructors, and thus no values, like the `Nothing`"
" type in Scala or Kotlin. In Scala and Kotlin, `Nothing` can represent "
"computations that never return a result, such as functions that crash the "
"program, throw exceptions, or always fall into infinite loops. An argument "
"to a function or method of type `Nothing` indicates dead code, as there will"
" never be a suitable argument value. Lean doesn't support infinite loops and"
" exceptions, but `Empty` is still useful as an indication to the type system"
" that a function cannot be called. Using the syntax `nomatch E` when `E` is "
"an expression whose type has no constructors indicates to Lean that the "
"current expression need not return a result, because it could never have "
"been called. "
msgstr ""
"`Empty` 类型没有构造子，因此没有值，就像 Scala 或 Kotlin 中的 `Nothing` 类型。在 Scala 和 Kotlin "
"中，`Nothing` 可以表示永不返回结果的计算，例如导致程序崩溃、引发异常或始终陷入无限循环的函数。类型为 `Nothing` "
"的函数或方法的参数表示死代码，因为永远不会有合适的参数值。Lean 不支持无限循环和异常，但 `Empty` "
"仍然可作为指示类型系统函数不可调用的标志。当 `E` 是类型没有构造子的表达式的表达式时，使用语法 `nomatch E` 向 Lean "
"指示当前表达式不需要返回结果，因为它永远不会被调用。"

#: src/monads/arithmetic.md:218
#, fuzzy
msgid ""
"Using `Empty` as the parameter to `Prim` indicates that there are no "
"additional cases beyond `Prim.plus`, `Prim.minus`, and `Prim.times`, because"
" it is impossible to come up with a value of type `Empty` to place in the "
"`Prim.other` constructor. Because a function to apply an operator of type "
"`Empty` to two integers can never be called, it doesn't need to return a "
"result. Thus, it can be used in _any_ monad:"
msgstr ""
"将 `Empty` 用作 `Prim` 的参数表示除了 `Prim.plus`、`Prim.minus` 和 `Prim.times` "
"之外没有其他情况，因为不可能想出一个 `Empty` 类型的值来放在 `Prim.other` 构造子中。由于应用类型为 `Empty` "
"的运算符到两个整数的函数永远不会被调用，因此它不需要返回结果。因此，它可以在 _任何_ 单子中使用："

#: src/monads/arithmetic.md:225
#, fuzzy
msgid ""
"This can be used together with `Id`, the identity monad, to evaluate "
"expressions that have no effects whatsoever:"
msgstr "这可以与恒等单子 `Id` 一起使用，以计算没有任何副作用的表达式："

#: src/monads/arithmetic.md:234
#, fuzzy
msgid "Nondeterministic Search"
msgstr "非确定性搜索"

#: src/monads/arithmetic.md:236
#, fuzzy
msgid ""
"Instead of simply failing when encountering division by zero, it would also "
"be sensible to backtrack and try a different input. Given the right monad, "
"the very same `evaluateM` can perform a nondeterministic search for a _set_ "
"of answers that do not result in failure. This requires, in addition to "
"division, some means of specifying a choice of results. One way to do this "
"is to add a function `choose` to the language of expressions that instructs "
"the evaluator to pick either of its arguments while searching for non-"
"failing results."
msgstr ""
"遇到除以零时，除了直接失败之外，还可以回溯并尝试不同的输入。给定正确的单子，同一个 `evaluateM` 可以对不导致失败的答案 _集_ "
"执行非确定性搜索。除了除法之外，还需要一些指定结果选择的方法。一种方法是在表达式的语言中添加一个函数 "
"`choose`，指示求值器在搜索非失败结果时选择其任一参数。"

#: src/monads/arithmetic.md:241
#, fuzzy
msgid ""
"The result of the evaluator is now a multiset of values, rather than a "
"single value. The rules for evaluation into a multiset are:"
msgstr "求值结果现在是一个多重集，而不是一个单一值。求值到多重集的规则如下："

#: src/monads/arithmetic.md:243
#, fuzzy
msgid "Constants \\\\( n \\\\) evaluate to singleton sets \\\\( {n} \\\\)."
msgstr "常量 \\\\( n \\\\) 求值为单元素集 \\\\( {n} \\\\)。"

#: src/monads/arithmetic.md:244
#, fuzzy
msgid ""
"Arithmetic operators other than division are called on each pair from the "
"Cartesian product of the operators, so \\\\( X + Y \\\\) evaluates to \\\\( "
"\\\\{ x + y \\\\mid x ∈ X, y ∈ Y \\\\} \\\\)."
msgstr ""
"除法以外的算术运算符对运算符笛卡尔积中的每一对进行调用，所以 \\\\( X + Y \\\\) 求值为 \\\\( \\\\{ x + y "
"\\\\mid x ∈ X, y ∈ Y \\\\} \\\\)。"

#: src/monads/arithmetic.md:245
#, fuzzy
msgid ""
"Division \\\\( X / Y \\\\) evaluates to \\\\( \\\\{ x / y \\\\mid x ∈ X, y ∈"
" Y, y ≠ 0\\\\} \\\\). In other words, all \\\\( 0 \\\\) values in \\\\( Y "
"\\\\)  are thrown out."
msgstr ""
"除法 \\\\( X / Y \\\\) 求值为 \\\\( \\\\{ x / y \\\\mid x ∈ X, y ∈ Y, y ≠ 0\\\\} "
"\\\\)。换句话说，\\\\( Y \\\\) 中的所有 \\\\( 0 \\\\) 值都被丢弃。"

#: src/monads/arithmetic.md:246
#, fuzzy
msgid "A choice \\\\( \\\\mathrm{choose}(x, y) \\\\) evaluates to \\\\( \\\\{ x, y \\\\} \\\\)."
msgstr "一个选择 \\\\( \\\\mathrm{choose}(x, y) \\\\) 求值为 \\\\( \\\\{ x, y \\\\} \\\\)。"

#: src/monads/arithmetic.md:248
#, fuzzy
msgid ""
"For example, \\\\( 1 + \\\\mathrm{choose}(2, 5) \\\\) evaluates to \\\\( "
"\\\\{ 3, 6 \\\\} \\\\), \\\\(1 + 2 / 0 \\\\) evaluates to \\\\( \\\\{\\\\} "
"\\\\), and \\\\( 90 / (\\\\mathrm{choose}(-5, 5) + 5) \\\\) evaluates to "
"\\\\( \\\\{ 9 \\\\} \\\\). Using multisets instead of true sets simplifies "
"the code by removing the need to check for uniqueness of elements."
msgstr ""
"例如，\\\\( 1 + \\\\mathrm{choose}(2, 5) \\\\) 求值为 \\\\( \\\\{ 3, 6 \\\\} "
"\\\\)，\\\\(1 + 2 / 0 \\\\) 求值为 \\\\( \\\\{\\\\} \\\\)，\\\\( 90 / "
"(\\\\mathrm{choose}(-5, 5) + 5) \\\\) 求值为 \\\\( \\\\{ 9 \\\\} "
"\\\\)。使用多重集代替真集简化了代码，无需再检查元素的唯一性。"

#: src/monads/arithmetic.md:251
#, fuzzy
msgid ""
"A monad that represents this non-deterministic effect must be able to "
"represent a situation in which there are no answers, and a situation in "
"which there is at least one answer together with any remaining answers:"
msgstr "表示这种非确定性效果的单子必须能够表示没有答案的情况，以及至少有一个答案和任何剩余答案的情况："

#: src/monads/arithmetic.md:257
#, fuzzy
msgid ""
"This datatype looks very much like `List`. The difference is that where "
"`cons` stores the rest of the list, `more` stores a function that should "
"compute the next value on demand. This means that a consumer of `Many` can "
"stop the search when some number of results have been found."
msgstr ""
"此数据类型看起来非常像 `List`。不同之处在于，`cons` 存储列表的其余部分，而 `more` 存储一个函数，该函数应按需计算下一个值。这意味着"
" `Many` 的使用者可以在找到一定数量的结果后停止搜索。"

#: src/monads/arithmetic.md:261
#, fuzzy
msgid ""
"A single result is represented by a `more` constructor that returns no "
"further results:"
msgstr "单个结果由 `more` 构造子表示，该构造子不返回任何进一步的结果："

#: src/monads/arithmetic.md:265
#, fuzzy
msgid ""
"The union of two multisets of results can be computed by checking whether "
"the first multiset is empty. If so, the second multiset is the union. If "
"not, the union consists of the first element of the first multiset followed "
"by the union of the rest of the first multiset with the second multiset:"
msgstr ""
"两个结果多重集的并集可以通过检查第一个多重集是否为空来计算。如果是，则第二个多重集是并集。如果不是，则并集由第一个多重集的第一个元素后跟第一个多重集的其余部分与第二个多重集的并集组成："

#: src/monads/arithmetic.md:274
#, fuzzy
msgid ""
"It can be convenient to start a search process with a list of values. "
"`Many.fromList` converts a list into a multiset of results:"
msgstr "从值列表开始搜索过程会很方便。`Many.fromList` 将列表转换为结果的多重集合："

#: src/monads/arithmetic.md:281
#, fuzzy
msgid ""
"Similarly, once a search has been specified, it can be convenient to extract"
" either a number of values, or all the values:"
msgstr "同样，一旦指定了搜索，就可以方便地提取多个值或所有值："

#: src/monads/arithmetic.md:293
#, fuzzy
msgid ""
"A `Monad Many` instance requires a `bind` operator. In a nondeterministic "
"search, sequencing two operations consists of taking all possibilities from "
"the first step and running the rest of the program on each of them, taking "
"the union of the results. In other words, if the first step returns three "
"possible answers, the second step needs to be tried for all three. Because "
"the second step can return any number of answers for each input, taking "
"their union represents the entire search space."
msgstr ""
"`Monad Many` 实例需要一个 `bind` "
"运算符。在非确定性搜索中，对两个操作进行排序包括从第一步中获取所有可能性，并在每个可能性上运行程序的其余部分，取结果的并集。换句话说，如果第一步返回三个可能的答案，则需要对所有三个答案尝试第二步。由于第二步可以为每个输入返回任意数量的答案，因此取它们的并集表示整个搜索空间。"

#: src/monads/arithmetic.md:305
#, fuzzy
msgid ""
"`Many.one` and `Many.bind` obey the monad contract. To check that `Many.bind"
" (Many.one v) f` is the same as `f v`, start by evaluating the expression as"
" far as possible:"
msgstr ""
"`Many.one` 和 `Many.bind` 遵循 monad 契约。要检查 `Many.bind (Many.one v) f` 是否与 `f "
"v` 相同，首先尽可能地计算表达式："

#: src/monads/arithmetic.md:316
#, fuzzy
msgid ""
"The empty multiset is a right identity of `union`, so the answer is "
"equivalent to `f v`. To check that `Many.bind v Many.one` is the same as "
"`v`, consider that `bind` takes the union of applying `Many.one` to each "
"element of `v`. In other words, if `v` has the form `{v1, v2, v3, ..., vn}`,"
" then `Many.bind v Many.one` is `{v1} ∪ {v2} ∪ {v3} ∪ ... ∪ {vn}`, which is "
"`{v1, v2, v3, ..., vn}`."
msgstr ""
"空多重集合是 `union` 的右单位，因此答案等同于 `f v`。要检查 `Many.bind v Many.one` 是否与 `v` 相同，请考虑 "
"`bind` 取 `Many.one` 应用于 `v` 的每个元素的并集。换句话说，如果 `v` 的形式为 `{v1, v2, v3, ..., "
"vn}`，则 `Many.bind v Many.one` 为 `{v1} ∪ {v2} ∪ {v3} ∪ ... ∪ {vn}`，即 `{v1, "
"v2, v3, ..., vn}`。"

#: src/monads/arithmetic.md:320
#, fuzzy
msgid ""
"Finally, to check that `Many.bind` is associative, check that `Many.bind "
"(Many.bind bind v f) g` is the same as `Many.bind v (fun x => Many.bind (f "
"x) g)`. If `v` has the form `{v1, v2, v3, ..., vn}`, then:"
msgstr ""
"最后，要检查 `Many.bind` 是否关联，请检查 `Many.bind (Many.bind bind v f) g` 是否与 "
"`Many.bind v (fun x => Many.bind (f x) g)` 相同。如果 `v` 的形式为 `{v1, v2, v3, ...,"
" vn}`，则："

#: src/monads/arithmetic.md:327
#, fuzzy
msgid "which means that"
msgstr "这意味着"

#: src/monads/arithmetic.md:337
#, fuzzy
msgid "Similarly,"
msgstr "同样地，"

#: src/monads/arithmetic.md:353
#, fuzzy
msgid "Thus, both sides are equal, so `Many.bind` is associative."
msgstr "因此，两边相等，所以 `Many.bind` 是结合的。"

#: src/monads/arithmetic.md:355
#, fuzzy
msgid "The resulting monad instance is:"
msgstr "由此产生的单子实例为："

#: src/monads/arithmetic.md:361
#, fuzzy
msgid ""
"An example search using this monad finds all the combinations of numbers in "
"a list that add to 15:"
msgstr "使用此单子的示例搜索可找到列表中所有加起来等于 15 的数字组合："

#: src/monads/arithmetic.md:377
#, fuzzy
msgid ""
"The search process is recursive over the list. The empty list is a "
"successful search when the goal is `0`; otherwise, it fails. When the list "
"is non-empty, there are two possibilities: either the head of the list is "
"greater than the goal, in which case it cannot participate in any successful"
" searches, or it is not, in which case it can. If the head of the list is "
"_not_ a candidate, then the search proceeds to the tail of the list. If the "
"head is a candidate, then there are two possibilities to be combined with "
"`Many.union`: either the solutions found contain the head, or they do not. "
"The solutions that do not contain the head are found with a recursive call "
"on the tail, while the solutions that do contain it result from subtracting "
"the head from the goal, and then attaching the head to the solutions that "
"result from the recursive call."
msgstr ""
"搜索过程对列表进行递归。当目标为 `0` "
"时，空列表是一个成功的搜索；否则，它将失败。当列表非空时，有两种可能性：列表的头部大于目标，在这种情况下，它不能参与任何成功的搜索，或者不是，在这种情况下，它可以。如果列表的头部"
" _不是_ 候选者，则搜索将继续进行到列表的尾部。如果头部是候选者，则有两个可能性与 `Many.union` "
"结合：找到的解包含头部，或者不包含。不包含头部的解通过对尾部进行递归调用找到，而包含头部的解则通过从目标中减去头部，然后将头部附加到递归调用产生的解中得到。"

#: src/monads/arithmetic.md:384
#, fuzzy
msgid ""
"Returning to the arithmetic evaluator that produces multisets of results, "
"the `both` and `neither` operators can be written as follows:"
msgstr "回到产生结果多重集的算术求值器，`both` 和 `neither` 运算符可以写成如下形式："

#: src/monads/arithmetic.md:398
#, fuzzy
msgid "Using these operators, the earlier examples can be evaluated:"
msgstr "使用这些运算符，可以对前面的示例进行求值："

#: src/monads/arithmetic.md:420
#, fuzzy
msgid "Custom Environments"
msgstr "自定义环境"

#: src/monads/arithmetic.md:422
#, fuzzy
msgid ""
"The evaluator can be made user-extensible by allowing strings to be used as "
"operators, and then providing a mapping from strings to a function that "
"implements them. For example, users could extend the evaluator with a "
"remainder operator or with one that returns the maximum of its two "
"arguments. The mapping from function names to function implementations is "
"called an _environment_."
msgstr ""
"可以通过允许将字符串用作运算符，然后提供从字符串到实现它们的函数的映射，使求值器可由用户扩展。例如，用户可以用余数运算符或返回其两个参数最大值的运算符来扩展求值器。从函数名称到函数实现的映射称为"
" _环境_。"

#: src/monads/arithmetic.md:426
#, fuzzy
msgid ""
"The environments needs to be passed in each recursive call. Initially, it "
"might seem that `evaluateM` needs an extra argument to hold the environment,"
" and that this argument should be passed to each recursive invocation. "
"However, passing an argument like this is another form of monad, so an "
"appropriate `Monad` instance allows the evaluator to be used unchanged."
msgstr ""
"环境需要在每次递归调用中传递。最初，`evaluateM` "
"似乎需要一个额外的参数来保存环境，并且该参数应该传递给每个递归调用。然而，像这样传递参数是单子的另一种形式，因此一个合适的 `Monad` "
"实例允许评估器保持不变。"

#: src/monads/arithmetic.md:430
#, fuzzy
msgid ""
"Using functions as a monad is typically called a _reader_ monad. When "
"evaluating expressions in the reader monad, the following rules are used:"
msgstr "将函数用作单子通常称为 _reader_ 单子。在 reader 单子中求值表达式时，使用以下规则："

#: src/monads/arithmetic.md:432
#, fuzzy
msgid "Constants \\\\( n \\\\) evaluate to constant functions \\\\( λ e . n \\\\),"
msgstr "常量 \\\\( n \\\\) 求值为常量函数 \\\\( λ e . n \\\\)；"

#: src/monads/arithmetic.md:433
#, fuzzy
msgid ""
"Arithmetic operators evaluate to functions that pass their arguments on, so "
"\\\\( f + g \\\\) evaluates to \\\\( λ e . f(e) + g(e) \\\\), and"
msgstr "算术运算符求值为将参数传递给它们的函数，因此 \\\\( f + g \\\\) 求值为 \\\\( λ e . f(e) + g(e) \\\\)；"

#: src/monads/arithmetic.md:434
#, fuzzy
msgid ""
"Custom operators evaluate to the result of applying the custom operator to "
"the arguments, so \\\\( f \\\\ \\\\mathrm{OP}\\\\ g \\\\) evaluates to "
"\\\\\\[ λ e . \\\\begin{cases} h(f(e), g(e)) & \\\\mathrm{if}\\\\ e\\\\ "
"\\\\mathrm{contains}\\\\ (\\\\mathrm{OP}, h) \\\\\\\\ 0 & "
"\\\\mathrm{otherwise} \\\\end{cases} \\\\\\] with \\\\( 0 \\\\) serving as a"
" fallback in case an unknown operator is applied."
msgstr ""
"自定义运算符求值为将自定义运算符应用于参数的结果，因此 \\\\( f \\\\ \\\\mathrm{OP}\\\\ g \\\\) 求值为 "
"\\\\\\[ λ e . \\\\begin{cases} h(f(e), g(e)) & \\\\mathrm{if}\\\\ e\\\\ "
"\\\\mathrm{contains}\\\\ (\\\\mathrm{OP}, h) \\\\\\\\ 0 & "
"\\\\mathrm{otherwise} \\\\end{cases} \\\\\\]，其中 \\\\( 0 \\\\) 在应用未知运算符时用作后备。"

#: src/monads/arithmetic.md:444
#, fuzzy
msgid ""
"To define the reader monad in Lean, the first step is to define the `Reader`"
" type and the effect that allows users to get ahold of the environment:"
msgstr "要在 Lean 中定义 reader 单子，第一步是定义 `Reader` 类型和允许用户获取环境的效果："

#: src/monads/arithmetic.md:450
#, fuzzy
msgid ""
"By convention, the Greek letter `ρ`, which is pronounced \"rho\", is used "
"for environments."
msgstr "按照惯例，希腊字母 `ρ`（发音为「rho」）用于表示环境。"

#: src/monads/arithmetic.md:452
#, fuzzy
msgid ""
"The fact that constants in arithmetic expressions evaluate to constant "
"functions suggests that the appropriate definition of `pure` for `Reader` is"
" a a constant function:"
msgstr "算术表达式中的常量求值为常量函数这一事实表明，`Reader` 的 `pure` 的适当定义是一个常量函数："

#: src/monads/arithmetic.md:457
#, fuzzy
msgid ""
"On the other hand, `bind` is a bit tricker. Its type is `Reader ρ α → (α → "
"Reader ρ β) → Reader ρ β`. This type can be easier to understand by "
"expanding the definitions of `Reader`, which yields `(ρ → α) → (α → ρ → β) →"
" ρ → β`. It should take an environment-accepting function as its first "
"argument, while the second argument should transform the result of the "
"environment-accepting function into yet another environment-accepting "
"function. The result of combining these is itself a function, waiting for an"
" environment."
msgstr ""
"另一方面，`bind` 有点棘手。它的类型是 `Reader ρ α → (α → Reader ρ β) → Reader ρ β`。通过展开 "
"`Reader` 的定义，可以更容易地理解此类型，从而产生 `(ρ → α) → (α → ρ → β) → ρ → "
"β`。它应该将接受环境的函数作为其第一个参数，而第二个参数应该将接受环境的函数的结果转换为另一个接受环境的函数。组合这些结果本身就是一个函数，等待一个环境。"

#: src/monads/arithmetic.md:463
#, fuzzy
msgid ""
"It's possible to use Lean interactively to get help writing this function. "
"The first step is to write down the arguments and return type, being very "
"explicit in order to get as much help as possible, with an underscore for "
"the definition's body:"
msgstr "交互式使用 Lean 可以获得编写此函数的帮助。第一步是写下参数和返回类型，为了获得尽可能多的帮助，需要非常明确，用下划线表示定义的主体："

#: src/monads/arithmetic.md:470
#, fuzzy
msgid ""
"Lean provides a message that describes which variables are available in "
"scope, and the type that's expected for the result. The `⊢` symbol, called a"
" _turnstile_ due to its resemblance to subway entrances, separates the local"
" variables from the desired type, which is `ρ → β` in this message:"
msgstr ""
"Lean 提供了一条消息，描述了哪些变量在范围内可用，以及结果的预期类型。`⊢` "
"符号，由于它类似于地铁入口而被称为「转门」，将局部变量与所需类型分开，在此消息中为 `ρ → β`："

#: src/monads/arithmetic.md:481
#, fuzzy
msgid ""
"Because the return type is a function, a good first step is to wrap a `fun` "
"around the underscore:"
msgstr "由于返回类型是一个函数，因此一个好的第一步是在下划线周围包装一个 `fun`："

#: src/monads/arithmetic.md:487
#, fuzzy
msgid ""
"The resulting message now shows the function's argument as a local variable:"
msgstr "现在，结果消息将函数的参数显示为局部变量："

#: src/monads/arithmetic.md:498
#, fuzzy
msgid ""
"The only thing in the context that can produce a `β` is `next`, and it will "
"require two arguments to do so. Each argument can itself be an underscore:"
msgstr "上下文中唯一可以生成 `β` 的是 `next`，它需要两个参数才能做到这一点。每个参数本身可以是一个下划线："

#: src/monads/arithmetic.md:505
#, fuzzy
msgid ""
"The two underscores have the following respective messages associated with "
"them:"
msgstr "两个下划线具有以下各自关联的消息："

#: src/monads/arithmetic.md:525
#, fuzzy
msgid ""
"Attacking the first underscore, only one thing in the context can produce an"
" `α`, namely `result`:"
msgstr "攻击第一个下划线，上下文中只有一件事可以生成 `α`，即 `result`："

#: src/monads/arithmetic.md:531
#, fuzzy
msgid "Now, both underscores have the same error:"
msgstr "现在，两个下划线都有相同的错误："

#: src/monads/arithmetic.md:541
#, fuzzy
msgid "Happily, both underscores can be replaced by `env`, yielding:"
msgstr "幸运的是，两个下划线都可以替换为 `env`，得到："

#: src/monads/arithmetic.md:548
#, fuzzy
msgid ""
"The final version can be obtained by undoing the expansion of `Reader` and "
"cleaning up the explicit details:"
msgstr "最终版本可以通过撤消 `Reader` 的展开并清理显式细节来获得："

#: src/monads/arithmetic.md:554
#, fuzzy
msgid ""
"It's not always possible to write correct functions by simply \"following "
"the types\", and it carries the risk of not understanding the resulting "
"program. However, it can also be easier to understand a program that has "
"been written than one that has not, and the process of filling in the "
"underscores can bring insights. In this case, `Reader.bind` works just like "
"`bind` for `Id`, except it accepts an additional argument that it then "
"passes down to its arguments, and this intuition can help in understanding "
"how it works."
msgstr ""
"仅仅「遵循类型」并不总是可以编写出正确的函数，并且有导致不理解结果程序的风险。然而，理解一个已经编写的程序也可能比理解一个没有编写的程序更容易，并且填写下划线的过程可以带来见解。在这种情况下，`Reader.bind`"
" 的工作方式与 `Id` 的 `bind` 完全相同，除了它接受一个额外的参数，然后将其传递给它的参数，并且这种直觉有助于理解它的工作原理。"

#: src/monads/arithmetic.md:558
#, fuzzy
msgid ""
"`Reader.pure`, which generates constant functions, and `Reader.bind` obey "
"the monad contract. To check that `Reader.bind (Reader.pure v) f` is the "
"same as `f v`, it's enough to replace definitions until the last step:"
msgstr ""
"`Reader.pure` 生成常量函数，`Reader.bind` 遵循单子契约。要检查 `Reader.bind (Reader.pure v) "
"f` 是否与 `f v` 相同，只需替换定义直到最后一步："

#: src/monads/arithmetic.md:571
#, fuzzy
msgid ""
"For every function `f`, `fun x => f x` is the same as `f`, so the first part"
" of the contract is satisfied. To check that `Reader.bind r Reader.pure` is "
"the same as `r`, a similar technique works:"
msgstr ""
"对于每个函数 `f`，`fun x => f x` 与 `f` 相同，因此契约的第一部分得到满足。要检查 `Reader.bind r "
"Reader.pure` 是否与 `r` 相同，可以使用类似的技术："

#: src/monads/arithmetic.md:582
#, fuzzy
msgid ""
"Because reader actions `r` are themselves functions, this is the same as "
"`r`. To check associativity, the same thing can be done for both "
"`Reader.bind (Reader.bind r f) g` and `Reader.bind r (fun x => Reader.bind "
"(f x) g)`:"
msgstr ""
"因为 reader 动作 `r` 本身是函数，所以这与 `r` 相同。要检查关联性，可以对 `Reader.bind (Reader.bind r f)"
" g` 和 `Reader.bind r (fun x => Reader.bind (f x) g)` 执行相同操作："

#: src/monads/arithmetic.md:606
#, fuzzy
msgid "Thus, a `Monad (Reader ρ)` instance is justified:"
msgstr "因此，`Monad (Reader ρ)` 实例是合理的："

#: src/monads/arithmetic.md:613
#, fuzzy
msgid ""
"The custom environments that will be passed to the expression evaluator can "
"be represented as lists of pairs:"
msgstr "将传递给表达式求值器的自定义环境可以表示为对列表："

#: src/monads/arithmetic.md:617
#, fuzzy
msgid "For instance, `exampleEnv` contains maximum and modulus functions:"
msgstr "例如，`exampleEnv` 包含最大值和模函数："

#: src/monads/arithmetic.md:618
#, fuzzy
msgid ""
"```lean\n"
"def exampleEnv : Env := [(\"max\", max), (\"mod\", (· % ·))]\n"
"```"
msgstr ""
"```lean\n"
"def exampleEnv : Env := [(\"max\", max), (\"mod\", (· % ·))]\n"
"```"

#: src/monads/arithmetic.md:622
#, fuzzy
msgid ""
"Lean already has a function `List.lookup` that finds the value associated "
"with a key in a list of pairs, so `applyPrimReader` needs only check whether"
" the custom function is present in the environment. It returns `0` if the "
"function is unknown:"
msgstr ""
"Lean 已经有一个函数 `List.lookup`，它在对列表中找到与键关联的值，因此 `applyPrimReader` "
"只需检查自定义函数是否存在于环境中。如果函数未知，它将返回 `0`："

#: src/monads/arithmetic.md:631
#, fuzzy
msgid ""
"Using `evaluateM` with `applyPrimReader` and an expression results in a "
"function that expects an environment. Luckily, `exampleEnv` is available:"
msgstr ""
"将 `evaluateM` 与 `applyPrimReader` 和表达式一起使用，将生成一个期望环境的函数。幸运的是，`exampleEnv` "
"可用："

#: src/monads/arithmetic.md:633
#, fuzzy
msgid ""
"```lean\n"
"open Expr Prim in\n"
"#eval evaluateM applyPrimReader (prim (other \"max\") (prim plus (const 5) (const 4)) (prim times (const 3) (const 2))) exampleEnv\n"
"```"
msgstr ""
"```lean\n"
"open Expr Prim in\n"
"#eval evaluateM applyPrimReader (prim (other \"max\") (prim plus (const 5) (const 4)) (prim times (const 3) (const 2))) exampleEnv\n"
"```"

#: src/monads/arithmetic.md:641
#, fuzzy
msgid ""
"Like `Many`, `Reader` is an example of an effect that is difficult to encode"
" in most languages, but type classes and monads make it just as convenient "
"as any other effect. The dynamic or special variables found in Common Lisp, "
"Clojure, and Emacs Lisp can be used like `Reader`. Similarly, Scheme and "
"Racket's parameter objects are an effect that exactly correspond to "
"`Reader`. The Kotlin idiom of context objects can solve a similar problem, "
"but they are fundamentally a means of passing function arguments "
"automatically, so this idiom is more like the encoding as a reader monad "
"than it is an effect in the language."
msgstr ""
"与 `Many` 一样，`Reader` 是一个难以在大多数语言中编码的效应示例，但类型类和单子使其与任何其他效应一样方便。Common "
"Lisp、Clojure 和 Emacs Lisp 中的动态或特殊变量可以用作 `Reader`。类似地，Scheme 和 Racket "
"的参数对象是一个与 `Reader` 完全对应的效应。Kotlin "
"的上下文对象惯用法可以解决类似的问题，但它们从根本上是一种自动传递函数参数的方法，因此这种惯用法更像是作为 reader "
"单子的编码，而不是语言中的效应。"

#: src/monads/arithmetic.md:648
#, fuzzy
msgid "Checking Contracts"
msgstr "检查合约"

#: src/monads/arithmetic.md:650
#, fuzzy
msgid "Check the monad contract for `State σ` and `Except ε`."
msgstr "检查 `State σ` 和 `Except ε` 的单子合约。"

#: src/monads/arithmetic.md:653
#, fuzzy
msgid "Readers with Failure"
msgstr "带有失败的 Reader"

#: src/monads/arithmetic.md:654
#, fuzzy
msgid ""
"Adapt the reader monad example so that it can also indicate failure when the"
" custom operator is not defined, rather than just returning zero. In other "
"words, given these definitions:"
msgstr "调整 Reader 单子示例，使其在自定义运算符未定义时也能指示失败，而不仅仅是返回零。换句话说，给定以下定义："

#: src/monads/arithmetic.md:661
#, fuzzy
msgid "do the following:"
msgstr "执行以下操作："

#: src/monads/arithmetic.md:662
#, fuzzy
msgid "Write suitable `pure` and `bind` functions"
msgstr "编写合适的 `pure` 和 `bind` 函数"

#: src/monads/arithmetic.md:663
#, fuzzy
msgid "Check that these functions satisfy the `Monad` contract"
msgstr "检查这些函数是否满足 `Monad` 合约"

#: src/monads/arithmetic.md:664
#, fuzzy
msgid "Write `Monad` instances for `ReaderOption` and `ReaderExcept`"
msgstr "为 `ReaderOption` 和 `ReaderExcept` 编写 `Monad` 实例"

#: src/monads/arithmetic.md:665
#, fuzzy
msgid ""
"Define suitable `applyPrim` operators and test them with `evaluateM` on some"
" example expressions"
msgstr "定义合适的 `applyPrim` 运算符，并使用 `evaluateM` 在一些示例表达式上对其进行测试"

#: src/monads/arithmetic.md:667
#, fuzzy
msgid "A Tracing Evaluator"
msgstr "一个跟踪求值器"

#: src/monads/arithmetic.md:669
#, fuzzy
msgid ""
"The `WithLog` type can be used with the evaluator to add optional tracing of"
" some operations. In particular, the type `ToTrace` can serve as a signal to"
" trace a given operator:"
msgstr "`WithLog` 类型可以与求值器一起使用，以添加对某些操作的可选跟踪。特别是，`ToTrace` 类型可以作为跟踪给定运算符的信号："

#: src/monads/arithmetic.md:675
#, fuzzy
msgid ""
"For the tracing evaluator, expressions should have type `Expr (Prim (ToTrace"
" (Prim Empty)))`. This says that the operators in the expression consist of "
"addition, subtraction, and multiplication, augmented with traced versions of"
" each. The innermost argument is `Empty` to signal that there are no further"
" special operators inside of `trace`, only the three basic ones."
msgstr ""
"对于跟踪求值器，表达式应具有类型 `Expr (Prim (ToTrace (Prim "
"Empty)))`。这意味着表达式中的运算符包括加法、减法和乘法，并带有每个运算符的跟踪版本。最内层的参数是 `Empty`，表示 `trace` "
"中没有其他特殊运算符，只有三个基本运算符。"

#: src/monads/arithmetic.md:678
#, fuzzy
msgid "Do the following:"
msgstr "执行以下操作："

#: src/monads/arithmetic.md:679
#, fuzzy
msgid "Implement a `Monad (WithLog logged)` instance"
msgstr "实现 `Monad (WithLog logged)` 实例"

#: src/monads/arithmetic.md:680
#, fuzzy
msgid ""
"Write an `applyTraced` function to apply traced operators to their "
"arguments, logging both the operator and the arguments, with type `ToTrace "
"(Prim Empty) → Int → Int → WithLog (Prim Empty × Int × Int) Int`"
msgstr ""
"编写 `applyTraced` 函数，将跟踪运算符应用于其参数，同时记录运算符和参数，类型为 `ToTrace (Prim Empty) → Int "
"→ Int → WithLog (Prim Empty × Int × Int) Int`"

#: src/monads/arithmetic.md:682
#, fuzzy
msgid "If the exercise has been completed correctly, then"
msgstr "如果练习已正确完成，那么"

#: src/monads/arithmetic.md:687
#, fuzzy
msgid "should result in"
msgstr "将导致"

#: src/monads/arithmetic.md:692
#, fuzzy
msgid ""
"Hint: values of type `Prim Empty` will appear in the resulting log. In order"
" to display them as a result of `#eval`, the following instances are "
"required:"
msgstr "提示：`Prim Empty` 类型的将在结果日志中出现。为了将它们显示为 `#eval` 的结果，需要以下实例："

#: src/monads/do.md:3
#, fuzzy
msgid ""
"While APIs based on monads are very powerful, the explicit use of `>>=` with"
" anonymous functions is still somewhat noisy. Just as infix operators are "
"used instead of explicit calls to `HAdd.hAdd`, Lean provides a syntax for "
"monads called _`do`\\-notation_ that can make programs that use monads "
"easier to read and write. This is the very same `do`\\-notation that is used"
" to write programs in `IO`, and `IO` is also a monad."
msgstr ""
"基于单子的 API 非常强大，但显式使用 `>>=` 和匿名函数仍然有些繁琐。正如使用中缀运算符代替显式调用 `HAdd.hAdd` 一样，Lean "
"提供了一种称为 _`do`\\-notation_ 的单子语法，它可以使使用单子的程序更易于阅读和编写。这与用于编写 `IO` 程序的 "
"`do`\\-notation 完全相同，而 `IO` 也是一个单子。"

#: src/monads/do.md:7
#, fuzzy
msgid ""
"In [Hello, World!](../hello-world.md), the `do` syntax is used to combine "
"`IO` actions, but the meaning of these programs is explained directly. "
"Understanding how to program with monads means that `do` can now be "
"explained in terms of how it translates into uses of the underlying monad "
"operators."
msgstr ""
"在 [Hello, World!](../hello-world.md) 中，`do` 语法用于组合 `IO` "
"操作，但这些程序的含义是直接解释的。理解如何使用单子进行编程意味着现在可以使用 `do` 来解释它如何转换为对底层单子运算符的使用。"

#: src/monads/do.md:10
#, fuzzy
msgid ""
"The first translation of `do` is used when the only statement in the `do` is"
" a single expression `E`. In this case, the `do` is removed, so"
msgstr "当 `do` 中的唯一语句是单个表达式 `E` 时，使用 `do` 的第一个转换。在这种情况下，`do` 被删除，因此"

#: src/monads/do.md:15 src/monads/do.md:28 src/monads/do.md:43
#: src/monads/do.md:58
#, fuzzy
msgid "translates to"
msgstr "转换为"

#: src/monads/do.md:20
#, fuzzy
msgid ""
"The second translation is used when the first statement of the `do` is a "
"`let` with an arrow, binding a local variable. This translates to a use of "
"`>>=` together with a function that binds that very same variable, so"
msgstr ""
"当 `do` 的第一个语句是带有箭头的 `let`，绑定一个局部变量时，使用第二个转换。这转换为使用 `>>=` 以及绑定同一变量的函数，因此"

#: src/monads/do.md:36
#, fuzzy
msgid ""
"When the first statement of the `do` block is an expression, then it is "
"considered to be a monadic action that returns `Unit`, so the function "
"matches the `Unit` constructor and"
msgstr "当 `do` 块的第一个语句是一个表达式时，它被认为是一个返回 `Unit` 的单子操作，因此该函数匹配 `Unit` 构造子，因此"

#: src/monads/do.md:51
#, fuzzy
msgid ""
"Finally, when the first statement of the `do` block is a `let` that uses "
"`:=`, the translated form is an ordinary let expression, so"
msgstr "最后，当 `do` 块的第一个语句是使用 `:=` 的 `let` 时，转换后的形式是一个普通的 let 表达式，因此"

#: src/monads/do.md:66
#, fuzzy
msgid ""
"The definition of `firstThirdFifthSeventh` that uses the `Monad` class looks"
" like this:"
msgstr "使用 `Monad` 类的 `firstThirdFifthSeventh` 的定义如下所示："

#: src/monads/do.md:75
#, fuzzy
msgid "Using `do`\\-notation, it becomes significantly more readable:"
msgstr "使用 `do`\\-notation，它变得更加易于阅读："

#: src/monads/do.md:85
#, fuzzy
msgid ""
"Without the `Monad` type class, the function `number` that numbers the nodes"
" of a tree was written:"
msgstr "`Monad` 类型类缺失时，对树的节点进行编号的函数 `number` 编写如下："

#: src/monads/do.md:98
#, fuzzy
msgid "With `Monad` and `do`, its definition is much less noisy:"
msgstr "有了 `Monad` 和 `do`，其定义就简洁多了："

#: src/monads/do.md:113
#, fuzzy
msgid ""
"All of the conveniences from `do` with `IO` are also available when using it"
" with other monads. For example, nested actions also work in any monad. The "
"original definition of `mapM` was:"
msgstr "使用 `do` 与 `IO` 的所有便利性在使用其他单子时也可用。例如，嵌套操作也适用于任何单子。`mapM` 的原始定义为："

#: src/monads/do.md:124
#, fuzzy
msgid "With `do`\\-notation, it can be written:"
msgstr "使用 `do` 符号，可以写成："

#: src/monads/do.md:133
#, fuzzy
msgid ""
"Using nested actions makes it almost as short as the original non-monadic "
"`map`:"
msgstr "使用嵌套操作使其几乎与原始非单子 `map` 一样简洁："

#: src/monads/do.md:140
#, fuzzy
msgid "Using nested actions, `number` can be made much more concise:"
msgstr "使用嵌套操作，`number` 可以变得更加简洁："

#: src/monads/do.md:159
#, fuzzy
msgid ""
"Rewrite `evaluateM`, its helpers, and the different specific use cases using"
" `do`\\-notation instead of explicit calls to `>>=`."
msgstr "使用 `do` 符号而不是显式调用 `>>=` 重写 `evaluateM`、其帮助器和不同的特定用例。"

#: src/monads/do.md:160
#, fuzzy
msgid "Rewrite `firstThirdFifthSeventh` using nested actions."
msgstr "使用嵌套操作重写 `firstThirdFifthSeventh`。"

#: src/monads/io.md:1
#, fuzzy
msgid "The IO Monad"
msgstr "IO 单子"

#: src/monads/io.md:3
#, fuzzy
msgid ""
"`IO` as a monad can be understood from two perspectives, which were "
"described in the section on [running programs](../hello-world/running-a-"
"program.md). Each can help to understand the meanings of `pure` and `bind` "
"for `IO`."
msgstr ""
"`IO` 作为单子可以从两个角度理解，这在 [运行程序](../hello-world/running-a-program.md) "
"一节中进行了描述。每个角度都可以帮助理解 `IO` 的 `pure` 和 `bind` 的含义。"

#: src/monads/io.md:6
#, fuzzy
msgid ""
"From the first perspective, an `IO` action is an instruction to Lean's run-"
"time system. For example, the instruction might be \"read a string from this"
" file descriptor, then re-invoke the pure Lean code with the string\". This "
"perspective is an _exterior_ one, viewing the program from the perspective "
"of the operating system. In this case, `pure` is an `IO` action that does "
"not request any effects from the RTS, and `bind` instructs the RTS to first "
"carry out one potentially-effectful operation and then invoke the rest of "
"the program with the resulting value."
msgstr ""
"从第一个角度看，`IO` 操作是 Lean 运行时系统的指令。例如，指令可能是“从该文件描述符读取字符串，然后使用该字符串重新调用纯 Lean "
"代码”。此角度是一个外部角度，从操作系统的角度查看程序。在这种情况下，`pure` 是一个不请求 RTS 产生任何效果的 `IO` 操作，而 "
"`bind` 指示 RTS 首先执行一个潜在产生效果的操作，然后使用结果值调用程序的其余部分。"

#: src/monads/io.md:11
#, fuzzy
msgid ""
"From the second perspective, an `IO` action transforms the whole world. `IO`"
" actions are actually pure, because they receive a unique world as an "
"argument and then return the changed world. This perspective is an "
"_interior_ one that matches how `IO` is represented inside of Lean. The "
"world is represented in Lean as a token, and the `IO` monad is structured to"
" make sure that each token is used exactly once."
msgstr ""
"从第二个角度看，`IO` 操作会改变整个世界。`IO` "
"操作实际上是纯的，因为它们接收一个唯一的世界作为参数，然后返回改变后的世界。此角度是一个内部角度，与 `IO` 在 Lean "
"内部表示的方式相匹配。世界在 Lean 中表示为令牌，`IO` 单子被构造为确保每个令牌只使用一次。"

#: src/monads/io.md:16
#, fuzzy
msgid ""
"To see how this works, it can be helpful to peel back one definition at a "
"time. The `#print` command reveals the internals of Lean datatypes and "
"definitions. For example,"
msgstr "为了了解其工作原理，逐层剥离定义会很有帮助。`#print` 命令揭示了 Lean 数据类型和定义的内部结构体。例如，"

#: src/monads/io.md:40
#, fuzzy
msgid ""
"Sometimes, the output of `#print` includes Lean features that have not yet "
"been presented in this book. For example,"
msgstr "有时，`#print` 的输出包括本书尚未介绍的 Lean 特性。例如，"

#: src/monads/io.md:45
#, fuzzy
msgid "produces"
msgstr "生成"

#: src/monads/io.md:53
#, fuzzy
msgid ""
"which includes a `.{u}` after the definition's name, and annotates types as "
"`Type u` rather than just `Type`. This can be safely ignored for now."
msgstr "其中在定义名称后包含一个 `.{u}`，并将类型标注为 `Type u` 而不是仅仅 `Type`。现在可以安全地忽略它。"

#: src/monads/io.md:56
#, fuzzy
msgid ""
"Printing the definition of `IO` shows that it's defined in terms of simpler "
"structures:"
msgstr "打印 `IO` 的定义表明它是根据更简单的结构体定义的："

#: src/monads/io.md:64
#, fuzzy
msgid ""
"`IO.Error` represents all the errors that could be thrown by an `IO` action:"
msgstr "`IO.Error` 表示 `IO` 操作可能抛出的所有错误："

#: src/monads/io.md:92
#, fuzzy
msgid ""
"`EIO ε α` represents `IO` actions that will either terminate with an error "
"of type `ε` or succeed with a value of type `α`. This means that, like the "
"`Except ε` monad, the `IO` monad includes the ability to define error "
"handling and exceptions."
msgstr ""
"`EIO ε α` 表示 `IO` 操作，它将以类型为 `ε` 的错误终止或以类型为 `α` 的值成功。这意味着，与 `Except ε` "
"单子一样，`IO` 单子包括定义错误处理和异常的能力。"

#: src/monads/io.md:95
#, fuzzy
msgid ""
"Peeling back another layer, `EIO` is itself defined in terms of a simpler "
"structure:"
msgstr "剥离另一层，`EIO` 本身是根据更简单的结构体定义的："

#: src/monads/io.md:103
#, fuzzy
msgid ""
"The `EStateM` monad includes both errors and state—it's a combination of "
"`Except` and `State`. It is defined using another type, `EStateM.Result`:"
msgstr ""
"`EStateM` 单子同时包括错误和状态——它是 `Except` 和 `State` 的组合。它使用另一个类型 `EStateM.Result` "
"定义："

#: src/monads/io.md:112
#, fuzzy
msgid ""
"In other words, a program with type `EStateM ε σ α` is a function that "
"accepts an initial state of type `σ` and returns an `EStateM.Result ε σ α`."
msgstr ""
"换句话说，类型为 `EStateM ε σ α` 的程序是一个函数，它接受类型为 `σ` 的初始状态并返回一个 `EStateM.Result ε σ "
"α`。"

#: src/monads/io.md:114
#, fuzzy
msgid ""
"`EStateM.Result` is very much like the definition of `Except`, with one "
"constructor that indicates a successful termination and one constructor that"
" indicates an error:"
msgstr "`EStateM.Result` 与 `Except` 的定义非常相似，一个构造子表示成功终止，一个构造子表示错误："

#: src/monads/io.md:125
#, fuzzy
msgid ""
"Just like `Except ε α`, the `ok` constructor includes a result of type `α`, "
"and the `error` constructor includes an exception of type `ε`. Unlike "
"`Except`, both constructors have an additional state field that includes the"
" final state of the computation."
msgstr ""
"就像 `Except ε α` 一样，`ok` 构造子包含类型为 `α` 的结果，`error` 构造子包含类型为 `ε` 的异常。与 `Except`"
" 不同，这两个构造子都有一个附加的状态字段，其中包含计算的最终状态。"

#: src/monads/io.md:128
#, fuzzy
msgid ""
"The `Monad` instance for `EStateM ε σ` requires `pure` and `bind`. Just as "
"with `State`, the implementation of `pure` for `EStateM` accepts an initial "
"state and returns it unchanged, and just as with `Except`, it returns its "
"argument in the `ok` constructor:"
msgstr ""
"`EStateM ε σ` 的 `Monad` 实例需要 `pure` 和 `bind`。与 `State` 一样，`EStateM` 的 `pure`"
" 实现接受一个初始状态并将其返回而不改变，并且与 `Except` 一样，它在 `ok` 构造子中返回其参数："

#: src/monads/io.md:137
#, fuzzy
msgid ""
"`protected` means that the full name `EStateM.pure` is needed even if the "
"`EStateM` namespace has been opened."
msgstr "`protected` 意味着即使打开了 `EStateM` 命名空间，也需要完整的名称 `EStateM.pure`。"

#: src/monads/io.md:139
#, fuzzy
msgid ""
"Similarly, `bind` for `EStateM` takes an initial state as an argument. It "
"passes this initial state to its first action. Like `bind` for `Except`, it "
"then checks whether the result is an error. If so, the error is returned "
"unchanged and the second argument to `bind` remains unused. If the result "
"was a success, then the second argument is applied to both the returned "
"value and to the resulting state."
msgstr ""
"类似地，`EStateM` 的 `bind` 将初始状态作为参数。它将此初始状态传递给其第一个操作。与 `Except` 的 `bind` "
"一样，它然后检查结果是否为错误。如果是，则错误将保持不变，并且 `bind` "
"的第二个参数保持未使用。如果结果成功，则将第二个参数应用于返回值和结果状态。"

#: src/monads/io.md:155
#, fuzzy
msgid ""
"Putting all of this together, `IO` is a monad that tracks state and errors "
"at the same time. The collection of available errors is that given by the "
"datatype `IO.Error`, which has constructors that describe many things that "
"can go wrong in a program. The state is a type that represents the real "
"world, called `IO.RealWorld`. Each basic `IO` action receives this real "
"world and returns another one, paired either with an error or a result. In "
"`IO`, `pure` returns the world unchanged, while `bind` passes the modified "
"world from one action into the next action."
msgstr ""
"综上所述，`IO` 是同时跟踪状态和错误的单子。可用错误的集合由数据类型 `IO.Error` "
"给出，该数据类型具有描述程序中可能出错的许多情况的构造子。状态是一种表示现实世界的数据类型，称为 `IO.RealWorld`。每个基本的 `IO` "
"操作都会接收这个现实世界并返回另一个，与错误或结果配对。在 `IO` 中，`pure` 返回未更改的世界，而 `bind` "
"将修改后的世界从一个操作传递到下一个操作。"

#: src/monads/io.md:161
#, fuzzy
msgid ""
"Because the entire universe doesn't fit in a computer's memory, the world "
"being passed around is just a representation. So long as world tokens are "
"not re-used, the representation is safe. This means that world tokens do not"
" need to contain any data at all:"
msgstr ""
"由于计算机内存无法容纳整个宇宙，因此传递的世界仅仅是一种表示。只要不重复使用世界标记，该表示就是安全的。这意味着世界标记根本不需要包含任何数据："

#: src/monads/conveniences.md:3
#, fuzzy
msgid "Shared Argument Types"
msgstr "共享参数类型"

#: src/monads/conveniences.md:5
#, fuzzy
msgid ""
"When defining a function that takes multiple arguments that have the same "
"type, both can be written before the same colon. For example,"
msgstr "在定义一个接受多个具有相同类型参数的函数时，可以在同一个冒号前编写这两个参数。例如，"

#: src/monads/conveniences.md:14
#, fuzzy
msgid "can be written"
msgstr "可以写成"

#: src/monads/conveniences.md:22
#, fuzzy
msgid "This is especially useful when the type signature is large."
msgstr "当类型签名较大时，这尤其有用。"

#: src/monads/conveniences.md:24
#, fuzzy
msgid "Leading Dot Notation"
msgstr "前导点表示法"

#: src/monads/conveniences.md:26
#, fuzzy
msgid ""
"The constructors of an inductive type are in a namespace. This allows "
"multiple related inductive types to use the same constructor names, but it "
"can lead to programs becoming verbose. In contexts where the inductive type "
"in question is known, the namespace can be omitted by preceding the "
"constructor's name with a dot, and Lean uses the expected type to resolve "
"the constructor names. For example, a function that mirrors a binary tree "
"can be written:"
msgstr ""
"归纳类型的构造子位于一个命名空间中。这允许多个相关的归纳类型使用相同的构造子名称，但可能导致程序变得冗长。在已知归纳类型的情况下，可以通过在构造子名称前加上一个点来省略命名空间，并且"
" Lean 使用预期的类型来解析构造子名称。例如，可以编写一个镜像二叉树的函数："

#: src/monads/conveniences.md:35
#, fuzzy
msgid ""
"Omitting the namespaces makes it significantly shorter, at the cost of "
"making the program harder to read in contexts like code review tools that "
"don't include the Lean compiler:"
msgstr "省略命名空间可以显著缩短代码，但代价是使程序在不包含 Lean 编译器的代码审查工具等上下文中更难阅读："

#: src/monads/conveniences.md:42
#, fuzzy
msgid ""
"Using the expected type of an expression to disambiguate a namespace is also"
" applicable to names other than constructors. If `BinTree.empty` is defined "
"as an alternative way of creating `BinTree`s, then it can also be used with "
"dot notation:"
msgstr ""
"使用表达式的预期类型来消除命名空间歧义也适用于除构造子之外的其他名称。如果将 `BinTree.empty` 定义为创建 `BinTree` "
"的另一种方式，那么它也可以与点表示法一起使用："

#: src/monads/conveniences.md:53
#, fuzzy
msgid "Or-Patterns"
msgstr "或模式"

#: src/monads/conveniences.md:55
#, fuzzy
msgid ""
"In contexts that allow multiple patterns, such as `match`\\-expressions, "
"multiple patterns may share their result expressions. The datatype `Weekday`"
" that represents days of the week:"
msgstr "在允许多个模式的上下文中，例如 `match` 表达式，多个模式可以共享其结果表达式。表示一周中几天的数据类型 `Weekday`："

#: src/monads/conveniences.md:69
#, fuzzy
msgid "Pattern matching can be used to check whether a day is a weekend:"
msgstr "模式匹配可用于检查某天是否为周末："

#: src/monads/conveniences.md:77
#, fuzzy
msgid "This can already be simplified by using constructor dot notation:"
msgstr "使用构造子点表示法可以简化此操作："

#: src/monads/conveniences.md:85
#, fuzzy
msgid ""
"Because both weekend patterns have the same result expression (`true`), they"
" can be condensed into one:"
msgstr "由于两个周末模式具有相同的结果表达式（「true」），因此可以将它们合并为一个："

#: src/monads/conveniences.md:92
#, fuzzy
msgid ""
"This can be further simplified into a version in which the argument is not "
"named:"
msgstr "可以进一步简化为不命名参数的版本："

#: src/monads/conveniences.md:99
#, fuzzy
msgid ""
"Behind the scenes, the result expression is simply duplicated across each "
"pattern. This means that patterns can bind variables, as in this example "
"that removes the `inl` and `inr` constructors from a sum type in which both "
"contain the same type of value:"
msgstr ""
"在幕后，结果表达式只是在每个模式中重复。这意味着模式可以绑定变量，如本例中从和类型中删除 `inl` 和 `inr` "
"构造子，其中两者都包含相同类型的值："

#: src/monads/conveniences.md:105
#, fuzzy
msgid ""
"Because the result expression is duplicated, the variables bound by the "
"patterns are not required to have the same types. Overloaded functions that "
"work for multiple types may be used to write a single result expression that"
" works for patterns that bind variables of different types:"
msgstr ""
"由于结果表达式是重复的，因此模式绑定的变量不必具有相同的类型。适用于多种类型的高级函数可用于编写一个结果表达式，该表达式适用于绑定不同类型变量的模式："

#: src/monads/conveniences.md:107
msgid ""
"```lean\n"
"def stringy : Nat ⊕ Weekday → String\n"
"  | .inl x | .inr x => s!\"It is {repr x}\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:111
#, fuzzy
msgid ""
"In practice, only variables shared in all patterns can be referred to in the"
" result expression, because the result must make sense for each pattern. In "
"`getTheNat`, only `n` can be accessed, and attempts to use either `x` or `y`"
" lead to errors."
msgstr ""
"实际上，只有在所有模式中共享的变量才能在结果表达式中引用，因为结果必须对每个模式都有意义。在 `getTheNat` 中，只能访问 `n`，而尝试使用 "
"`x` 或 `y` 会导致错误。"

#: src/monads/conveniences.md:117
#, fuzzy
msgid ""
"Attempting to access `x` in a similar definition causes an error because "
"there is no `x` available in the second pattern:"
msgstr "尝试在类似定义中访问 `x` 会导致错误，因为第二个模式中没有 `x` 可用："

#: src/monads/conveniences.md:126
#, fuzzy
msgid ""
"The fact that the result expression is essentially copy-pasted to each "
"branch of the pattern match can lead to some surprising behavior. For "
"example, the following definitions are acceptable because the `inr` version "
"of the result expression refers to the global definition of `str`:"
msgstr ""
"结果表达式本质上是复制粘贴到模式匹配的每个分支，这可能会导致一些令人惊讶的行为。例如，以下定义是可以接受的，因为 `inr` 版本的结果表达式引用了 "
"`str` 的全局定义："

#: src/monads/conveniences.md:128
msgid ""
"```lean\n"
"def str := \"Some string\"\n"
"\n"
"def getTheString : (Nat × String) ⊕ (Nat × β) → String\n"
"  | .inl (n, str) | .inr (n, y) => str\n"
"```"
msgstr ""

#: src/monads/conveniences.md:134
#, fuzzy
msgid ""
"Calling this function on both constructors reveals the confusing behavior. "
"In the first case, a type annotation is needed to tell Lean which type `β` "
"should be:"
msgstr "对两个构造子调用此函数会显示令人困惑的行为。在第一种情况下，需要类型标注来告诉 Lean `β` 应该是什么类型："

#: src/monads/conveniences.md:136
msgid ""
"```lean\n"
"#eval getTheString (.inl (20, \"twenty\") : (Nat × String) ⊕ (Nat × String))\n"
"```"
msgstr ""

#: src/monads/conveniences.md:139
msgid ""
"```output info\n"
"\"twenty\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:142
#, fuzzy
msgid "In the second case, the global definition is used:"
msgstr "在第二种情况下，使用了全局定义："

#: src/monads/conveniences.md:143
msgid ""
"```lean\n"
"#eval getTheString (.inr (20, \"twenty\"))\n"
"```"
msgstr ""

#: src/monads/conveniences.md:146
msgid ""
"```output info\n"
"\"Some string\"\n"
"```"
msgstr ""

#: src/monads/conveniences.md:150
#, fuzzy
msgid ""
"Using or-patterns can vastly simplify some definitions and increase their "
"clarity, as in `Weekday.isWeekend`. Because there is a potential for "
"confusing behavior, it's a good idea to be careful when using them, "
"especially when variables of multiple types or disjoint sets of variables "
"are involved."
msgstr ""
"使用或模式可以极大地简化一些定义并提高其清晰度，如 "
"`Weekday.isWeekend`。由于存在混淆行为的可能性，因此在使用它们时最好小心，尤其是在涉及多种类型或不相交变量集的变量时。"

#: src/monads/summary.md:3
#, fuzzy
msgid "Encoding Side Effects"
msgstr "对副作用进行编码"

#: src/monads/summary.md:5
#, fuzzy
msgid ""
"Lean is a pure functional language. This means that it does not include side"
" effects such as mutable variables, logging, or exceptions. However, most "
"side effects can be _encoded_ using a combination of functions and inductive"
" types or structures. For example, mutable state can be encoded as a "
"function from an initial state to a pair of a final state and a result, and "
"exceptions can be encoded as an inductive type with constructors for "
"successful termination and errors."
msgstr ""
"Lean "
"是一种纯函数式语言。这意味着它不包含副作用，例如可变变量、日志记录或异常。但是，大多数副作用都可以使用函数和归纳类型或结构体的组合进行_编码_。例如，可变状态可以编码为从初始状态到最终状态和结果对的函数，异常可以编码为具有成功终止和错误构造子的归纳类型。"

#: src/monads/summary.md:10
#, fuzzy
msgid ""
"Each set of encoded effects is a type. As a result, if a program uses these "
"encoded effects, then this is apparent in its type. Functional programming "
"does not mean that programs can't use effects, it simply requires that they "
"be _honest_ about which effects they use. A Lean type signature describes "
"not only the types of arguments that a function expects and the type of "
"result that it returns, but also which effects it may use."
msgstr ""
"每组编码效果都是一种类型。因此，如果程序使用这些编码效果，那么这在它的类型中是显而易见的。函数式编程并不意味着程序不能使用效果，它只是要求它们_诚实_地说明它们使用的效果。Lean"
" 类型签名不仅描述了函数期望的参数类型和它返回的结果类型，还描述了它可能使用的效果。"

#: src/monads/summary.md:17
#, fuzzy
msgid ""
"It's possible to write purely functional programs in languages that allow "
"effects anywhere. For example, `2 + 3` is a valid Python program that has no"
" effects at all. Similarly, combining programs that have effects requires a "
"way to state the order in which the effects must occur. It matters whether "
"an exception is thrown before or after modifying a variable, after all."
msgstr ""
"在允许在任何地方使用效果的语言中编写纯函数式程序是可能的。例如，`2 + 3` 是一个有效的 Python "
"程序，它没有任何效果。类似地，组合具有效果的程序需要一种方法来说明效果必须发生的顺序。毕竟，异常是在修改变量之前还是之后抛出是有区别的。"

#: src/monads/summary.md:22
#, fuzzy
msgid ""
"The type class `Monad` captures these two important properties. It has two "
"methods: `pure` represents programs that have no effects, and `bind` "
"sequences effectful programs. The contract for `Monad` instances ensures "
"that `bind` and `pure` actually capture pure computation and sequencing."
msgstr ""
"类型类 `Monad` 捕获了这两个重要属性。它有两个方法：`pure` 表示没有副作用的程序，`bind` 顺序执行有副作用的程序。`Monad` "
"实例的契约确保 `bind` 和 `pure` 实际上捕获了纯计算和顺序执行。"

#: src/monads/summary.md:28
#, fuzzy
msgid ""
"Rather than being limited to `IO`, `do`\\-notation works for any monad. It "
"allows programs that use monads to be written in a style that is reminiscent"
" of statement-oriented languages, with statements sequenced after one "
"another. Additionally, `do`\\-notation enables a number of additional "
"convenient shorthands, such as nested actions. A program written with `do` "
"is translated to applications of `>>=` behind the scenes."
msgstr ""
"`do` 符号不仅限于 `IO`，它适用于任何单子。它允许使用单子的程序以类似于面向语句的语言的风格编写，语句一个接一个地顺序执行。此外，`do` "
"符号还支持许多其他方便的简写，例如嵌套动作。使用 `do` 编写的程序在幕后被翻译为 `>>=` 的应用程序。"

#: src/monads/summary.md:33
#, fuzzy
msgid "Custom Monads"
msgstr "自定义单子"

#: src/monads/summary.md:35
#, fuzzy
msgid ""
"Different languages provide different sets of side effects. While most "
"languages feature mutable variables and file I/O, not all have features like"
" exceptions. Other languages offer effects that are rare or unique, like "
"Icon's search-based program execution, Scheme and Ruby's continuations, and "
"Common Lisp's resumable exceptions. An advantage to encoding effects with "
"monads is that programs are not limited to the set of effects that are "
"provided by the language. Because Lean is designed to make programming with "
"any monad convenient, programmers are free to choose exactly the set of side"
" effects that make sense for any given application."
msgstr ""
"不同的语言提供不同的副作用集。虽然大多数语言都具有可变变量和文件 I/O，但并非所有语言都具有异常等特性。其他语言提供罕见或独特的副作用，例如 Icon"
" 基于搜索的程序执行、Scheme 和 Ruby 的延续以及 Common Lisp "
"的可恢复异常。用单子对副作用进行编码的一个优点是，程序不受语言提供的副作用集的限制。由于 Lean "
"被设计为方便使用任何单子进行编程，因此程序员可以自由选择最适合任何给定应用程序的副作用集。"

#: src/monads/summary.md:43
#, fuzzy
msgid ""
"Programs that can affect the real world are written as `IO` actions in Lean."
" `IO` is one monad among many. The `IO` monad encodes state and exceptions, "
"with the state being used to keep track of the state of the world and the "
"exceptions modeling failure and recovery."
msgstr ""
"可以在现实世界中产生影响的程序在 Lean 中被写为 `IO` 动作。`IO` 是众多单子中的一个。`IO` "
"单子对状态和异常进行编码，其中状态用于跟踪世界状态，异常对失败和恢复进行建模。"

#: src/functor-applicative-monad.md:3
#, fuzzy
msgid ""
"`Functor` and `Monad` both describe operations for types that are still "
"waiting for a type argument. One way to understand them is that `Functor` "
"describes containers in which the contained data can be transformed, and "
"`Monad` describes an encoding of programs with side effects. This "
"understanding is incomplete, however. After all, `Option` has instances for "
"both `Functor` and `Monad`, and simultaneously represents an optional value "
"_and_ a computation that might fail to return a value."
msgstr ""
"函子（Functor）和单子（Monad）都描述了等待类型参数的类型操作。一种理解方式是，函子描述了其中包含的数据可以被转换的容器，而单子描述了具有副作用的程序的编码。然而，这种理解是不完整的。毕竟，Option"
" 同时具有函子和单子的实例，并且同时表示一个可选值和一个可能无法返回值的计算。"

#: src/functor-applicative-monad.md:8
#, fuzzy
msgid ""
"From the perspective of data structures, `Option` is a bit like a nullable "
"type or like a list that can contain at most one entry. From the perspective"
" of control structures, `Option` represents a computation that might "
"terminate early without a result. Typically, programs that use the `Functor`"
" instance are easiest to think of as using `Option` as a data structure, "
"while programs that use the `Monad` instance are easiest to think of as "
"using `Option` to allow early failure, but learning to use both of these "
"perspectives fluently is an important part of becoming proficient at "
"functional programming."
msgstr ""
"从数据结构体的角度来看，Option 有点像一个可为空的类型或最多可以包含一个条目的列表。从控制结构体的角度来看，Option "
"表示一个可能在没有结果的情况下提前终止的计算。通常，使用函子实例的程序最容易被认为是将 Option "
"用作数据结构体，而使用单子实例的程序最容易被认为是使用 Option 来允许早期失败，但学习流畅地使用这两种视角是精通函数式编程的重要组成部分。"

#: src/functor-applicative-monad.md:12
#, fuzzy
msgid ""
"There is a deeper relationship between functors and monads. It turns out "
"that _every monad is a functor_. Another way to say this is that the monad "
"abstraction is more powerful than the functor abstraction, because not every"
" functor is a monad. Furthermore, there is an additional intermediate "
"abstraction, called _applicative functors_, that has enough power to write "
"many interesting programs and yet permits libraries that cannot use the "
"`Monad` interface. The type class `Applicative` provides the overloadable "
"operations of applicative functors. Every monad is an applicative functor, "
"and every applicative functor is a functor, but the converses do not hold."
msgstr ""
"函子和单子之间存在更深层次的关系。事实证明，每个单子都是一个函子。另一种说法是，单子抽象比函子抽象更强大，因为并非每个函子都是单子。此外，还有一个称为应用函子的附加中间抽象，它有足够的能力编写许多有趣的程序，但允许使用无法使用单子接口的库。类型类"
" Applicative 提供了应用函子的可重载操作。每个单子都是一个应用函子，每个应用函子都是一个函子，但逆否命题不成立。"

#: src/functor-applicative-monad/inheritance.md:3
#, fuzzy
msgid ""
"In order to understand the full definitions of `Functor`, `Applicative`, and"
" `Monad`, another Lean feature is necessary: structure inheritance. "
"Structure inheritance allows one structure type to provide the interface of "
"another, along with additional fields. This can be useful when modeling "
"concepts that have a clear taxonomic relationship. For example, take a model"
" of mythical creatures. Some of them are large, and some are small:"
msgstr ""
"为了理解 `Functor`、`Applicative` 和 `Monad` 的完整定义，还需要另一个 Lean "
"特性：结构体继承。结构体继承允许一个结构体类型提供另一个结构体的接口，以及额外的字段。在对具有明确分类关系的概念进行建模时，这可能很有用。例如，以神话生物模型为例。其中一些是大型的，而另一些是小型："

#: src/functor-applicative-monad/inheritance.md:13
#, fuzzy
msgid ""
"Behind the scenes, defining the `MythicalCreature` structure creates an "
"inductive type with a single constructor called `mk`:"
msgstr "在幕后，定义 `MythicalCreature` 结构体会创建一个具有名为 `mk` 的单个构造子的归纳类型："

#: src/functor-applicative-monad/inheritance.md:20
#, fuzzy
msgid ""
"Similarly, a function `MythicalCreature.large` is created that actually "
"extracts the field from the constructor:"
msgstr "类似地，创建了一个函数 `MythicalCreature.large`，它实际上从构造子中提取字段："

#: src/functor-applicative-monad/inheritance.md:28
#, fuzzy
msgid ""
"In most old stories, each monster can be defeated in some way. A description"
" of a monster should include this information, along with whether it is "
"large:"
msgstr "在大多数古老的故事中，每个怪物都可以用某种方式被击败。怪物的描述应该包括此信息，以及它是否是大型："

#: src/functor-applicative-monad/inheritance.md:35
#, fuzzy
msgid ""
"The `extends MythicalCreature` in the heading states that every monster is "
"also mythical. To define a `Monster`, both the fields from "
"`MythicalCreature` and the fields from `Monster` should be provided. A troll"
" is a large monster that is vulnerable to sunlight:"
msgstr ""
"标题中的 `extends MythicalCreature` 指出每个怪物也是神话生物。要定义 `Monster`，应同时提供 "
"`MythicalCreature` 的字段和 `Monster` 的字段。巨魔是一种大型怪物，容易受到阳光照射："

#: src/functor-applicative-monad/inheritance.md:38
msgid ""
"```lean\n"
"def troll : Monster where\n"
"  large := true\n"
"  vulnerability := \"sunlight\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:44
#, fuzzy
msgid ""
"Behind the scenes, inheritance is implemented using composition. The "
"constructor `Monster.mk` takes a `MythicalCreature` as its argument:"
msgstr "在幕后，继承是使用组合实现的。构造子 `Monster.mk` 将 `MythicalCreature` 作为其参数："

#: src/functor-applicative-monad/inheritance.md:52
#, fuzzy
msgid ""
"In addition to defining functions to extract the value of each new field, a "
"function `Monster.toMythicalCreature` is defined with type `Monster → "
"MythicalCreature`. This can be used to extract the underlying creature."
msgstr ""
"除了定义函数以提取每个新字段的值外，还定义了一个类型为 `Monster → MythicalCreature` 的函数 "
"`Monster.toMythicalCreature`。这可用于提取基础生物。"

#: src/functor-applicative-monad/inheritance.md:55
#, fuzzy
msgid ""
"Moving up the inheritance hierarchy in Lean is not the same thing as "
"upcasting in object-oriented languages. An upcast operator causes a value "
"from a derived class to be treated as an instance of the parent class, but "
"the value retains its identity and structure. In Lean, however, moving up "
"the inheritance hierarchy actually erases the underlying information. To see"
" this in action, consider the result of evaluating "
"`troll.toMythicalCreature`:"
msgstr ""
"在 Lean 中向上移动继承层次结构体与面向对象语言中的向上转型不同。向上转型运算符导致派生类的值被视为父类的实例，但该值保留其标识和结构体。然而，在 "
"Lean 中，向上移动继承层次结构体实际上会擦除底层信息。要查看此操作，请考虑评估 `troll.toMythicalCreature` 的结果："

#: src/functor-applicative-monad/inheritance.md:65
#, fuzzy
msgid "Only the fields of `MythicalCreature` remain."
msgstr "仅保留 `MythicalCreature` 的字段。"

#: src/functor-applicative-monad/inheritance.md:68
#, fuzzy
msgid ""
"Just like the `where` syntax, curly-brace notation with field names also "
"works with structure inheritance:"
msgstr "与 `where` 语法类似，带字段名的花括号表示法也适用于结构体继承："

#: src/functor-applicative-monad/inheritance.md:69
msgid ""
"```lean\n"
"def troll : Monster := {large := true, vulnerability := \"sunlight\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:72
#, fuzzy
msgid ""
"However, the anonymous angle-bracket notation that delegates to the "
"underlying constructor reveals the internal details:"
msgstr "然而，委托给底层构造子的匿名尖括号表示法揭示了内部细节："

#: src/functor-applicative-monad/inheritance.md:73
msgid ""
"```lean\n"
"def troll : Monster := ⟨true, \"sunlight\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:86
#, fuzzy
msgid ""
"An extra set of angle brackets is required, which invokes "
"`MythicalCreature.mk` on `true`:"
msgstr "需要额外的尖括号，在 `true` 上调用 `MythicalCreature.mk`："

#: src/functor-applicative-monad/inheritance.md:87
msgid ""
"```lean\n"
"def troll : Monster := ⟨⟨true⟩, \"sunlight\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:92
#, fuzzy
msgid ""
"Lean's dot notation is capable of taking inheritance into account. In other "
"words, the existing `MythicalCreature.large` can be used with a `Monster`, "
"and Lean automatically inserts the call to `Monster.toMythicalCreature` "
"before the call to `MythicalCreature.large`. However, this only occurs when "
"using dot notation, and applying the field lookup function using normal "
"function call syntax results in a type error:"
msgstr ""
"Lean 的点表示法能够考虑继承。换句话说，现有的 `MythicalCreature.large` 可以与 `Monster` 一起使用，并且 "
"Lean 会在调用 `MythicalCreature.large` 之前自动插入对 `Monster.toMythicalCreature` "
"的调用。但是，这仅在使用点表示法时发生，而使用普通函数调用语法应用字段查找函数会导致类型错误："

#: src/functor-applicative-monad/inheritance.md:108
#, fuzzy
msgid ""
"Dot notation can also take inheritance into account for user-defined "
"functions. A small creature is one that is not large:"
msgstr "点表示法还可以考虑用户定义函数的继承。小生物不是大型生物："

#: src/functor-applicative-monad/inheritance.md:113
#, fuzzy
msgid ""
"Evaluating `troll.small` yields `false`, while attempting to evaluate "
"`MythicalCreature.small troll` results in:"
msgstr ""
"求值 `troll.small` 会得到 `false`，而尝试求值 `MythicalCreature.small troll` 会得到："

#: src/functor-applicative-monad/inheritance.md:125
#, fuzzy
msgid "Multiple Inheritance"
msgstr "多重继承"

#: src/functor-applicative-monad/inheritance.md:127
#, fuzzy
msgid ""
"A helper is a mythical creature that can provide assistance when given the "
"correct payment:"
msgstr "助手是一种神话生物，在得到正确报酬时可以提供帮助："

#: src/functor-applicative-monad/inheritance.md:134
#, fuzzy
msgid ""
"For example, a _nisse_ is a kind of small elf that's known to help around "
"the house when provided with tasty porridge:"
msgstr "例如，_nisse_ 是一种小精灵，当提供美味的粥时，它会帮助打扫房子："

#: src/functor-applicative-monad/inheritance.md:135
msgid ""
"```lean\n"
"def nisse : Helper where\n"
"  large := false\n"
"  assistance := \"household tasks\"\n"
"  payment := \"porridge\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:142
#, fuzzy
msgid ""
"If domesticated, trolls make excellent helpers. They are strong enough to "
"plow a whole field in a single night, though they require model goats to "
"keep them satisfied with their lot in life. A monstrous assistant is a "
"monster that is also a helper:"
msgstr ""
"如果驯化，巨魔会成为优秀的助手。它们强壮到可以在一夜之间耕完整个田地，尽管它们需要模范山羊来让它们对生活感到满意。一个巨大的助手是一个既是怪物又是助手的怪物："

#: src/functor-applicative-monad/inheritance.md:149
#, fuzzy
msgid ""
"A value of this structure type must fill in all of the fields from both "
"parent structures:"
msgstr "此结构体类型的某个值必须填写来自两个父结构体的所有字段："

#: src/functor-applicative-monad/inheritance.md:150
msgid ""
"```lean\n"
"def domesticatedTroll : MonstrousAssistant where\n"
"  large := false\n"
"  assistance := \"heavy labor\"\n"
"  payment := \"toy goats\"\n"
"  vulnerability := \"sunlight\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/inheritance.md:158
#, fuzzy
msgid ""
"Both of the parent structure types extend `MythicalCreature`. If multiple "
"inheritance were implemented naïvely, then this could lead to a \"diamond "
"problem\", where it would be unclear which path to `large` should be taken "
"from a given `MonstrousAssistant`. Should it take `large` from the contained"
" `Monster` or from the contained `Helper`? In Lean, the answer is that the "
"first specified path to the grandparent structure is taken, and the "
"additional parent structures' fields are copied rather than having the new "
"structure include both parents directly."
msgstr ""
"这两个父结构体类型都扩展了 `MythicalCreature`。如果天真地实现多重继承，那么这可能会导致「菱形问题」，其中从给定的 "
"`MonstrousAssistant` 到 `large` 的路径将不明确。它应该从包含的 `Monster` 还是从包含的 `Helper` 中获取"
" `large`？在 Lean 中，答案是采用到祖先结构体的第一个指定路径，并且复制附加父结构体的字段，而不是让新结构体直接包含两个父结构体。"

#: src/functor-applicative-monad/inheritance.md:163
#, fuzzy
msgid ""
"This can be seen by examining the signature of the constructor for "
"`MonstrousAssistant`:"
msgstr "可以通过检查 `MonstrousAssistant` 的构造子签名来看到这一点："

#: src/functor-applicative-monad/inheritance.md:170
#, fuzzy
msgid ""
"It takes a `Monster` as an argument, along with the two fields that `Helper`"
" introduces on top of `MythicalCreature`. Similarly, while "
"`MonstrousAssistant.toMonster` merely extracts the `Monster` from the "
"constructor, `MonstrousAssistant.toHelper` has no `Helper` to extract. The "
"`#print` command exposes its implementation:"
msgstr ""
"它将 `Monster` 作为参数，以及 `Helper` 在 `MythicalCreature` 之上引入的两个字段。类似地，虽然 "
"`MonstrousAssistant.toMonster` 只是从构造子中提取 `Monster`，但 "
"`MonstrousAssistant.toHelper` 没有要提取的 `Helper`。`#print` 命令公开了它的实现："

#: src/functor-applicative-monad/inheritance.md:181
#, fuzzy
msgid ""
"This function constructs a `Helper` from the fields of `MonstrousAssistant`."
" The `@[reducible]` attribute has the same effect as writing `abbrev`."
msgstr ""
"此函数从 `MonstrousAssistant` 的字段构造一个 `Helper`。`@[reducible]` 属性与编写 `abbrev` "
"的效果相同。"

#: src/functor-applicative-monad/inheritance.md:184
#, fuzzy
msgid "Default Declarations"
msgstr "默认声明"

#: src/functor-applicative-monad/inheritance.md:186
#, fuzzy
msgid ""
"When one structure inherits from another, default field definitions can be "
"used to instantiate the parent structure's fields based on the child "
"structure's fields. If more size specificity is required than whether a "
"creature is large or not, a dedicated datatype describing sizes can be used "
"together with inheritance, yielding a structure in which the `large` field "
"is computed from the contents of the `size` field:"
msgstr ""
"当一个结构体继承自另一个结构体时，可以使用默认字段定义来基于子结构体的字段实例化父结构体的字段。如果需要比生物是否大型更具体的尺寸，则可以将描述尺寸的专用数据类型与继承一起使用，从而生成一个结构体，其中"
" `large` 字段是从 `size` 字段的内容计算出来的："

#: src/functor-applicative-monad/inheritance.md:199
#, fuzzy
msgid ""
"This default definition is only a default definition, however. Unlike "
"property inheritance in a language like C# or Scala, the definitions in the "
"child structure are only used when no specific value for `large` is "
"provided, and nonsensical results can occur:"
msgstr ""
"然而，此默认定义仅仅是一个默认定义。与 C# 或 Scala 等语言中的属性继承不同，仅当未提供 `large` "
"的特定值时，才会使用子结构体中的定义，并且可能会出现无意义的结果："

#: src/functor-applicative-monad/inheritance.md:206
#, fuzzy
msgid ""
"If the child structure should not deviate from the parent structure, there "
"are a few options:"
msgstr "如果子结构体不应偏离父结构体，则有几种选择："

#: src/functor-applicative-monad/inheritance.md:208
#, fuzzy
msgid "Documenting the relationship, as is done for `BEq` and `Hashable`"
msgstr "记录关系，如对 `BEq` 和 `Hashable` 所做的那样"

#: src/functor-applicative-monad/inheritance.md:209
#, fuzzy
msgid ""
"Defining a proposition that the fields are related appropriately, and "
"designing the API to require evidence that the proposition is true where it "
"matters"
msgstr "定义一个命题，使字段适当相关，并设计 API 以要求证据表明命题在重要的地方为真"

#: src/functor-applicative-monad/inheritance.md:210
#, fuzzy
msgid "Not using inheritance at all"
msgstr "根本不使用继承"

#: src/functor-applicative-monad/inheritance.md:212
#, fuzzy
msgid "The second option could look like this:"
msgstr "第二个选项可能如下所示："

#: src/functor-applicative-monad/inheritance.md:217
#, fuzzy
msgid ""
"Note that a single equality sign is used to indicate the equality "
"_proposition_, while a double equality sign is used to indicate a function "
"that checks equality and returns a `Bool`. `SizesMatch` is defined as an "
"`abbrev` because it should automatically be unfolded in proofs, so that "
"`simp` can see the equality that should be proven."
msgstr ""
"请注意，使用单个等号表示相等性命题，而使用双等号表示检查相等性和返回 `Bool` 的函数。`SizesMatch` 被定义为 "
"`abbrev`，因为它应该在证明中自动展开，以便 `simp` 能够看到应该被证明的相等性。"

#: src/functor-applicative-monad/inheritance.md:220
#, fuzzy
msgid ""
"A _huldre_ is a medium-sized mythical creature—in fact, they are the same "
"size as humans. The two sized fields on `huldre` match one another:"
msgstr "_huldre_ 是一种中等大小的神话生物——事实上，它们与人类大小相同。`huldre` 上的两个大小字段相互匹配："

#: src/functor-applicative-monad/inheritance.md:231
#, fuzzy
msgid "Type Class Inheritance"
msgstr "类型类继承"

#: src/functor-applicative-monad/inheritance.md:233
#, fuzzy
msgid ""
"Behind the scenes, type classes are structures. Defining a new type class "
"defines a new structure, and defining an instance creates a value of that "
"structure type. They are then added to internal tables in Lean that allow it"
" to find the instances upon request. A consequence of this is that type "
"classes may inherit from other type classes."
msgstr ""
"在幕后，类型类是结构体。定义一个新的类型类定义一个新的结构体，而定义一个实例创建该结构体类型的某个值。然后将它们添加到 Lean "
"中的内部表中，以便它在请求时找到这些实例。由此产生的一个后果是类型类可以从其他类型类继承。"

#: src/functor-applicative-monad/inheritance.md:238
#, fuzzy
msgid ""
"Because it uses precisely the same language features, type class inheritance"
" supports all the features of structure inheritance, including multiple "
"inheritance, default implementations of parent types' methods, and automatic"
" collapsing of diamonds. This is useful in many of the same situations that "
"multiple interface inheritance is useful in languages like Java, C# and "
"Kotlin. By carefully designing type class inheritance hierarchies, "
"programmers can get the best of both worlds: a fine-grained collection of "
"independently-implementable abstractions, and automatic construction of "
"these specific abstractions from larger, more general abstractions."
msgstr ""
"由于它使用完全相同的语言特性，类型类继承支持结构体继承的所有特性，包括多重继承、父类型方法的默认实现以及菱形的自动折叠。这在许多情况下很有用，就像多接口继承在"
" Java、C# 和 Kotlin "
"等语言中很有用一样。通过仔细设计类型类继承层次结构体，程序员可以兼得两全其美：独立可实现抽象的细粒度集合，以及从更大、更通用的抽象中自动构建这些特定抽象。"

#: src/functor-applicative-monad/applicative.md:3
#, fuzzy
msgid ""
"An _applicative functor_ is a functor that has two additional operations "
"available: `pure` and `seq`. `pure` is the same operator used in `Monad`, "
"because `Monad` in fact inherits from `Applicative`. `seq` is much like "
"`map`: it allows a function to be used in order to transform the contents of"
" a datatype. However, with `seq`, the function is itself contained in the "
"datatype: `f (α → β) → (Unit → f α) → f β`. Having the function under the "
"type `f` allows the `Applicative` instance to control how the function is "
"applied, while `Functor.map` unconditionally applies a function. The second "
"argument has a type that begins with `Unit →` to allow the definition of "
"`seq` to short-circuit in cases where the function will never be applied."
msgstr ""
"应用函子是一种函子，它具有两个附加操作：`pure` 和 `seq`。`pure` 是 `Monad` 中使用的相同操作符，因为 `Monad` "
"实际上继承自 `Applicative`。`seq` 与 `map` 非常相似：它允许使用函数来转换数据类型的內容。但是，使用 `seq` "
"时，函数本身包含在数据类型中：`f (α → β) → (Unit → f α) → f β`。将函数置于类型 `f` 下允许 "
"`Applicative` 实例控制如何应用函数，而 `Functor.map` 无条件地应用函数。第二个参数的类型以 `Unit →` "
"开头，以便在函数永远不会被应用的情况下允许 `seq` 的定义短路。"

#: src/functor-applicative-monad/applicative.md:10
#, fuzzy
msgid ""
"The value of this short-circuiting behavior can be seen in the instance of "
"`Applicative Option`:"
msgstr "这种短路行为的价值可以在 `Applicative Option` 的实例中看到："

#: src/functor-applicative-monad/applicative.md:19
#, fuzzy
msgid ""
"In this case, if there is no function for `seq` to apply, then there is no "
"need to compute its argument, so `x` is never called. The same consideration"
" informs the instance of `Applicative` for `Except`:"
msgstr ""
"在这种情况下，如果没有要应用的 `seq` 函数，则无需计算其参数，因此永远不会调用 `x`。相同的考虑适用于 `Except` 的 "
"`Applicative` 实例："

#: src/functor-applicative-monad/applicative.md:29
#, fuzzy
msgid ""
"This short-circuiting behavior depends only on the `Option` or `Except` "
"structures that _surround_ the function, rather than on the function itself."
msgstr "这种短路行为仅取决于包围函数的 `Option` 或 `Except` 结构体，而不是函数本身。"

#: src/functor-applicative-monad/applicative.md:31
#, fuzzy
msgid ""
"Monads can be seen as a way of capturing the notion of sequentially "
"executing statements into a pure functional language. The result of one "
"statement can affect which further statements run. This can be seen in the "
"type of `bind`: `m α → (α → m β) → m β`. The first statement's resulting "
"value is an input into a function that computes the next statement to "
"execute. Successive uses of `bind` are like a sequence of statements in an "
"imperative programming language, and `bind` is powerful enough to implement "
"control structures like conditionals and loops."
msgstr ""
"Monad 可以看作是一种将顺序执行语句的概念捕获到纯函数语言中的方式。一个语句的结果会影响哪些进一步的语句运行。这可以在 `bind` "
"的类型中看到：`m α → (α → m β) → m β`。第一个语句的结果值是计算要执行的下一个语句的函数的输入。`bind` "
"的连续使用就像命令式编程语言中的语句序列，并且 `bind` 足够强大，可以实现条件和循环等控制结构体。"

#: src/functor-applicative-monad/applicative.md:37
#, fuzzy
msgid ""
"Following this analogy, `Applicative` captures function application in a "
"language that has side effects. The arguments to a function in languages "
"like Kotlin or C# are evaluated from left to right. Side effects performed "
"by earlier arguments occur before those performed by later arguments. A "
"function is not powerful enough to implement custom short-circuiting "
"operators that depend on the specific _value_ of an argument, however."
msgstr ""
"类比而言，`Applicative` 捕获了具有副作用的语言中的函数应用。在 Kotlin 或 C# "
"等语言中，函数的参数从左到右求值。较早参数执行的副作用发生在较后参数执行的副作用之前。然而，函数不够强大，无法实现依赖于参数特定 _值_ "
"的自定义短路运算符。"

#: src/functor-applicative-monad/applicative.md:42
#, fuzzy
msgid ""
"Typically, `seq` is not invoked directly. Instead, the operator `<*>` is "
"used. This operator wraps its second argument in `fun () => ...`, "
"simplifying the call site. In other words, `E1 <*> E2` is syntactic sugar "
"for `Seq.seq E1 (fun () => E2)`."
msgstr ""
"通常，`seq` 不会直接调用。相反，使用运算符 `<*>`。此运算符将其第二个参数包装在 `fun () => ...` "
"中，简化了调用站点。换句话说，`E1 <*> E2` 是 `Seq.seq E1 (fun () => E2)` 的语法糖。"

#: src/functor-applicative-monad/applicative.md:48
#, fuzzy
msgid ""
"The key feature that allows `seq` to be used with multiple arguments is that"
" a multiple-argument Lean function is really a single-argument function that"
" returns another function that's waiting for the rest of the arguments. In "
"other words, if the first argument to `seq` is awaiting multiple arguments, "
"then the result of the `seq` will be awaiting the rest. For example, `some "
"Plus.plus` can have the type `Option (Nat → Nat → Nat)`. Providing one "
"argument, `some Plus.plus <*> some 4`, results in the type `Option (Nat → "
"Nat)`. This can itself be used with `seq`, so `some Plus.plus <*> some 4 <*>"
" some 7` has the type `Option Nat`."
msgstr ""
"允许 `seq` 用于多个参数的关键特性是，多参数 Lean 函数实际上是一个单参数函数，它返回另一个等待其余参数的函数。换句话说，如果 `seq` "
"的第一个参数正在等待多个参数，那么 `seq` 的结果将等待其余参数。例如，`some Plus.plus` 可以具有类型 `Option (Nat →"
" Nat → Nat)`。提供一个参数，`some Plus.plus <*> some 4`，得到类型 `Option (Nat → "
"Nat)`。这本身可以与 `seq` 一起使用，所以 `some Plus.plus <*> some 4 <*> some 7` 具有类型 "
"`Option Nat`。"

#: src/functor-applicative-monad/applicative.md:54
#, fuzzy
msgid ""
"Not every functor is applicative. `Pair` is like the built-in product type "
"`Prod`:"
msgstr "并非每个函子都是应用函子。`Pair` 类似于内置的乘积类型 `Prod`："

#: src/functor-applicative-monad/applicative.md:61
#, fuzzy
msgid ""
"Like `Except`, `Pair` has type `Type → Type → Type`. This means that `Pair "
"α` has type `Type → Type`, and a `Functor` instance is possible:"
msgstr ""
"与 `Except` 一样，`Pair` 具有类型 `Type → Type → Type`。这意味着 `Pair α` 具有类型 `Type → "
"Type`，并且 `Functor` 实例是可能的："

#: src/functor-applicative-monad/applicative.md:67
#, fuzzy
msgid "This instance obeys the `Functor` contract."
msgstr "此实例遵循 `Functor` 契约。"

#: src/functor-applicative-monad/applicative.md:69
#, fuzzy
msgid ""
"The two properties to check are that `id <$> Pair.mk x y = Pair.mk x y` and "
"that `f <$> g <$> Pair.mk x y = (f ∘ g) <$> Pair.mk x y`. The first property"
" can be checked by just stepping through the evaluation of the left side, "
"and noticing that it evaluates to the right side:"
msgstr ""
"要检查的两个属性是 `id <$> Pair.mk x y = Pair.mk x y` 和 `f <$> g <$> Pair.mk x y = (f"
" ∘ g) <$> Pair.mk x y`。第一个属性可以通过逐步执行左侧的求值来检查，并注意到它求值为右侧："

#: src/functor-applicative-monad/applicative.md:78
#, fuzzy
msgid ""
"The second can be checked by stepping through both sides, and noting that "
"they yield the same result:"
msgstr "第二个属性可以通过逐步执行双方来检查，并注意到它们产生相同的结果："

#: src/functor-applicative-monad/applicative.md:93
#, fuzzy
msgid ""
"Attempting to define an `Applicative` instance, however, does not work so "
"well. It will require a definition of `pure`:"
msgstr "然而，尝试定义一个 `Applicative` 实例并不能很好地工作。它需要一个 `pure` 的定义："

#: src/functor-applicative-monad/applicative.md:105
#, fuzzy
msgid ""
"There is a value with type `β` in scope (namely `x`), and the error message "
"from the underscore suggests that the next step is to use the constructor "
"`Pair.mk`:"
msgstr "作用域中有一个类型为 `β` 的值（即 `x`），下划线中的错误消息表明下一步是使用构造子 `Pair.mk`："

#: src/functor-applicative-monad/applicative.md:116
#, fuzzy
msgid ""
"Unfortunately, there is no `α` available. Because `pure` would need to work "
"for _all possible types_ α to define an instance of `Applicative (Pair α)`, "
"this is impossible. After all, a caller could choose `α` to be `Empty`, "
"which has no values at all."
msgstr ""
"不幸的是，没有 `α` 可用。因为 `pure` 需要对所有可能的类型 α 起作用才能定义 `Applicative (Pair α)` "
"的实例，这是不可能的。毕竟，调用者可以选择 `α` 为 `Empty`，它没有任何值。"

#: src/functor-applicative-monad/applicative.md:120
#, fuzzy
msgid "A Non-Monadic Applicative"
msgstr "非单子 Applicative"

#: src/functor-applicative-monad/applicative.md:122
#, fuzzy
msgid ""
"When validating user input to a form, it's generally considered to be best "
"to provide many errors at once, rather than one error at a time. This allows"
" the user to have an overview of what is needed to please the computer, "
"rather than feeling badgered as they correct the errors field by field."
msgstr ""
"在验证表单的用户输入时，通常认为一次提供多个错误比一次提供一个错误更好。这使用户能够概览满足计算机需要的内容，而不是在逐个字段更正错误时感到烦恼。"

#: src/functor-applicative-monad/applicative.md:125
#, fuzzy
msgid ""
"Ideally, validating user input will be visible in the type of the function "
"that's doing the validating. It should return a datatype that is "
"specific—checking that a text box contains a number should return an actual "
"numeric type, for instance. A validation routine could throw an exception "
"when the input does not pass validation. Exceptions have a major drawback, "
"however: they terminate the program at the first error, making it impossible"
" to accumulate a list of errors."
msgstr ""
"理想情况下，验证用户输入将在执行验证的函数的类型中可见。它应该返回一个特定的数据类型——例如，检查文本框是否包含数字应该返回一个实际的数字类型。当输入未通过验证时，验证例程可能会抛出异常。然而，异常有一个主要的缺点：它们在第一个错误时终止程序，使得无法累积错误列表。"

#: src/functor-applicative-monad/applicative.md:130
#, fuzzy
msgid ""
"On the other hand, the common design pattern of accumulating a list of "
"errors and then failing when it is non-empty is also problematic. A long "
"nested sequences of `if` statements that validate each sub-section of the "
"input data is hard to maintain, and it's easy to lose track of an error "
"message or two. Ideally, validation can be performed using an API that "
"enables a new value to be returned yet automatically tracks and accumulates "
"error messages."
msgstr ""
"另一方面，积累一个错误列表，然后在列表非空时失败的常见设计模式也存在问题。一个验证输入数据每个子部分的嵌套 `if` 语句的序列难以维护，并且很容易丢失一两个错误消息。理想情况下，可以使用允许返回新值但自动跟踪和积累错误消息的 API 来执行验证。\n"
"\n"
"一个名为 `Validate` 的应用函子提供了一种实现这种风格的 API 的方法。与 `Except` 单子类似，`Validate` 允许构造一个新值，该值准确地表征了经过验证的数据。与 `Except` 不同，它允许积累多个错误，而不会忘记检查列表是否为空。\n"
"\n"
"用户输入\n"
"\n"
"以下结构体作为用户输入的一个示例：\n"
"\n"
"要实现的业务逻辑如下：\n"
"\n"
"名称不能为空\n"
"出生年份必须为数字且非负\n"
"出生年份必须大于 1900 年，且小于或等于验证表单的年份\n"
"将这些表示为数据类型需要一个称为 _子类型_ 的新特性。有了这个工具，就可以编写一个使用应用函子来跟踪错误的验证框架，并且可以在框架中实现这些规则。\n"
"\n"
"子类型\n"
"\n"
"使用一个称为 `Subtype` 的附加 Lean 类型最容易表示这些条件：\n"
"\n"
"此结构体有两个类型参数：一个隐式参数是数据 `α` 的类型，一个显式参数 `p` 是 `α` 上的谓词。_谓词_ 是其中包含变量的逻辑语句，该变量可以用值替换以产生实际语句，例如 [GetElem 的参数](../type-classes/indexing.md#overloading-indexing) 描述了索引在查找中处于界内意味着什么。在 `Subtype` 的情况下，谓词切分出 `α` 值的某些子集，谓词对这些值成立。该结构体的两个字段分别是来自 `α` 的值和该值满足谓词 `p` 的证据。Lean 有用于 `Subtype` 的特殊语法。如果 `p` 的类型为 `α → Prop`，则类型 `Subtype p` 也可以写为 `{x : α // p x}`，甚至在可以自动推断类型时写为 `{x // p x}`。"

#: src/functor-applicative-monad/applicative.md:134
#, fuzzy
msgid ""
"An applicative functor called `Validate` provides one way to implement this "
"style of API. Like the `Except` monad, `Validate` allows a new value to be "
"constructed that characterizes the validated data accurately. Unlike "
"`Except`, it allows multiple errors to be accumulated, without a risk of "
"forgetting to check whether the list is empty."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:138
#, fuzzy
msgid "User Input"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:139
#, fuzzy
msgid "As an example of user input, take the following structure:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:145
#, fuzzy
msgid "The business logic to be implemented is the following:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:146
#, fuzzy
msgid "The name may not be empty"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:147
#, fuzzy
msgid "The birth year must be numeric and non-negative"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:148
#, fuzzy
msgid ""
"The birth year must be greater than 1900, and less than or equal to the year"
" in which the form is validated"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:150
#, fuzzy
msgid ""
"Representing these as a datatype will require a new feature, called "
"_subtypes_. With this tool in hand, a validation framework can be written "
"that uses an applicative functor to track errors, and these rules can be "
"implemented in the framework."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:153
#, fuzzy
msgid "Subtypes"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:154
#, fuzzy
msgid ""
"Representing these conditions is easiest with one additional Lean type, "
"called `Subtype`:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:160
#, fuzzy
msgid ""
"This structure has two type parameters: an implicit parameter that is the "
"type of data `α`, and an explicit parameter `p` that is a predicate over "
"`α`. A _predicate_ is a logical statement with a variable in it that can be "
"replaced with a value to yield an actual statement, like the [parameter to "
"`GetElem`](../type-classes/indexing.md#overloading-indexing) that describes "
"what it means for an index to be in bounds for a lookup. In the case of "
"`Subtype`, the predicate slices out some subset of the values of `α` for "
"which the predicate holds. The structure's two fields are, respectively, a "
"value from `α` and evidence that the value satisfies the predicate `p`. Lean"
" has special syntax for `Subtype`. If `p` has type `α → Prop`, then the type"
" `Subtype p` can also be written `{x : α // p x}`, or even `{x // p x}` when"
" the type can be inferred automatically."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:167
#, fuzzy
msgid ""
"[Representing positive numbers as inductive types](../type-classes/pos.md) "
"is clear and easy to program with. However, it has a key disadvantage. While"
" `Nat` and `Int` have the structure of ordinary inductive types from the "
"perspective of Lean programs, the compiler treats them specially and uses "
"fast arbitrary-precision number libraries to implement them. This is not the"
" case for additional user-defined types. However, a subtype of `Nat` that "
"restricts it to non-zero numbers allows the new type to use the efficient "
"representation while still ruling out zero at compile time:"
msgstr ""
"以归纳类型表示正数清晰易于编程。然而，它有一个关键缺点。从 Lean 程序的角度来看，`Nat` 和 `Int` "
"具有普通归纳类型的结构体，但编译器将它们视为特殊类型，并使用快速任意精度数字库来实现它们。对于其他用户定义类型而言，情况并非如此。然而，`Nat` "
"的一个子类型将其限制为非零数字，允许新类型使用高效表示，同时在编译时仍排除零：最小的快速正数仍然是一。现在，它不再是归纳类型的构造子，而是用尖括号构造的结构体的一个实例。第一个参数是底层的"
" `Nat`，第二个参数是证据，即所述 `Nat` 大于零：`OfNat` 实例与 `Pos` 的实例非常相似，除了它使用简短的策略证明来提供证据，即 "
"`n + 1 > 0`：`simp_arith` 策略是 `simp` "
"的一个版本，它考虑了额外的算术恒等式。子类型是一把双刃剑。它们允许对验证规则进行高效表示，但它们将维护这些规则的负担转移给了库的用户，他们必须证明他们没有违反重要的不变量。通常，最好在库内部使用它们，为用户提供一个"
" API，该 API 自动确保满足所有不变量，并且任何必要的证明都属于库的内部。"

#: src/functor-applicative-monad/applicative.md:172
msgid ""
"```lean\n"
"def FastPos : Type := {x : Nat // x > 0}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:176
#, fuzzy
msgid ""
"The smallest fast positive number is still one. Now, instead of being a "
"constructor of an inductive type, it's an instance of a structure that's "
"constructed with angle brackets. The first argument is the underlying `Nat`,"
" and the second argument is the evidence that said `Nat` is greater than "
"zero:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:182
#, fuzzy
msgid ""
"The `OfNat` instance is very much like that for `Pos`, except it uses a "
"short tactic proof to provide evidence that `n + 1 > 0`:"
msgstr "?"

#: src/functor-applicative-monad/applicative.md:187
#, fuzzy
msgid ""
"The `simp_arith` tactic is a version of `simp` that takes additional "
"arithmetic identities into account."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:189
#, fuzzy
msgid ""
"Subtypes are a two-edged sword. They allow efficient representation of "
"validation rules, but they transfer the burden of maintaining these rules to"
" the users of the library, who have to _prove_ that they are not violating "
"important invariants. Generally, it's a good idea to use them internally to "
"a library, providing an API to users that automatically ensures that all "
"invariants are satisfied, with any necessary proofs being internal to the "
"library."
msgstr "?"

#: src/functor-applicative-monad/applicative.md:193
#, fuzzy
msgid ""
"Checking whether a value of type `α` is in the subtype `{x : α // p x}` "
"usually requires that the proposition `p x` be decidable. The [section on "
"equality and ordering classes](../type-classes/standard-classes.md#equality-"
"and-ordering) describes how decidable propositions can be used with `if`. "
"When `if` is used with a decidable proposition, a name can be provided. In "
"the `then` branch, the name is bound to evidence that the proposition is "
"true, and in the `else` branch, it is bound to evidence that the proposition"
" is false. This comes in handy when checking whether a given `Nat` is "
"positive:"
msgstr ""
"检查类型为 `α` 的值是否在子类型 `{x : α // p x}` 中通常需要命题 `p x` 可判定。[等式和排序类部分](../type-"
"classes/standard-classes.md#equality-and-ordering) 描述了如何将可判定命题与 `if` 一起使用。当 "
"`if` 与可判定命题一起使用时，可以提供一个名称。在 `then` 分支中，该名称绑定到命题为真的证据，而在 `else` "
"分支中，它绑定到命题为假的证据。这在检查给定的 `Nat` 是否为正数时非常方便："

#: src/functor-applicative-monad/applicative.md:204
#, fuzzy
msgid ""
"In the `then` branch, `h` is bound to evidence that `n > 0`, and this "
"evidence can be used as the second argument to `Subtype`'s constructor."
msgstr "在 `then` 分支中，`h` 绑定到 `n > 0` 的证据，并且此证据可以用作 `Subtype` 构造子的第二个参数。"

#: src/functor-applicative-monad/applicative.md:207
#, fuzzy
msgid "Validated Input"
msgstr "已验证的输入"

#: src/functor-applicative-monad/applicative.md:209
#, fuzzy
msgid ""
"The validated user input is a structure that expresses the business logic "
"using multiple techniques:"
msgstr "已验证的用户输入是一个结构体，它使用多种技术来表达业务逻辑："

#: src/functor-applicative-monad/applicative.md:210
#, fuzzy
msgid ""
"The structure type itself encodes the year in which it was checked for "
"validity, so that `CheckedInput 2019` is not the same type as `CheckedInput "
"2020`"
msgstr ""
"结构体类型本身编码了检查其有效性的年份，因此 `CheckedInput 2019` 与 `CheckedInput 2020` 不是同一种类型"

#: src/functor-applicative-monad/applicative.md:211
#, fuzzy
msgid "The birth year is represented as a `Nat` rather than a `String`"
msgstr "出生年份表示为 `Nat` 而不是 `String`"

#: src/functor-applicative-monad/applicative.md:212
#, fuzzy
msgid ""
"Subtypes are used to constrain the allowed values in the name and birth year"
" fields"
msgstr "子类型用于限制名称和出生年份字段中的允许值"

#: src/functor-applicative-monad/applicative.md:213
msgid ""
"```lean\n"
"structure CheckedInput (thisYear : Nat) : Type where\n"
"  name : {n : String // n ≠ \"\"}\n"
"  birthYear : {y : Nat // y > 1900 ∧ y ≤ thisYear}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:219
#, fuzzy
msgid ""
"An input validator should take the current year and a `RawInput` as "
"arguments, returning either a checked input or at least one validation "
"failure. This is represented by the `Validate` type:"
msgstr "输入验证器应以当前年份和 `RawInput` 作为参数，返回已检查的输入或至少一个验证失败。这由 `Validate` 类型表示："

#: src/functor-applicative-monad/applicative.md:226
#, fuzzy
msgid ""
"It looks very much like `Except`. The only difference is that the `error` "
"constructor may contain more than one failure."
msgstr "它看起来非常像 `Except`。唯一的区别是 `error` 构造子可能包含多个失败。"

#: src/functor-applicative-monad/applicative.md:229
#, fuzzy
msgid ""
"Validate is a functor. Mapping a function over it transforms any successful "
"value that might be present, just as in the `Functor` instance for `Except`:"
msgstr "Validate 是一个函子。对其进行函数映射会转换可能存在的任何成功值，就像 `Except` 的 `Functor` 实例一样："

#: src/functor-applicative-monad/applicative.md:238
#, fuzzy
msgid ""
"The `Applicative` instance for `Validate` has an important difference from "
"the instance for `Except`: while the instance for `Except` terminates at the"
" first error encountered, the instance for `Validate` is careful to "
"accumulate all errors from _both_ the function and the argument branches:"
msgstr ""
"`Validate` 的 `Applicative` 实例与 `Except` 的实例有一个重要的区别：`Except` 实例在遇到第一个错误时终止，而"
" `Validate` 实例会小心地累积来自函数和参数分支的所有错误："

#: src/functor-applicative-monad/applicative.md:251
#, fuzzy
msgid ""
"Using `.errors` together with the constructor for `NonEmptyList` is a bit "
"verbose. Helpers like `reportError` make code more readable. In this "
"application, error reports will consist of field names paired with messages:"
msgstr ""
"将 `.errors` 与 `NonEmptyList` 的构造子一起使用有点冗长。像 `reportError` "
"这样的辅助函数使代码更具可读性。在此应用程序中，错误报告将由与消息配对的字段名称组成："

#: src/functor-applicative-monad/applicative.md:261
#, fuzzy
msgid ""
"The `Applicative` instance for `Validate` allows the checking procedures for"
" each field to be written independently and then composed. Checking a name "
"consists of ensuring that a string is non-empty, then returning evidence of "
"this fact in the form of a `Subtype`. This uses the evidence-binding version"
" of `if`:"
msgstr ""
"`Validate` 的 `Applicative` 实例允许独立编写每个字段的检查过程，然后进行组合。检查名称包括确保字符串非空，然后以 "
"`Subtype` 的形式返回此事实的证据。这使用 `if` 的证据绑定版本："

#: src/functor-applicative-monad/applicative.md:264
msgid ""
"```lean\n"
"def checkName (name : String) : Validate (Field × String) {n : String // n ≠ \"\"} :=\n"
"  if h : name = \"\" then\n"
"    reportError \"name\" \"Required\"\n"
"  else pure ⟨name, h⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:270
#, fuzzy
msgid ""
"In the `then` branch, `h` is bound to evidence that `name = \"\"`, while it "
"is bound to evidence that `¬name = \"\"` in the `else` branch."
msgstr "在 `then` 分支中，`h` 绑定到 `name = \"\"` 的证据，而在 `else` 分支中，它绑定到 `¬name = \"\"` 的证据。"

#: src/functor-applicative-monad/applicative.md:272
#, fuzzy
msgid ""
"It's certainly the case that some validation errors make other checks "
"impossible. For example, it makes no sense to check whether the birth year "
"field is greater than 1900 if a confused user wrote the word `\"syzygy\"` "
"instead of a number. Checking the allowed range of the number is only "
"meaningful after ensuring that the field in fact contains a number. This can"
" be expressed using the function `andThen`:"
msgstr ""
"当然，某些验证错误会使其他检查变得不可能。例如，如果一个困惑的用户写了单词 `\"syzygy\"` 而不是数字，那么检查出生年份字段是否大于 1900"
" 就没有意义了。只有在确保字段实际上包含数字后，检查数字的允许范围才有意义。这可以使用 `andThen` 函数来表示："

#: src/functor-applicative-monad/applicative.md:282
#, fuzzy
msgid ""
"While this function's type signature makes it suitable to be used as `bind` "
"in a `Monad` instance, there are good reasons not to do so. They are "
"described [in the section that describes the `Applicative` "
"contract](applicative-contract.md#additional-stipulations)."
msgstr ""
"虽然此函数的类型签名使其适合用作 `Monad` 实例中的 `bind`，但有充分的理由不这样做。它们在 [描述 `Applicative` "
"契约的部分](applicative-contract.md#additional-stipulations) 中进行了描述。"

#: src/functor-applicative-monad/applicative.md:285
#, fuzzy
msgid ""
"To check that the birth year is a number, a built-in function called "
"`String.toNat? : String → Option Nat` is useful. It's most user-friendly to "
"eliminate leading and trailing whitespace first using `String.trim`:"
msgstr ""
"为了检查出生年份是否为数字，内置函数 `String.toNat? : String → Option Nat` 非常有用。最用户友好的做法是首先使用 "
"`String.trim` 去除前导和尾随空格："

#: src/functor-applicative-monad/applicative.md:287
msgid ""
"```lean\n"
"def checkYearIsNat (year : String) : Validate (Field × String) Nat :=\n"
"  match year.trim.toNat? with\n"
"  | none => reportError \"birth year\" \"Must be digits\"\n"
"  | some n => pure n\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:293
#, fuzzy
msgid ""
"To check that the provided year is in the expected range, nested uses of the"
" evidence-providing form of `if` are in order:"
msgstr "为了检查提供的年份是否在预期范围内，需要嵌套使用提供证据形式的 `if`："

#: src/functor-applicative-monad/applicative.md:294
msgid ""
"```leantac\n"
"def checkBirthYear (thisYear year : Nat) : Validate (Field × String) {y : Nat // y > 1900 ∧ y ≤ thisYear} :=\n"
"  if h : year > 1900 then\n"
"    if h' : year ≤ thisYear then\n"
"      pure ⟨year, by simp [*]⟩\n"
"    else reportError \"birth year\" s!\"Must be no later than {thisYear}\"\n"
"  else reportError \"birth year\" \"Must be after 1900\"\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:303
#, fuzzy
msgid "Finally, these three components can be combined using `seq`:"
msgstr "最后，这三个组件可以使用 `seq` 组合："

#: src/functor-applicative-monad/applicative.md:312
#, fuzzy
msgid ""
"Testing `checkInput` shows that it can indeed return multiple pieces of "
"feedback:"
msgstr "测试 `checkInput` 表明它确实可以返回多条反馈："

#: src/functor-applicative-monad/applicative.md:313
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"David\", birthYear := \"1984\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:316
msgid ""
"```output info\n"
"Validate.ok { name := \"David\", birthYear := 1984 }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:319
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"\", birthYear := \"2045\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:322
msgid ""
"```output info\n"
"Validate.errors { head := (\"name\", \"Required\"), tail := [(\"birth year\", \"Must be no later than 2023\")] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:325
msgid ""
"```lean\n"
"#eval checkInput 2023 {name := \"David\", birthYear := \"syzygy\"}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:328
msgid ""
"```output info\n"
"Validate.errors { head := (\"birth year\", \"Must be digits\"), tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative.md:333
#, fuzzy
msgid ""
"Form validation with `checkInput` illustrates a key advantage of "
"`Applicative` over `Monad`. Because `>>=` provides enough power to modify "
"the rest of the program's execution based on the value from the first step, "
"it _must_ receive a value from the first step to pass on. If no value is "
"received (e.g. because an error has occurred), then `>>=` cannot execute the"
" rest of the program. `Validate` demonstrates why it can be useful to run "
"the rest of the program anyway: in cases where the earlier data isn't "
"needed, running the rest of the program can yield useful information (in "
"this case, more validation errors). `Applicative`'s `<*>` may run both of "
"its arguments before recombining the results. Similarly, `>>=` forces "
"sequential execution. Each step must complete before the next may run. This "
"is generally useful, but it makes it impossible to have parallel execution "
"of different threads that naturally emerges from the program's actual data "
"dependencies. A more powerful abstraction like `Monad` increases the "
"flexibility that's available to the API consumer, but it decreases the "
"flexibility that is available to the API implementor."
msgstr ""
"使用 `checkInput` 进行表单验证说明了 `Applicative` 相对于 `Monad` 的一个关键优势。由于 `>>=` "
"提供了足够的权力来根据第一步的值修改程序其余部分的执行，因此它_必须_从第一步接收一个值才能传递。如果没有收到值（例如，因为发生了错误），则 `>>=`"
" 无法执行程序的其余部分。`Validate` "
"展示了为什么无论如何运行程序的其余部分都可能很有用：在不需要早期数据的情况下，运行程序的其余部分可以产生有用的信息（在本例中，更多验证错误）。`Applicative`"
" 的 `<*>` 可以在重新组合结果之前运行其两个参数。类似地，`>>=` "
"强制顺序执行。每个步骤都必须完成，然后才能运行下一个步骤。这通常很有用，但它使得无法并行执行程序的实际数据依赖性自然产生的不同线程。像 `Monad` "
"这样更强大的抽象增加了 API 消费者可用的灵活性，但它降低了 API 实现者可用的灵活性。"

#: src/functor-applicative-monad/applicative-contract.md:3
#, fuzzy
msgid ""
"Just like `Functor`, `Monad`, and types that implement `BEq` and `Hashable`,"
" `Applicative` has a set of rules that all instances should adhere to."
msgstr ""
"与 `Functor`、`Monad` 以及实现 `BEq` 和 `Hashable` 的类型一样，`Applicative` "
"有一组所有实例都应遵守的规则。"

#: src/functor-applicative-monad/applicative-contract.md:5
#, fuzzy
msgid "There are four rules that an applicative functor should follow:"
msgstr "一个应用式函子应遵循四条规则："

#: src/functor-applicative-monad/applicative-contract.md:6
#, fuzzy
msgid "It should respect identity, so `pure id <*> v = v`"
msgstr "它应尊重恒等，因此 `pure id <*> v = v`"

#: src/functor-applicative-monad/applicative-contract.md:7
#, fuzzy
msgid ""
"It should respect function composition, so `pure (· ∘ ·) <*> u <*> v <*> w ="
" u <*> (v <*> w)`"
msgstr "它应尊重函数组合，因此 `pure (· ∘ ·) <*> u <*> v <*> w = u <*> (v <*> w)`"

#: src/functor-applicative-monad/applicative-contract.md:8
#, fuzzy
msgid ""
"Sequencing pure operations should be a no-op, so `pure f <*> pure x = pure "
"(f x)`"
msgstr "对纯操作进行排序应为无操作，因此 `pure f <*> pure x = pure (f x)`"

#: src/functor-applicative-monad/applicative-contract.md:9
#, fuzzy
msgid ""
"The ordering of pure operations doesn't matter, so `u <*> pure x = pure (fun"
" f => f x) <*> u`"
msgstr "纯操作的顺序无关紧要，因此 `u <*> pure x = pure (fun f => f x) <*> u`"

#: src/functor-applicative-monad/applicative-contract.md:11
#, fuzzy
msgid ""
"To check these for the `Applicative Option` instance, start by expanding "
"`pure` into `some`."
msgstr "要检查 `Applicative Option` 实例的这些规则，首先将 `pure` 扩展为 `some`。"

#: src/functor-applicative-monad/applicative-contract.md:13
#, fuzzy
msgid ""
"The first rule states that `some id <*> v = v`. The definition of `seq` for "
"`Option` states that this is the same as `id <$> v = v`, which is one of the"
" `Functor` rules that have already been checked."
msgstr ""
"第一条规则指出 `some id <*> v = v`。`Option` 的 `seq` 定义指出这与 `id <$> v = v` "
"相同，这是已检查过的 `Functor` 规则之一。"

#: src/functor-applicative-monad/applicative-contract.md:16
#, fuzzy
msgid ""
"The second rule states that `some (· ∘ ·) <*> u <*> v <*> w = u <*> (v <*> "
"w)`. If any of `u`, `v`, or `w` is `none`, then both sides are `none`, so "
"the property holds. Assuming that `u` is `some f`, that `v` is `some g`, and"
" that `w` is `some x`, then this is equivalent to saying that `some (· ∘ ·) "
"<*> some f <*> some g <*> some x = some f <*> (some g <*> some x)`. "
"Evaluating the two sides yields the same result:"
msgstr ""
"第二条规则指出 `some (· ∘ ·) <*> u <*> v <*> w = u <*> (v <*> w)`。如果 `u`、`v` 或 `w` "
"中的任何一个是 `none`，则双方都是 `none`，因此该属性成立。假设 `u` 是 `some f`，`v` 是 `some g`，`w` 是 "
"`some x`，那么这等同于说 `some (· ∘ ·) <*> some f <*> some g <*> some x = some f <*>"
" (some g <*> some x)`。计算两边得到相同的结果："

#: src/functor-applicative-monad/applicative-contract.md:38
#, fuzzy
msgid "The third rule follows directly from the definition of `seq`:"
msgstr "第三条规则直接源于 `seq` 的定义："

#: src/functor-applicative-monad/applicative-contract.md:47
#, fuzzy
msgid ""
"In the fourth case, assume that `u` is `some f`, because if it's `none`, "
"both sides of the equation are `none`. `some f <*> some x` evaluates "
"directly to `some (f x)`, as does `some (fun g => g x) <*> some f`."
msgstr ""
"在第四种情况下，假设 `u` 是 `some f`，因为如果它是 `none`，则等式的双方都是 `none`。`some f <*> some x` "
"直接计算为 `some (f x)`，`some (fun g => g x) <*> some f` 也是如此。"

#: src/functor-applicative-monad/applicative-contract.md:51
#, fuzzy
msgid "All Applicatives are Functors"
msgstr "所有应用器都是函子"

#: src/functor-applicative-monad/applicative-contract.md:53
#, fuzzy
msgid "The two operators for `Applicative` are enough to define `map`:"
msgstr "`Applicative` 的两个运算符足以定义 `map`："

#: src/functor-applicative-monad/applicative-contract.md:59
#, fuzzy
msgid ""
"This can only be used to implement `Functor` if the contract for "
"`Applicative` guarantees the contract for `Functor`, however. The first rule"
" of `Functor` is that `id <$> x = x`, which follows directly from the first "
"rule for `Applicative`. The second rule of `Functor` is that `map (f ∘ g) x "
"= map f (map g x)`. Unfolding the definition of `map` here results in `pure "
"(f ∘ g) <*> x = pure f <*> (pure g <*> x)`. Using the rule that sequencing "
"pure operations is a no-op, the left side can be rewritten to `pure (· ∘ ·) "
"<*> pure f <*> pure g <*> x`. This is an instance of the rule that states "
"that applicative functors respect function composition."
msgstr ""
"然而，这只能用于实现 `Functor`，如果 `Applicative` 的契约保证了 `Functor` 的契约。`Functor` 的第一条规则是"
" `id <$> x = x`，它直接源于 `Applicative` 的第一条规则。`Functor` 的第二条规则是 `map (f ∘ g) x "
"= map f (map g x)`。在此处展开 `map` 的定义，得到 `pure (f ∘ g) <*> x = pure f <*> (pure"
" g <*> x)`。使用纯操作的顺序是一个空操作的规则，左侧可以重写为 `pure (· ∘ ·) <*> pure f <*> pure g <*>"
" x`。这是应用函子尊重函数组合的规则的一个实例。"

#: src/functor-applicative-monad/applicative-contract.md:66
#, fuzzy
msgid ""
"This justifies a definition of `Applicative` that extends `Functor`, with a "
"default definition of `map` given in terms of `pure` and `seq`:"
msgstr ""
"这证明了 `Applicative` 的一个定义，它扩展了 `Functor`，其中 `map` 的默认定义以 `pure` 和 `seq` "
"的形式给出："

#: src/functor-applicative-monad/applicative-contract.md:74
#, fuzzy
msgid "All Monads are Applicative Functors"
msgstr "所有单子都是应用函子"

#: src/functor-applicative-monad/applicative-contract.md:76
#, fuzzy
msgid ""
"An instance of `Monad` already requires an implementation of `pure`. "
"Together with `bind`, this is enough to define `seq`:"
msgstr "`Monad` 的一个实例已经需要 `pure` 的实现。连同 `bind`，这足以定义 `seq`："

#: src/functor-applicative-monad/applicative-contract.md:84
#, fuzzy
msgid ""
"Once again, checking that the `Monad` contract implies the `Applicative` "
"contract will allow this to be used as a default definition for `seq` if "
"`Monad` extends `Applicative`."
msgstr ""
"再次检查 `Monad` 契约暗示 `Applicative` 契约，如果 `Monad` 扩展 `Applicative`，这将允许将其用作 "
"`seq` 的默认定义。"

#: src/functor-applicative-monad/applicative-contract.md:86
#, fuzzy
msgid ""
"The rest of this section consists of an argument that this implementation of"
" `seq` based on `bind` in fact satisfies the `Applicative` contract. One of "
"the beautiful things about functional programming is that this kind of "
"argument can be worked out on a piece of paper with a pencil, using the "
"kinds of evaluation rules from [the initial section on evaluating "
"expressions](../getting-to-know/evaluating.md). Thinking about the meanings "
"of the operations while reading these arguments can sometimes help with "
"understanding."
msgstr ""
"本节的其余部分包含一个论证，即基于 `bind` 的 `seq` 的这种实现实际上满足 `Applicative` "
"契约。函数式编程的美妙之处之一在于，这种论证可以用一支铅笔在一张纸上进行，使用 [关于求值表达式的初始部分](../getting-to-"
"know/evaluating.md) 中的求值规则。在阅读这些论证时思考运算的含义有时有助于理解。"

#: src/functor-applicative-monad/applicative-contract.md:90
#, fuzzy
msgid ""
"Replacing `do`\\-notation with explicit uses of `>>=` makes it easier to "
"apply the `Monad` rules:"
msgstr "用显式使用 `>>=` 替换 `do` 符号，可以更轻松地应用 `Monad` 规则："

#: src/functor-applicative-monad/applicative-contract.md:99
#, fuzzy
msgid ""
"To check that this definition respects identity, check that `seq (pure id) "
"(fun () => v) = v`. The left hand side is equivalent to `pure id >>= fun g "
"=> (fun () => v) () >>= fun y => pure (g y)`. The unit function in the "
"middle can be eliminated immediately, yielding `pure id >>= fun g => v >>= "
"fun y => pure (g y)`. Using the fact that `pure` is a left identity of "
"`>>=`, this is the same as `v >>= fun y => pure (id y)`, which is `v >>= fun"
" y => pure y`. Because `fun x => f x` is the same as `f`, this is the same "
"as `v >>= pure`, and the fact that `pure` is a right identity of `>>=` can "
"be used to get `v`."
msgstr ""
"要检查此定义是否符合恒等性，请检查 `seq (pure id) (fun () => v) = v`。左侧等价于 `pure id >>= fun g"
" => (fun () => v) () >>= fun y => pure (g y)`。中间的单位函数可以立即消除，得到 `pure id >>= "
"fun g => v >>= fun y => pure (g y)`。利用 `pure` 是 `>>=` 的左恒等性的事实，这等同于 `v >>= "
"fun y => pure (id y)`，即 `v >>= fun y => pure y`。由于 `fun x => f x` 等同于 "
"`f`，这等同于 `v >>= pure`，而 `pure` 是 `>>=` 的右恒等性的事实可用于得到 `v`。"

#: src/functor-applicative-monad/applicative-contract.md:105
#, fuzzy
msgid ""
"This kind of informal reasoning can be made easier to read with a bit of "
"reformatting. In the following chart, read \"EXPR1 ={ REASON }= EXPR2\" as "
"\"EXPR1 is the same as EXPR2 because REASON\":"
msgstr ""
"通过一些重新格式化，这种非正式推理可以变得更容易阅读。在以下图表中，将 \"EXPR1 ={ REASON }= EXPR2\" 理解为 \"EXPR1"
" 等同于 EXPR2，因为 REASON\"："

#: src/functor-applicative-monad/applicative-contract.md:139
#, fuzzy
msgid ""
"To check that it respects function composition, check that `pure (· ∘ ·) <*>"
" u <*> v <*> w = u <*> (v <*> w)`. The first step is to replace `<*>` with "
"this definition of `seq`. After that, a (somewhat long) series of steps that"
" use the identity and associativity rules from the `Monad` contract is "
"enough to get from one to the other:"
msgstr ""
"要检查它是否符合函数组合，请检查 `pure (· ∘ ·) <*> u <*> v <*> w = u <*> (v <*> w)`。第一步是用此 "
"`seq` 定义替换 `<*>`。之后，使用 `Monad` 契约中的恒等性和结合性规则的一系列（有点长的）步骤就足以从一个得到另一个："

#: src/functor-applicative-monad/applicative-contract.md:277
#, fuzzy
msgid "To check that sequencing pure operations is a no-op:"
msgstr "要检查对纯操作进行排序是否为无操作："

#: src/functor-applicative-monad/applicative-contract.md:306
#, fuzzy
msgid ""
"And finally, to check that the ordering of pure operations doesn't matter:"
msgstr "最后，要检查纯操作的顺序无关紧要："

#: src/functor-applicative-monad/applicative-contract.md:350
#, fuzzy
msgid ""
"This justifies a definition of `Monad` that extends `Applicative`, with a "
"default definition of `seq`:"
msgstr "这证明了 `Monad` 的定义扩展了 `Applicative`，其中 `seq` 的默认定义为："

#: src/functor-applicative-monad/applicative-contract.md:359
#, fuzzy
msgid ""
"`Applicative`'s own default definition of `map` means that every `Monad` "
"instance automatically generates `Applicative` and `Functor` instances as "
"well."
msgstr ""
"`Applicative` 自身的 `map` 默认定义意味着每个 `Monad` 实例都会自动生成 `Applicative` 和 `Functor`"
" 实例。"

#: src/functor-applicative-monad/applicative-contract.md:361
#, fuzzy
msgid "Additional Stipulations"
msgstr "附加规定"

#: src/functor-applicative-monad/applicative-contract.md:363
#, fuzzy
msgid ""
"In addition to adhering to the individual contracts associated with each "
"type class, combined implementations `Functor`, `Applicative` and `Monad` "
"should work equivalently to these default implementations. In other words, a"
" type that provides both `Applicative` and `Monad` instances should not have"
" an implementation of `seq` that works differently from the version that the"
" `Monad` instance generates as a default implementation. This is important "
"because polymorphic functions may be refactored to replace a use of `>>=` "
"with an equivalent use of `<*>`, or a use of `<*>` with an equivalent use of"
" `>>=`. This refactoring should not change the meaning of programs that use "
"this code."
msgstr ""
"除了遵守与每个类型类关联的各个契约外，组合实现 `Functor`、`Applicative` 和 `Monad` "
"应等效于这些默认实现。换句话说，同时提供 `Applicative` 和 `Monad` 实例的类型不应具有与 `Monad` "
"实例作为默认实现生成的版本不同的 `seq` 实现。这很重要，因为多态函数可能会重构，以使用等效的 `<*>` 替换 `>>=`，或使用等效的 "
"`>>=` 替换 `<*>`。此重构不应更改使用此代码的程序的含义。"

#: src/functor-applicative-monad/applicative-contract.md:368
#, fuzzy
msgid ""
"This rule explains why `Validate.andThen` should not be used to implement "
"`bind` in a `Monad` instance. On its own, it obeys the monad contract. "
"However, when it is used to implement `seq`, the behavior is not equivalent "
"to `seq` itself. To see where they differ, take the example of two "
"computations, both of which return errors. Start with an example of a case "
"where two errors should be returned, one from validating a function (which "
"could have just as well resulted from a prior argument to the function), and"
" one from validating an argument:"
msgstr ""
"此规则解释了为什么不应使用 `Validate.andThen` 在 `Monad` 实例中实现 `bind`。它本身遵守 monad "
"契约。但是，当它用于实现 `seq` 时，行为与 `seq` "
"本身不相等。要了解它们的不同之处，请以两个计算为例，它们都返回错误。从一个案例开始，其中应返回两个错误，一个来自验证函数（也可能来自函数的先前参数），另一个来自验证参数："

#: src/functor-applicative-monad/applicative-contract.md:373
msgid ""
"```lean\n"
"def notFun : Validate String (Nat → String) :=\n"
"  .errors { head := \"First error\", tail := [] }\n"
"\n"
"def notArg : Validate String Nat :=\n"
"  .errors { head := \"Second error\", tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:381
#, fuzzy
msgid ""
"Combining them with the version of `<*>` from `Validate`'s `Applicative` "
"instance results in both errors being reported to the user:"
msgstr "将它们与 `Validate` 的 `Applicative` 实例中的 `<*>` 版本结合使用，将导致向用户报告这两个错误："

#: src/functor-applicative-monad/applicative-contract.md:382
msgid ""
"```lean\n"
"notFun <*> notArg\n"
"===>\n"
"match notFun with\n"
"| .ok g => g <$> notArg\n"
"| .errors errs =>\n"
"  match notArg with\n"
"  | .ok _ => .errors errs\n"
"  | .errors errs' => .errors (errs ++ errs')\n"
"===>\n"
"match notArg with\n"
"| .ok _ => .errors { head := \"First error\", tail := [] }\n"
"| .errors errs' => .errors ({ head := \"First error\", tail := [] } ++ errs')\n"
"===>\n"
".errors ({ head := \"First error\", tail := [] } ++ { head := \"Second error\", tail := []})\n"
"===>\n"
".errors { head := \"First error\", tail := [\"Second error\"]}\n"
"```"
msgstr ""

#: src/functor-applicative-monad/applicative-contract.md:401
#, fuzzy
msgid ""
"Using the version of `seq` that was implemented with `>>=`, here rewritten "
"to `andThen`, results in only the first error being available:"
msgstr "使用使用 `>>=` 实现的 `seq` 版本（在此重写为 `andThen`）导致仅第一个错误可用："

#: src/functor-applicative-monad/applicative-contract.md:402
msgid ""
"```lean\n"
"seq notFun (fun () => notArg)\n"
"===>\n"
"notFun.andThen fun g =>\n"
"notArg.andThen fun y =>\n"
"pure (g y)\n"
"===>\n"
"match notFun with\n"
"| .errors errs => .errors errs\n"
"| .ok val =>\n"
"  (fun g =>\n"
"    notArg.andThen fun y =>\n"
"    pure (g y)) val\n"
"===>\n"
".errors { head := \"First error\", tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:4
#, fuzzy
msgid "Recovery from Failure"
msgstr "从失败中恢复"

#: src/functor-applicative-monad/alternative.md:6
#, fuzzy
msgid ""
"`Validate` can also be used in situations where there is more than one way "
"for input to be acceptable. For the input form `RawInput`, an alternative "
"set of business rules that implement conventions from a legacy system might "
"be the following:"
msgstr "`Validate` 还可以用于输入有多种可接受方式的情况。对于输入表单 `RawInput`，实现旧系统约定的备用业务规则集可能是："

#: src/functor-applicative-monad/alternative.md:9
#, fuzzy
msgid "All human users must provide a birth year that is four digits."
msgstr "所有人类用户都必须提供四位数的出生年份。"

#: src/functor-applicative-monad/alternative.md:10
#, fuzzy
msgid ""
"Users born prior to 1970 do not need to provide names, due to incomplete "
"older records."
msgstr "由于旧记录不完整，1970 年之前出生的用户无需提供姓名。"

#: src/functor-applicative-monad/alternative.md:11
#, fuzzy
msgid "Users born after 1970 must provide names."
msgstr "1970 年之后出生的用户必须提供姓名。"

#: src/functor-applicative-monad/alternative.md:12
#, fuzzy
msgid ""
"Companies should enter `\"FIRM\"` as their year of birth and provide a "
"company name."
msgstr "公司应将其出生年份输入为 `\"FIRM\"`，并提供公司名称。"

#: src/functor-applicative-monad/alternative.md:14
#, fuzzy
msgid ""
"No particular provision is made for users born in 1970. It is expected that "
"they will either give up, lie about their year of birth, or call. The "
"company considers this an acceptable cost of doing business."
msgstr "对于 1970 年出生的用户没有做出任何特别规定。预计他们要么会放弃，要么谎报出生年份，要么打电话。公司认为这是开展业务的可接受成本。"

#: src/functor-applicative-monad/alternative.md:18
#, fuzzy
msgid ""
"The following inductive type captures the values that can be produced from "
"these stated rules:"
msgstr "以下归纳类型捕获了可以从这些既定规则中产生的值："

#: src/functor-applicative-monad/alternative.md:19
msgid ""
"```lean\n"
"abbrev NonEmptyString := {s : String // s ≠ \"\"}\n"
"\n"
"inductive LegacyCheckedInput where\n"
"  | humanBefore1970 :\n"
"    (birthYear : {y : Nat // y > 999 ∧ y < 1970}) →\n"
"    String →\n"
"    LegacyCheckedInput\n"
"  | humanAfter1970 :\n"
"    (birthYear : {y : Nat // y > 1970}) →\n"
"    NonEmptyString →\n"
"    LegacyCheckedInput\n"
"  | company :\n"
"    NonEmptyString →\n"
"    LegacyCheckedInput\n"
"deriving Repr\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:37
#, fuzzy
msgid ""
"A validator for these rules is more complicated, however, as it must address"
" all three cases. While it can be written as a series of nested `if` "
"expressions, it's easier to design the three cases independently and then "
"combine them. This requires a means of recovering from failure while "
"preserving error messages:"
msgstr ""
"但是，针对这些规则的验证器会更复杂，因为它必须解决所有三种情况。虽然它可以写成一系列嵌套的 `if` "
"表达式，但独立设计这三种情况然后将它们组合起来会更容易。这需要一种在保留错误消息的同时从失败中恢复的方法："

#: src/functor-applicative-monad/alternative.md:50
#, fuzzy
msgid ""
"This pattern of recovery from failures is common enough that Lean has built-"
"in syntax for it, attached to a type class named `OrElse`:"
msgstr "从失败中恢复的这种模式很常见，以至于 Lean 为它内置了语法，附加到名为 `OrElse` 的类型类："

#: src/functor-applicative-monad/alternative.md:55
#, fuzzy
msgid ""
"The expression `E1 <|> E2` is short for `OrElse.orElse E1 (fun () => E2)`. "
"An instance of `OrElse` for `Validate` allows this syntax to be used for "
"error recovery:"
msgstr ""
"表达式 `E1 <|> E2` 是 `OrElse.orElse E1 (fun () => E2)` 的缩写。`Validate` 的 "
"`OrElse` 实例允许将此语法用于错误恢复："

#: src/functor-applicative-monad/alternative.md:62
#, fuzzy
msgid ""
"The validator for `LegacyCheckedInput` can be built from a validator for "
"each constructor. The rules for a company state that the birth year should "
"be the string `\"FIRM\"` and that the name should be non-empty. The "
"constructor `LegacyCheckedInput.company`, however, has no representation of "
"the birth year at all, so there's no easy way to carry it out using `<*>`. "
"The key is to use a function with `<*>` that ignores its argument."
msgstr ""
"`LegacyCheckedInput` 的验证器可以从每个构造子的验证器构建。公司的规则规定出生年份应为字符串 "
"`\"FIRM\"`，并且姓名应非空。但是，构造子 `LegacyCheckedInput.company` 根本没有出生年份的表示，因此无法使用 "
"`<*>` 轻松执行。关键是要使用忽略其参数的函数和 `<*>`。"

#: src/functor-applicative-monad/alternative.md:67
#, fuzzy
msgid ""
"Checking that a Boolean condition holds without recording any evidence of "
"this fact in a type can be accomplished with `checkThat`:"
msgstr "使用 `checkThat` 可以检查布尔条件是否成立，而无需在类型中记录此事实的任何证据："

#: src/functor-applicative-monad/alternative.md:72
#, fuzzy
msgid ""
"This definition of `checkCompany` uses `checkThat`, and then throws away the"
" resulting `Unit` value:"
msgstr "`checkCompany` 的此定义使用 `checkThat`，然后丢弃结果 `Unit` 值："

#: src/functor-applicative-monad/alternative.md:73
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  pure (fun () name => .company name) <*>\n"
"    checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a company\" <*>\n"
"    checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:80
#, fuzzy
msgid ""
"However, this definition is quite noisy. It can be simplified in two ways. "
"The first is to replace the first use of `<*>` with a specialized version "
"that automatically ignores the value returned by the first argument, called "
"`*>`. This operator is also controlled by a type class, called `SeqRight`, "
"and `E1 *> E2` is syntactic sugar for `SeqRight.seqRight E1 (fun () => E2)`:"
msgstr ""
"但是，此定义非常冗长。可以通过两种方式简化它。首先，用一个专门版本替换第一个 `<*>` 用法，该版本会自动忽略第一个参数返回的值，称为 "
"`*>`。此运算符也由类型类 `SeqRight` 控制，并且 `E1 *> E2` 是 `SeqRight.seqRight E1 (fun () "
"=> E2)` 的语法糖："

#: src/functor-applicative-monad/alternative.md:88
#, fuzzy
msgid ""
"There is a default implementation of `seqRight` in terms of `seq`: `seqRight"
" (a : f α) (b : Unit → f β) : f β := pure (fun _ x => x) <*> a <*> b ()`."
msgstr ""
"`seqRight` 有一个基于 `seq` 的默认实现：`seqRight (a : f α) (b : Unit → f β) : f β := "
"pure (fun _ x => x) <*> a <*> b ()`。"

#: src/functor-applicative-monad/alternative.md:90
#, fuzzy
msgid "Using `seqRight`, `checkCompany` becomes simpler:"
msgstr "使用 `seqRight`，`checkCompany` 变得更简单："

#: src/functor-applicative-monad/alternative.md:91
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a company\" *>\n"
"  pure .company <*> checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:96
#, fuzzy
msgid ""
"One more simplification is possible. For every `Applicative`, `pure F <*> E`"
" is equivalent to `f <$> E`. In other words, using `seq` to apply a function"
" that was placed into the `Applicative` type using `pure` is overkill, and "
"the function could have just been applied using `Functor.map`. This "
"simplification yields:"
msgstr ""
"还可以进行更多简化。对于每个 `Applicative`，`pure F <*> E` 等同于 `f <$> E`。换句话说，使用 `seq` 应用使用"
" `pure` 放入 `Applicative` 类型的函数是多余的，可以使用 `Functor.map` 直接应用函数。此简化产生："

#: src/functor-applicative-monad/alternative.md:100
msgid ""
"```lean\n"
"def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  checkThat (input.birthYear == \"FIRM\") \"birth year\" \"FIRM if a company\" *>\n"
"  .company <$> checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:106
#, fuzzy
msgid ""
"The remaining two constructors of `LegacyCheckedInput` use subtypes for "
"their fields. A general-purpose tool for checking subtypes will make these "
"easier to read:"
msgstr "`LegacyCheckedInput` 的其余两个构造子为其字段使用子类型。用于检查子类型的通用工具将使这些字段更易于阅读："

#: src/functor-applicative-monad/alternative.md:108
msgid ""
"```lean\n"
"def checkSubtype {α : Type} (v : α) (p : α → Prop) [Decidable (p v)] (err : ε) : Validate ε {x : α // p x} :=\n"
"  if h : p v then\n"
"    pure ⟨v, h⟩\n"
"  else\n"
"    .errors { head := err, tail := [] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:115
#, fuzzy
msgid ""
"In the function's argument list, it's important that the type class "
"`[Decidable (p v)]` occur after the specification of the arguments `v` and "
"`p`. Otherwise, it would refer to an additional set of automatic implicit "
"arguments, rather than to the manually-provided values. The `Decidable` "
"instance is what allows the proposition `p v` to be checked using `if`."
msgstr ""
"在函数的参数列表中，类型类 `[Decidable (p v)]` 必须在参数 `v` 和 `p` "
"的规范之后出现。否则，它将引用一组额外的自动隐式参数，而不是手动提供的值。`Decidable` 实例允许使用 `if` 检查命题 `p v`。"

#: src/functor-applicative-monad/alternative.md:119
#, fuzzy
msgid "The two human cases do not need any additional tools:"
msgstr "两种人类情况不需要任何附加工具："

#: src/functor-applicative-monad/alternative.md:120
msgid ""
"```lean\n"
"def checkHumanBefore1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  (checkYearIsNat input.birthYear).andThen fun y =>\n"
"    .humanBefore1970 <$>\n"
"      checkSubtype y (fun x => x > 999 ∧ x < 1970) (\"birth year\", \"less than 1970\") <*>\n"
"      pure input.name\n"
"\n"
"def checkHumanAfter1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=\n"
"  (checkYearIsNat input.birthYear).andThen fun y =>\n"
"    .humanAfter1970 <$>\n"
"      checkSubtype y (· > 1970) (\"birth year\", \"greater than 1970\") <*>\n"
"      checkName input.name\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:134
#, fuzzy
msgid "The validators for the three cases can be combined using `<|>`:"
msgstr "三个案例的验证器可以使用 `<|>` 组合："

#: src/functor-applicative-monad/alternative.md:140
#, fuzzy
msgid ""
"The successful cases return constructors of `LegacyCheckedInput`, as "
"expected:"
msgstr "成功案例按预期返回 `LegacyCheckedInput` 的构造子："

#: src/functor-applicative-monad/alternative.md:141
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"Johnny's Troll Groomers\", \"FIRM\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:144
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.company \"Johnny's Troll Groomers\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:147
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"Johnny\", \"1963\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:150
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.humanBefore1970 1963 \"Johnny\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:153
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"\", \"1963\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:156
msgid ""
"```output info\n"
"Validate.ok (LegacyCheckedInput.humanBefore1970 1963 \"\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:160
#, fuzzy
msgid "The worst possible input returns all the possible failures:"
msgstr "最差的可能输入返回所有可能的失败："

#: src/functor-applicative-monad/alternative.md:161
msgid ""
"```lean\n"
"#eval checkLegacyInput ⟨\"\", \"1970\"⟩\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:164
msgid ""
"```output info\n"
"Validate.errors\n"
"  { head := (\"birth year\", \"FIRM if a company\"),\n"
"    tail := [(\"name\", \"Required\"),\n"
"             (\"birth year\", \"less than 1970\"),\n"
"             (\"birth year\", \"greater than 1970\"),\n"
"             (\"name\", \"Required\")] }\n"
"```"
msgstr ""

#: src/functor-applicative-monad/alternative.md:174
#, fuzzy
msgid "The `Alternative` Class"
msgstr "`Alternative` 类"

#: src/functor-applicative-monad/alternative.md:176
#, fuzzy
msgid ""
"Many types support a notion of failure and recovery. The `Many` monad from "
"the section on [evaluating arithmetic expressions in a variety of "
"monads](../monads/arithmetic.md#nondeterministic-search) is one such type, "
"as is `Option`. Both support failure without providing a reason (unlike, "
"say, `Except` and `Validate`, which require some indication of what went "
"wrong)."
msgstr ""
"许多类型支持失败和恢复的概念。[在各种单子中计算算术表达式](../monads/arithmetic.md#nondeterministic-"
"search) 部分中的 `Many` 单子就是其中之一，`Option` 也是如此。两者都支持失败，而不提供原因（与 `Except` 和 "
"`Validate` 不同，它们需要一些指示出错内容的指示）。"

#: src/functor-applicative-monad/alternative.md:180
#, fuzzy
msgid ""
"The `Alternative` class describes applicative functors that have additional "
"operators for failure and recovery:"
msgstr "`Alternative` 类描述了具有附加失败和恢复运算符的应用函子："

#: src/functor-applicative-monad/alternative.md:186
#, fuzzy
msgid ""
"Just as implementors of `Add α` get `HAdd α α α` instances for free, "
"implementors of `Alternative` get `OrElse` instances for free:"
msgstr ""
"就像 `Add α` 的实现者免费获得 `HAdd α α α` 实例一样，`Alternative` 的实现者免费获得 `OrElse` 实例："

#: src/functor-applicative-monad/alternative.md:192
#, fuzzy
msgid ""
"The implementation of `Alternative` for `Option` keeps the first none-`none`"
" argument:"
msgstr "`Option` 的 `Alternative` 实现保留第一个非 `none` 参数："

#: src/functor-applicative-monad/alternative.md:200
#, fuzzy
msgid ""
"Similarly, the implementation for `Many` follows the general structure of "
"`Many.union`, with minor differences due to the laziness-inducing `Unit` "
"parameters being placed differently:"
msgstr "同样，`Many` 的实现遵循 `Many.union` 的一般结构体，由于惰性诱导 `Unit` 参数放置不同而有细微差别："

#: src/functor-applicative-monad/alternative.md:211
#, fuzzy
msgid ""
"Like other type classes, `Alternative` enables the definition of a variety "
"of operations that work for _any_ applicative functor that implements "
"`Alternative`. One of the most important is `guard`, which causes `failure` "
"when a decidable proposition is false:"
msgstr ""
"与其他类型类一样，`Alternative` 允许定义各种操作，这些操作适用于实现 `Alternative` 的任何应用函子。其中最重要的一个操作是 "
"`guard`，当可判定命题为假时，它会导致 `failure`："

#: src/functor-applicative-monad/alternative.md:219
#, fuzzy
msgid ""
"It is very useful in monadic programs to terminate execution early. In "
"`Many`, it can be used to filter out a whole branch of a search, as in the "
"following program that computes all even divisors of a natural number:"
msgstr "在单子程序中非常有用，可以提前终止执行。在 `Many` 中，它可用于过滤搜索的整个分支，如下程序计算自然数的所有偶数除数："

#: src/functor-applicative-monad/alternative.md:232
#, fuzzy
msgid "Running it on `20` yields the expected results:"
msgstr "运行它，得到预期结果："

#: src/functor-applicative-monad/alternative.md:243
#, fuzzy
msgid "Improve Validation Friendliness"
msgstr "改进验证友好性"

#: src/functor-applicative-monad/alternative.md:245
#, fuzzy
msgid ""
"The errors returned from `Validate` programs that use `<|>` can be difficult"
" to read, because inclusion in the list of errors simply means that the "
"error can be reached through _some_ code path. A more structured error "
"report can be used to guide the user through the process more accurately:"
msgstr ""
"使用 `<|>` 的 `Validate` 程序返回的错误可能难以阅读，因为包含在错误列表中仅仅意味着可以通过 _some_ "
"代码路径到达该错误。更结构体化的错误报告可以更准确地指导用户完成该过程："

#: src/functor-applicative-monad/alternative.md:248
#, fuzzy
msgid ""
"Replace the `NonEmptyList` in `Validate.error` with a bare type variable, "
"and then update the definitions of the `Applicative (Validate ε)` and "
"`OrElse (Validate ε α)` instances to require only that there be an `Append "
"ε` instance available."
msgstr ""
"用一个裸类型变量替换 `Validate.error` 中的 `NonEmptyList`，然后更新 `Applicative (Validate "
"ε)` 和 `OrElse (Validate ε α)` 实例的定义，仅要求提供一个可用的 `Append ε` 实例。"

#: src/functor-applicative-monad/alternative.md:249
#, fuzzy
msgid ""
"Define a function `Validate.mapErrors : Validate ε α → (ε → ε') → Validate "
"ε' α` that transforms all the errors in a validation run."
msgstr ""
"定义一个函数 `Validate.mapErrors : Validate ε α → (ε → ε') → Validate ε' "
"α`，它转换验证运行中的所有错误。"

#: src/functor-applicative-monad/alternative.md:250
#, fuzzy
msgid ""
"Using the datatype `TreeError` to represent errors, rewrite the legacy "
"validation system to track its path through the three alternatives."
msgstr "使用数据类型 `TreeError` 来表示错误，重写旧验证系统以跟踪其通过三个备选方案的路径。"

#: src/functor-applicative-monad/alternative.md:251
#, fuzzy
msgid ""
"Write a function `report : TreeError → String` that outputs a user-friendly "
"view of the `TreeError`'s accumulated warnings and errors."
msgstr "编写一个函数 `report : TreeError → String`，它输出 `TreeError` 累积的警告和错误的用户友好视图。"

#: src/functor-applicative-monad/universes.md:3
#, fuzzy
msgid ""
"In the interests of simplicity, this book has thus far papered over an "
"important feature of Lean: _universes_. A universe is a type that classifies"
" other types. Two of them are familiar: `Type` and `Prop`. `Type` classifies"
" ordinary types, such as `Nat`, `String`, `Int → String × Char`, and `IO "
"Unit`. `Prop` classifies propositions that may be true or false, such as "
"`\"nisse\" = \"elf\"` or `3 > 2`. The type of `Prop` is `Type`:"
msgstr ""
"为了简单起见，本书迄今为止一直掩盖了 Lean 的一个重要特性：_universe_。universe "
"是对其他类型进行分类的类型。其中两个很熟悉：`Type` 和 `Prop`。`Type` 对普通类型进行分类，例如 "
"`Nat`、`String`、`Int → String × Char` 和 `IO Unit`。`Prop` 对可能为真或假的命题进行分类，例如 "
"`\"nisse\" = \"elf\"` 或 `3 > 2`。`Prop` 的类型是 `Type`："

#: src/functor-applicative-monad/universes.md:16
#, fuzzy
msgid ""
"For technical reasons, more universes than these two are needed. In "
"particular, `Type` cannot itself be a `Type`. This would allow a logical "
"paradox to be constructed and undermine Lean's usefulness as a theorem "
"prover."
msgstr ""
"出于技术原因，需要比这两个更多的 universe。特别是，`Type` 本身不能是 `Type`。这将允许构建一个逻辑悖论，并破坏 Lean "
"作为定理证明器的效用。"

#: src/functor-applicative-monad/universes.md:20
#, fuzzy
msgid ""
"The formal argument for this is known as _Girard's Paradox_. It related to a"
" better-known paradox known as _Russell's Paradox_, which was used to show "
"that early versions of set theory were inconsistent. In these set theories, "
"a set can be defined by a property. For example, one might have the set of "
"all red things, the set of all fruit, the set of all natural numbers, or "
"even the set of all sets. Given a set, one can ask whether a given element "
"is contained in it. For instance, a bluebird is not contained in the set of "
"all red things, but the set of all red things is contained in the set of all"
" sets. Indeed, the set of all sets even contains itself."
msgstr ""
"吉拉德悖论是这一形式化论证的名称。它与更著名的罗素悖论相关，后者被用来证明集合论的早期版本是不一致的。在这些集合论中，集合可以通过属性来定义。例如，我们可以有所有红色事物的集合、所有水果的集合、所有自然数的集合，甚至所有集合的集合。给定一个集合，我们可以询问给定的元素是否包含在其中。例如，一只蓝鸟不包含在所有红色事物的集合中，但所有红色事物的集合包含在所有集合的集合中。事实上，所有集合的集合甚至包含它自己。"

#: src/functor-applicative-monad/universes.md:28
#, fuzzy
msgid ""
"What about the set of all sets that do not contain themselves? It contains "
"the set of all red things, as the set of all red things is not itself red. "
"It does not contain the set of all sets, because the set of all sets "
"contains itself. But does it contain itself? If it does contain itself, then"
" it cannot contain itself. But if it does not, then it must."
msgstr ""
"那么所有不包含自己的集合的集合呢？它包含所有红色事物的集合，因为所有红色事物的集合本身不是红色的。它不包含所有集合的集合，因为所有集合的集合包含它自己。但它是否包含它自己？如果它包含它自己，那么它不能包含它自己。但如果它不包含它自己，那么它必须包含它自己。"

#: src/functor-applicative-monad/universes.md:35
#, fuzzy
msgid ""
"This is a contradiction, which demonstrates that something was wrong with "
"the initial assumptions. In particular, allowing sets to be constructed by "
"providing an arbitrary property is too powerful. Later versions of set "
"theory restrict the formation of sets to remove the paradox."
msgstr "这是一个矛盾，表明最初的假设出了问题。特别是，允许通过提供任意属性来构造集合过于强大。集合论的后续版本限制了集合的形成以消除这个悖论。"

#: src/functor-applicative-monad/universes.md:39
#, fuzzy
msgid ""
"A related paradox can be constructed in versions of dependent type theory "
"that assign the type `Type` to `Type`. To ensure that Lean has consistent "
"logical foundations and can be used as a tool for mathematics, `Type` needs "
"to have some other type. This type is called `Type 1`:"
msgstr ""
"在将类型 `Type` 赋值给 `Type` 的依值类型论版本中，可以构造一个相关的悖论。为了确保 Lean "
"具有自洽的逻辑基础，并且可以用作数学工具，`Type` 需要具有其他类型。此类型称为 `Type 1`："

#: src/functor-applicative-monad/universes.md:48
#, fuzzy
msgid ""
"Similarly, `Type 1` is a `Type 2`, `Type 2` is a `Type 3`, `Type 3` is a "
"`Type 4`, and so forth."
msgstr "类似地，`Type 1` 是 `Type 2`，`Type 2` 是 `Type 3`，`Type 3` 是 `Type 4`，依此类推。"

#: src/functor-applicative-monad/universes.md:52
#, fuzzy
msgid ""
"Function types occupy the smallest universe that can contain both the "
"argument type and the return type. This means that `Nat → Nat` is a `Type`, "
"`Type → Type` is a `Type 1`, and `Type 1 → Type 2` is a `Type 3`."
msgstr ""
"函数类型占据了最小的类型域，它可以同时包含参数类型和返回类型。这意味着 `Nat → Nat` 是 `Type`，`Type → Type` 是 "
"`Type 1`，`Type 1 → Type 2` 是 `Type 3`。"

#: src/functor-applicative-monad/universes.md:55
#, fuzzy
msgid ""
"There is one exception to this rule. If the return type of a function is a "
"`Prop`, then the whole function type is in `Prop`, even if the argument is "
"in a larger universe such as `Type` or even `Type 1`. In particular, this "
"means that predicates over values that have ordinary types are in `Prop`. "
"For example, the type `(n : Nat) → n = n + 0` represents a function from a "
"`Nat` to evidence that it is equal to itself plus zero. Even though `Nat` is"
" in `Type`, this function type is in `Prop` due to this rule. Similarly, "
"even though `Type` is in `Type 1`, the function type `Type → 2 + 2 = 4` is "
"still in `Prop`."
msgstr ""
"对于此规则有一个例外。如果函数的返回类型是 `Prop`，那么整个函数类型就在 `Prop` 中，即使参数在更大的类型域中，例如 `Type` 甚至 "
"`Type 1`。具体来说，这意味着对具有普通类型的值的谓词在 `Prop` 中。例如，类型 `(n : Nat) → n = n + 0` 表示从 "
"`Nat` 到证明它等于自身加零的证据的函数。即使 `Nat` 在 `Type` 中，此函数类型也由于此规则而在 `Prop` 中。类似地，即使 "
"`Type` 在 `Type 1` 中，函数类型 `Type → 2 + 2 = 4` 仍然在 `Prop` 中。"

#: src/functor-applicative-monad/universes.md:62
#, fuzzy
msgid "User Defined Types"
msgstr "用户定义类型"

#: src/functor-applicative-monad/universes.md:64
#, fuzzy
msgid ""
"Structures and inductive datatypes can be declared to inhabit particular "
"universes. Lean then checks whether each datatype avoids paradoxes by being "
"in a universe that's large enough to prevent it from containing its own "
"type. For instance, in the following declaration, `MyList` is declared to "
"reside in `Type`, and so is its type argument `α`:"
msgstr ""
"可以声明结构体和归纳数据类型来占据特定的类型域。然后，Lean "
"会检查每个数据类型是否通过位于足够大的类型域中来避免悖论，以防止它包含自己的类型。例如，在以下声明中，`MyList` 被声明为驻留在 `Type` "
"中，其类型参数 `α` 也是如此："

#: src/functor-applicative-monad/universes.md:72
#, fuzzy
msgid ""
"`MyList` itself is a `Type → Type`. This means that it cannot be used to "
"contain actual types, because then its argument would be `Type`, which is a "
"`Type 1`:"
msgstr ""
"`MyList` 本身是 `Type → Type`。这意味着它不能用于包含实际类型，因为那时它的参数将是 `Type`，而 `Type` 是 "
"`Type 1`："

#: src/functor-applicative-monad/universes.md:89
#, fuzzy
msgid ""
"Updating `MyList` so that its argument is a `Type 1` results in a definition"
" rejected by Lean:"
msgstr "更新 `MyList` 以使其参数为 `Type 1` 会导致 Lean 拒绝的定义："

#: src/functor-applicative-monad/universes.md:103
#, fuzzy
msgid ""
"This error occurs because the argument to `cons` with type `α` is from a "
"larger universe than `MyList`. Placing `MyList` itself in `Type 1` solves "
"this issue, but at the cost of `MyList` now being itself inconvenient to use"
" in contexts that expect a `Type`."
msgstr ""
"此错误发生的原因是 `cons` 的参数类型 `α` 大于 `MyList` 的类型域。将 `MyList` 本身放在 `Type 1` "
"中可以解决此问题，但代价是 `MyList` 本身在需要 `Type` 的上下文中使用时会不方便。"

#: src/functor-applicative-monad/universes.md:106
#, fuzzy
msgid ""
"The specific rules that govern whether a datatype is allowed are somewhat "
"complicated. Generally speaking, it's easiest to start with the datatype in "
"the same universe as the largest of its arguments. Then, if Lean rejects the"
" definition, increase its level by one, which will usually go through."
msgstr ""
"控制数据类型是否允许的具体规则有些复杂。一般来说，最简单的方法是从数据类型与其最大参数相同的类型域开始。然后，如果 Lean "
"拒绝定义，则将其级别增加一，这通常会通过。"

#: src/functor-applicative-monad/universes.md:110
#, fuzzy
msgid "Universe Polymorphism"
msgstr "类型域多态"

#: src/functor-applicative-monad/universes.md:112
#, fuzzy
msgid ""
"Defining a datatype in a specific universe can lead to code duplication. "
"Placing `MyList` in `Type → Type` means that it can't be used for an actual "
"list of types. Placing it in `Type 1 → Type 1` means that it can't be used "
"for a list of lists of types. Rather than copy-pasting the datatype to "
"create versions in `Type`, `Type 1`, `Type 2`, and so on, a feature called "
"_universe polymorphism_ can be used to write a single definition that can be"
" instantiated in any of these universes."
msgstr ""
"在特定类型域中定义数据类型会导致代码重复。将 `MyList` 放在 `Type → Type` 中意味着它不能用于实际的类型列表。将其放在 `Type"
" 1 → Type 1` 中意味着它不能用于类型列表的列表。与其复制粘贴数据类型以创建 `Type`、`Type 1`、`Type 2` "
"等版本，不如使用称为 _类型域多态_ 的特性来编写一个可以在任何这些类型域中实例化的单个定义。"

#: src/functor-applicative-monad/universes.md:117
#, fuzzy
msgid ""
"Ordinary polymorphic types use variables to stand for types in a definition."
" This allows Lean to fill in the variables differently, which enables these "
"definitions to be used with a variety of types. Similarly, universe "
"polymorphism allows variables to stand for universes in a definition, "
"enabling Lean to fill them in differently so that they can be used with a "
"variety of universes. Just as type arguments are conventionally named with "
"Greek letters, universe arguments are conventionally named `u`, `v`, and "
"`w`."
msgstr ""
"普通的多态类型使用变量来表示定义中的类型。这允许 Lean "
"以不同的方式填充变量，从而使这些定义可以与各种类型一起使用。类似地，类型域多态允许变量表示定义中的类型域，从而使 Lean "
"可以以不同的方式填充它们，以便它们可以与各种类型域一起使用。就像类型参数通常用希腊字母命名一样，类型域参数通常用 `u`、`v` 和 `w` 命名。"

#: src/functor-applicative-monad/universes.md:122
#, fuzzy
msgid ""
"This definition of `MyList` doesn't specify a particular universe level, but"
" instead uses a variable `u` to stand for any level. If the resulting "
"datatype is used with `Type`, then `u` is `0`, and if it's used with `Type "
"3`, then `u` is `3`:"
msgstr ""
"此 `MyList` 定义未指定特定宇宙级别，而是使用变量 `u` 表示任意级别。如果结果数据类型与 `Type` 一起使用，则 `u` 为 "
"`0`，如果与 `Type 3` 一起使用，则 `u` 为 `3`："

#: src/functor-applicative-monad/universes.md:130
#, fuzzy
msgid ""
"With this definition, the same definition of `MyList` can be used to contain"
" both actual natural numbers and the natural number type itself:"
msgstr "有了此定义，相同的 `MyList` 定义可用于同时包含实际自然数和自然数类型本身："

#: src/functor-applicative-monad/universes.md:138
#, fuzzy
msgid "It can even contain itself:"
msgstr "它甚至可以包含自身："

#: src/functor-applicative-monad/universes.md:144
#, fuzzy
msgid ""
"It would seem that this would make it possible to write a logical paradox. "
"After all, the whole point of the universe system is to rule out self-"
"referential types. Behind the scenes, however, each occurrence of `MyList` "
"is provided with a universe level argument. In essence, the universe-"
"polymorphic definition of `MyList` created a _copy_ of the datatype at each "
"level, and the level argument selects which copy is to be used. These level "
"arguments are written with a dot and curly braces, so `MyList.{0} : Type → "
"Type`, `MyList.{1} : Type 1 → Type 1`, and `MyList.{2} : Type 2 → Type 2`."
msgstr ""
"这似乎可以写出逻辑悖论。毕竟，宇宙系统的主要目的是排除自引用类型。然而，在幕后，每次出现 `MyList` "
"都会提供一个宇宙级别参数。本质上，`MyList` 的宇宙多态定义在每个级别创建了数据类型的 "
"_副本_，而级别参数选择要使用的副本。这些级别参数用点和大括号编写，因此 `MyList.{0} : Type → Type`、`MyList.{1} "
": Type 1 → Type 1` 和 `MyList.{2} : Type 2 → Type 2`。"

#: src/functor-applicative-monad/universes.md:150
#, fuzzy
msgid "Writing the levels explicitly, the prior example becomes:"
msgstr "明确编写级别后，前面的示例变为："

#: src/functor-applicative-monad/universes.md:162
#, fuzzy
msgid ""
"When a universe-polymorphic definition takes multiple types as arguments, "
"it's a good idea to give each argument its own level variable for maximum "
"flexibility. For example, a version of `Sum` with a single level argument "
"can be written as follows:"
msgstr ""
"当宇宙多态定义将多个类型作为参数时，最好为每个参数提供自己的级别变量以实现最大的灵活性。例如，可以将具有单个级别参数的 `Sum` 版本写为："

#: src/functor-applicative-monad/universes.md:169
#, fuzzy
msgid "This definition can be used at multiple levels:"
msgstr "此定义可在多个级别使用："

#: src/functor-applicative-monad/universes.md:170
msgid ""
"```lean\n"
"def stringOrNat : Sum String Nat := .inl \"hello\"\n"
"\n"
"def typeOrType : Sum Type Type := .inr Nat\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:175
#, fuzzy
msgid "However, it requires that both arguments be in the same universe:"
msgstr "但是，它要求两个参数都在同一宇宙中："

#: src/functor-applicative-monad/universes.md:190
#, fuzzy
msgid ""
"This datatype can be made more flexible by using different variables for the"
" two type arguments' universe levels, and then declaring that the resulting "
"datatype is in the largest of the two:"
msgstr "可以通过对两个类型参数的宇宙级别使用不同的变量，然后声明结果数据类型位于两者中较大的一个中，来使此数据类型更灵活："

#: src/functor-applicative-monad/universes.md:196
#, fuzzy
msgid "This allows `Sum` to be used with arguments from different universes:"
msgstr "`Sum` 可用于不同宇宙中的参数："

#: src/functor-applicative-monad/universes.md:201
#, fuzzy
msgid ""
"In positions where Lean expects a universe level, any of the following are "
"allowed:"
msgstr "在 Lean 期望宇宙级别的位置，允许以下任何内容："

#: src/functor-applicative-monad/universes.md:202
#, fuzzy
msgid "A concrete level, like `0` or `1`"
msgstr "具体级别，如 `0` 或 `1`"

#: src/functor-applicative-monad/universes.md:203
#, fuzzy
msgid "A variable that stands for a level, such as `u` or `v`"
msgstr "表示级别的变量，如 `u` 或 `v`"

#: src/functor-applicative-monad/universes.md:204
#, fuzzy
msgid "The maximum of two levels, written as `max` applied to the levels"
msgstr "两个级别的最大值，写为应用于级别的 `max`"

#: src/functor-applicative-monad/universes.md:205
#, fuzzy
msgid "A level increase, written with `+ 1`"
msgstr "级别增加，用 `+ 1` 编写"

#: src/functor-applicative-monad/universes.md:207
#, fuzzy
msgid "Writing Universe-Polymorphic Definitions"
msgstr "编写宇宙多态定义"

#: src/functor-applicative-monad/universes.md:209
#, fuzzy
msgid ""
"Until now, every datatype defined in this book has been in `Type`, the "
"smallest universe of data. When presenting polymorphic datatypes from the "
"Lean standard library, such as `List` and `Sum`, this book created non-"
"universe-polymorphic versions of them. The real versions use universe "
"polymorphism to enable code re-use between type-level and non-type-level "
"programs."
msgstr ""
"到目前为止，本书中定义的每个数据类型都在 `Type` 中，这是最小的数据宇宙。在从 Lean 标准库中展示多态数据类型（如 `List` 和 "
"`Sum`）时，本书创建了它们的非宇宙多态版本。真实版本使用宇宙多态性，以便在类型级别和非类型级别程序之间重新使用代码。"

#: src/functor-applicative-monad/universes.md:213
#, fuzzy
msgid ""
"There are a few general guidelines to follow when writing universe-"
"polymorphic types. First off, independent type arguments should have "
"different universe variables, which enables the polymorphic definition to be"
" used with a wider variety of arguments, increasing the potential for code "
"reuse. Secondly, the whole type is itself typically either in the maximum of"
" all the universe variables, or one greater than this maximum. Try the "
"smaller of the two first. Finally, it's a good idea to put the new type in "
"as small of a universe as possible, which allows it to be used more flexibly"
" in other contexts. Non-polymorphic types, such as `Nat` and `String`, can "
"be placed directly in `Type 0`."
msgstr ""
"编写宇宙多态类型时，有一些通用的准则需要遵循。首先，独立类型参数应该有不同的宇宙变量，这使得多态定义可以与更广泛的参数一起使用，从而增加了代码重用的可能性。其次，整个类型本身通常要么是所有宇宙变量的最大值，要么比这个最大值大"
" 1。先尝试较小的一个。最后，最好将新类型放在尽可能小的宇宙中，这样可以在其他上下文中更灵活地使用它。非多态类型（如 `Nat` 和 "
"`String`）可以直接放在 `Type 0` 中。"

#: src/functor-applicative-monad/universes.md:220
#, fuzzy
msgid "`Prop` and Polymorphism"
msgstr "`Prop` 和多态性"

#: src/functor-applicative-monad/universes.md:222
#, fuzzy
msgid ""
"Just as `Type`, `Type 1`, and so on describe types that classify programs "
"and data, `Prop` classifies logical propositions. A type in `Prop` describes"
" what counts as convincing evidence for the truth of a statement. "
"Propositions are like ordinary types in many ways: they can be declared "
"inductively, they can have constructors, and functions can take propositions"
" as arguments. However, unlike datatypes, it typically doesn't matter "
"_which_ evidence is provided for the truth of a statement, only _that_ "
"evidence is provided. On the other hand, it is very important that a program"
" not only return a `Nat`, but that it's the _correct_ `Nat`."
msgstr ""
"就像 `Type`、`Type 1` 等描述对程序和数据进行分类的类型一样，`Prop` 对逻辑命题进行分类。`Prop` "
"中的类型描述了什么算作对某个陈述的真实性的令人信服的证据。命题在很多方面都像普通类型：它们可以被归纳声明，它们可以有构造子，函数可以将命题作为参数。然而，与数据类型不同，通常并不重要为陈述的真实性提供了"
" _哪_ 个证据，只提供了 _那个_ 证据。另一方面，非常重要的是，程序不仅要返回一个 `Nat`，而且它是 _正确的_ `Nat`。"

#: src/functor-applicative-monad/universes.md:228
#, fuzzy
msgid ""
"`Prop` is at the bottom of the universe hierarchy, and the type of `Prop` is"
" `Type`. This means that `Prop` is a suitable argument to provide to `List`,"
" for the same reason that `Nat` is. Lists of propositions have type `List "
"Prop`:"
msgstr ""
"`Prop` 位于类型等级的底部，而 `Prop` 的类型是 `Type`。这意味着 `Prop` 是一个合适的参数来提供给 `List`，原因与 "
"`Nat` 相同。命题列表的类型为 `List Prop`："

#: src/functor-applicative-monad/universes.md:231
msgid ""
"```lean\n"
"def someTruePropositions : List Prop := [\n"
"  1 + 1 = 2,\n"
"  \"Hello, \" ++ \"world!\" = \"Hello, world!\"\n"
"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:237
#, fuzzy
msgid ""
"Filling out the universe argument explicitly demonstrates that `Prop` is a "
"`Type`:"
msgstr "显式填写类型等级参数表明 `Prop` 是一个 `Type`："

#: src/functor-applicative-monad/universes.md:238
msgid ""
"```lean\n"
"def someTruePropositions : List.{0} Prop := [\n"
"  1 + 1 = 2,\n"
"  \"Hello, \" ++ \"world!\" = \"Hello, world!\"\n"
"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/universes.md:245
#, fuzzy
msgid ""
"Behind the scenes, `Prop` and `Type` are united into a single hierarchy "
"called `Sort`. `Prop` is the same as `Sort 0`, `Type 0` is `Sort 1`, `Type "
"1` is `Sort 2`, and so forth. In fact, `Type u` is the same as `Sort (u+1)`."
" When writing programs with Lean, this is typically not relevant, but it may"
" occur in error messages from time to time, and it explains the name of the "
"`CoeSort` class. Additionally, having `Prop` as `Sort 0` allows one more "
"universe operator to become useful. The universe level `imax u v` is `0` "
"when `v` is `0`, or the larger of `u` or `v` otherwise. Together with "
"`Sort`, this allows the special rule for functions that return `Prop`s to be"
" used when writing code that should be as portable as possible between "
"`Prop` and `Type` universes."
msgstr ""
"在幕后，`Prop` 和 `Type` 被统一到一个称为 `Sort` 的单一等级中。`Prop` 等同于 `Sort 0`，`Type 0` 是 "
"`Sort 1`，`Type 1` 是 `Sort 2`，以此类推。事实上，`Type u` 等同于 `Sort (u+1)`。在使用 Lean "
"编写程序时，这通常无关紧要，但它可能会偶尔出现在错误消息中，并且它解释了 `CoeSort` 类的名称。此外，将 `Prop` 作为 `Sort 0` "
"允许另一个类型等级运算符变得有用。当 `v` 为 `0` 时，类型等级 `imax u v` 为 `0`，否则为 `u` 或 `v` 中较大的那个。结合"
" `Sort`，这允许在编写尽可能在 `Prop` 和 `Type` 类型等级之间移植的代码时使用返回 `Prop` 的函数的特殊规则。"

#: src/functor-applicative-monad/universes.md:253
#, fuzzy
msgid "Polymorphism in Practice"
msgstr "实践中的多态性"

#: src/functor-applicative-monad/universes.md:255
#, fuzzy
msgid ""
"In the remainder of the book, definitions of polymorphic datatypes, "
"structures, and classes will use universe polymorphism in order to be "
"consistent with the Lean standard library. This will enable the complete "
"presentation of the `Functor`, `Applicative`, and `Monad` classes to be "
"completely consistent with their actual definitions."
msgstr ""
"在本书的其余部分中，多态数据类型、结构体和类的定义将使用类型等级多态性，以便与 Lean 标准库保持一致。这将使 "
"`Functor`、`Applicative` 和 `Monad` 类的完整表示与它们的实际定义完全一致。"

#: src/functor-applicative-monad/complete.md:3
#, fuzzy
msgid ""
"Now that all the relevant language features have been presented, this "
"section describes the complete, honest definitions of `Functor`, "
"`Applicative`, and `Monad` as they occur in the Lean standard library. For "
"the sake of understanding, no details are omitted."
msgstr ""
"现在已经介绍了所有相关的语言特性，本节描述了 `Functor`、`Applicative` 和 `Monad` 在 Lean "
"标准库中出现的完整、真实的定义。为了理解，没有省略任何细节。"

#: src/functor-applicative-monad/complete.md:6
#, fuzzy
msgid "Functor"
msgstr "函子"

#: src/functor-applicative-monad/complete.md:8
#, fuzzy
msgid ""
"The complete definition of the `Functor` class makes use of universe "
"polymorphism and a default method implementation:"
msgstr "`Functor` 类的完整定义使用了宇宙多态和默认方法实现："

#: src/functor-applicative-monad/complete.md:15
#, fuzzy
msgid ""
"In this definition, `Function.comp` is function composition, which is "
"typically written with the `∘` operator. `Function.const` is the _constant "
"function_, which is a two-argument function that ignores its second "
"argument. Applying this function to only one argument produces a function "
"that always returns the same value, which is useful when an API demands a "
"function but a program doesn't need to compute different results for "
"different arguments. A simple version of `Function.const` can be written as "
"follows:"
msgstr ""
"在这个定义中，`Function.comp` 是函数组合，通常用 `∘` 运算符表示。`Function.const` 是 "
"_常量函数_，这是一个双参数函数，它忽略其第二个参数。仅对一个参数应用此函数会生成一个始终返回相同值的函数，当 API "
"要求一个函数但程序不需要为不同的参数计算不同的结果时，这很有用。`Function.const` 的一个简单版本可以写成如下："

#: src/functor-applicative-monad/complete.md:22
#, fuzzy
msgid ""
"Using it with one argument as the function argument to `List.map` "
"demonstrates its utility:"
msgstr "将其与一个参数一起用作 `List.map` 的函数参数，演示了它的效用："

#: src/functor-applicative-monad/complete.md:23
msgid ""
"```lean\n"
"#eval [1, 2, 3].map (simpleConst \"same\")\n"
"```"
msgstr ""

#: src/functor-applicative-monad/complete.md:26
msgid ""
"```output info\n"
"[\"same\", \"same\", \"same\"]\n"
"```"
msgstr ""

#: src/functor-applicative-monad/complete.md:29
#, fuzzy
msgid "The actual function has the following signature:"
msgstr "实际函数具有以下签名："

#: src/functor-applicative-monad/complete.md:33
#, fuzzy
msgid ""
"Here, the type argument `β` is an explicit argument, so the default "
"definition of `Functor.mapConst` provides an `_` argument that instructs "
"Lean to find a unique type to pass to `Function.const` that would cause the "
"program to type check. `(Function.comp map (Function.const _) : α → f β → f "
"α)` is equivalent to `fun (x : α) (y : f β) => map (fun _ => x) y`."
msgstr ""
"这里，类型参数 `β` 是一个显式参数，因此 `Functor.mapConst` 的默认定义提供了一个 `_` 参数，指示 Lean "
"找到一个唯一的类型传递给 `Function.const`，这将导致程序类型检查。`(Function.comp map (Function.const"
" _) : α → f β → f α)` 等价于 `fun (x : α) (y : f β) => map (fun _ => x) y`。"

#: src/functor-applicative-monad/complete.md:36
#, fuzzy
msgid ""
"The `Functor` type class inhabits a universe that is the greater of `u+1` "
"and `v`. Here, `u` is the level of universes accepted as arguments to `f`, "
"while `v` is the universe returned by `f`. To see why the structure that "
"implements the `Functor` type class must be in a universe that's larger than"
" `u`, begin with a simplified definition of the class:"
msgstr ""
"`Functor` 类型类存在于大于 `u+1` 和 `v` 的宇宙中。这里，`u` 是作为 `f` 参数接受的宇宙级别，而 `v` 是 `f` "
"返回的宇宙。要了解为什么实现 `Functor` 类型类的结构体必须位于大于 `u` 的宇宙中，请从类的简化定义开始："

#: src/functor-applicative-monad/complete.md:43
#, fuzzy
msgid ""
"This type class's structure type is equivalent to the following inductive "
"type:"
msgstr "此类型类的结构体类型等效于以下归纳类型："

#: src/functor-applicative-monad/complete.md:48
#, fuzzy
msgid ""
"The implementation of the `map` method that is passed as an argument to "
"`Functor.mk` contains a function that takes two types in `Type u` as "
"arguments. This means that the type of the function itself is in `Type "
"(u+1)`, so `Functor` must also be at a level that is at least `u+1`. "
"Similarly, other arguments to the function have a type built by applying "
"`f`, so it must also have a level that is at least `v`. All the type classes"
" in this section share this property."
msgstr ""
"`map` 方法的实现作为参数传递给 `Functor.mk`，其中包含一个将 `Type u` 中的两个类型作为参数的函数。这意味着函数本身的类型在 "
"`Type (u+1)` 中，因此 `Functor` 也必须处于至少 `u+1` 的级别。类似地，函数的其他参数具有通过应用 `f` "
"构建的类型，因此它也必须具有至少 `v` 的级别。本节中的所有类型类都共享此属性。"

#: src/functor-applicative-monad/complete.md:53
#, fuzzy
msgid "Applicative"
msgstr "应用"

#: src/functor-applicative-monad/complete.md:55
#, fuzzy
msgid ""
"The `Applicative` type class is actually built from a number of smaller "
"classes that each contain some of the relevant methods. The first are `Pure`"
" and `Seq`, which contain `pure` and `seq` respectively:"
msgstr ""
"`Applicative` 类型类实际上是由许多较小的类构建的，每个类都包含一些相关方法。第一个是 `Pure` 和 `Seq`，它们分别包含 "
"`pure` 和 `seq`："

#: src/functor-applicative-monad/complete.md:65
#, fuzzy
msgid ""
"In addition to these, `Applicative` also depends on `SeqRight` and an "
"analogous `SeqLeft` class:"
msgstr "除了这些之外，`Applicative` 还依赖于 `SeqRight` 和类似的 `SeqLeft` 类："

#: src/functor-applicative-monad/complete.md:74
#, fuzzy
msgid ""
"The `seqRight` function, which was introduced in the [section about "
"alternatives and validation](alternative.md), is easiest to understand from "
"the perspective of effects. `E1 *> E2`, which desugars to `SeqRight.seqRight"
" E1 (fun () => E2)`, can be understood as first executing `E1`, and then "
"`E2`, resulting only in `E2`'s result. Effects from `E1` may result in `E2` "
"not being run, or being run multiple times. Indeed, if `f` has a `Monad` "
"instance, then `E1 *> E2` is equivalent to `do let _ ← E1; E2`, but "
"`seqRight` can be used with types like `Validate` that are not monads."
msgstr ""
"`seqRight` 函数在 [关于备选和验证](alternative.md) 的部分中介绍，从效果的角度最容易理解。`E1 *> E2`，它简化为 "
"`SeqRight.seqRight E1 (fun () => E2)`，可以理解为先执行 `E1`，然后执行 `E2`，仅产生 `E2` "
"的结果。`E1` 的效果可能导致 `E2` 不运行或运行多次。事实上，如果 `f` 有一个 `Monad` 实例，那么 `E1 *> E2` 等价于 "
"`do let _ ← E1; E2`，但是 `seqRight` 可以与不是单子的类型（如 `Validate`）一起使用。"

#: src/functor-applicative-monad/complete.md:79
#, fuzzy
msgid ""
"Its cousin `seqLeft` is very similar, except the leftmost expression's value"
" is returned. `E1 <* E2` desugars to `SeqLeft.seqLeft E1 (fun () => E2)`. "
"`SeqLeft.seqLeft` has type `f α → (Unit → f β) → f α`, which is identical to"
" that of `seqRight` except for the fact that it returns `f α`. `E1 <* E2` "
"can be understood as a program that first executes `E1`, and then `E2`, "
"returning the original result for `E1`. If `f` has a `Monad` instance, then "
"`E1 <* E2` is equivalent to `do let x ← E1; _ ← E2; pure x`. Generally "
"speaking, `seqLeft` is useful for specifying extra conditions on a value in "
"a validation or parser-like workflow without changing the value itself."
msgstr ""
"它的表亲 `seqLeft` 非常相似，除了返回最左边的表达式的值。`E1 <* E2` 简化为 `SeqLeft.seqLeft E1 (fun ()"
" => E2)`。`SeqLeft.seqLeft` 的类型为 `f α → (Unit → f β) → f α`，它与 `seqRight` "
"的类型相同，除了它返回 `f α`。`E1 <* E2` 可以理解为一个程序，它首先执行 `E1`，然后执行 `E2`，返回 `E1` 的原始结果。如果"
" `f` 有一个 `Monad` 实例，那么 `E1 <* E2` 等价于 `do let x ← E1; _ ← E2; pure "
"x`。一般来说，`seqLeft` 对于在验证或类似解析器的流程中指定值的额外条件很有用，而无需更改值本身。"

#: src/functor-applicative-monad/complete.md:86
#, fuzzy
msgid ""
"The definition of `Applicative` extends all these classes, along with "
"`Functor`:"
msgstr "`Applicative` 的定义扩展了所有这些类，以及 `Functor`："

#: src/functor-applicative-monad/complete.md:93
#, fuzzy
msgid ""
"A complete definition of `Applicative` requires only definitions for `pure` "
"and `seq`. This is because there are default definitions for all of the "
"methods from `Functor`, `SeqLeft`, and `SeqRight`. The `mapConst` method of "
"`Functor` has its own default implementation in terms of `Functor.map`. "
"These default implementations should only be overridden with new functions "
"that are behaviorally equivalent, but more efficient. The default "
"implementations should be seen as specifications for correctness as well as "
"automatically-created code."
msgstr ""
"`Applicative` 的完整定义只需要 `pure` 和 `seq` 的定义。这是因为 `Functor`、`SeqLeft` 和 "
"`SeqRight` 的所有方法都有默认定义。`Functor` 的 `mapConst` 方法有自己的默认实现，即 "
"`Functor.map`。这些默认实现只应被行为等效但效率更高的新函数覆盖。默认实现应被视为正确性的规范以及自动创建的代码。"

#: src/functor-applicative-monad/complete.md:99
#, fuzzy
msgid ""
"The default implementation for `seqLeft` is very compact. Replacing some of "
"the names with their syntactic sugar or their definitions can provide "
"another view on it, so:"
msgstr "`seqLeft` 的默认实现非常简洁。用它们的语法糖或定义替换一些名称可以提供另一种视图，因此："

#: src/functor-applicative-monad/complete.md:104
#, fuzzy
msgid "becomes"
msgstr "变为"

#: src/functor-applicative-monad/complete.md:108
#, fuzzy
msgid ""
"How should `(fun x _ => x) <$> a` be understood? Here, `a` has type `f α`, "
"and `f` is a functor. If `f` is `List`, then `(fun x _ => x) <$> [1, 2, 3]` "
"evaluates to `[fun _ => 1, fun _ => 2, fun _ => 3]`. If `f` is `Option`, "
"then `(fun x _ => x) <$> some \"hello\"` evaluates to `some (fun _ => "
"\"hello\")`. In each case, the values in the functor are replaced by "
"functions that return the original value, ignoring their argument. When "
"combined with `seq`, this function discards the values from `seq`'s second "
"argument."
msgstr ""
"如何理解 `(fun x _ => x) <$> a`？此处，`a` 的类型为 `f α`，而 `f` 是一个函子。如果 `f` 是 `List`，则 "
"`(fun x _ => x) <$> [1, 2, 3]` 的值为 `[fun _ => 1, fun _ => 2, fun _ => 3]`。如果"
" `f` 是 `Option`，则 `(fun x _ => x) <$> some \"hello\"` 的值为 `some (fun _ => "
"\"hello\")`。在每种情况下，函子中的值都会被返回原始值的函数替换，而忽略它们的实参。与 `seq` 结合使用时，此函数会丢弃 `seq` "
"第二个实参中的值。"

#: src/functor-applicative-monad/complete.md:115
#, fuzzy
msgid ""
"The default implementation for `seqRight` is very similar, except `const` "
"has an additional argument `id`. This definition can be understood "
"similarly, by first introducing some standard syntactic sugar and then "
"replacing some names with their definitions:"
msgstr ""
"`seqRight` 的默认实现非常相似，除了 `const` 有一个附加实参 "
"`id`。此定义可以类似地理解，首先引入一些标准语法糖，然后用它们的定义替换一些名称："

#: src/functor-applicative-monad/complete.md:126
#, fuzzy
msgid ""
"How should `(fun _ x => x) <$> a` be understood? Once again, examples are "
"useful. `(fun _ x => x) <$> [1, 2, 3]` is equivalent to `[fun x => x, fun x "
"=> x, fun x => x]`, and `(fun _ x => x) <$> some \"hello\"` is equivalent to"
" `some (fun x => x)`. In other words, `(fun _ x => x) <$> a` preserves the "
"overall shape of `a`, but each value is replaced by the identity function. "
"From the perspective of effects, the side effects of `a` occur, but the "
"values are thrown out when it is used with `seq`."
msgstr ""
"如何理解 `(fun _ x => x) <$> a`？同样，示例很有用。`(fun _ x => x) <$> [1, 2, 3]` 等价于 "
"`[fun x => x, fun x => x, fun x => x]`，而 `(fun _ x => x) <$> some \"hello\"`"
" 等价于 `some (fun x => x)`。换句话说，`(fun _ x => x) <$> a` 保留了 `a` "
"的整体形状，但每个值都被恒等函数替换。从效果的角度来看，`a` 的副作用会发生，但当它与 `seq` 一起使用时，这些值会被丢弃。"

#: src/functor-applicative-monad/complete.md:132
#, fuzzy
msgid "Monad"
msgstr "Monad"

#: src/functor-applicative-monad/complete.md:134
#, fuzzy
msgid ""
"Just as the constituent operations of `Applicative` are split into their own"
" type classes, `Bind` has its own class as well:"
msgstr "正如 `Applicative` 的组成操作被拆分为它们自己的类型类一样，`Bind` 也有自己的类："

#: src/functor-applicative-monad/complete.md:139
#, fuzzy
msgid "`Monad` extends `Applicative` with `Bind`:"
msgstr "`Monad` 用 `Bind` 扩展了 `Applicative`："

#: src/functor-applicative-monad/complete.md:147
#, fuzzy
msgid ""
"Tracing the collection of inherited methods and default methods from the "
"entire hierarchy shows that a `Monad` instance requires only implementations"
" of `bind` and `pure`. In other words, `Monad` instances automatically yield"
" implementations of `seq`, `seqLeft`, `seqRight`, `map`, and `mapConst`. "
"From the perspective of API boundaries, any type with a `Monad` instance "
"gets instances for `Bind`, `Pure`, `Seq`, `Functor`, `SeqLeft`, and "
"`SeqRight`."
msgstr ""
"从整个层次结构体中追踪继承的方法和默认方法的集合可以看出，`Monad` 实例只需要 `bind` 和 `pure` 的实现。换句话说，`Monad` "
"实例会自动生成 `seq`、`seqLeft`、`seqRight`、`map` 和 `mapConst` 的实现。从 API 边界的角度来看，任何具有"
" `Monad` 实例的类型都会获得 `Bind`、`Pure`、`Seq`、`Functor`、`SeqLeft` 和 `SeqRight` 的实例。"

#: src/functor-applicative-monad/complete.md:154
#, fuzzy
msgid ""
"Understand the default implementations of `map`, `seq`, `seqLeft`, and "
"`seqRight` in `Monad` by working through examples such as `Option` and "
"`Except`. In other words, substitute their definitions for `bind` and `pure`"
" into the default definitions, and simplify them to recover the versions "
"`map`, `seq`, `seqLeft`, and `seqRight` that would be written by hand."
msgstr ""
"通过处理诸如 `Option` 和 `Except` 的示例来理解 `Monad` 中 `map`、`seq`、`seqLeft` 和 "
"`seqRight` 的默认实现。换句话说，将它们的定义替换为 `bind` 和 `pure` 的默认定义，并对其进行简化以恢复手动编写的 "
"`map`、`seq`、`seqLeft` 和 `seqRight` 版本。"

#: src/functor-applicative-monad/complete.md:155
#, fuzzy
msgid ""
"On paper or in a text file, prove to yourself that the default "
"implementations of `map` and `seq` satisfy the contracts for `Functor` and "
"`Applicative`. In this argument, you're allowed to use the rules from the "
"`Monad` contract as well as ordinary expression evaluation."
msgstr ""
"在纸上或文本文件中，向自己证明 `map` 和 `seq` 的默认实现满足 `Functor` 和 `Applicative` "
"的契约。在此论证中，你可以使用 `Monad` 契约中的规则以及普通的表达式求值。"

#: src/functor-applicative-monad/summary.md:3
#, fuzzy
msgid "Type Classes and Structures"
msgstr "类型类和结构体"

#: src/functor-applicative-monad/summary.md:5
#, fuzzy
msgid ""
"Behind the scenes, type classes are represented by structures. Defining a "
"class defines a structure, and additionally creates an empty table of "
"instances. Defining an instance creates a value that either has the "
"structure as its type or is a function that can return the structure, and "
"additionally adds an entry to the table. Instance search consists of "
"constructing an instance by consulting the instance tables. Both structures "
"and classes may provide default values for fields (which are default "
"implementations of methods)."
msgstr ""
"在幕后，类型类由结构体表示。定义一个类定义了一个结构体，并另外创建一个空的实例表。定义一个实例会创建一个值，该值要么具有结构体作为其类型，要么是一个可以返回结构体的函数，并另外向表中添加一个条目。实例搜索包括通过查阅实例表来构造实例。结构体和类都可以为字段提供默认值（这是方法的默认实现）。"

#: src/functor-applicative-monad/summary.md:13
#, fuzzy
msgid ""
"Structures may inherit from other structures. Behind the scenes, a structure"
" that inherits from another structure contains an instance of the original "
"structure as a field. In other words, inheritance is implemented with "
"composition. When multiple inheritance is used, only the unique fields from "
"the additional parent structures are used to avoid a diamond problem, and "
"the functions that would normally extract the parent value are instead "
"organized to construct one. Record dot notation takes structure inheritance "
"into account."
msgstr ""
"结构体可以从其他结构体继承。在幕后，从另一个结构体继承的结构体包含一个原始结构体的实例作为字段。换句话说，继承是通过组合实现的。当使用多重继承时，仅使用来自附加父结构体的唯一字段来避免菱形问题，并且通常用于提取父值的功能被组织为构造一个功能。记录点表示法考虑了结构体继承。"

#: src/functor-applicative-monad/summary.md:19
#, fuzzy
msgid ""
"Because type classes are just structures with some additional automation "
"applied, all of these features are available in type classes. Together with "
"default methods, this can be used to create a fine-grained hierarchy of "
"interfaces that nonetheless does not impose a large burden on clients, "
"because the small classes that the large classes inherit from can be "
"automatically implemented."
msgstr ""
"因为类型类只是应用了一些额外自动化的结构体，所以所有这些特性在类型类中都是可用的。结合默认方法，这可用于创建粒度很细的接口层次结构体，但不会给客户端带来很大的负担，因为大类继承的小类可以自动实现。"

#: src/functor-applicative-monad/summary.md:24
#, fuzzy
msgid "An applicative functor is a functor with two additional operations:"
msgstr "应用函子是一个具有两个附加操作的函子："

#: src/functor-applicative-monad/summary.md:25
#, fuzzy
msgid "`pure`, which is the same operator as that for `Monad`"
msgstr "`pure`，与 `Monad` 中的同名运算符相同"

#: src/functor-applicative-monad/summary.md:26
#, fuzzy
msgid ""
"`seq`, which allows a function to be applied in the context of the functor."
msgstr "`seq`，允许在函子的上下文中应用函数。"

#: src/functor-applicative-monad/summary.md:28
#, fuzzy
msgid ""
"While monads can represent arbitrary programs with control flow, applicative"
" functors can only run function arguments from left to right. Because they "
"are less powerful, they provide less control to programs written against the"
" interface, while the implementor of the method has a greater degree of "
"freedom. Some useful types can implement `Applicative` but not `Monad`."
msgstr ""
"虽然单子可以表示具有控制流的任意程序，但应用函子只能从左到右运行函数参数。由于它们的功能较弱，因此对针对该接口编写的程序提供的控制较少，而方法的实现者拥有更大的自由度。一些有用的类型可以实现"
" `Applicative` 但不能实现 `Monad`。"

#: src/functor-applicative-monad/summary.md:32
#, fuzzy
msgid ""
"In fact, the type classes `Functor`, `Applicative`, and `Monad` form a "
"hierarchy of power. Moving up the hierarchy, from `Functor` towards `Monad`,"
" allows more powerful programs to be written, but fewer types implement the "
"more powerful classes. Polymorphic programs should be written to use as weak"
" of an abstraction as possible, while datatypes should be given instances "
"that are as powerful as possible. This maximizes code re-use. The more "
"powerful type classes extend the less powerful ones, which means that an "
"implementation of `Monad` provides implementations of `Functor` and "
"`Applicative` for free."
msgstr ""
"事实上，类型类 `Functor`、`Applicative` 和 `Monad` 构成了一个功能层次结构体。从 `Functor` 向 `Monad` "
"移动，允许编写更强大的程序，但实现更强大类的类型更少。多态程序应该编写为使用尽可能弱的抽象，而数据类型应该被赋予尽可能强大的实例。这最大限度地提高了代码的重用性。更强大的类型类扩展了功能较弱的类型类，这意味着"
" `Monad` 的实现免费提供了 `Functor` 和 `Applicative` 的实现。"

#: src/functor-applicative-monad/summary.md:38
#, fuzzy
msgid ""
"Each class has a set of methods to be implemented and a corresponding "
"contract that specifies additional rules for the methods. Programs that are "
"written against these interfaces expect that the additional rules are "
"followed, and may be buggy if they are not. The default implementations of "
"`Functor`'s methods in terms of `Applicative`'s, and of `Applicative`'s in "
"terms of `Monad`'s, will obey these rules."
msgstr ""
"每个类都有一组要实现的方法，以及一个对应的契约，该契约为这些方法指定了附加规则。针对这些接口编写的程序期望遵循这些附加规则，如果不遵循这些规则，则可能会出现错误。`Functor`"
" 的方法相对于 `Applicative` 的默认实现，以及 `Applicative` 相对于 `Monad` 的默认实现，将遵守这些规则。"

#: src/functor-applicative-monad/summary.md:44
#, fuzzy
msgid ""
"To allow Lean to be used as both a programming language and a theorem "
"prover, some restrictions on the language are necessary. This includes "
"restrictions on recursive functions that ensure that they all either "
"terminate or are marked as `partial` and written to return types that are "
"not uninhabited. Additionally, it must be impossible to represent certain "
"kinds of logical paradoxes as types."
msgstr ""
"为了让 Lean 既可以用作编程语言，又可以用作定理证明器，对该语言进行了一些限制。这包括对递归函数的限制，以确保它们要么终止，要么标记为 "
"`partial`，并写入返回类型，该类型不是空类型。此外，必须不可能将某些类型的逻辑悖论表示为类型。"

#: src/functor-applicative-monad/summary.md:48
#, fuzzy
msgid ""
"One of the restrictions that rules out certain paradoxes is that every type "
"is assigned to a _universe_. Universes are types such as `Prop`, `Type`, "
"`Type 1`, `Type 2`, and so forth. These types describe other types—just as "
"`0` and `17` are described by `Nat`, `Nat` is itself described by `Type`, "
"and `Type` is described by `Type 1`. The type of functions that take a type "
"as an argument must be a larger universe than the argument's universe."
msgstr ""
"排除某些悖论的限制之一是，每个类型都分配给一个 _universe_。Universe 是类型，例如 `Prop`、`Type`、`Type "
"1`、`Type 2` 等。这些类型描述其他类型——就像 `0` 和 `17` 由 `Nat` 描述一样，`Nat` 本身由 `Type` "
"描述，`Type` 由 `Type 1` 描述。将类型作为参数的函数的类型必须大于参数的 universe。"

#: src/functor-applicative-monad/summary.md:53
#, fuzzy
msgid ""
"Because each declared datatype has a universe, writing code that uses types "
"like data would quickly become annoying, requiring each polymorphic type to "
"be copy-pasted to take arguments from `Type 1`. A feature called _universe "
"polymorphism_ allows Lean programs and datatypes to take universe levels as "
"arguments, just as ordinary polymorphism allows programs to take types as "
"arguments. Generally speaking, Lean libraries should use universe "
"polymorphism when implementing libraries of polymorphic operations."
msgstr ""
"因为每个声明的数据类型都有一个 universe，所以编写使用数据类型类型的代码会很快变得很烦人，需要将每个多态类型复制粘贴到从 `Type 1` "
"获取参数。一个称为 _universe polymorphism_ 的特性允许 Lean 程序和数据类型将 universe "
"级别作为参数，就像普通多态性允许程序将类型作为参数一样。一般来说，在实现多态操作的库时，Lean 库应该使用 universe 多态性。"

#: src/monad-transformers.md:3
#, fuzzy
msgid ""
"A monad is a way to encode some collection of side effects in a pure "
"language. Different monads provide different effects, such as state and "
"error handling. Many monads even provide useful effects that aren't "
"available in most languages, such as nondeterministic searches, readers, and"
" even continuations."
msgstr ""
"Monad 是一种在纯语言中对一些副作用集合进行编码的方法。不同的 monad 提供不同的效果，例如状态和错误处理。许多 monad "
"甚至提供了大多数语言中没有的有用效果，例如非确定性搜索、读取器，甚至延续。"

#: src/monad-transformers.md:7
#, fuzzy
msgid ""
"A typical application has a core set of easily testable functions written "
"without monads paired with an outer wrapper that uses a monad to encode the "
"necessary application logic. These monads are constructed from well-known "
"components. For example:"
msgstr ""
"典型的应用程序有一组核心函数，这些函数易于测试，不使用单子编写，并配有一个外部包装器，该包装器使用单子对必要的应用程序逻辑进行编码。这些单子由众所周知的组件构建。例如："

#: src/monad-transformers.md:10
#, fuzzy
msgid ""
"Mutable state is encoded with a function parameter and a return value that "
"have the same type"
msgstr "可变状态使用具有相同类型的函数参数和返回值进行编码"

#: src/monad-transformers.md:11
#, fuzzy
msgid ""
"Error handling is encoded by having a return type that is similar to "
"`Except`, with constructors for success and failure"
msgstr "错误处理通过具有类似于 `Except` 的返回类型进行编码，其中包含成功和失败的构造子"

#: src/monad-transformers.md:12
#, fuzzy
msgid "Logging is encoded by pairing the return value with the log"
msgstr "日志记录通过将返回值与日志配对进行编码"

#: src/monad-transformers.md:14
#, fuzzy
msgid ""
"Writing each monad by hand is tedious, however, involving boilerplate "
"definitions of the various type classes. Each of these components can also "
"be extracted to a definition that modifies some other monad to add an "
"additional effect. Such a definition is called a _monad transformer_. A "
"concrete monad can be build from a collection of monad transformers, which "
"enables much more code re-use."
msgstr ""
"但是，手动编写每个单子很乏味，涉及各种类型类的样板定义。这些组件中的每一个也可以提取到一个修改其他单子以添加附加效果的定义中。这样的定义称为 "
"_单子转换器_。可以从单子转换器的集合中构建一个具体的单子，这使得代码可以更多地重复使用。"

#: src/monad-transformers/reader-io.md:3
#, fuzzy
msgid ""
"One case where a reader monad can be useful is when there is some notion of "
"the \"current configuration\" of the application that is passed through many"
" recursive calls. An example of such a program is `tree`, which recursively "
"prints the files in the current directory and its subdirectories, indicating"
" their tree structure using characters. The version of `tree` in this "
"chapter, called `doug` after the mighty Douglas Fir tree that adorns the "
"west coast of North America, provides the option of Unicode box-drawing "
"characters or their ASCII equivalents when indicating directory structure."
msgstr ""
"读者单子有用的一个案例是当应用程序的「当前配置」的概念在许多递归调用中传递时。这样的程序的一个示例是 "
"`tree`，它递归地打印当前目录及其子目录中的文件，使用字符指示它们的树结构体。本章中 `tree` 的版本称为 "
"`doug`，以装饰北美西海岸的巨型道格拉斯冷杉树命名，它提供了在指示目录结构体时使用 Unicode 框图字符或其 ASCII 等效项的选项。"

#: src/monad-transformers/reader-io.md:7
#, fuzzy
msgid ""
"For example, the following commands create a directory structure and some "
"empty files in a directory called `doug-demo`:"
msgstr "例如，以下命令在名为 `doug-demo` 的目录中创建目录结构体和一些空文件："

#: src/monad-transformers/reader-io.md:17
#, fuzzy
msgid "Running `doug` results in the following:"
msgstr "运行 `doug` 会产生以下结果："

#: src/monad-transformers/reader-io.md:32
#, fuzzy
msgid "Implementation"
msgstr "实现"

#: src/monad-transformers/reader-io.md:34
#, fuzzy
msgid ""
"Internally, `doug` passes a configuration value downwards as it recursively "
"traverses the directory structure. This configuration contains two fields: "
"`useASCII` determines whether to use Unicode box-drawing characters or ASCII"
" vertical line and dash characters to indicate structure, and "
"`currentPrefix` contains a string to prepend to each line of output. As the "
"current directory deepens, the prefix string accumulates indicators of being"
" in a directory. The configuration is a structure:"
msgstr ""
"在内部，`doug` 在递归遍历目录结构体时向下传递一个配置值。此配置包含两个字段：`useASCII` 确定是否使用 Unicode 框图字符或 "
"ASCII 竖线和破折号字符来指示结构体，而 `currentPrefix` "
"包含要添加到每行输出的字符串。随着当前目录的深入，前缀字符串会累积目录中的指示符。配置是一个结构体："

#: src/monad-transformers/reader-io.md:38
msgid ""
"```lean\n"
"structure Config where\n"
"  useASCII : Bool := false\n"
"  currentPrefix : String := \"\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:43
#, fuzzy
msgid ""
"This structure has default definitions for both fields. The default `Config`"
" uses Unicode display with no prefix."
msgstr "此结构体为这两个字段提供了默认定义。默认的 `Config` 使用 Unicode 显示，没有前缀。"

#: src/monad-transformers/reader-io.md:46
#, fuzzy
msgid ""
"Users who invoke `doug` will need to be able to provide command-line "
"arguments. The usage information is as follows:"
msgstr "调用 `doug` 的用户需要能够提供命令行参数。用法信息如下："

#: src/monad-transformers/reader-io.md:48
msgid ""
"```lean\n"
"def usage : String :=\n"
"  \"Usage: doug [--ascii]\n"
"Options:\n"
"\\t--ascii\\tUse ASCII characters to display the directory structure\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:54
#, fuzzy
msgid ""
"Accordingly, a configuration can be constructed by examining a list of "
"command-line arguments:"
msgstr "因此，可以通过检查命令行参数列表来构建配置："

#: src/monad-transformers/reader-io.md:55
msgid ""
"```lean\n"
"def configFromArgs : List String → Option Config\n"
"  | [] => some {} -- both fields default\n"
"  | [\"--ascii\"] => some {useASCII := true}\n"
"  | _ => none\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:62
#, fuzzy
msgid ""
"The `main` function is a wrapper around an inner worker, called `dirTree`, "
"that shows the contents of a directory using a configuration. Before calling"
" `dirTree`, `main` is responsible for processing command-line arguments. It "
"must also return the appropriate exit code to the operating system:"
msgstr ""
"`main` 函数是对内部工作器 `dirTree` 的包装，该工作器使用配置显示目录的内容。在调用 `dirTree` 之前，`main` "
"负责处理命令行参数。它还必须向操作系统返回适当的退出代码："

#: src/monad-transformers/reader-io.md:65
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"  match configFromArgs args with\n"
"  | some config =>\n"
"    dirTree config (← IO.currentDir)\n"
"    pure 0\n"
"  | none =>\n"
"    IO.eprintln s!\"Didn't understand argument(s) {\" \".separate args}\\n\"\n"
"    IO.eprintln usage\n"
"    pure 1\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:77
#, fuzzy
msgid ""
"Not all paths should be shown in the directory tree. In particular, files "
"named `.` or `..` should be skipped, as they are actually features used for "
"navigation rather than files _per se_. Of those files that should be shown, "
"there are two kinds: ordinary files and directories:"
msgstr ""
"并非所有路径都应显示在目录树中。特别是，应跳过名为 `.` 或 `..` "
"的文件，因为它们实际上是用于导航而不是文件本身的功能。在应该显示的文件中，有两种类型：普通文件和目录："

#: src/monad-transformers/reader-io.md:85
#, fuzzy
msgid ""
"To determine whether a file should be shown, along with which kind of entry "
"it is, `doug` uses `toEntry`:"
msgstr "`doug` 使用 `toEntry` 来确定是否显示文件以及显示哪种类型的条目："

#: src/monad-transformers/reader-io.md:86
msgid ""
"```lean\n"
"def toEntry (path : System.FilePath) : IO (Option Entry) := do\n"
"  match path.components.getLast? with\n"
"  | none => pure (some (.dir \"\"))\n"
"  | some \".\" | some \"..\" => pure none\n"
"  | some name =>\n"
"    pure (some (if (← path.isDir) then .dir name else .file name))\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:94
#, fuzzy
msgid ""
"`System.FilePath.components` converts a path into a list of path components,"
" splitting the name at directory separators. If there is no last component, "
"then the path is the root directory. If the last component is a special "
"navigation file (`.` or `..`), then the file should be excluded. Otherwise, "
"directories and files are wrapped in the corresponding constructors."
msgstr ""
"`System.FilePath.components` "
"将路径转换为路径组件列表，在目录分隔符处拆分名称。如果没有最后一个组件，则路径是根目录。如果最后一个组件是特殊导航文件（`.` 或 "
"`..`），则应排除该文件。否则，目录和文件将被包装在相应的构造子中。"

#: src/monad-transformers/reader-io.md:99
#, fuzzy
msgid ""
"Lean's logic has no way to know that directory trees are finite. Indeed, "
"some systems allow the construction of circular directory structures. Thus, "
"`dirTree` is declared `partial`:"
msgstr "Lean 的逻辑无法知道目录树是有限的。事实上，某些系统允许构建循环目录结构体。因此，`dirTree` 被声明为 `partial`："

#: src/monad-transformers/reader-io.md:114
#, fuzzy
msgid ""
"The call to `toEntry` is a [nested action](../hello-"
"world/conveniences.md#nested-actions)—the parentheses are optional in "
"positions where the arrow couldn't have any other meaning, such as `match`. "
"When the filename doesn't correspond to an entry in the tree (e.g. because "
"it is `..`), `dirTree` does nothing. When the filename points to an ordinary"
" file, `dirTree` calls a helper to show it with the current configuration. "
"When the filename points to a directory, it is shown with a helper, and then"
" its contents are recursively shown in a new configuration in which the "
"prefix has been extended to account for being in a new directory."
msgstr ""
"对 `toEntry` 的调用是一个 [嵌套操作](../hello-world/conveniences.md#nested-"
"actions)——在箭头不可能有任何其他含义的位置（例如 `match`）中，括号是可选的。当文件名与树中的条目不对应（例如，因为它是 "
"`..`）时，`dirTree` 不执行任何操作。当文件名指向普通文件时，`dirTree` "
"调用一个帮助器来使用当前配置显示它。当文件名指向目录时，它将使用帮助器显示，然后以递归方式在其内容中显示一个新的配置，其中前缀已扩展为考虑在新目录中。"

#: src/monad-transformers/reader-io.md:119
#, fuzzy
msgid ""
"Showing the names of files and directories is achieved with `showFileName` "
"and `showDirName`:"
msgstr "使用 `showFileName` 和 `showDirName` 显示文件和目录的名称："

#: src/monad-transformers/reader-io.md:127
#, fuzzy
msgid ""
"Both of these helpers delegate to functions on `Config` that take the ASCII "
"vs Unicode setting into account:"
msgstr "这两个帮助器都委托给 `Config` 上的函数，这些函数考虑了 ASCII 与 Unicode 设置："

#: src/monad-transformers/reader-io.md:128
msgid ""
"```lean\n"
"def Config.preFile (cfg : Config) :=\n"
"  if cfg.useASCII then \"|--\" else \"├──\"\n"
"\n"
"def Config.preDir (cfg : Config) :=\n"
"  if cfg.useASCII then \"|  \" else \"│  \"\n"
"\n"
"def Config.fileName (cfg : Config) (file : String) : String :=\n"
"  s!\"{cfg.currentPrefix}{cfg.preFile} {file}\"\n"
"\n"
"def Config.dirName (cfg : Config) (dir : String) : String :=\n"
"  s!\"{cfg.currentPrefix}{cfg.preFile} {dir}/\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:141
#, fuzzy
msgid ""
"Similarly, `Config.inDirectory` extends the prefix with a directory marker:"
msgstr "类似地，`Config.inDirectory` 使用目录标记扩展前缀："

#: src/monad-transformers/reader-io.md:142
msgid ""
"```lean\n"
"def Config.inDirectory (cfg : Config) : Config :=\n"
"  {cfg with currentPrefix := cfg.preDir ++ \" \" ++ cfg.currentPrefix}\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:147
#, fuzzy
msgid ""
"Iterating an IO action over a list of directory contents is achieved using "
"`doList`. Because `doList` carries out all the actions in a list and does "
"not base control-flow decisions on the values returned by any of the "
"actions, the full power of `Monad` is not necessary, and it will work for "
"any `Applicative`:"
msgstr ""
"使用 `doList` 可以对目录内容列表执行 IO 操作。由于 `doList` "
"执行列表中的所有操作，并且不会根据任何操作返回的值做出控制流决策，因此不需要 `Monad` 的全部功能，并且它适用于任何 `Applicative`："

#: src/monad-transformers/reader-io.md:158
#, fuzzy
msgid "Using a Custom Monad"
msgstr "使用自定义单子"

#: src/monad-transformers/reader-io.md:160
#, fuzzy
msgid ""
"While this implementation of `doug` works, manually passing the "
"configuration around is verbose and error-prone. The type system will not "
"catch it if the wrong configuration is passed downwards, for instance. A "
"reader effect ensures that the same configuration is passed to all recursive"
" calls, unless it is manually overridden, and it helps make the code less "
"verbose."
msgstr ""
"虽然此 `doug` "
"实现有效，但手动传递配置既冗长又容易出错。例如，如果错误的配置向下传递，类型系统将无法捕获它。读取器效果确保将相同的配置传递给所有递归调用，除非手动覆盖它，并且它有助于减少代码冗长。"

#: src/monad-transformers/reader-io.md:164
#, fuzzy
msgid ""
"To create a version of `IO` that is also a reader of `Config`, first define "
"the type and its `Monad` instance, following the recipe from [the evaluator "
"example](../monads/arithmetic.md#custom-environments):"
msgstr ""
"要创建同时也是 `Config` 读取器的 `IO` 版本，请首先定义类型及其 `Monad` 实例，按照 "
"[评估器示例](../monads/arithmetic.md#custom-environments) 中的配方进行操作："

#: src/monad-transformers/reader-io.md:175
#, fuzzy
msgid ""
"The difference between this `Monad` instance and the one for `Reader` is "
"that this one uses `do`\\-notation in the `IO` monad as the body of the "
"function that `bind` returns, rather than applying `next` directly to the "
"value returned from `result`. Any `IO` effects performed by `result` must "
"occur before `next` is invoked, which is ensured by the `IO` monad's `bind` "
"operator. `ConfigIO` is not universe polymorphic because the underlying `IO`"
" type is also not universe polymorphic."
msgstr ""
"此 `Monad` 实例与 `Reader` 实例之间的区别在于，此实例在 `bind` 返回的函数中使用 `do` 符号作为 `IO` "
"单子中的主体，而不是将 `next` 直接应用于 `result` 返回的值。`result` 执行的任何 `IO` 效果都必须在调用 `next` "
"之前发生，这由 `IO` 单子的 `bind` 运算符确保。`ConfigIO` 不是 universe 多态的，因为底层的 `IO` 类型也不是 "
"universe 多态的。"

#: src/monad-transformers/reader-io.md:179
#, fuzzy
msgid ""
"Running a `ConfigIO` action involves transforming it into an `IO` action by "
"providing it with a configuration:"
msgstr "运行 `ConfigIO` 操作涉及通过提供配置将其转换为 `IO` 操作："

#: src/monad-transformers/reader-io.md:184
#, fuzzy
msgid ""
"This function is not really necessary, as a caller could simply provide the "
"configuration directly. However, naming the operation can make it easier to "
"see which parts of the code are intended to run in which monad."
msgstr "此函数不是必需的，因为调用者可以简单地直接提供配置。但是，命名操作可以更容易地看出代码的哪些部分旨在在哪个单子中运行。"

#: src/monad-transformers/reader-io.md:187
#, fuzzy
msgid ""
"The next step is to define a means of accessing the current configuration as"
" part of `ConfigIO`:"
msgstr "下一步是定义一种访问当前配置的方法，作为 `ConfigIO` 的一部分："

#: src/monad-transformers/reader-io.md:192
#, fuzzy
msgid ""
"This is just like `read` from [the evaluator "
"example](../monads/arithmetic.md#custom-environments), except it uses `IO`'s"
" `pure` to return its value rather than doing so directly. Because entering "
"a directory modifies the current configuration for the scope of a recursive "
"call, it will be necessary to have a way to override a configuration:"
msgstr ""
"这就像 [求值器示例](../monads/arithmetic.md#custom-environments) 中的 `read`，除了它使用 "
"`IO` 的 `pure` 来返回其值，而不是直接返回。因为进入目录会修改当前配置以进行递归调用，所以需要一种覆盖配置的方法："

#: src/monad-transformers/reader-io.md:199
#, fuzzy
msgid ""
"Much of the code used in `doug` has no need for configurations, and `doug` "
"calls ordinary Lean `IO` actions from the standard library that certainly "
"don't need a `Config`. Ordinary `IO` actions can be run using `runIO`, which"
" ignores the configuration argument:"
msgstr ""
"`doug` 中使用的许多代码不需要配置，并且 `doug` 从标准库中调用普通的 Lean `IO` 操作，这些操作肯定不需要 "
"`Config`。可以使用 `runIO` 运行普通的 `IO` 操作，它会忽略配置参数："

#: src/monad-transformers/reader-io.md:206
#, fuzzy
msgid ""
"With these components, `showFileName` and `showDirName` can be updated to "
"take their configuration arguments implicitly through the `ConfigIO` monad. "
"They use [nested actions](../hello-world/conveniences.md#nested-actions) to "
"retrieve the configuration, and `runIO` to actually execute the call to "
"`IO.println`:"
msgstr ""
"有了这些组件，`showFileName` 和 `showDirName` 可以更新为通过 `ConfigIO` 单子隐式获取其配置参数。它们使用 "
"[嵌套操作](../hello-world/conveniences.md#nested-actions) 来检索配置，并使用 `runIO` "
"来实际执行对 `IO.println` 的调用："

#: src/monad-transformers/reader-io.md:216
#, fuzzy
msgid ""
"In the new version of `dirTree`, the calls to `toEntry` and "
"`System.FilePath.readDir` are wrapped in `runIO`. Additionally, instead of "
"building a new configuration and then requiring the programmer to keep track"
" of which one to pass to recursive calls, it uses `locally` to naturally "
"delimit the modified configuration to only a small region of the program, in"
" which it is the _only_ valid configuration:"
msgstr ""
"在新版本的 `dirTree` 中，对 `toEntry` 和 `System.FilePath.readDir` 的调用被包装在 `runIO` "
"中。此外，它没有构建新配置，然后要求程序员跟踪将哪个配置传递给递归调用，而是使用 `locally` "
"将修改后的配置自然地限定为程序的一个小区域，在该区域中它是 _唯一_ 有效的配置："

#: src/monad-transformers/reader-io.md:231
#, fuzzy
msgid ""
"The new version of `main` uses `ConfigIO.run` to invoke `dirTree` with the "
"initial configuration:"
msgstr "新版本的 `main` 使用 `ConfigIO.run` 使用初始配置调用 `dirTree`："

#: src/monad-transformers/reader-io.md:232
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"    match configFromArgs args with\n"
"    | some config =>\n"
"      (dirTree (← IO.currentDir)).run config\n"
"      pure 0\n"
"    | none =>\n"
"      IO.eprintln s!\"Didn't understand argument(s) {\" \".separate args}\\n\"\n"
"      IO.eprintln usage\n"
"      pure 1\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:244
#, fuzzy
msgid ""
"This custom monad has a number of advantages over passing configurations "
"manually:"
msgstr "这种自定义单子比手动传递配置具有许多优势："

#: src/monad-transformers/reader-io.md:246
#, fuzzy
msgid ""
"It is easier to ensure that configurations are passed down unchanged, except"
" when changes are desired"
msgstr "更容易确保配置按原样传递，除非需要更改"

#: src/monad-transformers/reader-io.md:247
#, fuzzy
msgid ""
"The concern of passing the configuration onwards is more clearly separated "
"from the concern of printing directory contents"
msgstr "传递配置的顾虑与打印目录内容的顾虑更加清晰地分离开来"

#: src/monad-transformers/reader-io.md:248
#, fuzzy
msgid ""
"As the program grows, there will be more and more intermediate layers that "
"do nothing with configurations except propagate them, and these layers don't"
" need to be rewritten as the configuration logic changes"
msgstr "随着程序的增长，将有越来越多的中间层对配置不执行任何操作，除了传播它们，并且这些层不需要在配置逻辑更改时重写"

#: src/monad-transformers/reader-io.md:250
#, fuzzy
msgid "However, there are also some clear downsides:"
msgstr "但是，也有一些明显的缺点："

#: src/monad-transformers/reader-io.md:252
#, fuzzy
msgid ""
"As the program evolves and the monad requires more features, each of the "
"basic operators such as `locally` and `currentConfig` will need to be "
"updated"
msgstr "随着程序的演进和单子需要更多功能，每个基本运算符（如 `locally` 和 `currentConfig`）都需要更新"

#: src/monad-transformers/reader-io.md:253
#, fuzzy
msgid ""
"Wrapping ordinary `IO` actions in `runIO` is noisy and distracts from the "
"flow of the program"
msgstr "将普通的 `IO` 操作包装在 `runIO` 中很嘈杂，并且会分散程序的流程"

#: src/monad-transformers/reader-io.md:254
#, fuzzy
msgid ""
"Writing monads instances by hand is repetitive, and the technique for adding"
" a reader effect to another monad is a design pattern that requires "
"documentation and communication overhead"
msgstr "手动编写单子实例很重复，并且将读取器效果添加到另一个单子的技术是一种设计模式，需要文档和通信开销"

#: src/monad-transformers/reader-io.md:256
#, fuzzy
msgid ""
"Using a technique called _monad transformers_, all of these downsides can be"
" addressed. A monad transformer takes a monad as an argument and returns a "
"new monad. Monad transformers consist of:"
msgstr "使用称为「单子转换器」的技术，可以解决所有这些缺点。单子转换器将单子作为参数并返回一个新单子。单子转换器包括："

#: src/monad-transformers/reader-io.md:259
#, fuzzy
msgid ""
"A definition of the transformer itself, which is typically a function from "
"types to types"
msgstr "转换器本身的定义，它通常是从类型到类型的函数"

#: src/monad-transformers/reader-io.md:260
#: src/monad-transformers/summary.md:12
#, fuzzy
msgid "A `Monad` instance that assumes the inner type is already a monad"
msgstr "一个 `Monad` 实例，它假定内部类型已经是一个单子"

#: src/monad-transformers/reader-io.md:261
#, fuzzy
msgid ""
"An operator to \"lift\" an action from the inner monad to the transformed "
"monad, akin to `runIO`"
msgstr "一个运算符，用于将操作从内部单子「提升」到转换后的单子，类似于 `runIO`"

#: src/monad-transformers/reader-io.md:263
#, fuzzy
msgid "Adding a Reader to Any Monad"
msgstr "将读取器添加到任何单子"

#: src/monad-transformers/reader-io.md:265
#, fuzzy
msgid ""
"Adding a reader effect to `IO` was accomplished in `ConfigIO` by wrapping "
"`IO α` in a function type. The Lean standard library contains a function "
"that can do this to _any_ polymorphic type, called `ReaderT`:"
msgstr ""
"通过将 `IO α` 包装在函数类型中，在 `ConfigIO` 中实现了向 `IO` 添加读取器效果。Lean 标准库包含一个函数，可以对 _any_"
" 多态类型执行此操作，称为 `ReaderT`："

#: src/monad-transformers/reader-io.md:271
#, fuzzy
msgid "Its arguments are as follows:"
msgstr "其参数如下："

#: src/monad-transformers/reader-io.md:272
#, fuzzy
msgid "`ρ` is the environment that is accessible to the reader"
msgstr "`ρ` 是可供读取器的环境"

#: src/monad-transformers/reader-io.md:273
#, fuzzy
msgid "`m` is the monad that is being transformed, such as `IO`"
msgstr "`m` 是要转换的单子，例如 `IO`"

#: src/monad-transformers/reader-io.md:274
#, fuzzy
msgid ""
"`α` is the type of values being returned by the monadic computation Both `α`"
" and `ρ` are in the same universe because the operator that retrieves the "
"environment in the monad will have type `m ρ`."
msgstr "`α` 是单子计算返回的值的类型"

#: src/monad-transformers/reader-io.md:277
#, fuzzy
msgid "With `ReaderT`, `ConfigIO` becomes:"
msgstr "`α` 和 `ρ` 都在同一个 universe 中，因为在单子中检索环境的运算符将具有类型 `m ρ`。"

#: src/monad-transformers/reader-io.md:281
#, fuzzy
msgid ""
"It is an `abbrev` because `ReaderT` has many useful features defined in the "
"standard library that a non-reducible definition would hide. Rather than "
"taking responsibility for making these work directly for `ConfigIO`, it's "
"easier to simply have `ConfigIO` behave identically to `ReaderT Config IO`."
msgstr "使用 `ReaderT`，`ConfigIO` 变为："

#: src/monad-transformers/reader-io.md:284
#, fuzzy
msgid ""
"The manually-written `currentConfig` obtained the environment out of the "
"reader. This effect can be defined in a generic form for all uses of "
"`ReaderT`, under the name `read`:"
msgstr ""
"它是一个 `abbrev`，因为 `ReaderT` 在标准库中定义了许多有用的特性，而不可约化的定义会隐藏这些特性。与其直接负责让这些特性对 "
"`ConfigIO` 起作用，不如简单地让 `ConfigIO` 的行为与 `ReaderT Config IO` 完全相同。"

#: src/monad-transformers/reader-io.md:290
#, fuzzy
msgid ""
"However, not every monad that provides a reader effect is built with "
"`ReaderT`. The type class `MonadReader` allows any monad to provide a `read`"
" operator:"
msgstr ""
"手动编写的 `currentConfig` 从读取器中获取环境。这种效果可以为 `ReaderT` 的所有用法定义一个通用形式，名称为 `read`："

#: src/monad-transformers/reader-io.md:301
#, fuzzy
msgid ""
"The type `ρ` is an output parameter because any given monad typically only "
"provides a single type of environment through a reader, so automatically "
"selecting it when the monad is known makes programs more convenient to "
"write."
msgstr ""
"但是，并非每个提供读取器效果的单子都是用 `ReaderT` 构建的。类型类 `MonadReader` 允许任何单子提供一个 `read` 运算符："

#: src/monad-transformers/reader-io.md:303
#, fuzzy
msgid ""
"The `Monad` instance for `ReaderT` is essentially the same as the `Monad` "
"instance for `ConfigIO`, except `IO` has been replaced by some arbitrary "
"monad argument `m`:"
msgstr "类型 `ρ` 是一个输出参数，因为任何给定的单子通常只通过读取器提供一种类型的环境，因此在已知单子时自动选择它使得程序更易于编写。"

#: src/monad-transformers/reader-io.md:313
#, fuzzy
msgid ""
"The next step is to eliminate uses of `runIO`. When Lean encounters a "
"mismatch in monad types, it automatically attempts to use a type class "
"called `MonadLift` to transform the actual monad into the expected monad. "
"This process is similar to the use of coercions. `MonadLift` is defined as "
"follows:"
msgstr ""
"`ReaderT` 的 `Monad` 实例与 `ConfigIO` 的 `Monad` 实例基本相同，只是 `IO` 已被某个任意的单子参数 `m` "
"替换："

#: src/monad-transformers/reader-io.md:321
#, fuzzy
msgid ""
"The method `monadLift` translates from the monad `m` to the monad `n`. The "
"process is called \"lifting\" because it takes an action in the embedded "
"monad and makes it into an action in the surrounding monad. In this case, it"
" will be used to \"lift\" from `IO` to `ReaderT Config IO`, though the "
"instance works for _any_ inner monad `m`:"
msgstr ""
"`monadLift` 方法将单子 `m` 转换为单子 "
"`n`。这个过程被称为「提升」，因为它将嵌入式单子中的动作转换为周围单子中的动作。在本例中，它将用于从 `IO` 「提升」到 `ReaderT "
"Config IO`，尽管该实例适用于 _任何_ 内部单子 `m`："

#: src/monad-transformers/reader-io.md:328
#, fuzzy
msgid ""
"The implementation of `monadLift` is very similar to that of `runIO`. "
"Indeed, it is enough to define `showFileName` and `showDirName` without "
"using `runIO`:"
msgstr ""
"`monadLift` 的实现与 `runIO` 非常相似。事实上，只需在不使用 `runIO` 的情况下定义 `showFileName` 和 "
"`showDirName` 即可："

#: src/monad-transformers/reader-io.md:330
msgid ""
"```lean\n"
"def showFileName (file : String) : ConfigIO Unit := do\n"
"  IO.println s!\"{(← read).currentPrefix} {file}\"\n"
"\n"
"def showDirName (dir : String) : ConfigIO Unit := do\n"
"  IO.println s!\"{(← read).currentPrefix} {dir}/\"\n"
"```"
msgstr ""

#: src/monad-transformers/reader-io.md:338
#, fuzzy
msgid ""
"One final operation from the original `ConfigIO` remains to be translated to"
" a use of `ReaderT`: `locally`. The definition can be translated directly to"
" `ReaderT`, but the Lean standard library provides a more general version. "
"The standard version is called `withReader`, and it is part of a type class "
"called `MonadWithReader`:"
msgstr ""
"原始 `ConfigIO` 中的最后一个操作仍需转换为 `ReaderT` 的用法：`locally`。该定义可以直接转换为 `ReaderT`，但 "
"Lean 标准库提供了一个更通用的版本。标准版本称为 `withReader`，它是类型类 `MonadWithReader` 的一部分："

#: src/monad-transformers/reader-io.md:345
#, fuzzy
msgid ""
"Just as in `MonadReader`, the environment `ρ` is an `outParam`. The "
"`withReader` operation is exported, so that it doesn't need to be written "
"with the type class name before it:"
msgstr ""
"与 `MonadReader` 中一样，环境 `ρ` 是一个 `outParam`。`withReader` "
"操作被导出，因此无需在它之前编写类型类名称："

#: src/monad-transformers/reader-io.md:350
#, fuzzy
msgid ""
"The instance for `ReaderT` is essentially the same as the definition of "
"`locally`:"
msgstr "`ReaderT` 的实例本质上与 `locally` 的定义相同："

#: src/monad-transformers/reader-io.md:357
#, fuzzy
msgid ""
"With these definitions in place, the new version of `dirTree` can be "
"written:"
msgstr "有了这些定义，就可以编写新版本的 `dirTree`："

#: src/monad-transformers/reader-io.md:370
#, fuzzy
msgid ""
"Aside from replacing `locally` with `withReader`, it is the same as before."
msgstr "除了将 `locally` 替换为 `withReader` 之外，它与之前相同。"

#: src/monad-transformers/reader-io.md:373
#, fuzzy
msgid ""
"Replacing the custom `ConfigIO` type with `ReaderT` did not save a large "
"number of lines of code in this section. However, rewriting the code using "
"components from the standard library does have long-term benefits. First, "
"readers who know about `ReaderT` don't need to take time to understand the "
"`Monad` instance for `ConfigIO`, working backwards to the meaning of monad "
"itself. Instead, they can be confident in their initial understanding. Next,"
" adding further effects to the monad (such as a state effect to count the "
"files in each directory and display a count at the end) requires far fewer "
"changes to the code, because the monad transformers and `MonadLift` "
"instances provided in the library work well together. Finally, using a set "
"of type classes included in the standard library, polymorphic code can be "
"written in such a way that it can work with a variety of monads without "
"having to care about details like the order in which the monad transformers "
"were applied. Just as some functions work in any monad, others can work in "
"any monad that provides a certain type of state, or a certain type of "
"exceptions, without having to specifically describe the _way_ in which a "
"particular concrete monad provides the state or exceptions."
msgstr ""
"用 `ReaderT` 替换自定义 `ConfigIO` 类型并没有节省本节中的大量代码行。然而，使用标准库中的组件重写代码确实具有长期好处。首先，了解"
" `ReaderT` 的读者无需花时间理解 `ConfigIO` 的 `Monad` "
"实例，从而反向理解单子的含义。相反，他们可以确信自己最初的理解。接下来，向单子添加更多效果（例如状态效果来计算每个目录中的文件并显示结尾处的计数）需要对代码进行的更改要少得多，因为库中提供的单子转换器和"
" `MonadLift` "
"实例可以很好地协同工作。最后，使用标准库中包含的一组类型类，可以编写多态代码，使其可以与各种单子一起使用，而无需关心诸如应用单子转换器的顺序之类的细节。就像某些函数可以在任何单子中工作一样，其他函数可以在提供某种状态或某种异常的任何单子中工作，而无需具体描述特定具体单子提供状态或异常的方式。"

#: src/monad-transformers/reader-io.md:383
#, fuzzy
msgid "Controlling the Display of Dotfiles"
msgstr "控制点文件的显示"

#: src/monad-transformers/reader-io.md:385
#, fuzzy
msgid ""
"Files whose names begin with a dot character (`'.'`) typically represent "
"files that should usually be hidden, such as source-control metadata and "
"configuration files. Modify `doug` with an option to show or hide filenames "
"that begin with a dot. This option should be controlled with a `-a` command-"
"line option."
msgstr ""
"以点字符（'.'）开头的文件通常表示通常应该隐藏的文件，例如源代码控制元数据和配置文件。使用 `-a` 命令行选项修改 `doug` "
"以显示或隐藏以点开头的文件名。"

#: src/monad-transformers/reader-io.md:389
#, fuzzy
msgid "Starting Directory as Argument"
msgstr "起始目录作为参数"

#: src/monad-transformers/reader-io.md:391
#, fuzzy
msgid ""
"Modify `doug` so that it takes a starting directory as an additional "
"command-line argument."
msgstr "修改 `doug`，使其将起始目录作为附加命令行参数。"

#: src/monad-transformers/transformers.md:3
#, fuzzy
msgid ""
"`ReaderT` is far from the only useful monad transformer. This section "
"describes a number of additional transformers. Each monad transformer "
"consists of the following:"
msgstr "`ReaderT` 远非唯一有用的单子变换器。本节介绍了许多其他变换器。每个单子变换器包含以下内容："

#: src/monad-transformers/transformers.md:6
#, fuzzy
msgid ""
"A definition or datatype `T` that takes a monad as an argument. It should "
"have a type like `(Type u → Type v) → Type u → Type v`, though it may accept"
" additional arguments prior to the monad."
msgstr ""
"一个定义或数据类型 `T`，它将单子作为参数。它的类型应类似于 `(Type u → Type v) → Type u → Type "
"v`，尽管它可以在单子之前接受其他参数。"

#: src/monad-transformers/transformers.md:8
#, fuzzy
msgid ""
"A `Monad` instance for `T m` that relies on an instance of `Monad m`. This "
"enables the transformed monad to be used as a monad."
msgstr "一个 `Monad` 实例，用于 `T m`，它依赖于 `Monad m` 的实例。这使得变换后的单子可以用作单子。"

#: src/monad-transformers/transformers.md:9
#, fuzzy
msgid ""
"A `MonadLift` instance that translates actions of type `m α` into actions of"
" type `T m α`, for arbitrary monads `m`. This enables actions from the "
"underlying monad to be used in the transformed monad."
msgstr ""
"一个 `MonadLift` 实例，它将类型为 `m α` 的动作转换为类型为 `T m α` 的动作，适用于任意单子 "
"`m`。这使得可以将来自底层单子的动作用于变换后的单子。"

#: src/monad-transformers/transformers.md:11
#, fuzzy
msgid ""
"Furthermore, the `Monad` instance for the transformer should obey the "
"contract for `Monad`, at least if the underlying `Monad` instance does. In "
"addition, `monadLift (pure x)` should be equivalent to `pure x` in the "
"transformed monad, and `monadLift` should distribute over `bind` so that "
"`monadLift (x >>= f)` is the same as `monadLift x >>= fun y => monadLift (f "
"y)`."
msgstr ""
"此外，变换器的 `Monad` 实例应遵守 `Monad` 的契约，至少在底层 `Monad` 实例这样做时。此外，`monadLift (pure "
"x)` 在变换后的单子中应等同于 `pure x`，并且 `monadLift` 应分布在 `bind` 上，以便 `monadLift (x >>= "
"f)` 与 `monadLift x >>= fun y => monadLift (f y)` 相同。"

#: src/monad-transformers/transformers.md:14
#, fuzzy
msgid ""
"Many monad transformers additionally define type classes in the style of "
"`MonadReader` that describe the actual effects available in the monad. This "
"can provide more flexibility: it allows programs to be written that rely "
"only on an interface, and don't constrain the underlying monad to be "
"implemented by a given transformer. The type classes are a way for programs "
"to express their requirements, and monad transformers are a convenient way "
"to meet these requirements."
msgstr ""
"许多单子变换器还定义了类似于 `MonadReader` "
"的类型类，用于描述单子中可用的实际效果。这可以提供更大的灵活性：它允许编写仅依赖于接口的程序，并且不会限制底层单子由给定的变换器实现。类型类是程序表达其需求的一种方式，而单子变换器是满足这些需求的便捷方式。"

#: src/monad-transformers/transformers.md:19
#, fuzzy
msgid "Failure with `OptionT`"
msgstr "`OptionT` 的失败"

#: src/monad-transformers/transformers.md:21
#, fuzzy
msgid ""
"Failure, represented by the `Option` monad, and exceptions, represented by "
"the `Except` monad, both have corresponding transformers. In the case of "
"`Option`, failure can be added to a monad by having it contain values of "
"type `Option α` where it would otherwise contain values of type `α`. For "
"example, `IO (Option α)` represents `IO` actions that don't always return a "
"value of type `α`. This suggests the definition of the monad transformer "
"`OptionT`:"
msgstr ""
"由 `Option` 单子表示的失败和由 `Except` 单子表示的异常都有相应的变换器。对于 `Option`，可以通过让它包含类型为 "
"`Option α` 的值（在其他情况下它将包含类型为 `α` 的值）来将失败添加到单子中。例如，`IO (Option α)` 表示不总是返回类型为 "
"`α` 的值的 `IO` 操作。这表明了单子变换器 `OptionT` 的定义："

#: src/monad-transformers/transformers.md:30
#, fuzzy
msgid ""
"As an example of `OptionT` in action, consider a program that asks the user "
"questions. The function `getSomeInput` asks for a line of input and removes "
"whitespace from both ends. If the resulting trimmed input is non-empty, then"
" it is returned, but the function fails if there are no non-whitespace "
"characters:"
msgstr ""
"作为 `OptionT` 实际应用的示例，考虑一个向用户提问的程序。函数 `getSomeInput` "
"要求输入一行内容，并从两端删除空格。如果修剪后的输入非空，则返回它，但如果没有非空格字符，则函数失败："

#: src/monad-transformers/transformers.md:33
msgid ""
"```lean\n"
"def getSomeInput : OptionT IO String := do\n"
"  let input ← (← IO.getStdin).getLine\n"
"  let trimmed := input.trim\n"
"  if trimmed == \"\" then\n"
"    failure\n"
"  else pure trimmed\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:41
#, fuzzy
msgid ""
"This particular application tracks users with their name and their favorite "
"species of beetle:"
msgstr "此特定应用程序使用其姓名和最喜欢的甲虫种类跟踪用户："

#: src/monad-transformers/transformers.md:47
#, fuzzy
msgid ""
"Asking the user for input is no more verbose than a function that uses only "
"`IO` would be:"
msgstr "向用户询问输入的内容并不比仅使用 `IO` 的函数更冗长："

#: src/monad-transformers/transformers.md:48
msgid ""
"```lean\n"
"def getUserInfo : OptionT IO UserInfo := do\n"
"  IO.println \"What is your name?\"\n"
"  let name ← getSomeInput\n"
"  IO.println \"What is your favorite species of beetle?\"\n"
"  let beetle ← getSomeInput\n"
"  pure ⟨name, beetle⟩\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:56
#, fuzzy
msgid ""
"However, because the function runs in an `OptionT IO` context rather than "
"just in `IO`, failure in the first call to `getSomeInput` causes the whole "
"`getUserInfo` to fail, with control never reaching the question about "
"beetles. The main function, `interact`, invokes `getUserInfo` in a purely "
"`IO` context, which allows it to check whether the call succeeded or failed "
"by matching on the inner `Option`:"
msgstr ""
"但是，由于函数在 `OptionT IO` 上下文中而不是仅在 `IO` 中运行，因此在第一次调用 `getSomeInput` 时失败会导致整个 "
"`getUserInfo` 失败，并且控制权永远不会到达有关甲虫的问题。主函数 `interact` 在纯 `IO` 上下文中调用 "
"`getUserInfo`，这允许它通过匹配内部 `Option` 来检查调用是否成功或失败："

#: src/monad-transformers/transformers.md:58
msgid ""
"```lean\n"
"def interact : IO Unit := do\n"
"  match ← getUserInfo with\n"
"  | none => IO.eprintln \"Missing info\"\n"
"  | some ⟨name, beetle⟩ => IO.println s!\"Hello {name}, whose favorite beetle is {beetle}.\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:65
#, fuzzy
msgid "The Monad Instance"
msgstr "单子实例"

#: src/monad-transformers/transformers.md:67
#, fuzzy
msgid ""
"Writing the monad instance reveals a difficulty. Based on the types, `pure` "
"should use `pure` from the underlying monad `m` together with `some`. Just "
"as `bind` for `Option` branches on the first argument, propagating `none`, "
"`bind` for `OptionT` should run the monadic action that makes up the first "
"argument, branch on the result, and then propagate `none`. Following this "
"sketch yields the following definition, which Lean does not accept:"
msgstr ""
"编写单子实例时会遇到一个困难。根据类型，`pure` 应将基础单子 `m` 中的 `pure` 与 `some` 一起使用。正如 `Option` 的 "
"`bind` 分支在第一个参数上，传播 `none`，`OptionT` 的 `bind` 应运行构成第一个参数的单子操作，在结果上分支，然后传播 "
"`none`。按照此草图，会得到以下定义，而 Lean 无法接受："

#: src/monad-transformers/transformers.md:79
#, fuzzy
msgid "The error message shows a cryptic type mismatch:"
msgstr "错误消息显示了一个难以理解的类型不匹配："

#: src/monad-transformers/transformers.md:90
#, fuzzy
msgid ""
"The problem here is that Lean is selecting the wrong `Monad` instance for "
"the surrounding use of `pure`. Similar errors occur for the definition of "
"`bind`. One solution is to use type annotations to guide Lean to the correct"
" `Monad` instance:"
msgstr ""
"这里的问题是 Lean 为周围的 `pure` 用法选择了错误的 `Monad` 实例。`bind` "
"定义也会出现类似的错误。一种解决方案是使用类型标注来指导 Lean 使用正确的 `Monad` 实例："

#: src/monad-transformers/transformers.md:101
#, fuzzy
msgid ""
"While this solution works, it is inelegant and the code becomes a bit noisy."
msgstr "虽然此解决方案可行，但它不够优雅，并且代码会变得有点嘈杂。"

#: src/monad-transformers/transformers.md:103
#, fuzzy
msgid ""
"An alternative solution is to define functions whose type signatures guide "
"Lean to the correct instances. In fact, `OptionT` could have been defined as"
" a structure:"
msgstr "另一种解决方案是定义其类型签名指导 Lean 使用正确实例的函数。事实上，`OptionT` 可以定义为一个结构体："

#: src/monad-transformers/transformers.md:109
#, fuzzy
msgid ""
"This would solve the problem, because the constructor `OptionT.mk` and the "
"field accessor `OptionT.run` would guide type class inference to the correct"
" instances. The downside to doing this is that structure values would need "
"to be allocated and deallocated repeatedly when running code that uses it, "
"while the direct definition is a compile-time-only feature. The best of both"
" worlds can be achieved by defining functions that serve the same role as "
"`OptionT.mk` and `OptionT.run`, but that work with the direct definition:"
msgstr ""
"这将解决问题，因为构造子 `OptionT.mk` 和字段访问器 `OptionT.run` "
"将指导类型类推断到正确的实例。这样做的缺点是，在运行使用它的代码时，需要反复分配和释放结构体值，而直接定义只是一个编译时特性。可以通过定义与 "
"`OptionT.mk` 和 `OptionT.run` 具有相同作用但适用于直接定义的函数来实现两全其美："

#: src/monad-transformers/transformers.md:117
#, fuzzy
msgid ""
"Both functions return their inputs unchanged, but they indicate the boundary"
" between code that is intended to present the interface of `OptionT` and "
"code that is intended to present the interface of the underlying monad `m`. "
"Using these helpers, the `Monad` instance becomes more readable:"
msgstr ""
"这两个函数都返回它们未更改的输入，但它们指示了打算呈现 `OptionT` 接口的代码与打算呈现底层单子 `m` "
"接口的代码之间的界限。使用这些帮助器，`Monad` 实例变得更具可读性："

#: src/monad-transformers/transformers.md:127
#, fuzzy
msgid ""
"Here, the use of `OptionT.mk` indicates that its arguments should be "
"considered as code that uses the interface of `m`, which allows Lean to "
"select the correct `Monad` instances."
msgstr "此处，使用 `OptionT.mk` 表示其参数应被视为使用 `m` 接口的代码，这允许 Lean 选择正确的 `Monad` 实例。"

#: src/monad-transformers/transformers.md:129
#, fuzzy
msgid ""
"After defining the monad instance, it's a good idea to check that the monad "
"contract is satisfied. The first step is to show that `bind (pure v) f` is "
"the same as `f v`. Here's the steps:"
msgstr "在定义单子实例后，最好检查单子契约是否得到满足。第一步是证明 `bind (pure v) f` 与 `f v` 相同。以下是步骤："

#: src/monad-transformers/transformers.md:189
#, fuzzy
msgid ""
"The second rule states that `bind w pure` is the same as `w`. To demonstrate"
" this, unfold the definitions of `bind` and `pure`, yielding:"
msgstr "第二条规则指出 `bind w pure` 与 `w` 相同。为了证明这一点，展开 `bind` 和 `pure` 的定义，得到："

#: src/monad-transformers/transformers.md:197
#, fuzzy
msgid ""
"In this pattern match, the result of both cases is the same as the pattern "
"being matched, just with `pure` around it. In other words, it is equivalent "
"to `w >>= fun y => pure y`, which is an instance of `m`'s second monad rule."
msgstr ""
"在此模式匹配中，两种情况的结果都与正在匹配的模式相同，只是周围有 `pure`。换句话说，它等效于 `w >>= fun y => pure y`，这是"
" `m` 的第二个单子规则的一个实例。"

#: src/monad-transformers/transformers.md:200
#, fuzzy
msgid ""
"The final rule states that `bind (bind v f) g`  is the same as `bind v (fun "
"x => bind (f x) g)`. It can be checked in the same way, by expanding the "
"definitions of `bind` and `pure` and then delegating to the underlying monad"
" `m`."
msgstr ""
"最后一条规则指出 `bind (bind v f) g` 与 `bind v (fun x => bind (f x) g)` 相同。可以通过展开 "
"`bind` 和 `pure` 的定义，然后委托给底层单子 `m` 来以相同的方式进行检查。"

#: src/monad-transformers/transformers.md:203
#, fuzzy
msgid "An `Alternative` Instance"
msgstr "`Alternative` 实例"

#: src/monad-transformers/transformers.md:205
#, fuzzy
msgid ""
"One convenient way to use `OptionT` is through the `Alternative` type class."
" Successful return is already indicated by `pure`, and the `failure` and "
"`orElse` methods of `Alternative` provide a way to write a program that "
"returns the first successful result from a number of subprograms:"
msgstr ""
"使用 `OptionT` 的一种便捷方法是通过 `Alternative` 类型类。`pure` 已经指示了成功的返回，而 `Alternative` "
"的 `failure` 和 `orElse` 方法提供了一种编写程序的方法，该程序从多个子程序中返回第一个成功的结果："

#: src/monad-transformers/transformers.md:217
#, fuzzy
msgid "Lifting"
msgstr "提升"

#: src/monad-transformers/transformers.md:219
#, fuzzy
msgid ""
"Lifting an action from `m` to `OptionT m` only requires wrapping `some` "
"around the result of the computation:"
msgstr "将一个动作从 `m` 提升到 `OptionT m` 只需要将计算结果用 `some` 包裹起来："

#: src/monad-transformers/transformers.md:227
#, fuzzy
msgid "Exceptions"
msgstr "异常"

#: src/monad-transformers/transformers.md:229
#, fuzzy
msgid ""
"The monad transformer version of `Except` is very similar to the monad "
"transformer version of `Option`. Adding exceptions of type `ε` to some "
"monadic action of type `m α` can be accomplished by adding exceptions to "
"`α`, yielding type `m (Except ε α)`:"
msgstr ""
"`Except` 的单子变换器版本与 `Option` 的单子变换器版本非常相似。向类型为 `m α` 的某个单子动作添加类型为 `ε` "
"的异常可以通过向 `α` 添加异常来完成，得到类型 `m (Except ε α)`："

#: src/monad-transformers/transformers.md:235
#, fuzzy
msgid ""
"`OptionT` provides `mk` and `run` functions to guide the type checker "
"towards the correct `Monad` instances. This trick is also useful for "
"`ExceptT`:"
msgstr ""
"`OptionT` 提供了 `mk` 和 `run` 函数来指导类型检查器指向正确的 `Monad` 实例。此技巧对 `ExceptT` 也有用："

#: src/monad-transformers/transformers.md:242
#, fuzzy
msgid ""
"The `Monad` instance for `ExceptT` is also very similar to the instance for "
"`OptionT`. The only difference is that it propagates a specific error value,"
" rather than `none`:"
msgstr ""
"`ExceptT` 的 `Monad` 实例也与 `OptionT` 的实例非常相似。唯一的区别是它传播一个特定的错误值，而不是 `none`："

#: src/monad-transformers/transformers.md:253
#, fuzzy
msgid ""
"The type signatures of `ExceptT.mk` and `ExceptT.run` contain a subtle "
"detail: they annotate the universe levels of `α` and `ε` explicitly. If they"
" are not explicitly annotated, then Lean generates a more general type "
"signature in which they have distinct polymorphic universe variables. "
"However, the definition of `ExceptT` expects them to be in the same "
"universe, because they can both be provided as arguments to `m`. This can "
"lead to a problem in the `Monad` instance where the universe level solver "
"fails to find a working solution:"
msgstr ""
"`ExceptT.mk` 和 `ExceptT.run` 的类型签名包含一个微妙的细节：它们明确地标注了 `α` 和 `ε` "
"的宇宙级别。如果它们没有被明确标注，那么 Lean 会生成一个更通用的类型签名，其中它们具有不同的多态宇宙变量。然而，`ExceptT` "
"的定义期望它们在同一个宇宙中，因为它们都可以作为 `m` 的参数提供。这可能会导致 `Monad` "
"实例出现问题，其中宇宙级别求解器无法找到一个可行的解决方案："

#: src/monad-transformers/transformers.md:275
#, fuzzy
msgid ""
"This kind of error message is typically caused by underconstrained universe "
"variables. Diagnosing it can be tricky, but a good first step is to look for"
" reused universe variables in some definitions that are not reused in "
"others."
msgstr ""
"这种类型的错误消息通常是由约束不足的宇宙变量引起的。诊断它可能很棘手，但一个好的第一步是查找某些定义中重复使用的宇宙变量，而其他定义中没有重复使用。"

#: src/monad-transformers/transformers.md:278
#, fuzzy
msgid ""
"Unlike `Option`, the `Except` datatype is typically not used as a data "
"structure. It is always used as a control structure with its `Monad` "
"instance. This means that it is reasonable to lift `Except ε` actions into "
"`ExceptT ε m`, as well as actions from the underlying monad `m`. Lifting "
"`Except` actions into `ExceptT` actions is done by wrapping them in `m`'s "
"`pure`, because an action that only has exception effects cannot have any "
"effects from the monad `m`:"
msgstr ""
"与 `Option` 不同，`Except` 数据类型通常不用作数据结构体。它总是与它的 `Monad` 实例一起用作控制结构体。这意味着将 `Except"
" ε` 动作提升到 `ExceptT ε m` 是合理的，以及从底层单子 `m` 中提升动作。将 `Except` 动作提升到 `ExceptT` "
"动作是通过将它们包装在 `m` 的 `pure` 中完成的，因为一个只有异常效果的动作不能有任何来自单子 `m` 的效果："

#: src/monad-transformers/transformers.md:286
#, fuzzy
msgid ""
"Because actions from `m` do not have any exceptions in them, their value "
"should be wrapped in `Except.ok`. This can be accomplished using the fact "
"that `Functor` is a superclass of `Monad`, so applying a function to the "
"result of any monadic computation can be accomplished using `Functor.map`:"
msgstr ""
"由于 `m` 中的动作不会引发任何异常，因此其值应包装在 `Except.ok` 中。这可以通过利用 `Functor` 是 `Monad` "
"的超类这一事实来实现，因此可以使用 `Functor.map` 将函数应用于任何单子计算的结果："

#: src/monad-transformers/transformers.md:293
#, fuzzy
msgid "Type Classes for Exceptions"
msgstr "异常类型类"

#: src/monad-transformers/transformers.md:295
#, fuzzy
msgid ""
"Exception handling fundamentally consists of two operations: the ability to "
"throw exceptions, and the ability to recover from them. Thus far, this has "
"been accomplished using the constructors of `Except` and pattern matching, "
"respectively. However, this ties a program that uses exceptions to one "
"specific encoding of the exception handling effect. Using a type class to "
"capture these operations allows a program that uses exceptions to be used in"
" _any_ monad that supports throwing and catching."
msgstr ""
"异常处理基本上包含两个操作：引发异常的能力和从异常中恢复的能力。到目前为止，这已分别使用 `Except` "
"的构造子和模式匹配来完成。但是，这将使用异常的程序绑定到异常处理效果的一个特定编码。使用类型类来捕获这些操作允许使用异常的程序在支持引发和捕获的 "
"_任何_ 单子中使用。"

#: src/monad-transformers/transformers.md:300
#, fuzzy
msgid ""
"Throwing an exception should take an exception as an argument, and it should"
" be allowed in any context where a monadic action is requested. The \"any "
"context\" part of the specification can be written as a type by writing `m "
"α`—because there's no way to produce a value of any arbitrary type, the "
"`throw` operation must be doing something that causes control to leave that "
"part of the program. Catching an exception should accept any monadic action "
"together with a handler, and the handler should explain how to get back to "
"the action's type from an exception:"
msgstr ""
"引发异常应将异常作为参数，并且应允许在任何需要单子操作的上下文中使用它。规范的「任何上下文」部分可以通过编写 `m α` "
"作为类型来编写——因为无法生成任何任意类型的值，所以 `throw` "
"操作必须执行某些操作导致控制离开程序的该部分。捕获异常应接受任何单子操作和处理程序，并且处理程序应解释如何从异常返回到操作的类型："

#: src/monad-transformers/transformers.md:309
#, fuzzy
msgid ""
"The universe levels on `MonadExcept` differ from those of `ExceptT`. In "
"`ExceptT`, both `ε` and `α` have the same level, while `MonadExcept` imposes"
" no such limitation. This is because `MonadExcept` never places an exception"
" value inside of `m`. The most general universe signature recognizes the "
"fact that `ε` and `α` are completely independent in this definition. Being "
"more general means that the type class can be instantiated for a wider "
"variety of types."
msgstr ""
"`MonadExcept` 上的宇宙级别与 `ExceptT` 的宇宙级别不同。在 `ExceptT` 中，`ε` 和 `α` 都具有相同的级别，而 "
"`MonadExcept` 则没有这样的限制。这是因为 `MonadExcept` 永远不会将异常值放在 `m` 中。最通用的宇宙签名认识到 `ε` 和"
" `α` 在此定义中是完全独立的。更通用意味着类型类可以实例化更多种类的类型。"

#: src/monad-transformers/transformers.md:315
#, fuzzy
msgid ""
"An example program that uses `MonadExcept` is a simple division service. The"
" program is divided into two parts: a frontend that supplies a user "
"interface based on strings that handles errors, and a backend that actually "
"does the division. Both the frontend and the backend can throw exceptions, "
"the former for ill-formed input and the latter for division by zero errors. "
"The exceptions are an inductive type:"
msgstr ""
"一个使用 `MonadExcept` "
"的示例程序是一个简单的除法服务。该程序分为两部分：一个基于处理错误的字符串提供用户界面的前端，以及一个实际执行除法的后端。前端和后端都可能抛出异常，前者针对格式错误的输入，后者针对除以零的错误。异常是一种归纳类型："

#: src/monad-transformers/transformers.md:324
#, fuzzy
msgid "The backend checks for zero, and divides if it can:"
msgstr "后端检查零，如果可以，则进行除法："

#: src/monad-transformers/transformers.md:331
#, fuzzy
msgid ""
"The frontend's helper `asNumber` throws an exception if the string it is "
"passed is not a number. The overall frontend converts its inputs to `Int`s "
"and calls the backend, handling exceptions by returning a friendly string "
"error:"
msgstr ""
"前端的助手 `asNumber` 在传递给它的字符串不是数字时抛出异常。整个前端将其输入转换为 `Int` "
"并调用后端，通过返回友好的字符串错误来处理异常："

#: src/monad-transformers/transformers.md:333
msgid ""
"```lean\n"
"def asNumber [Monad m] [MonadExcept Err m] (s : String) : m Int :=\n"
"  match s.toInt? with\n"
"  | none => throw (.notANumber s)\n"
"  | some i => pure i\n"
"\n"
"def divFrontend [Monad m] [MonadExcept Err m] (n k : String) : m String :=\n"
"  tryCatch (do pure (toString (← divBackend (← asNumber n) (← asNumber k))))\n"
"    fun\n"
"      | .divByZero => pure \"Division by zero!\"\n"
"      | .notANumber s => pure s!\"Not a number: \\\"{s}\\\"\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:345
#, fuzzy
msgid ""
"Throwing and catching exceptions is common enough that Lean provides a "
"special syntax for using `MonadExcept`. Just as `+` is short for "
"`HAdd.hAdd`, `try` and `catch` can be used as shorthand for the `tryCatch` "
"method:"
msgstr ""
"抛出和捕获异常很常见，以至于 Lean 提供了一种特殊的语法来使用 `MonadExcept`。就像 `+` 是 `HAdd.hAdd` "
"的缩写一样，`try` 和 `catch` 可以用作 `tryCatch` 方法的缩写："

#: src/monad-transformers/transformers.md:347
msgid ""
"```lean\n"
"def divFrontend [Monad m] [MonadExcept Err m] (n k : String) : m String :=\n"
"  try\n"
"    pure (toString (← divBackend (← asNumber n) (← asNumber k)))\n"
"  catch\n"
"    | .divByZero => pure \"Division by zero!\"\n"
"    | .notANumber s => pure s!\"Not a number: \\\"{s}\\\"\"\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:356
#, fuzzy
msgid ""
"In addition to `Except` and `ExceptT`, there are useful `MonadExcept` "
"instances for other types that may not seem like exceptions at first glance."
" For example, failure due to `Option` can be seen as throwing an exception "
"that contains no data whatsoever, so there is an instance of `MonadExcept "
"Unit Option` that allows `try ... catch ...` syntax to be used with "
"`Option`."
msgstr ""
"除了 `Except` 和 `ExceptT` 之外，还有其他类型的有用的 `MonadExcept` 实例，乍一看可能不像异常。例如，由于 "
"`Option` 导致的失败可以看作抛出一个不包含任何数据的异常，因此有一个 `MonadExcept Unit Option` 实例，允许将 `try"
" ... catch ...` 语法与 `Option` 一起使用。"

#: src/monad-transformers/transformers.md:359
#, fuzzy
msgid "State"
msgstr "状态"

#: src/monad-transformers/transformers.md:361
#, fuzzy
msgid ""
"A simulation of mutable state is added to a monad by having monadic actions "
"accept a starting state as an argument and return a final state together "
"with their result. The bind operator for a state monad provides the final "
"state of one action as an argument to the next action, threading the state "
"through the program. This pattern can also be expressed as a monad "
"transformer:"
msgstr ""
"通过让单子操作接受一个起始状态作为参数并返回一个最终状态及其结果，将可变状态的模拟添加到单子中。状态单子的绑定运算符将一个操作的最终状态作为参数提供给下一个操作，从而将状态贯穿整个程序。此模式也可以表示为单子转换器："

#: src/monad-transformers/transformers.md:370
#, fuzzy
msgid ""
"Once again, the monad instance is very similar to that for `State`. The only"
" difference is that the input and output states are passed around and "
"returned in the underlying monad, rather than with pure code:"
msgstr "再次，单子实例与 `State` 非常相似。唯一的区别是输入和输出状态在底层单子中传递和返回，而不是使用纯代码："

#: src/monad-transformers/transformers.md:380
#, fuzzy
msgid ""
"The corresponding type class has `get` and `set` methods. One downside of "
"`get` and `set` is that it becomes too easy to `set` the wrong state when "
"updating it. This is because retrieving the state, updating it, and saving "
"the updated state is a natural way to write some programs. For example, the "
"following program counts the number of diacritic-free English vowels and "
"consonants in a string of letters:"
msgstr ""
"对应的类型类具有 `get` 和 `set` 方法。`get` 和 `set` 的一个缺点是更新状态时很容易 `set` "
"错误的状态。这是因为检索状态、更新状态和保存更新后的状态是编写某些程序的自然方式。例如，以下程序计算一串字母中不带变音符号的英语元音和辅音的数量："

#: src/monad-transformers/transformers.md:384
msgid ""
"```lean\n"
"structure LetterCounts where\n"
"  vowels : Nat\n"
"  consonants : Nat\n"
"deriving Repr\n"
"\n"
"inductive Err where\n"
"  | notALetter : Char → Err\n"
"deriving Repr\n"
"\n"
"def vowels :=\n"
"  let lowerVowels := \"aeiuoy\"\n"
"  lowerVowels ++ lowerVowels.map (·.toUpper)\n"
"\n"
"def consonants :=\n"
"  let lowerConsonants := \"bcdfghjklmnpqrstvwxz\"\n"
"  lowerConsonants ++ lowerConsonants.map (·.toUpper )\n"
"\n"
"def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=\n"
"  let rec loop (chars : List Char) := do\n"
"    match chars with\n"
"    | [] => pure ()\n"
"    | c :: cs =>\n"
"      let st ← get\n"
"      let st' ←\n"
"        if c.isAlpha then\n"
"          if vowels.contains c then\n"
"            pure {st with vowels := st.vowels + 1}\n"
"          else if consonants.contains c then\n"
"            pure {st with consonants := st.consonants + 1}\n"
"          else -- modified or non-English letter\n"
"            pure st\n"
"        else throw (.notALetter c)\n"
"      set st'\n"
"      loop cs\n"
"  loop str.toList\n"
"```"
msgstr ""

#: src/monad-transformers/transformers.md:421
#, fuzzy
msgid ""
"It would be very easy to write `set st` instead of `set st'`. In a large "
"program, this kind of mistake can lead to difficult-to-diagnose bugs."
msgstr "很容易写成 `set st` 而不是 `set st'`。在一个大型程序中，这种类型的错误可能导致难以诊断的错误。"

#: src/monad-transformers/transformers.md:424
#, fuzzy
msgid ""
"While using a nested action for the call to `get` would solve this problem, "
"it can't solve all such problems. For example, a function might update a "
"field on a structure based on the values of two other fields. This would "
"require two separate nested-action calls to `get`. Because the Lean compiler"
" contains optimizations that are only effective when there is a single "
"reference to a value, duplicating the references to the state might lead to "
"code that is significantly slower. Both the potential performance problem "
"and the potential bug can be worked around by using `modify`, which "
"transforms the state using a function:"
msgstr ""
"虽然对 `get` 调用使用嵌套动作可以解决这个问题，但它不能解决所有此类问题。例如，一个函数可能会根据其他两个字段的值更新结构体上的字段。这将需要对 "
"`get` 进行两个单独的嵌套动作调用。由于 Lean "
"编译器包含仅在对值有单个引用时才有效的优化，因此复制对状态的引用可能会导致代码速度显着降低。潜在的性能问题和潜在的错误都可以通过使用 `modify` "
"来解决，它使用函数转换状态："

#: src/monad-transformers/transformers.md:446
#, fuzzy
msgid ""
"The type class contains a function akin to `modify` called `modifyGet`, "
"which allows the function to both compute a return value and transform an "
"old state in a single step. The function returns a pair in which the first "
"element is the return value, and the second element is the new state; "
"`modify` just adds the constructor of `Unit` to the pair used in "
"`modifyGet`:"
msgstr ""
"类型类包含一个类似于 `modify` 的函数，称为 "
"`modifyGet`，它允许函数在一步中计算返回值和转换旧状态。该函数返回一个对，其中第一个元素是返回值，第二个元素是新状态；`modify` 只是将"
" `Unit` 的构造子添加到 `modifyGet` 中使用的对中："

#: src/monad-transformers/transformers.md:453
#, fuzzy
msgid "The definition of `MonadState` is as follows:"
msgstr "`MonadState` 的定义如下："

#: src/monad-transformers/transformers.md:460
#, fuzzy
msgid ""
"`PUnit` is a version of the `Unit` type that is universe-polymorphic to "
"allow it to be in `Type u` instead of `Type`. While it would be possible to "
"provide a default implementation of `modifyGet` in terms of `get` and `set`,"
" it would not admit the optimizations that make `modifyGet` useful in the "
"first place, rendering the method useless."
msgstr ""
"`PUnit` 是 `Unit` 类型的版本，它是 universe-polymorphic，允许它在 `Type u` 中而不是 `Type` "
"中。虽然可以根据 `get` 和 `set` 提供 `modifyGet` 的默认实现，但它不会承认使 `modifyGet` "
"有用的优化，从而使该方法毫无用处。"

#: src/monad-transformers/transformers.md:463
#, fuzzy
msgid "`Of` Classes and `The` Functions"
msgstr "`Of` 类和 `The` 函数"

#: src/monad-transformers/transformers.md:465
#, fuzzy
msgid ""
"Thus far, each monad type class that takes extra information, like the type "
"of exceptions for `MonadExcept` or the type of the state for `MonadState`, "
"has this type of extra information as an output parameter. For simple "
"programs, this is generally convenient, because a monad that combines one "
"use each of `StateT`, `ReaderT`, and `ExceptT` has only a single state type,"
" environment type, and exception type. As monads grow in complexity, "
"however, they may involve multiple states or errors types. In this case, the"
" use of an output parameter makes it impossible to target both states in the"
" same `do`\\-block."
msgstr ""
"到目前为止，每个获取额外信息的 monad 类型类（例如 `MonadExcept` 的异常类型或 `MonadState` "
"的状态类型）都将此类额外信息作为输出参数。对于简单的程序，这通常很方便，因为结合了 `StateT`、`ReaderT` 和 `ExceptT` 的 "
"monad 只有一个状态类型、环境类型和异常类型。然而，随着 monad "
"的复杂性增加，它们可能涉及多个状态或错误类型。在这种情况下，使用输出参数使得无法在同一个 `do` 块中针对这两个状态。"

#: src/monad-transformers/transformers.md:470
#, fuzzy
msgid ""
"For these cases, there are additional type classes in which the extra "
"information is not an output parameter. These versions of the type classes "
"use the word `Of` in the name. For example, `MonadStateOf` is like "
"`MonadState`, but without an `outParam` modifier."
msgstr ""
"对于这些情况，还有其他类型类，其中额外信息不是输出参数。这些版本的类型类在名称中使用单词 `Of`。例如，`MonadStateOf` 类似于 "
"`MonadState`，但没有 `outParam` 修饰符。"

#: src/monad-transformers/transformers.md:474
#, fuzzy
msgid ""
"Similarly, there are versions of the type class methods that accept the type"
" of the extra information as an _explicit_, rather than implicit, argument. "
"For `MonadStateOf`, there are `getThe` with type"
msgstr "类似地，有类型类方法的版本，它们接受额外信息的类型作为显式（而不是隐式）参数。对于 `MonadStateOf`，有类型为"

#: src/monad-transformers/transformers.md:479
#, fuzzy
msgid "and `modifyThe` with type"
msgstr "的 `getThe` 和类型为"

#: src/monad-transformers/transformers.md:483
#, fuzzy
msgid ""
"There is no `setThe` because the type of the new state is enough to decide "
"which surrounding state monad transformer to use."
msgstr "由于新状态的类型足以决定使用哪个周围状态单子变换器，因此没有 `setThe`。"

#: src/monad-transformers/transformers.md:485
#, fuzzy
msgid ""
"In the Lean standard library, there are instances of the non-`Of` versions "
"of the classes defined in terms of the instances of the versions with `Of`. "
"In other words, implementing the `Of` version yields implementations of "
"both. It's generally a good idea to implement the `Of` version, and then "
"start writing programs using the non-`Of` versions of the class, "
"transitioning to the `Of` version if the output parameter becomes "
"inconvenient."
msgstr ""
"在 Lean 标准库中，有非 `Of` 版本的类实例，这些类实例是根据带有 `Of` 的版本实例定义的。换句话说，实现 `Of` "
"版本会产生两个版本。通常情况下，最好实现 `Of` 版本，然后开始使用非 `Of` 版本的类编写程序，如果输出参数变得不方便，则过渡到 `Of` 版本。"

#: src/monad-transformers/transformers.md:489
#, fuzzy
msgid "Transformers and `Id`"
msgstr "变换器和 `Id`"

#: src/monad-transformers/transformers.md:491
#, fuzzy
msgid ""
"The identity monad `Id` is the monad that has no effects whatsoever, to be "
"used in contexts that expect a monad for some reason but where none is "
"actually necessary. Another use of `Id` is to serve as the bottom of a stack"
" of monad transformers. For instance, `StateT σ Id` works just like `State "
"σ`."
msgstr ""
"恒等单子 `Id` 是没有任何效果的单子，用于在某些原因需要单子但实际上不需要单子的上下文中。`Id` "
"的另一个用途是作为单子变换器堆栈的底部。例如，`StateT σ Id` 的工作方式与 `State σ` 相同。"

#: src/monad-transformers/transformers.md:498
#, fuzzy
msgid "Monad Contract"
msgstr "单子契约"

#: src/monad-transformers/transformers.md:500
#, fuzzy
msgid ""
"Using pencil and paper, check that the rules of the monad transformer "
"contract are satisfied for each monad transformer in this section."
msgstr "使用纸笔，检查本节中每个单子变换器是否满足单子变换器契约的规则。"

#: src/monad-transformers/transformers.md:502
#, fuzzy
msgid "Logging Transformer"
msgstr "日志记录变换器"

#: src/monad-transformers/transformers.md:504
#, fuzzy
msgid ""
"Define a monad transformer version of `WithLog`. Also define the "
"corresponding type class `MonadWithLog`, and write a program that combines "
"logging and exceptions."
msgstr "定义 `WithLog` 的单子变换器版本。还要定义相应的类型类 `MonadWithLog`，并编写一个结合日志记录和异常的程序。"

#: src/monad-transformers/transformers.md:507
#, fuzzy
msgid "Counting Files"
msgstr "计数文件"

#: src/monad-transformers/transformers.md:509
#, fuzzy
msgid ""
"Modify `doug`'s monad with `StateT` such that it counts the number of "
"directories and files seen. At the end of execution, it should display a "
"report like:"
msgstr "使用 `StateT` 修改 `doug` 的单子，以便计算看到的目录和文件数。在执行结束时，它应显示类似以下的报告："

#: src/monad-transformers/order.md:3
#, fuzzy
msgid ""
"When composing a monad from a stack of monad transformers, it's important to"
" be aware that the order in which the monad transformers are layered "
"matters. Different orderings of the same set of transformers result in "
"different monads."
msgstr "在从单子变换器堆栈组合单子时，需要注意单子变换器分层的顺序很重要。同一组变换器的不同顺序会导致不同的单子。"

#: src/monad-transformers/order.md:6
#, fuzzy
msgid ""
"This version of `countLetters` is just like the previous version, except it "
"uses type classes to describe the set of available effects instead of "
"providing a concrete monad:"
msgstr "此版本的 `countLetters` 与前一个版本类似，不同之处在于它使用类型类来描述可用效果集，而不是提供一个具体的单子："

#: src/monad-transformers/order.md:24
#, fuzzy
msgid ""
"The state and exception monad transformers can be combined in two different "
"orders, each resulting in a monad that has instances of both type classes:"
msgstr "状态和异常单子转换器可以按两种不同的顺序组合，每种顺序都会生成一个同时具有这两个类型类的实例的单子："

#: src/monad-transformers/order.md:30
#, fuzzy
msgid ""
"When run on input for which the program does not throw an exception, both "
"monads yield similar results:"
msgstr "当在程序不抛出异常的输入上运行时，这两个单子都会产生类似的结果："

#: src/monad-transformers/order.md:31
msgid ""
"```lean\n"
"#eval countLetters (m := M1) \"hello\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:37
msgid ""
"```lean\n"
"#eval countLetters (m := M2) \"hello\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:43
#, fuzzy
msgid ""
"However, there is a subtle difference between these return values. In the "
"case of `M1`, the outermost constructor is `Except.ok`, and it contains a "
"pair of the unit constructor with the final state. In the case of `M2`, the "
"outermost constructor is the pair, which contains `Except.ok` applied only "
"to the unit constructor. The final state is outside of `Except.ok`. In both "
"cases, the program returns the counts of vowels and consonants."
msgstr ""
"然而，这些返回值之间存在细微差别。在 `M1` 的情况下，最外层的构造子是 `Except.ok`，它包含一个单元构造子和最终状态的元组。在 `M2` "
"的情况下，最外层的构造子是元组，它只包含应用于单元构造子的 `Except.ok`。最终状态在 `Except.ok` "
"之外。在这两种情况下，程序都会返回元音和辅音的计数。"

#: src/monad-transformers/order.md:49
#, fuzzy
msgid ""
"On the other hand, only one monad yields a count of vowels and consonants "
"when the string causes an exception to be thrown. Using `M1`, only an "
"exception value is returned:"
msgstr "另一方面，当字符串导致抛出异常时，只有一个单子会产生元音和辅音的计数。使用 `M1`，只返回一个异常值："

#: src/monad-transformers/order.md:51
msgid ""
"```lean\n"
"#eval countLetters (m := M1) \"hello!\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:57
#, fuzzy
msgid ""
"Using `M2`, the exception value is paired with the state as it was at the "
"time that the exception was thrown:"
msgstr "使用 `M2`，异常值与异常抛出时的状态配对："

#: src/monad-transformers/order.md:58
msgid ""
"```lean\n"
"#eval countLetters (m := M2) \"hello!\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:65
#, fuzzy
msgid ""
"It might be tempting to think that `M2` is superior to `M1` because it "
"provides more information that might be useful when debugging. The same "
"program might compute _different_ answers in `M1` than it does in `M2`, and "
"there's no principled reason to say that one of these answers is necessarily"
" better than the other. This can be seen by adding a step to the program "
"that handles exceptions:"
msgstr ""
"人们可能会倾向于认为 `M2` 优于 `M1`，因为它提供了更多信息，这在调试时可能很有用。同一个程序在 `M1` 中计算的答案可能与在 `M2` "
"中计算的不同，并且没有原则性的理由来说明其中一个答案一定比另一个更好。可以通过向程序中添加一个处理异常的步骤来看到这一点："

#: src/monad-transformers/order.md:68
msgid ""
"```lean\n"
"def countWithFallback\n"
"    [Monad m] [MonadState LetterCounts m] [MonadExcept Err m]\n"
"    (str : String) : m Unit :=\n"
"  try\n"
"    countLetters str\n"
"  catch _ =>\n"
"    countLetters \"Fallback\"\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:77
#, fuzzy
msgid ""
"This program always succeeds, but it might succeed with different results. "
"If no exception is thrown, then the results are the same as `countLetters`:"
msgstr "此程序始终成功，但可能获得不同的结果。如果未抛出异常，则结果与 `countLetters` 相同："

#: src/monad-transformers/order.md:79
msgid ""
"```lean\n"
"#eval countWithFallback (m := M1) \"hello\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:85
msgid ""
"```lean\n"
"#eval countWithFallback (m := M2) \"hello\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:91
#, fuzzy
msgid ""
"However, if the exception is thrown and caught, then the final states are "
"very different. With `M1`, the final state contains only the letter counts "
"from `\"Fallback\"`:"
msgstr "然而，如果抛出并捕获异常，则最终状态将非常不同。对于 `M1`，最终状态仅包含来自 `\"Fallback\"` 的字母计数："

#: src/monad-transformers/order.md:93
msgid ""
"```lean\n"
"#eval countWithFallback (m := M1) \"hello!\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:99
#, fuzzy
msgid ""
"With `M2`, the final state contains letter counts from both `\"hello\"` and "
"from `\"Fallback\"`, as one would expect in an imperative language:"
msgstr "对于 `M2`，最终状态包含来自 `\"hello\"` 和 `\"Fallback\"` 的字母计数，正如人们在命令式语言中所期望的那样："

#: src/monad-transformers/order.md:100
msgid ""
"```lean\n"
"#eval countWithFallback (m := M2) \"hello!\" ⟨0, 0⟩\n"
"```"
msgstr ""

#: src/monad-transformers/order.md:107
#, fuzzy
msgid ""
"In `M1`, throwing an exception \"rolls back\" the state to where the "
"exception was caught. In `M2`, modifications to the state persist across the"
" throwing and catching of exceptions. This difference can be seen by "
"unfolding the definitions of `M1` and `M2`. `M1 α` unfolds to `LetterCounts "
"→ Except Err (α × LetterCounts)`, and `M2 α` unfolds to `LetterCounts → "
"Except Err α × LetterCounts`. That is to say, `M1 α` describes functions "
"that take an initial letter count, returning either an error or an `α` "
"paired with updated counts. When an exception is thrown in `M1`, there is no"
" final state. `M2 α` describes functions that take an initial letter count "
"and return a new letter count paired with either an error or an `α`. When an"
" exception is thrown in `M2`, it is accompanied by a state."
msgstr ""
"在 `M1` 中，抛出异常会将状态「回滚」到捕获异常的位置。在 `M2` 中，对状态的修改会持续存在于异常的抛出和捕获过程中。可以通过展开 `M1` 和"
" `M2` 的定义来观察到这种差异。`M1 α` 展开为 `LetterCounts → Except Err (α × "
"LetterCounts)`，而 `M2 α` 展开为 `LetterCounts → Except Err α × "
"LetterCounts`。也就是说，`M1 α` 描述了获取初始字母计数并返回错误或与更新计数配对的 `α` 的函数。当在 `M1` "
"中抛出异常时，没有最终状态。`M2 α` 描述了获取初始字母计数并返回与错误或 `α` 配对的新字母计数的函数。当在 `M2` "
"中抛出异常时，它会伴随一个状态。"

#: src/monad-transformers/order.md:116
#, fuzzy
msgid "Commuting Monads"
msgstr "可交换单子"

#: src/monad-transformers/order.md:118
#, fuzzy
msgid ""
"In the jargon of functional programming, two monad transformers are said to "
"_commute_ if they can be re-ordered without the meaning of the program "
"changing. The fact that the result of the program can differ when `StateT` "
"and `ExceptT` are reordered means that state and exceptions do not commute. "
"In general, monad transformers should not be expected to commute."
msgstr ""
"在函数式编程的术语中，如果两个单子变换器可以重新排序而不会改变程序的含义，则称它们为 _可交换_。`StateT` 和 `ExceptT` "
"重新排序后程序结果可能不同的事实意味着状态和异常不可交换。通常，不应期望单子变换器可交换。"

#: src/monad-transformers/order.md:122
#, fuzzy
msgid ""
"Even though not all monad transformers commute, some do. For example, two "
"uses of `StateT` can be re-ordered. Expanding the definitions in `StateT σ "
"(StateT σ' Id) α` yields the type `σ → σ' → ((α × σ) × σ')`, and `StateT σ' "
"(StateT σ Id) α` yields `σ' → σ → ((α × σ') × σ)`. In other words, the "
"differences between them are that they nest the `σ` and `σ'` types in "
"different places in the return type, and they accept their arguments in a "
"different order. Any client code will still need to provide the same inputs,"
" and it will still receive the same outputs."
msgstr ""
"尽管并非所有单子变换器都可以交换，但有些可以。例如，`StateT` 的两个用法可以重新排序。展开 `StateT σ (StateT σ' Id) "
"α` 中的定义会得到类型 `σ → σ' → ((α × σ) × σ')`，而 `StateT σ' (StateT σ Id) α` 会得到 `σ'"
" → σ → ((α × σ') × σ)`。换句话说，它们之间的区别在于它们在返回类型中嵌套 `σ` 和 `σ'` "
"类型的不同位置，并且它们以不同的顺序接受它们的输入。任何客户端代码仍然需要提供相同的输入，并且它仍然会接收相同的输出。"

#: src/monad-transformers/order.md:128
#, fuzzy
msgid ""
"Most programming languages that have both mutable state and exceptions work "
"like `M2`. In those languages, state that _should_ be rolled back when an "
"exception is thrown is difficult to express, and it usually needs to be "
"simulated in a manner that looks much like the passing of explicit state "
"values in `M1`. Monad transformers grant the freedom to choose an "
"interpretation of effect ordering that works for the problem at hand, with "
"both choices being equally easy to program with. However, they also require "
"care to be taken in the choice of ordering of transformers. With great "
"expressive power comes the responsibility to check that what's being "
"expressed is what is intended, and the type signature of `countWithFallback`"
" is probably more polymorphic than it should be."
msgstr ""
"大多数同时具有可变状态和异常的编程语言都像 `M2` 一样工作。在这些语言中，当抛出异常时应该回滚的状态很难表示，并且通常需要以非常类似于在 `M1` "
"中传递显式状态值的方式来模拟它。单子变换器赋予了选择一种适用于手头问题的效应顺序解释的自由，并且两种选择都同样容易编程。然而，它们也需要在选择变换器的顺序时小心。强大的表现力带来了检查所表达的内容是否符合预期，以及"
" `countWithFallback` 的类型签名可能比它应该的更具多态性的责任。"

#: src/monad-transformers/order.md:137
#, fuzzy
msgid ""
"Check that `ReaderT` and `StateT` commute by expanding their definitions and"
" reasoning about the resulting types."
msgstr "通过展开它们的定义并推理结果类型，检查 `ReaderT` 和 `StateT` 是否交换。"

#: src/monad-transformers/order.md:138
#, fuzzy
msgid ""
"Do `ReaderT` and `ExceptT` commute? Check your answer by expanding their "
"definitions and reasoning about the resulting types."
msgstr "`ReaderT` 和 `ExceptT` 是否交换？通过展开它们的定义并推理结果类型来检查你的答案。"

#: src/monad-transformers/order.md:139
#, fuzzy
msgid ""
"Construct a monad transformer `ManyT` based on the definition of `Many`, "
"with a suitable `Alternative` instance. Check that it satisfies the `Monad` "
"contract."
msgstr ""
"基于 `Many` 的定义构造单子变换器 `ManyT`，并提供一个合适的 `Alternative` 实例。检查它是否满足 `Monad` 契约。"

#: src/monad-transformers/order.md:140
#, fuzzy
msgid ""
"Does `ManyT` commute with `StateT`? If so, check your answer by expanding "
"definitions and reasoning about the resulting types. If not, write a program"
" in `ManyT (StateT σ Id)` and a program in `StateT σ (ManyT Id)`. Each "
"program should be one that makes more sense for the given ordering of monad "
"transformers."
msgstr ""
"`ManyT` 是否与 `StateT` 可交换？如果是，请通过展开定义并推理结果类型来检查你的答案。如果不是，请在 `ManyT (StateT σ "
"Id)` 和 `StateT σ (ManyT Id)` 中编写一个程序。每个程序都应该更适合给定的单子变换器顺序。"

#: src/monad-transformers/do.md:1
#, fuzzy
msgid "More do Features"
msgstr "更多特性"

#: src/monad-transformers/do.md:3
#, fuzzy
msgid ""
"Lean's `do`\\-notation provides a syntax for writing programs with monads "
"that resembles imperative programming languages. In addition to providing a "
"convenient syntax for programs with monads, `do`\\-notation provides syntax "
"for using certain monad transformers."
msgstr ""
"Lean 的 `do` 语法提供了一种语法，用于编写类似于命令式编程语言的单子程序。除了为单子程序提供方便的语法外，`do` "
"语法还提供了使用某些单子变换器的语法。"

#: src/monad-transformers/do.md:6
#, fuzzy
msgid "Single-Branched `if`"
msgstr "单分支 `if`"

#: src/monad-transformers/do.md:8
#, fuzzy
msgid ""
"When working in a monad, a common pattern is to carry out a side effect only"
" if some condition is true. For instance, `countLetters` contains a check "
"for vowels or consonants, and letters that are neither have no effect on the"
" state. This is captured by having the `else` branch evaluate to `pure ()`, "
"which has no effects:"
msgstr ""
"在单子中工作时，一个常见的模式是在某个条件为真时执行副作用。例如，`countLetters` "
"包含对元音或辅音的检查，而既不是元音也不是辅音的字母对状态没有影响。这可以通过让 `else` 分支求值为 `pure ()` 来实现，`pure "
"()` 没有副作用："

#: src/monad-transformers/do.md:29
#, fuzzy
msgid ""
"When an `if` is a statement in a `do`\\-block, rather than being an "
"expression, then `else pure ()` can simply be omitted, and Lean inserts it "
"automatically. The following definition of `countLetters` is completely "
"equivalent:"
msgstr ""
"当 `if` 是 `do` 块中的一个语句，而不是一个表达式时，`else pure ()` 可以简单地省略，Lean 会自动插入它。以下 "
"`countLetters` 的定义完全等效："

#: src/monad-transformers/do.md:46
#, fuzzy
msgid ""
"A program that uses a state monad to count the entries in a list that "
"satisfy some monadic check can be written as follows:"
msgstr "一个使用状态单子来计算列表中满足某个单子检查的项的程序可以写成如下形式："

#: src/monad-transformers/do.md:56
#, fuzzy
msgid ""
"Similarly, `if not E1 then STMT...` can instead be written `unless E1 do "
"STMT...`. The converse of `count` that counts entries that don't satisfy the"
" monadic check can be written by replacing `if` with `unless`:"
msgstr ""
"类似地，`if not E1 then STMT...` 可以写成 `unless E1 do STMT...`。`count` "
"的反向，即计算不满足单子检查的项，可以通过用 `unless` 替换 `if` 来编写："

#: src/monad-transformers/do.md:67
#, fuzzy
msgid ""
"Understanding single-branched `if` and `unless` does not require thinking "
"about monad transformers. They simply replace the missing branch with `pure "
"()`. The remaining extensions in this section, however, require Lean to "
"automatically rewrite the `do`\\-block to add a local transformer on top of "
"the monad that the `do`\\-block is written in."
msgstr ""
"理解单分支 `if` 和 `unless` 无需考虑单子变换器。它们只是用 `pure ()` 替换缺失的分支。然而，本节中剩余的扩展需要 Lean "
"自动重写 `do` 块，以在 `do` 块所写单子的顶部添加一个局部变换器。"

#: src/monad-transformers/do.md:71
#, fuzzy
msgid "Early Return"
msgstr "提前返回"

#: src/monad-transformers/do.md:73
#, fuzzy
msgid ""
"The standard library contains a function `List.find?` that returns the first"
" entry in a list that satisfies some check. A simple implementation that "
"doesn't make use of the fact that `Option` is a monad loops over the list "
"using a recursive function, with an `if` to stop the loop when the desired "
"entry is found:"
msgstr ""
"标准库包含一个函数 `List.find?`，它返回列表中满足某个检查的第一个条目。一个简单的实现不利用 `Option` "
"是一个单子的事实，而是使用递归函数遍历列表，并使用 `if` 在找到所需条目时停止循环："

#: src/monad-transformers/do.md:85
#, fuzzy
msgid ""
"Imperative languages typically sport the `return` keyword that aborts the "
"execution of a function, immediately returning some value to the caller. In "
"Lean, this is available in `do`\\-notation, and `return` halts the execution"
" of a `do`\\-block, with `return`'s argument being the value returned from "
"the monad. In other words, `List.find?` could have been written like this:"
msgstr ""
"命令式语言通常使用 `return` 关键字中止函数的执行，立即向调用者返回某个值。在 Lean 中，这在 `do` 符号中可用，`return` 停止"
" `do` 块的执行，`return` 的参数是单子返回的值。换句话说，`List.find?` 可以这样编写："

#: src/monad-transformers/do.md:96
#, fuzzy
msgid ""
"Early return in imperative languages is a bit like an exception that can "
"only cause the current stack frame to be unwound. Both early return and "
"exceptions terminate execution of a block of code, effectively replacing the"
" surrounding code with the thrown value. Behind the scenes, early return in "
"Lean is implemented using a version of `ExceptT`. Each `do`\\-block that "
"uses early return is wrapped in an exception handler (in the sense of the "
"function `tryCatch`). Early returns are translated to throwing the value as "
"an exception, and the handlers catch the thrown value and return it "
"immediately. In other words, the `do`\\-block's original return value type "
"is also used as the exception type."
msgstr ""
"命令式语言中的提前返回有点像一个异常，它只能导致当前堆栈帧被展开。提前返回和异常都会终止代码块的执行，有效地用抛出的值替换周围的代码。在幕后，Lean "
"中的提前返回是使用 `ExceptT` 的一个版本实现的。每个使用提前返回的 `do` 块都被包装在一个异常处理程序中（在函数 `tryCatch` "
"的意义上）。提前返回被转换为将值作为异常抛出，处理程序捕获抛出的值并立即返回它。换句话说，`do` 块的原始返回值类型也用作异常类型。"

#: src/monad-transformers/do.md:103
#, fuzzy
msgid ""
"Making this more concrete, the helper function `runCatch` strips a layer of "
"`ExceptT` from the top of a monad transformer stack when the exception type "
"and return type are the same:"
msgstr "具体来说，辅助函数 `runCatch` 从单子变换器栈的顶部剥离一层 `ExceptT`，当异常类型和返回类型相同时："

#: src/monad-transformers/do.md:110
#, fuzzy
msgid ""
"The `do`\\-block in `List.find?` that uses early return is translated to a "
"`do`\\-block that does not use early return by wrapping it in a use of "
"`runCatch`, and replacing early returns with `throw`:"
msgstr ""
"`List.find?` 中使用提前返回的 `do` 块被翻译为不使用提前返回的 `do` 块，方法是将其包装在 `runCatch` "
"的使用中，并将提前返回替换为 `throw`："

#: src/monad-transformers/do.md:120
#, fuzzy
msgid ""
"Another situation in which early return is useful is command-line "
"applications that terminate early if the arguments or input are incorrect. "
"Many programs begin with a section that validates arguments and inputs "
"before proceeding to the main body of the program. The following version of "
"[the greeting program `hello-name`](../hello-world/running-a-program.md) "
"checks that no command-line arguments were provided:"
msgstr ""
"提前返回有用的另一个情况是命令行应用程序，如果参数或输入不正确，则提前终止。许多程序从验证参数和输入的部分开始，然后再进入程序的主体。以下版本的 "
"[问候程序 `hello-name`](../hello-world/running-a-program.md) 检查是否未提供命令行参数："

#: src/monad-transformers/do.md:123
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  let stderr ← IO.getStderr\n"
"\n"
"  unless argv == [] do\n"
"    stderr.putStrLn s!\"Expected no arguments, but got {argv.length}\"\n"
"    return 1\n"
"\n"
"  stdout.putStrLn \"How would you like to be addressed?\"\n"
"  stdout.flush\n"
"\n"
"  let name := (← stdin.getLine).trim\n"
"  if name == \"\" then\n"
"    stderr.putStrLn s!\"No name provided\"\n"
"    return 1\n"
"\n"
"  stdout.putStrLn s!\"Hello, {name}!\"\n"
"\n"
"  return 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:145
#, fuzzy
msgid ""
"Running it with no arguments and typing the name `David` yields the same "
"result as the previous version:"
msgstr "在没有参数的情况下运行它并键入名称 `David` 会产生与以前版本相同的结果："

#: src/monad-transformers/do.md:153
#, fuzzy
msgid ""
"Providing the name as a command-line argument instead of an answer causes an"
" error:"
msgstr "将名称作为命令行参数而不是答案提供会导致错误："

#: src/monad-transformers/do.md:159
#, fuzzy
msgid "And providing no name causes the other error:"
msgstr "不提供名称会导致另一个错误："

#: src/monad-transformers/do.md:167
#, fuzzy
msgid ""
"The program that uses early return avoids needing to nest the control flow, "
"as is done in this version that does not use early return:"
msgstr "使用提前返回的程序避免了嵌套控制流的需要，就像不使用提前返回的这个版本所做的那样："

#: src/monad-transformers/do.md:168
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  let stdin ← IO.getStdin\n"
"  let stdout ← IO.getStdout\n"
"  let stderr ← IO.getStderr\n"
"\n"
"  if argv != [] then\n"
"    stderr.putStrLn s!\"Expected no arguments, but got {argv.length}\"\n"
"    pure 1\n"
"  else\n"
"    stdout.putStrLn \"How would you like to be addressed?\"\n"
"    stdout.flush\n"
"\n"
"    let name := (← stdin.getLine).trim\n"
"    if name == \"\" then\n"
"      stderr.putStrLn s!\"No name provided\"\n"
"      pure 1\n"
"    else\n"
"      stdout.putStrLn s!\"Hello, {name}!\"\n"
"      pure 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:190
#, fuzzy
msgid ""
"One important difference between early return in Lean and early return in "
"imperative languages is that Lean's early return applies only to the current"
" `do`\\-block. When the entire definition of a function is in the same `do` "
"block, this difference doesn't matter. But if `do` occurs underneath some "
"other structures, then the difference becomes apparent. For example, given "
"the following definition of `greet`:"
msgstr ""
"Lean 中的提前返回与命令式语言中的提前返回之间的一个重要区别是，Lean 的提前返回仅适用于当前的 `do` 块。当函数的整个定义都在同一个 "
"`do` 块中时，这个区别并不重要。但是，如果 `do` 出现在其他一些结构体的下面，那么差异就会变得明显。例如，给定以下 `greet` 的定义："

#: src/monad-transformers/do.md:194
msgid ""
"```lean\n"
"def greet (name : String) : String :=\n"
"  \"Hello, \" ++ Id.run do return name\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:198
#, fuzzy
msgid ""
"the expression `greet \"David\"` evaluates to `\"Hello, David\"`, not just "
"`\"David\"`."
msgstr "表达式 `greet \"David\"` 求值为 `\"Hello, David\"`, 而不是 `\"David\"`。"

#: src/monad-transformers/do.md:200
#, fuzzy
msgid "Loops"
msgstr "循环"

#: src/monad-transformers/do.md:202
#, fuzzy
msgid ""
"Just as every program with mutable state can be rewritten to a program that "
"passes the state as arguments, every loop can be rewritten as a recursive "
"function. From one perspective, `List.find?` is most clear as a recursive "
"function. After all, its definition mirrors the structure of the list: if "
"the head passes the check, then it should be returned; otherwise look in the"
" tail. When no more entries remain, the answer is `none`. From another "
"perspective, `List.find?` is most clear as a loop. After all, the program "
"consults the entries in order until a satisfactory one is found, at which "
"point it terminates. If the loop terminates without having returned, the "
"answer is `none`."
msgstr ""
"就像每个带有可变状态的程序都可以重写为将状态作为参数传递的程序一样，每个循环都可以重写为递归函数。从一个角度来看，`List.find?` "
"最清楚地表现为递归函数。毕竟，它的定义反映了列表的结构体：如果头部通过检查，则应返回它；否则在尾部查找。当没有更多条目时，答案是 "
"`none`。从另一个角度来看，`List.find?` "
"最清楚地表现为循环。毕竟，程序按顺序查询条目，直到找到令人满意的条目，然后终止。如果循环在没有返回的情况下终止，则答案是 `none`。"

#: src/monad-transformers/do.md:210
#, fuzzy
msgid "Looping with ForM"
msgstr "使用 ForM 循环"

#: src/monad-transformers/do.md:212
#, fuzzy
msgid ""
"Lean includes a type class that describes looping over a container type in "
"some monad. This class is called `ForM`:"
msgstr "Lean 包含一个类型类，用于描述在某个单子中循环遍历容器类型。此类称为 `ForM`："

#: src/monad-transformers/do.md:218
#, fuzzy
msgid ""
"This class is quite general. The parameter `m` is a monad with some desired "
"effects, `γ` is the collection to be looped over, and `α` is the type of "
"elements from the collection. Typically, `m` is allowed to be any monad, but"
" it is possible to have a data structure that e.g. only supports looping in "
"`IO`. The method `forM` takes a collection, a monadic action to be run for "
"its effects on each element from the collection, and is then responsible for"
" running the actions."
msgstr ""
"此类非常通用。参数 `m` 是具有某些所需效果的单子，`γ` 是要循环遍历的集合，`α` 是集合中元素的类型。通常，`m` "
"可以是任何单子，但可以有一个数据结构体，例如仅支持在 `IO` 中循环。`forM` "
"方法获取一个集合，一个单子操作以对其集合中的每个元素产生效果，然后负责运行这些操作。"

#: src/monad-transformers/do.md:223
#, fuzzy
msgid ""
"The instance for `List` allows `m` to be any monad, it sets `γ` to be `List "
"α`, and sets the class's `α` to be the same `α` found in the list:"
msgstr "`List` 的实例允许 `m` 是任何单子，它将 `γ` 设置为 `List α`，并将类的 `α` 设置为列表中找到的相同 `α`："

#: src/monad-transformers/do.md:234
#, fuzzy
msgid ""
"The [function `doList` from `doug`](reader-io.md#implementation) is `forM` "
"for lists. Because `forM` is intended to be used in `do`\\-blocks, it uses "
"`Monad` rather than `Applicative`. `forM` can be used to make `countLetters`"
" much shorter:"
msgstr ""
"`doList` 函数（来自 `doug`）是列表的 `forM`。因为 `forM` 旨在用于 `do` 块中，所以它使用 `Monad` 而不是 "
"`Applicative`。`forM` 可用于使 `countLetters` 变得更短："

#: src/monad-transformers/do.md:249
#, fuzzy
msgid "The instance for `Many` is very similar:"
msgstr "`Many` 的实例非常相似："

#: src/monad-transformers/do.md:261
#, fuzzy
msgid ""
"Because `γ` can be any type at all, `ForM` can support non-polymorphic "
"collections. A very simple collection is one of the natural numbers less "
"than some given number, in reverse order:"
msgstr "因为 `γ` 可以是任何类型，所以 `ForM` 可以支持非多态集合。一个非常简单的集合是小于某个给定数字的自然数之一，按逆序排列："

#: src/monad-transformers/do.md:267
#, fuzzy
msgid "Its `forM` operator applies the provided action to each smaller `Nat`:"
msgstr "它的 `forM` 运算符将提供的操作应用于每个较小的 `Nat`："

#: src/monad-transformers/do.md:280
#, fuzzy
msgid ""
"Running `IO.println` on each number less than five can be accomplished with "
"`forM`:"
msgstr "在小于 5 的每个数字上运行 `IO.println` 可以通过 `forM` 完成："

#: src/monad-transformers/do.md:292
#, fuzzy
msgid ""
"An example `ForM` instance that works only in a particular monad is one that"
" loops over the lines read from an IO stream, such as standard input:"
msgstr "一个仅在特定单子中工作的 `ForM` 实例示例是循环遍历从 IO 流（例如标准输入）读取的行："

#: src/monad-transformers/do.md:293
msgid ""
"```lean\n"
"structure LinesOf where\n"
"  stream : IO.FS.Stream\n"
"\n"
"partial def LinesOf.forM (readFrom : LinesOf) (action : String → IO Unit) : IO Unit := do\n"
"  let line ← readFrom.stream.getLine\n"
"  if line == \"\" then return ()\n"
"  action line\n"
"  forM readFrom action\n"
"\n"
"instance : ForM IO LinesOf String where\n"
"  forM := LinesOf.forM\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:306
#, fuzzy
msgid ""
"The definition of `forM` is marked `partial` because there is no guarantee "
"that the stream is finite. In this case, `IO.FS.Stream.getLine` works only "
"in the `IO` monad, so no other monad can be used for looping."
msgstr ""
"`forM` 的定义标记为 `partial`，因为无法保证流是有限的。在这种情况下，`IO.FS.Stream.getLine` 仅在 `IO` "
"单子中工作，因此无法使用其他单子进行循环。"

#: src/monad-transformers/do.md:309
#, fuzzy
msgid ""
"This example program uses this looping construct to filter out lines that "
"don't contain letters:"
msgstr "此示例程序使用此循环构造来过滤不包含字母的行："

#: src/monad-transformers/do.md:310
msgid ""
"```lean\n"
"def main (argv : List String) : IO UInt32 := do\n"
"  if argv != [] then\n"
"    IO.eprintln \"Unexpected arguments\"\n"
"    return 1\n"
"\n"
"  forM (LinesOf.mk (← IO.getStdin)) fun line => do\n"
"    if line.any (·.isAlpha) then\n"
"      IO.print line\n"
"\n"
"  return 0\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:322
#, fuzzy
msgid "The file `test-data` contains:"
msgstr "`test-data` 文件包含："

#: src/monad-transformers/do.md:331
#, fuzzy
msgid ""
"Invoking this program, which is stored in `ForMIO.lean`, yields the "
"following output:"
msgstr "调用存储在 `ForMIO.lean` 中的此程序会产生以下输出："

#: src/monad-transformers/do.md:339
#, fuzzy
msgid "Stopping Iteration"
msgstr "停止迭代"

#: src/monad-transformers/do.md:341
#, fuzzy
msgid ""
"Terminating a loop early is difficult to do with `forM`. Writing a function "
"that iterates over the `Nat`s in an `AllLessThan` only until `3` is reached "
"requires a means of stopping the loop partway through. One way to achieve "
"this is to use `forM` with the `OptionT` monad transformer. The first step "
"is to define `OptionT.exec`, which discards information about both the "
"return value and whether or not the transformed computation succeeded:"
msgstr ""
"使用 `forM` 很难提前终止循环。编写一个函数来迭代 `AllLessThan` 中的 `Nat` 直到达到 "
"`3`，需要一种方法来中途停止循环。实现此目的的一种方法是将 `forM` 与 `OptionT` 单子转换器一起使用。第一步是定义 "
"`OptionT.exec`，它会丢弃有关返回值以及转换后的计算是否成功的信息："

#: src/monad-transformers/do.md:349
#, fuzzy
msgid ""
"Then, failure in the `OptionT` instance of `Alternative` can be used to "
"terminate looping early:"
msgstr "然后，`Alternative` 的 `OptionT` 实例中的失败可用于提前终止循环："

#: src/monad-transformers/do.md:356
#, fuzzy
msgid "A quick test demonstrates that this solution works:"
msgstr "快速测试表明此解决方案有效："

#: src/monad-transformers/do.md:367
#, fuzzy
msgid ""
"However, this code is not so easy to read. Terminating a loop early is a "
"common task, and Lean provides more syntactic sugar to make this easier. "
"This same function can also be written as follows:"
msgstr "然而，这段代码不太容易阅读。提前终止循环是一项常见任务，而 Lean 提供了更多语法糖来简化此操作。此函数还可以写成如下形式："

#: src/monad-transformers/do.md:377
#, fuzzy
msgid "Testing it reveals that it works just like the prior version:"
msgstr "测试表明它与之前的版本一样有效："

#: src/monad-transformers/do.md:388
#, fuzzy
msgid ""
"At the time of writing, the `for ... in ... do ...` syntax desugars to the "
"use of a type class called `ForIn`, which is a somewhat more complicated "
"version of `ForM` that keeps track of state and early termination. However, "
"there is a plan to refactor `for` loops to use the simpler `ForM`, with "
"monad transformers inserted as necessary. In the meantime, an adapter is "
"provided that converts a `ForM` instance into a `ForIn` instance, called "
"`ForM.forIn`. To enable `for` loops based on a `ForM` instance, add "
"something like the following, with appropriate replacements for "
"`AllLessThan` and `Nat`:"
msgstr ""
"在撰写本文时，`for ... in ... do ...` 语法反糖化为使用一个名为 `ForIn` 的类型类，它是 `ForM` "
"的一个稍微复杂一些的版本，它跟踪状态和提前终止。然而，有一个计划重构 `for` 循环以使用更简单的 "
"`ForM`，并在必要时插入单子变换器。在此期间，提供了一个适配器，它将 `ForM` 实例转换为 `ForIn` 实例，称为 "
"`ForM.forIn`。要启用基于 `ForM` 实例的 `for` 循环，请添加类似以下内容，并用 `AllLessThan` 和 `Nat` "
"的适当替换项替换："

#: src/monad-transformers/do.md:396
#, fuzzy
msgid ""
"Note, however, that this adapter only works for `ForM` instances that keep "
"the monad unconstrained, as most of them do. This is because the adapter "
"uses `StateT` and `ExceptT`, rather than the underlying monad."
msgstr ""
"但是，请注意，此适配器仅适用于保持单子不受约束的 `ForM` 实例，就像大多数实例一样。这是因为该适配器使用 `StateT` 和 "
"`ExceptT`，而不是底层单子。"

#: src/monad-transformers/do.md:399
#, fuzzy
msgid ""
"Early return is supported in `for` loops. The translation of `do` blocks "
"with early return into a use of an exception monad transformer applies "
"equally well underneath `forM` as the earlier use of `OptionT` to halt "
"iteration does. This version of `List.find?` makes use of both:"
msgstr ""
"`for` 循环支持提前返回。将带有提前返回的 `do` 块翻译成使用异常单子变换器同样适用于 `forM`，就像之前使用 `OptionT` "
"停止迭代一样。`List.find?` 的此版本同时使用了这两个功能："

#: src/monad-transformers/do.md:409
#, fuzzy
msgid ""
"In addition to `break`, `for` loops support `continue` to skip the rest of "
"the loop body in an iteration. An alternative (but confusing) formulation of"
" `List.find?` skips elements that don't satisfy the check:"
msgstr ""
"除了 `break` 之外，`for` 循环还支持 `continue` 以在迭代中跳过循环体的其余部分。`List.find?` "
"的另一种（但令人困惑的）公式跳过不满足检查的元素："

#: src/monad-transformers/do.md:419
#, fuzzy
msgid ""
"A `Range` is a structure that consists of a starting number, an ending "
"number, and a step. They represent a sequence of natural numbers, from the "
"starting number to the ending number, increasing by the step each time. Lean"
" has special syntax to construct ranges, consisting of square brackets, "
"numbers, and colons that comes in four varieties. The stopping point must "
"always be provided, while the start and the step are optional, defaulting to"
" `0` and `1`, respectively:"
msgstr ""
"区间`Range`是一个结构体，由起始数、终止数和步长组成。它们表示从起始数到终止数的自然数序列，每次增加步长。Lean "
"有特殊的语法来构造区间，包括方括号、数字和冒号，共有四种类型。终止点必须始终提供，而起始点和步长是可选的，分别默认为 `0` 和 `1`："

#: src/monad-transformers/do.md:424
#, fuzzy
msgid "Start"
msgstr "起始"

#: src/monad-transformers/do.md:424
#, fuzzy
msgid "Stop"
msgstr "终止"

#: src/monad-transformers/do.md:424
#, fuzzy
msgid "Step"
msgstr "步长"

#: src/monad-transformers/do.md:424
#, fuzzy
msgid "As List"
msgstr "作为列表"

#: src/monad-transformers/do.md:426
#, fuzzy
msgid "`[:10]`"
msgstr "`[:10]`"

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:428
#, fuzzy
msgid "`0`"
msgstr "`0`"

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:427
#: src/monad-transformers/do.md:428 src/monad-transformers/do.md:429
#, fuzzy
msgid "`10`"
msgstr "`10`"

#: src/monad-transformers/do.md:426 src/monad-transformers/do.md:427
#, fuzzy
msgid "`1`"
msgstr "`1`"

#: src/monad-transformers/do.md:426
#, fuzzy
msgid "`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`"
msgstr "`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`"

#: src/monad-transformers/do.md:427
#, fuzzy
msgid "`[2:10]`"
msgstr "`[2:10]`"

#: src/monad-transformers/do.md:427 src/monad-transformers/do.md:429
#, fuzzy
msgid "`2`"
msgstr "`2`"

#: src/monad-transformers/do.md:427
#, fuzzy
msgid "`[2, 3, 4, 5, 6, 7, 8, 9]`"
msgstr "`[2, 3, 4, 5, 6, 7, 8, 9]`"

#: src/monad-transformers/do.md:428
#, fuzzy
msgid "`[:10:3]`"
msgstr "`[:10:3]`"

#: src/monad-transformers/do.md:428 src/monad-transformers/do.md:429
#, fuzzy
msgid "`3`"
msgstr "`3`"

#: src/monad-transformers/do.md:428
#, fuzzy
msgid "`[0, 3, 6, 9]`"
msgstr "`[0, 3, 6, 9]`"

#: src/monad-transformers/do.md:429
#, fuzzy
msgid "`[2:10:3]`"
msgstr "`[2:10:3]`"

#: src/monad-transformers/do.md:429
#, fuzzy
msgid "`[2, 5, 8]`"
msgstr "`[2, 5, 8]`"

#: src/monad-transformers/do.md:431
#, fuzzy
msgid ""
"Note that the starting number _is_ included in the range, while the stopping"
" numbers is not. All three arguments are `Nat`s, which means that ranges "
"cannot count down—a range where the starting number is greater than or equal"
" to the stopping number simply contains no numbers."
msgstr ""
"请注意，起始数包含在区间中，而终止数不包含。所有三个参数都是 `Nat`，这意味着区间不能倒数——起始数大于或等于终止数的区间不包含任何数字。"

#: src/monad-transformers/do.md:434
#, fuzzy
msgid ""
"Ranges can be used with `for` loops to draw numbers from the range. This "
"program counts even numbers from four to eight:"
msgstr "区间可以与 `for` 循环一起使用，从区间中提取数字。此程序计算从四到八的偶数："

#: src/monad-transformers/do.md:441
#, fuzzy
msgid "Running it yields:"
msgstr "运行它会产生："

#: src/monad-transformers/do.md:449
#, fuzzy
msgid ""
"Finally, `for` loops support iterating over multiple collections in "
"parallel, by separating the `in` clauses with commas. Looping halts when the"
" first collection runs out of elements, so the declaration:"
msgstr "最后，`for` 循环支持通过用逗号分隔 `in` 子句来并行迭代多个集合。当第一个集合中的元素用完时，循环停止，因此声明："

#: src/monad-transformers/do.md:451
msgid ""
"```lean\n"
"def parallelLoop := do\n"
"  for x in [\"currant\", \"gooseberry\", \"rowan\"], y in [4:8] do\n"
"    IO.println (x, y)\n"
"```"
msgstr ""

#: src/monad-transformers/do.md:456
#, fuzzy
msgid "produces three lines of output:"
msgstr "会产生三行输出："

#: src/monad-transformers/do.md:466
#, fuzzy
msgid "Mutable Variables"
msgstr "可变变量"

#: src/monad-transformers/do.md:468
#, fuzzy
msgid ""
"In addition to early `return`, `else`\\-less `if`, and `for` loops, Lean "
"supports local mutable variables within a `do` block. Behind the scenes, "
"these mutable variables desugar to a use of `StateT`, rather than being "
"implemented by true mutable variables. Once again, functional programming is"
" used to simulate imperative programming."
msgstr ""
"除了早期 `return`、没有 `else` 的 `if` 和 `for` 循环之外，Lean 还支持 `do` "
"块中的局部可变变量。在幕后，这些可变变量会转化为使用 `StateT`，而不是通过真正的可变变量实现。再一次，函数式编程被用来模拟命令式编程。"

#: src/monad-transformers/do.md:472
#, fuzzy
msgid ""
"A local mutable variable is introduced with `let mut` instead of plain "
"`let`. The definition `two`, which uses the identity monad `Id` to enable "
"`do`\\-syntax without introducing any effects, counts to `2`:"
msgstr ""
"局部可变变量使用 `let mut` 而不是 `let` 引入。使用恒等单子 `Id` 以启用 `do` 语法而不引入任何效果的定义 `two` 计数到"
" `2`："

#: src/monad-transformers/do.md:481
#, fuzzy
msgid ""
"This code is equivalent to a definition that uses `StateT` to add `1` twice:"
msgstr "此代码等效于使用 `StateT` 两次添加 `1` 的定义："

#: src/monad-transformers/do.md:492
#, fuzzy
msgid ""
"Local mutable variables work well with all the other features of "
"`do`\\-notation that provide convenient syntax for monad transformers. The "
"definition `three` counts the number of entries in a three-entry list:"
msgstr "局部可变变量与 `do` 符号的所有其他功能配合良好，这些功能为单子转换器提供了便捷的语法。定义 `three` 统计三项列表中的项数："

#: src/monad-transformers/do.md:501
#, fuzzy
msgid "Similarly, `six` adds the entries in a list:"
msgstr "类似地，`six` 添加列表中的项："

#: src/monad-transformers/do.md:510
#, fuzzy
msgid ""
"`List.count` counts the number of entries in a list that satisfy some check:"
msgstr "`List.count` 统计满足某个检查的列表中的项数："

#: src/monad-transformers/do.md:519
#, fuzzy
msgid ""
"Local mutable variables can be more convenient to use and easier to read "
"than an explicit local use of `StateT`. However, they don't have the full "
"power of unrestricted mutable variables from imperative languages. In "
"particular, they can only be modified in the `do`\\-block in which they are "
"introduced. This means, for instance, that `for`\\-loops can't be replaced "
"by otherwise-equivalent recursive helper functions. This version of "
"`List.count`:"
msgstr ""
"局部可变变量比显式局部使用 `StateT` 更方便、更易读。但是，它们没有命令式语言中不受限制的可变变量的全部功能。特别是，它们只能在引入它们的 "
"`do` 块中修改。这意味着，例如，`for` 循环不能被其他等效的递归辅助函数替换。此版本的 `List.count`："

#: src/monad-transformers/do.md:534
#, fuzzy
msgid "yields the following error on the attempted mutation of `found`:"
msgstr "在尝试修改 `found` 时产生以下错误："

#: src/monad-transformers/do.md:538
#, fuzzy
msgid ""
"This is because the recursive function is written in the identity monad, and"
" only the monad of the `do`\\-block in which the variable is introduced is "
"transformed with `StateT`."
msgstr "这是因为递归函数是用恒等单子编写的，并且只有引入变量的 `do` 块的单子才使用 `StateT` 转换。"

#: src/monad-transformers/do.md:540
#, fuzzy
msgid "What counts as a `do` block?"
msgstr "什么算作 `do` 块？"

#: src/monad-transformers/do.md:542
#, fuzzy
msgid ""
"Many features of `do`\\-notation apply only to a single `do`\\-block. Early "
"return terminates the current block, and mutable variables can only be "
"mutated in the block that they are defined in. To use them effectively, it's"
" important to know what counts as \"the same block\"."
msgstr ""
"`do` 符号的许多功能仅适用于单个 `do` "
"块。提前返回终止当前块，并且可变变量只能在其定义的块中修改。为了有效地使用它们，了解什么算作「同一块」非常重要。"

#: src/monad-transformers/do.md:546
#, fuzzy
msgid ""
"Generally speaking, the indented block following the `do` keyword counts as "
"a block, and the immediate sequence of statements underneath it are part of "
"that block. Statements in independent blocks that are nonetheless contained "
"in a block are not considered part of the block. However, the rules that "
"govern what exactly counts as the same block are slightly subtle, so some "
"examples are in order. The precise nature of the rules can be tested by "
"setting up a program with a mutable variable and seeing where the mutation "
"is allowed. This program has a mutation that is clearly in the same block as"
" the mutable variable:"
msgstr ""
"一般来说，`do` "
"关键字后面的缩进块算作一个块，其下方的语句序列是该块的一部分。独立块中的语句虽然包含在块中，但不被视为块的一部分。然而，判断什么算作同一块的规则有些微妙，因此需要一些示例。可以通过设置一个带有可变变量的程序并查看允许变异的位置来测试规则的准确性。该程序有一个变异，显然与可变变量在同一块中："

#: src/monad-transformers/do.md:557
#, fuzzy
msgid ""
"When a mutation occurs in a `do`\\-block that is part of a `let`\\-statement"
" that defines a name using `:=`, then it is not considered to be part of the"
" block:"
msgstr "当变异发生在 `do` 块中，该块是 `let` 语句的一部分，该语句使用 `:=` 定义名称时，它不被视为块的一部分："

#: src/monad-transformers/do.md:568
#, fuzzy
msgid ""
"However, a `do`\\-block that occurs under a `let`\\-statement that defines a"
" name using `←` is considered part of the surrounding block. The following "
"program is accepted:"
msgstr "然而，在 `let` 语句下发生的 `do` 块，该语句使用 `←` 定义名称，被视为周围块的一部分。以下程序被接受："

#: src/monad-transformers/do.md:578
#, fuzzy
msgid ""
"Similarly, `do`\\-blocks that occur as arguments to functions are "
"independent of their surrounding blocks. The following program is not "
"accepted:"
msgstr "同样，作为函数参数出现的 `do` 块独立于其周围块。以下程序不被接受："

#: src/monad-transformers/do.md:591
#, fuzzy
msgid ""
"If the `do` keyword is completely redundant, then it does not introduce a "
"new block. This program is accepted, and is equivalent to the first one in "
"this section:"
msgstr "如果 `do` 关键字完全冗余，则它不会引入新块。该程序被接受，并且等效于本节中的第一个程序："

#: src/monad-transformers/do.md:599
#, fuzzy
msgid ""
"The contents of branches under a `do` (such as those introduced by `match` "
"or `if`) are considered to be part of the surrounding block, whether or not "
"a redundant `do` is added. The following programs are all accepted:"
msgstr ""
"`do` 下的分支内容（例如由 `match` 或 `if` 引入的内容）被视为周围块的一部分，无论是否添加了冗余 `do`。以下程序都被接受："

#: src/monad-transformers/do.md:626
#, fuzzy
msgid ""
"Similarly, the `do` that occurs as part of the `for` and `unless` syntax is "
"just part of their syntax, and does not introduce a fresh `do`\\-block. "
"These programs are also accepted:"
msgstr ""
"同样，作为 `for` 和 `unless` 语法的一部分出现的 `do` 只是其语法的一部分，不会引入新的 `do` 块。这些程序也被接受："

#: src/monad-transformers/do.md:641
#, fuzzy
msgid "Imperative or Functional Programming?"
msgstr "命令式或函数式编程？"

#: src/monad-transformers/do.md:643
#, fuzzy
msgid ""
"The imperative features provided by Lean's `do`\\-notation allow many "
"programs to very closely resemble their counterparts in languages like Rust,"
" Java, or C#. This resemblance is very convenient when translating an "
"imperative algorithm into Lean, and some tasks are just most naturally "
"thought of imperatively. The introduction of monads and monad transformers "
"enables imperative programs to be written in purely functional languages, "
"and `do`\\-notation as a specialized syntax for monads (potentially locally "
"transformed) allows functional programmers to have the best of both worlds: "
"the strong reasoning principles afforded by immutability and a tight control"
" over available effects through the type system are combined with syntax and"
" libraries that allow programs that use effects to look familiar and be easy"
" to read. Monads and monad transformers allow functional versus imperative "
"programming to be a matter of perspective."
msgstr ""
"Lean 的 `do` 语法提供的命令式特性允许许多程序非常接近 Rust、Java 或 C# 等语言中的对应程序。这种相似性在将命令式算法转换为 "
"Lean 时非常方便，并且某些任务最自然地被认为是命令式的。单子（monad）和单子变换器的引入使命令式程序能够用纯函数式语言编写，而 `do` "
"语法作为单子（可能局部转换）的专门语法，允许函数式程序员兼得两全其美：不可变性提供的强大推理原则和通过类型系统对可用效果的严格控制与允许使用效果的程序看起来熟悉且易于阅读的语法和库相结合。单子和单子变换器允许函数式与命令式编程成为一个观点问题。"

#: src/monad-transformers/do.md:651
#, fuzzy
msgid ""
"Rewrite `doug` to use `for` instead of the `doList` function. Are there "
"other opportunities to use the features introduced in this section to "
"improve the code? If so, use them!"
msgstr "使用 `for` 而不是 `doList` 函数重写 `doug`。是否有其他机会使用本节中引入的特性来改进代码？如果有，请使用它们！"

#: src/monad-transformers/conveniences.md:3
#, fuzzy
msgid "Pipe Operators"
msgstr "管道运算符"

#: src/monad-transformers/conveniences.md:5
#, fuzzy
msgid ""
"Functions are normally written before their arguments. When reading a "
"program from left to right, this promotes a view in which the function's "
"_output_ is paramount—the function has a goal to achieve (that is, a value "
"to compute), and it receives arguments to support it in this process. But "
"some programs are easier to understand in terms of an input that is "
"successively refined to produce the output. For these situations, Lean "
"provides a _pipeline_ operator which is similar to the that provided by F#. "
"Pipeline operators are useful in the same situations as Clojure's threading "
"macros."
msgstr ""
"函数通常写在其参数之前。从左到右读取程序时，这会促进一种函数的 _输出_ "
"至上的观点——函数有一个要实现的目标（即要计算的值），它接收参数来支持此过程。但有些程序更容易理解为连续细化以产生输出的输入。对于这些情况，Lean "
"提供了一个 _管道_ 运算符，类似于 F# 提供的运算符。管道运算符在与 Clojure 的线程宏相同的情况下很有用。"

#: src/monad-transformers/conveniences.md:11
#, fuzzy
msgid "The pipeline `E1 |> E2` is short for `E2 E1`. For example, evaluating:"
msgstr "管道 `E1 |> E2` 是 `E2 E1` 的简写。例如，求值："

#: src/monad-transformers/conveniences.md:17
msgid ""
"```output info\n"
"\"(some 5)\"\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:20
#, fuzzy
msgid ""
"While this change of emphasis can make some programs more convenient to "
"read, pipelines really come into their own when they contain many "
"components."
msgstr "虽然这种重点的改变可以让一些程序更易于阅读，但当管道包含许多组件时，它们才真正发挥作用。"

#: src/monad-transformers/conveniences.md:22
#, fuzzy
msgid "With the definition:"
msgstr "有了定义："

#: src/monad-transformers/conveniences.md:26
#, fuzzy
msgid "the following pipeline:"
msgstr "以下管道："

#: src/monad-transformers/conveniences.md:27
msgid ""
"```lean\n"
"#eval 5 |> times3 |> toString |> (\"It is \" ++ ·)\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:30
#, fuzzy
msgid "yields:"
msgstr "产生："

#: src/monad-transformers/conveniences.md:31
msgid ""
"```output info\n"
"\"It is 15\"\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:34
#, fuzzy
msgid ""
"More generally, a series of pipelines `E1 |> E2 |> E3 |> E4` is short for "
"nested function applications `E4 (E3 (E2 E1))`."
msgstr "更一般地，一系列管道 `E1 |> E2 |> E3 |> E4` 是嵌套函数应用 `E4 (E3 (E2 E1))` 的简写。"

#: src/monad-transformers/conveniences.md:36
#, fuzzy
msgid ""
"Pipelines may also be written in reverse. In this case, they do not place "
"the subject of data transformation first; however, in cases where many "
"nested parentheses pose a challenge for readers, they can clarify the steps "
"of application. The prior example could be equivalently written as:"
msgstr ""
"管道也可以反向编写。在这种情况下，它们不会首先放置数据转换的主体；然而，在许多嵌套括号对读者构成挑战的情况下，它们可以阐明应用步骤。前面的示例可以等效地写成："

#: src/monad-transformers/conveniences.md:39
msgid ""
"```lean\n"
"#eval (\"It is \" ++ ·) <| toString <| times3 <| 5\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:42
#, fuzzy
msgid "which is short for:"
msgstr "这是："

#: src/monad-transformers/conveniences.md:43
msgid ""
"```lean\n"
"#eval (\"It is \" ++ ·) (toString (times3 5))\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:47
#, fuzzy
msgid ""
"Lean's method dot notation that uses the name of the type before the dot to "
"resolve the namespace of the operator after the dot serves a similar purpose"
" to pipelines. Even without the pipeline operator, it is possible to write "
"`[1, 2, 3].reverse` instead of `List.reverse [1, 2, 3]`. However, the "
"pipeline operator is also useful for dotted functions when using many of "
"them. `([1, 2, 3].reverse.drop 1).reverse` can also be written as `[1, 2, 3]"
" |> List.reverse |> List.drop 1 |> List.reverse`. This version avoids having"
" to parenthesize expressions simply because they accept arguments, and it "
"recovers the convenience of a chain of method calls in languages like Kotlin"
" or C#. However, it still requires the namespace to be provided by hand. As "
"a final convenience, Lean provides the \"pipeline dot\" operator, which "
"groups functions like the pipeline but uses the name of the type to resolve "
"namespaces. With \"pipeline dot\", the example can be rewritten to `[1, 2, "
"3] |>.reverse |>.drop 1 |>.reverse`."
msgstr ""
"Lean 的方法点表示法在点之前使用类型名称来解析点之后运算符的命名空间，它与管道有类似的目的。即使没有管道运算符，也可以编写 `[1, 2, "
"3].reverse` 而不是 `List.reverse [1, 2, 3]`. 但是，当使用许多点函数时，管道运算符也很有用。`([1, 2, "
"3].reverse.drop 1).reverse` 也可以写成 `[1, 2, 3] |> List.reverse |> List.drop 1 "
"|> List.reverse`. 此版本避免了对表达式进行括号化，仅仅因为它们接受参数，并且它恢复了像 Kotlin 或 C# "
"这样的语言中方法调用链的便利性。但是，它仍然需要手动提供命名空间。作为最后的便利，Lean "
"提供了「管道点」运算符，它像管道一样对函数进行分组，但使用类型名称来解析命名空间。使用「管道点」，该示例可以重写为 `[1, 2, 3] "
"|>.reverse |>.drop 1 |>.reverse`."

#: src/monad-transformers/conveniences.md:56
#, fuzzy
msgid "Infinite Loops"
msgstr "无限循环"

#: src/monad-transformers/conveniences.md:58
#, fuzzy
msgid ""
"Within a `do`\\-block, the `repeat` keyword introduces an infinite loop. For"
" example, a program that spams the string `\"Spam!\"` can use it:"
msgstr "在 `do` 块中，`repeat` 关键字引入了一个无限循环。例如，一个发送字符串 `\"Spam!\"` 的程序可以使用它："

#: src/monad-transformers/conveniences.md:60
msgid ""
"```lean\n"
"def spam : IO Unit := do\n"
"  repeat IO.println \"Spam!\"\n"
"```"
msgstr ""

#: src/monad-transformers/conveniences.md:64
#, fuzzy
msgid ""
"A `repeat` loop supports `break` and `continue`, just like `for` loops."
msgstr "`repeat` 循环支持 `break` 和 `continue`，就像 `for` 循环一样。"

#: src/monad-transformers/conveniences.md:66
#, fuzzy
msgid ""
"The `dump` function from the [implementation of `feline`](../hello-"
"world/cat.md#streams) uses a recursive function to run forever:"
msgstr "[实现 `feline`](../hello-world/cat.md#streams) 中的 `dump` 函数使用递归函数无限运行："

#: src/monad-transformers/conveniences.md:77
#, fuzzy
msgid "This function can be greatly shortened using `repeat`:"
msgstr "可以使用 `repeat` 大大缩短此函数："

#: src/monad-transformers/conveniences.md:87
#, fuzzy
msgid ""
"Neither `spam` nor `dump` need to be declared as `partial` because they are "
"not themselves infinitely recursive. Instead, `repeat` makes use of a type "
"whose `ForM` instance is `partial`. Partiality does not \"infect\" calling "
"functions."
msgstr ""
"`spam` 和 `dump` 都无需声明为 `partial`，因为它们本身不是无限递归的。相反，`repeat` 使用了一个 `ForM` 实例为 "
"`partial` 的类型。偏函数性不会「感染」调用函数。"

#: src/monad-transformers/conveniences.md:91
#, fuzzy
msgid "While Loops"
msgstr "while 循环"

#: src/monad-transformers/conveniences.md:93
#, fuzzy
msgid ""
"When programming with local mutability, `while` loops can be a convenient "
"alternative to `repeat` with an `if`\\-guarded `break`:"
msgstr "在使用局部可变性编程时，`while` 循环可以作为带有 `if` 保护的 `break` 的 `repeat` 的便捷替代："

#: src/monad-transformers/conveniences.md:102
#, fuzzy
msgid "Behind the scenes, `while` is just a simpler notation for `repeat`."
msgstr "在幕后，`while` 只是 `repeat` 的一种更简单的表示法。"

#: src/monad-transformers/summary.md:3
#, fuzzy
msgid "Combining Monads"
msgstr "组合单子"

#: src/monad-transformers/summary.md:5
#, fuzzy
msgid ""
"When writing a monad from scratch, there are design patterns that tend to "
"describe the ways that each effect is added to the monad. Reader effects are"
" added by having the monad's type be a function from the reader's "
"environment, state effects are added by including a function from the "
"initial state to the value paired with the final state, failure or "
"exceptions are added by including a sum type in the return type, and logging"
" or other output is added by including a product type in the return type. "
"Existing monads can be made part of the return type as well, allowing their "
"effects to be included in the new monad."
msgstr ""
"在从头开始编写单子时，有一些设计模式倾向于描述将每种效果添加到单子的方式。通过将单子的类型设为从读取器环境读取的函数来添加读取器效果，通过包含从初始状态到与最终状态配对的值的函数来添加状态效果，通过在返回类型中包含和类型来添加失败或异常，通过在返回类型中包含乘积类型来添加日志记录或其他输出。现有的单子也可以作为返回类型的一部分，从而允许将它们的效果包含在新单子中。"

#: src/monad-transformers/summary.md:9
#, fuzzy
msgid ""
"These design patterns are made into a library of reusable software "
"components by defining _monad transformers_, which add an effect to some "
"base monad. Monad transformers take the simpler monad types as arguments, "
"returning the enhanced monad types. At a minimum, a monad transformer should"
" provide the following instances:"
msgstr ""
"通过定义添加效果到某个基本单子的 "
"_单子转换器_，将这些设计模式制成可重用软件组件库。单子转换器将更简单的单子类型作为参数，返回增强的单子类型。最起码，单子转换器应提供以下实例："

#: src/monad-transformers/summary.md:13
#, fuzzy
msgid ""
"A `MonadLift` instance to translate an action from the inner monad to the "
"transformed monad"
msgstr "`MonadLift` 实例用于将操作从内部单子提升到转换后的单子"

#: src/monad-transformers/summary.md:15
#, fuzzy
msgid ""
"Monad transformers may be implemented as polymorphic structures or inductive"
" datatypes, but they are most often implemented as functions from the "
"underlying monad type to the enhanced monad type."
msgstr "单子转换器可以实现为多态结构体或归纳数据类型，但最常实现为从底层单子类型到增强单子类型的函数。"

#: src/monad-transformers/summary.md:17
#, fuzzy
msgid "Type Classes for Effects"
msgstr "用于效果的类型类"

#: src/monad-transformers/summary.md:19
#, fuzzy
msgid ""
"A common design pattern is to implement a particular effect by defining a "
"monad that has the effect, a monad transformer that adds it to another "
"monad, and a type class that provides a generic interface to the effect. "
"This allows programs to be written that merely specify which effects they "
"need, so the caller can provide any monad that has the right effects."
msgstr ""
"一种常见的模式是通过定义具有效果的单子、添加该效果的单子转换器以及提供对该效果的通用接口的类型类来实现特定效果。这允许编写仅指定所需效果的程序，以便调用者可以提供具有正确效果的任何单子。"

#: src/monad-transformers/summary.md:22
#, fuzzy
msgid ""
"Sometimes, auxiliary type information (e.g. the state's type in a monad that"
" provides state, or the exception's type in a monad that provides "
"exceptions) is an output parameter, and sometimes it is not. The output "
"parameter is most useful for simple programs that use each kind of effect "
"only once, but it risks having the type checker commit to a the wrong type "
"too early when multiple instances of the same effect are used in a given "
"program. Thus, both versions are typically provided, with the ordinary-"
"parameter version of the type class having a name that ends in `-Of`."
msgstr ""
"有时，辅助类型信息（例如，提供状态的单子中的状态类型或提供异常的单子中的异常类型）是输出参数，有时则不是。输出参数最适用于仅使用每种效果一次的简单程序，但当给定程序中使用同一效果的多个实例时，它有风险让类型检查器过早地提交错误的类型。因此，通常提供两个版本，具有普通参数的类型类版本具有以"
" `-Of` 结尾的名称。"

#: src/monad-transformers/summary.md:26
#, fuzzy
msgid "Monad Transformers Don't Commute"
msgstr "单子转换器不可交换"

#: src/monad-transformers/summary.md:28
#, fuzzy
msgid ""
"It is important to note that changing the order of transformers in a monad "
"can change the meaning of programs that use the monad. For instance, re-"
"ordering `StateT` and `ExceptT` can result either in programs that lose "
"state modifications when exceptions are thrown or programs that keep "
"changes. While most imperative languages provide only the latter, the "
"increased flexibility provided by monad transformers demands thought and "
"attention to choose the correct variety for the task at hand."
msgstr ""
"需要注意的是，更改单子中转换器的顺序可能会改变使用该单子的程序的含义。例如，重新排序 `StateT` 和 `ExceptT` "
"可能会导致在抛出异常时丢失状态修改的程序或保留更改的程序。虽然大多数命令式语言仅提供后者，但单子转换器提供的灵活性要求对选择适合手头任务的正确类型进行思考和注意。"

#: src/monad-transformers/summary.md:32
#, fuzzy
msgid "`do`\\-Notation for Monad Transformers"
msgstr "**do** 符号用于单子变换器"

#: src/monad-transformers/summary.md:34
#, fuzzy
msgid ""
"Lean's `do`\\-blocks support early return, in which the block is terminated "
"with some value, locally mutable variables, `for`\\-loops with `break` and "
"`continue`, and single-branched `if`\\-statements. While this may seem to be"
" introducing imperative features that would get in the way of using Lean to "
"write proofs, it is in fact nothing more than a more convenient syntax for "
"certain common uses of monad transformers. Behind the scenes, whatever monad"
" the `do`\\-block is written in is transformed by appropriate uses of "
"`ExceptT` and `StateT` to support these additional effects."
msgstr ""
"Lean 的 **do** 块支持提前返回，其中块以某个值终止，局部可变变量，带有 **break** 和 **continue** 的 **for**"
" 循环，以及单分支 **if** 语句。虽然这似乎引入了命令式特性，会妨碍使用 Lean "
"编写证明，但实际上它只不过是对单子变换器某些常见用法的一种更方便的语法。在幕后，**do** 块所写的任何单子都会通过适当使用 **ExceptT** "
"和 **StateT** 来转换，以支持这些附加效果。"

#: src/dependent-types.md:3
#, fuzzy
msgid ""
"In most statically-typed programming languages, there is a hermetic seal "
"between the world of types and the world of programs. Types and programs "
"have different grammars and they are used at different times. Types are "
"typically used at compile time, to check that a program obeys certain "
"invariants. Programs are used at run time, to actually perform computations."
" When the two interact, it is usually in the form of a type-case operator "
"like an \"instance-of\" check or a casting operator that provides the type "
"checker with information that was otherwise unavailable, to be verified at "
"run time. In other words, the interaction consists of types being inserted "
"into the world of programs, gaining some limited run-time meaning."
msgstr ""
"在大多数静态类型编程语言中，类型世界和程序世界之间存在密封。类型和程序有不同的语法，它们在不同的时间使用。类型通常在编译时使用，以检查程序是否遵守某些不变量。程序在运行时使用，以实际执行计算。当两者交互时，通常采用类型案例运算符的形式，例如“instance-"
"of”检查或提供类型检查器在运行时验证的信息的强制转换运算符。换句话说，交互包括将类型插入程序世界，获得一些有限的运行时含义。"

#: src/dependent-types.md:10
#, fuzzy
msgid ""
"Lean does not impose this strict separation. In Lean, programs may compute "
"types and types may contain programs. Placing programs in types allows their"
" full computation power to be used at compile time, and the ability to "
"return types from functions makes types into first-class participants in the"
" programming process."
msgstr ""
"Lean 没有强加这种严格的分离。在 Lean "
"中，程序可以计算类型，类型可以包含程序。将程序放在类型中允许在编译时使用它们的全部计算能力，并且从函数返回类型的能力使类型成为编程过程中的一等参与者。"

#: src/dependent-types.md:14
#, fuzzy
msgid ""
"_Dependent types_ are types that contain non-type expressions. A common "
"source of dependent types is a named argument to a function. For example, "
"the function `natOrStringThree` returns either a natural number or a string,"
" depending on which `Bool` it is passed:"
msgstr ""
"**依值类型**包含非类型表达式。依值类型的常见来源是函数的命名参数。例如，函数 `natOrStringThree` 返回自然数或字符串，具体取决于传递给它的 `Bool`：\n"
"\n"
"依值类型的其他示例包括：\n"
"\n"
"[多态性的介绍部分](getting-to-know/polymorphism.md) 包含 `posOrNegThree`，其中函数的返回类型取决于参数的值。\n"
"\n"
"[`OfNat` 类型类](type-classes/pos.md#literal-numbers) 取决于正在使用的特定自然数文字。\n"
"\n"
"验证示例中使用的 [`CheckedInput` 结构体](functor-applicative-monad/applicative.md#validated-input) 取决于验证发生的年份。\n"
"\n"
"[子类型](functor-applicative-monad/applicative.md#subtypes) 包含引用特定值的命题。\n"
"\n"
"本质上，所有有趣的命题，包括那些确定 [数组索引符号](props-proofs-indexing.md) 有效性的命题，都是包含值的类型，因此是依值类型。\n"
"\n"
"依值类型极大地增强了类型系统的功能。返回类型根据参数值进行分支的灵活性使编写程序成为可能，而这些程序在其他类型系统中很难赋予类型。同时，依值类型允许类型签名限制函数可能返回的值，从而可以在编译时强制执行强不变性。\n"
"\n"
"但是，使用依值类型进行编程可能非常复杂，并且需要一整套超越函数式编程的技能。表达性规范可能难以实现，并且确实存在陷入困境和无法完成程序的风险。另一方面，这个过程可以带来新的理解，这可以用可以实现的精炼类型来表达。虽然本章只是触及了依值类型编程的表面，但这是一个值得专门写一本书的深刻主题。"

#: src/dependent-types.md:17
msgid ""
"```lean\n"
"def natOrStringThree (b : Bool) : if b then Nat else String :=\n"
"  match b with\n"
"  | true => (3 : Nat)\n"
"  | false => \"three\"\n"
"```"
msgstr ""

#: src/dependent-types.md:24
#, fuzzy
msgid "Further examples of dependent types include:"
msgstr "?"

#: src/dependent-types.md:25
#, fuzzy
msgid ""
"[The introductory section on polymorphism](getting-to-know/polymorphism.md) "
"contains `posOrNegThree`, in which the function's return type depends on the"
" value of the argument."
msgstr "?"

#: src/dependent-types.md:26
#, fuzzy
msgid ""
"[The `OfNat` type class](type-classes/pos.md#literal-numbers) depends on the"
" specific natural number literal being used."
msgstr "?"

#: src/dependent-types.md:27
#, fuzzy
msgid ""
"[The `CheckedInput` structure](functor-applicative-"
"monad/applicative.md#validated-input) used in the example of validators "
"depends on the year in which validation occurred."
msgstr "?"

#: src/dependent-types.md:28
#, fuzzy
msgid ""
"[Subtypes](functor-applicative-monad/applicative.md#subtypes) contain "
"propositions that refer to particular values."
msgstr "?"

#: src/dependent-types.md:29
#, fuzzy
msgid ""
"Essentially all interesting propositions, including those that determine the"
" validity of [array indexing notation](props-proofs-indexing.md), are types "
"that contain values and are thus dependent types."
msgstr "?"

#: src/dependent-types.md:31
#, fuzzy
msgid ""
"Dependent types vastly increase the power of a type system. The flexibility "
"of return types that branch on argument values enables programs to be "
"written that cannot easily be given types in other type systems. At the same"
" time, dependent types allow a type signature to restrict which values may "
"be returned from a function, enabling strong invariants to be enforced at "
"compile time."
msgstr "?"

#: src/dependent-types.md:35
#, fuzzy
msgid ""
"However, programming with dependent types can be quite complex, and it "
"requires a whole set of skills above and beyond functional programming. "
"Expressive specifications can be complicated to fulfill, and there is a real"
" risk of tying oneself in knots and being unable to complete the program. On"
" the other hand, this process can lead to new understanding, which can be "
"expressed in a refined type that can be fulfilled. While this chapter "
"scratches the surface of dependently typed programming, it is a deep topic "
"that deserves an entire book of its own."
msgstr "?"

#: src/dependent-types/indexed-families.md:3
#, fuzzy
msgid ""
"Polymorphic inductive types take type arguments. For instance, `List` takes "
"an argument that determines the type of the entries in the list, and "
"`Except` takes arguments that determine the types of the exceptions or "
"values. These type arguments, which are the same in every constructor of the"
" datatype, are referred to as _parameters_."
msgstr ""
"多态归纳类型接受类型参数。例如，`List` 接受一个参数来确定列表中条目的类型，而 `Except` "
"接受一个参数来确定异常或值的类型。这些类型参数在数据类型的每个构造子中都是相同的，称为「参数」。"

#: src/dependent-types/indexed-families.md:7
#, fuzzy
msgid ""
"Arguments to inductive types need not be the same in every constructor, "
"however. Inductive types in which the arguments to the type vary based on "
"the choice of constructor are called _indexed families_, and the arguments "
"that vary are referred to as _indices_. The \"hello world\" of indexed "
"families is a type of lists that contains the length of the list in addition"
" to the type of entries, conventionally referred to as \"vectors\":"
msgstr ""
"然而，归纳类型的参数不必在每个构造子中都相同。参数根据构造子的选择而变化的归纳类型称为「索引族」，而变化的参数称为「索引」。索引族的“hello "
"world”是一种列表类型，除了条目类型之外，还包含列表的长度，通常称为「向量」："

#: src/dependent-types/indexed-families.md:16
#, fuzzy
msgid ""
"Function declarations may take some arguments before the colon, indicating "
"that they are available in the entire definition, and some arguments after, "
"indicating a desire to pattern-match on them and define the function case by"
" case. Inductive datatypes have a similar principle: the argument `α` is "
"named at the top of the datatype declaration, prior to the colon, which "
"indicates that it is a parameter that must be provided as the first argument"
" in all occurrences of `Vect` in the definition, while the `Nat` argument "
"occurs after the colon, indicating that it is an index that may vary. "
"Indeed, the three occurrences of `Vect` in the `nil` and `cons` constructor "
"declarations consistently provide `α` as the first argument, while the "
"second argument is different in each case."
msgstr ""
"函数声明可以在冒号之前接受一些参数，表示它们在整个定义中可用，并在冒号之后接受一些参数，表示希望对它们进行模式匹配并逐个定义函数。归纳数据类型有一个类似的原则：参数"
" `α` 在数据类型声明的顶部，在冒号之前命名，这表示它是一个必须在定义中所有 `Vect` 的第一个参数中提供的参数，而 `Nat` "
"参数出现在冒号之后，表示它是一个可能变化的索引。事实上，`nil` 和 `cons` 构造子声明中 `Vect` 的三个出现始终将 `α` "
"提供为第一个参数，而第二个参数在每种情况下都不同。"

#: src/dependent-types/indexed-families.md:20
#, fuzzy
msgid ""
"The declaration of `nil` states that it is a constructor of type `Vect α 0`."
" This means that using `Vect.nil` in a context expecting a `Vect String 3` "
"is a type error, just as `[1, 2, 3]` is a type error in a context that "
"expects a `List String`:"
msgstr ""
"`nil` 的声明表明它是一个类型 `Vect α 0` 的构造子。这意味着在期望 `Vect String 3` 的上下文中使用 `Vect.nil`"
" 是一个类型错误，就像 `[1, 2, 3]` 在期望 `List String` 的上下文中是一个类型错误一样："

#: src/dependent-types/indexed-families.md:33
#, fuzzy
msgid ""
"The mismatch between `0` and `3` in this example plays exactly the same role"
" as any other type mismatch, even though `0` and `3` are not themselves "
"types."
msgstr "此示例中 `0` 和 `3` 之间的错配与任何其他类型错配的作用完全相同，即使 `0` 和 `3` 本身不是类型。"

#: src/dependent-types/indexed-families.md:35
#, fuzzy
msgid ""
"Indexed families are called _families_ of types because different index "
"values can make different constructors available for use. In some sense, an "
"indexed family is not a type; rather, it is a collection of related types, "
"and the choice of index values also chooses a type from the collection. "
"Choosing the index `5` for `Vect` means that only the constructor `cons` is "
"available, and choosing the index `0` means that only `nil` is available."
msgstr ""
"索引族被称为类型的「族」，因为不同的索引值可以使不同的构造子可供使用。从某种意义上说，索引族不是类型；相反，它是一组相关类型的集合，并且索引值的选取也从集合中选取了一个类型。为"
" `Vect` 选择索引 `5` 意味着只有构造子 `cons` 可用，而选择索引 `0` 意味着只有 `nil` 可用。"

#: src/dependent-types/indexed-families.md:39
#, fuzzy
msgid ""
"If the index is not yet known (e.g. because it is a variable), then no "
"constructor can be used until it becomes known. Using `n` for the length "
"allows neither `Vect.nil` nor `Vect.cons`, because there's no way to know "
"whether the variable `n` should stand for a `Nat` that matches `0` or `n + "
"1`:"
msgstr ""
"如果索引尚未知道（例如，因为它是一个变量），那么在它变得已知之前，不能使用任何构造子。对长度使用 `n` 既不允许 `Vect.nil` 也不允许 "
"`Vect.cons`，因为无法知道变量 `n` 是否应该代表与 `0` 或 `n + 1` 匹配的 `Nat`："

#: src/dependent-types/indexed-families.md:52
msgid ""
"```lean\n"
"example : Vect String n := Vect.cons \"Hello\" (Vect.cons \"world\" Vect.nil)\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:55
msgid ""
"```output error\n"
"type mismatch\n"
"  Vect.cons \"Hello\" (Vect.cons \"world\" Vect.nil)\n"
"has type\n"
"  Vect String (0 + 1 + 1) : Type\n"
"but is expected to have type\n"
"  Vect String n : Type\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:64
#, fuzzy
msgid ""
"Having the length of the list as part of its type means that the type "
"becomes more informative. For example, `Vect.replicate` is a function that "
"creates a `Vect` with a number of copies of a given value. The type that "
"says this precisely is:"
msgstr ""
"将列表的长度作为其类型的一部分意味着类型变得更有信息性。例如，`Vect.replicate` 是一个创建具有给定值副本的 `Vect` "
"的函数。确切地说出这一点的类型是："

#: src/dependent-types/indexed-families.md:70
#, fuzzy
msgid ""
"The argument `n` appears as the length of the result. The message associated"
" with the underscore placeholder describes the task at hand:"
msgstr "参数 `n` 显示为结果的长度。与下划线占位符关联的消息描述了手头的任务："

#: src/dependent-types/indexed-families.md:81
#, fuzzy
msgid ""
"When working with indexed families, constructors can only be applied when "
"Lean can see that the constructor's index matches the index in the expected "
"type. However, neither constructor has an index that matches `n`—`nil` "
"matches `Nat.zero`, and `cons` matches `Nat.succ`. Just as in the example "
"type errors, the variable `n` could stand for either, depending on which "
"`Nat` is provided to the function as an argument. The solution is to use "
"pattern matching to consider both of the possible cases:"
msgstr ""
"在处理索引族时，只有当 Lean 可以看到构造子的索引与预期类型中的索引匹配时，才能应用构造子。然而，这两个构造子都没有与 `n` "
"匹配的索引——`nil` 匹配 `Nat.zero`，而 `cons` 匹配 `Nat.succ`。就像在示例类型错误中一样，变量 `n` "
"可以代表这两个中的任何一个，具体取决于作为参数提供给函数的 `Nat`。解决方案是使用模式匹配来考虑这两种可能的情况："

#: src/dependent-types/indexed-families.md:91
#, fuzzy
msgid ""
"Because `n` occurs in the expected type, pattern matching on `n` _refines_ "
"the expected type in the two cases of the match. In the first underscore, "
"the expected type has become `Vect α 0`:"
msgstr ""
"由于 `n` 出现在预期类型中，因此对 `n` 进行模式匹配会根据匹配的两种情况来细化预期类型。在第一个下划线中，预期类型变为 `Vect α 0`："

#: src/dependent-types/indexed-families.md:101
#, fuzzy
msgid "In the second underscore, it has become `Vect α (k + 1)`:"
msgstr "在第二个下划线中，它变为 `Vect α (k + 1)`："

#: src/dependent-types/indexed-families.md:111
#, fuzzy
msgid ""
"When pattern matching refines the type of a program in addition to "
"discovering the structure of a value, it is called _dependent pattern "
"matching_."
msgstr "当模式匹配除了发现值结构体之外还细化程序的类型时，它被称为 _依赖模式匹配_。"

#: src/dependent-types/indexed-families.md:113
#, fuzzy
msgid ""
"The refined type makes it possible to apply the constructors. The first "
"underscore matches `Vect.nil`, and the second matches `Vect.cons`: "
msgstr "细化的类型使得可以应用构造子。第一个下划线匹配 `Vect.nil`，第二个匹配 `Vect.cons`："

#: src/dependent-types/indexed-families.md:121
#, fuzzy
msgid ""
"The first underscore under the `.cons` should have type `α`. There is an `α`"
" available, namely `x`:"
msgstr "`.cons` 下面的第一个下划线应为类型 `α`。有一个可用的 `α`，即 `x`："

#: src/dependent-types/indexed-families.md:132
#, fuzzy
msgid ""
"The second underscore should be a `Vect α k`, which can be produced by a "
"recursive call to `replicate`:"
msgstr "第二个下划线应为 `Vect α k`，可以通过对 `replicate` 的递归调用来生成："

#: src/dependent-types/indexed-families.md:142
#, fuzzy
msgid "Here is the final definition of `replicate`:"
msgstr "以下是 `replicate` 的最终定义："

#: src/dependent-types/indexed-families.md:150
#, fuzzy
msgid ""
"In addition to providing assistance while writing the function, the "
"informative type of `Vect.replicate` also allows client code to rule out a "
"number of unexpected functions without having to read the source code. A "
"version of `replicate` for lists could produce a list of the wrong length:"
msgstr ""
"除了在编写函数时提供帮助之外，`Vect.replicate` 的信息类型还允许客户端代码排除许多意外函数，而无需阅读源代码。列表版本的 "
"`replicate` 可能会生成长度错误的列表："

#: src/dependent-types/indexed-families.md:158
#, fuzzy
msgid "However, making this mistake with `Vect.replicate` is a type error:"
msgstr "然而，对 `Vect.replicate` 进行此操作会产生类型错误："

#: src/dependent-types/indexed-families.md:177
#, fuzzy
msgid ""
"The function `List.zip` combines two lists by pairing the first entry in the"
" first list with the first entry in the second list, the second entry in the"
" first list with the second entry in the second list, and so forth. "
"`List.zip` can be used to pair the three highest peaks in the US state of "
"Oregon with the three highest peaks in Denmark:"
msgstr ""
"函数 `List.zip` "
"通过将第一个列表中的第一个条目与第二个列表中的第一个条目配对，将第一个列表中的第二个条目与第二个列表中的第二个条目配对，依此类推，来组合两个列表。`List.zip`"
" 可用于将美国俄勒冈州的三个最高峰与丹麦的三个最高峰配对："

#: src/dependent-types/indexed-families.md:179
msgid ""
"```lean\n"
"[\"Mount Hood\",\n"
" \"Mount Jefferson\",\n"
" \"South Sister\"].zip [\"Møllehøj\", \"Yding Skovhøj\", \"Ejer Bavnehøj\"]\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:184
#, fuzzy
msgid "The result is a list of three pairs:"
msgstr "结果是一个包含三个对的列表："

#: src/dependent-types/indexed-families.md:185
msgid ""
"```lean\n"
"[(\"Mount Hood\", \"Møllehøj\"),\n"
" (\"Mount Jefferson\", \"Yding Skovhøj\"),\n"
" (\"South Sister\", \"Ejer Bavnehøj\")]\n"
"```"
msgstr ""

#: src/dependent-types/indexed-families.md:190
#, fuzzy
msgid ""
"It's somewhat unclear what should happen when the lists have different "
"lengths. Like many languages, Lean chooses to ignore the extra entries in "
"one of the lists. For instance, combining the heights of the five highest "
"peaks in Oregon with those of the three highest peaks in Denmark yields "
"three pairs. In particular,"
msgstr ""
"当列表具有不同长度时，应该发生什么情况有点不明确。与许多语言一样，Lean "
"选择忽略其中一个列表中的额外条目。例如，将俄勒冈州五个最高峰的高度与丹麦三个最高峰的高度相结合，会产生三个对。特别是，"

#: src/dependent-types/indexed-families.md:202
#, fuzzy
msgid ""
"While this approach is convenient because it always returns an answer, it "
"runs the risk of throwing away data when the lists unintentionally have "
"different lengths. F# takes a different approach: its version of `List.zip` "
"throws an exception when the lengths don't match, as can be seen in this "
"`fsi` session:"
msgstr ""
"虽然这种方法很方便，因为它总是返回一个答案，但当列表意外具有不同长度时，它有丢弃数据风险。F# 采取了不同的方法：当长度不匹配时，其版本的 "
"`List.zip` 会引发异常，如在以下 `fsi` 会话中所示："

#: src/dependent-types/indexed-families.md:217
#, fuzzy
msgid ""
"This avoids accidentally discarding information, but crashing a program "
"comes with its own difficulties. The Lean equivalent, which would use the "
"`Option` or `Except` monads, would introduce a burden that may not be worth "
"the safety."
msgstr ""
"这避免了意外丢弃信息，但程序崩溃也带来了自己的困难。Lean 等价项（将使用 `Option` 或 `Except` "
"单子）会引入一种负担，这种负担可能不值得安全。"

#: src/dependent-types/indexed-families.md:220
#, fuzzy
msgid ""
"Using `Vect`, however, it is possible to write a version of `zip` with a "
"type that requires that both arguments have the same length:"
msgstr "但是，使用 `Vect`，可以编写一个 `zip` 版本，其类型要求两个参数具有相同的长度："

#: src/dependent-types/indexed-families.md:226
#, fuzzy
msgid ""
"This definition only has patterns for the cases where either both arguments "
"are `Vect.nil` or both arguments are `Vect.cons`, and Lean accepts the "
"definition without a \"missing cases\" error like the one that results from "
"a similar definition for `List`:"
msgstr ""
"此定义仅对两种情况具有模式：两种参数均为 `Vect.nil` 或两种参数均为 `Vect.cons`，并且 Lean 接受此定义，而不会出现类似于 "
"`List` 的类似定义产生的「缺少情况」错误："

#: src/dependent-types/indexed-families.md:237
#, fuzzy
msgid ""
"This is because the constructor used in the first pattern, `nil` or `cons`, "
"_refines_ the type checker's knowledge about the length `n`. When the first "
"pattern is `nil`, the type checker can additionally determine that the "
"length was `0`, so the only possible choice for the second pattern is `nil`."
" Similarly, when the first pattern is `cons`, the type checker can determine"
" that the length was `k+1` for some `Nat` `k`, so the only possible choice "
"for the second pattern is `cons`. Indeed, adding a case that uses `nil` and "
"`cons` together is a type error, because the lengths don't match:"
msgstr ""
"因为第一个模式中使用的构造子 `nil` 或 `cons` 会细化类型检查器对长度 `n` 的了解。当第一个模式为 `nil` "
"时，类型检查器还可以确定长度为 `0`，因此第二个模式的唯一可能选择是 `nil`。类似地，当第一个模式为 `cons` "
"时，类型检查器可以确定长度为某个 `Nat` `k` 的 `k+1`，因此第二个模式的唯一可能选择是 `cons`。实际上，添加同时使用 `nil` 和"
" `cons` 的情况是一个类型错误，因为长度不匹配："

#: src/dependent-types/indexed-families.md:255
#, fuzzy
msgid ""
"The refinement of the length can be observed by making `n` into an explicit "
"argument:"
msgstr "可以通过将 `n` 变成显式参数来观察长度的细化："

#: src/dependent-types/indexed-families.md:264
#, fuzzy
msgid ""
"Getting a feel for programming with dependent types requires experience, and"
" the exercises in this section are very important. For each exercise, try to"
" see which mistakes the type checker can catch, and which ones it can't, by "
"experimenting with the code as you go. This is also a good way to develop a "
"feel for the error messages."
msgstr ""
"获得使用依值类型编程的感觉需要经验，本节中的练习非常重要。对于每个练习，尝试通过在进行过程中试验代码来查看类型检查器可以捕获哪些错误，哪些错误无法捕获。这也是培养对错误消息的感觉的好方法。"

#: src/dependent-types/indexed-families.md:268
#, fuzzy
msgid ""
"Double-check that `Vect.zip` gives the right answer when combining the three"
" highest peaks in Oregon with the three highest peaks in Denmark. Because "
"`Vect` doesn't have the syntactic sugar that `List` has, it can be helpful "
"to begin by defining `oregonianPeaks : Vect String 3` and `danishPeaks : "
"Vect String 3`."
msgstr ""
"仔细检查 `Vect.zip` 在将俄勒冈州的三个最高峰与丹麦的三个最高峰结合时是否给出了正确的答案。由于 `Vect` 没有 `List` "
"拥有的语法糖，因此首先定义 `oregonianPeaks : Vect String 3` 和 `danishPeaks : Vect String "
"3` 会很有帮助。"

#: src/dependent-types/indexed-families.md:271
#, fuzzy
msgid ""
"Define a function `Vect.map` with type `(α → β) → Vect α n → Vect β n`."
msgstr "定义一个类型为 `(α → β) → Vect α n → Vect β n` 的函数 `Vect.map`。"

#: src/dependent-types/indexed-families.md:273
#, fuzzy
msgid ""
"Define a function `Vect.zipWith` that combines the entries in a `Vect` one "
"at a time with a function. It should have the type `(α → β → γ) → Vect α n →"
" Vect β n → Vect γ n`."
msgstr ""
"定义一个函数 `Vect.zipWith`，它一次将 `Vect` 中的条目与一个函数结合起来。它的类型应该是 `(α → β → γ) → Vect "
"α n → Vect β n → Vect γ n`。"

#: src/dependent-types/indexed-families.md:276
#, fuzzy
msgid ""
"Define a function `Vect.unzip` that splits a `Vect` of pairs into a pair of "
"`Vect`s. It should have the type `Vect (α × β) n → Vect α n × Vect β n`."
msgstr ""
"定义一个函数 `Vect.unzip`，它将一个 `Vect` 对拆分为一对 `Vect`。它的类型应该是 `Vect (α × β) n → Vect"
" α n × Vect β n`。"

#: src/dependent-types/indexed-families.md:278
#, fuzzy
msgid ""
"Define a function `Vect.snoc` that adds an entry to the _end_ of a `Vect`. "
"Its type should be `Vect α n → α → Vect α (n + 1)` and `#eval Vect.snoc "
"(.cons \"snowy\" .nil) \"peaks\"` should yield `Vect.cons \"snowy\" "
"(Vect.cons \"peaks\" (Vect.nil))`. The name `snoc` is a traditional "
"functional programming pun: it is `cons` backwards."
msgstr ""
"定义一个函数 `Vect.snoc`，它在 `Vect` 的末尾添加一个条目。它的类型应该是 `Vect α n → α → Vect α (n + "
"1)`，并且 `#eval Vect.snoc (.cons \"snowy\" .nil) \"peaks\"` 应该生成 `Vect.cons "
"\"snowy\" (Vect.cons \"peaks\" (Vect.nil))`。`snoc` 这个名字是一个传统的函数式编程双关语：它是 "
"`cons` 的反向拼写。"

#: src/dependent-types/indexed-families.md:280
#, fuzzy
msgid "Define a function `Vect.reverse` that reverses the order of a `Vect`."
msgstr "定义一个函数 `Vect.reverse`，它反转 `Vect` 的顺序。"

#: src/dependent-types/indexed-families.md:282
#, fuzzy
msgid ""
"Define a function `Vect.drop` with the following type: `(n : Nat) → Vect α "
"(k + n) → Vect α k`. Verify that it works by checking that `#eval "
"danishPeaks.drop 2` yields `Vect.cons \"Ejer Bavnehøj\" (Vect.nil)`."
msgstr ""
"定义一个函数 `Vect.drop`，类型如下：`(n : Nat) → Vect α (k + n) → Vect α k`。通过检查 `#eval "
"danishPeaks.drop 2` 生成 `Vect.cons \"Ejer Bavnehøj\" (Vect.nil)` 来验证它是否有效。"

#: src/dependent-types/indexed-families.md:285
#, fuzzy
msgid ""
"Define a function `Vect.take` with type `(n : Nat) → Vect α (k + n) → Vect α"
" n` that returns the first `n` entries in the `Vect`. Check that it works on"
" an example."
msgstr ""
"定义一个类型为 `(n : Nat) → Vect α (k + n) → Vect α n` 的函数 `Vect.take`，它返回 `Vect` "
"中的前 `n` 个条目。通过一个示例检查它是否有效。"

#: src/dependent-types/universe-pattern.md:3
#, fuzzy
msgid ""
"In Lean, types such as `Type`, `Type 3`, and `Prop` that classify other "
"types are known as universes. However, the term _universe_ is also used for "
"a design pattern in which a datatype is used to represent a subset of Lean's"
" types, and a function converts the datatype's constructors into actual "
"types. The values of this datatype are called _codes_ for their types."
msgstr ""
"在 Lean 中，将其他类型分类的类型（如 `Type`、`Type 3` 和 "
"`Prop`）称为宇宙。然而，术语「宇宙」也用于设计模式，其中数据类型用于表示 Lean "
"类型的一个子集，并且一个函数将数据类型的构造子转换为实际类型。该数据类型的值称为其类型的「代码」。"

#: src/dependent-types/universe-pattern.md:7
#, fuzzy
msgid ""
"Just like Lean's built-in universes, the universes implemented with this "
"pattern are types that describe some collection of available types, even "
"though the mechanism by which it is done is different. In Lean, there are "
"types such as `Type`, `Type 3`, and `Prop` that directly describe other "
"types. This arrangement is referred to as _universes à la Russell_. The "
"user-defined universes described in this section represent all of their "
"types as _data_, and include an explicit function to interpret these codes "
"into actual honest-to-goodness types. This arrangement is referred to as "
"_universes à la Tarski_. While languages such as Lean that are based on "
"dependent type theory almost always use Russell-style universes, Tarski-"
"style universes are a useful pattern for defining APIs in these languages."
msgstr ""
"就像 Lean 的内置宇宙一样，使用此模式实现的宇宙是描述一些可用类型集合的类型，即使完成此操作的机制不同。在 Lean "
"中，有直接描述其他类型的类型，如 `Type`、`Type 3` 和 "
"`Prop`。这种安排被称为「罗素式宇宙」。本节中描述的用户定义宇宙将其所有类型表示为「数据」，并包含一个显式函数，将这些代码解释为实际的、诚实可靠的类型。这种安排被称为「塔斯基式宇宙」。虽然基于依值类型论的语言（如"
" Lean）几乎总是使用罗素式宇宙，但塔斯基式宇宙是为这些语言中的 API 定义提供帮助的一种有用模式。"

#: src/dependent-types/universe-pattern.md:14
#, fuzzy
msgid ""
"Defining a custom universe makes it possible to carve out a closed "
"collection of types that can be used with an API. Because the collection of "
"types is closed, recursion over the codes allows programs to work for _any_ "
"type in the universe. One example of a custom universe has the codes `nat`, "
"standing for `Nat`, and `bool`, standing for `Bool`:"
msgstr ""
"自定义宇宙可以划分出封闭的类型集合，该集合可与 API 一起使用。由于类型集合是封闭的，因此对代码的递归允许程序适用于宇宙中的 _任何_ "
"类型。自定义宇宙的一个示例具有代码 `nat`（代表 `Nat`）和 `bool`（代表 `Bool`）："

#: src/dependent-types/universe-pattern.md:26
#, fuzzy
msgid ""
"Pattern matching on a code allows the type to be refined, just as pattern "
"matching on the constructors of `Vect` allows the expected length to be "
"refined. For instance, a program that deserializes the types in this "
"universe from a string can be written as follows:"
msgstr ""
"对代码进行模式匹配可以优化类型，就像对 `Vect` "
"构造子进行模式匹配可以优化预期长度一样。例如，可以编写一个从字符串反序列化此宇宙中类型的程序，如下所示："

#: src/dependent-types/universe-pattern.md:28
msgid ""
"```lean\n"
"def decode (t : NatOrBool) (input : String) : Option t.asType :=\n"
"  match t with\n"
"  | .nat => input.toNat?\n"
"  | .bool =>\n"
"    match input with\n"
"    | \"true\" => some true\n"
"    | \"false\" => some false\n"
"    | _ => none\n"
"```"
msgstr ""

#: src/dependent-types/universe-pattern.md:38
#, fuzzy
msgid ""
"Dependent pattern matching on `t` allows the expected result type `t.asType`"
" to be respectively refined to `NatOrBool.nat.asType` and "
"`NatOrBool.bool.asType`, and these compute to the actual types `Nat` and "
"`Bool`."
msgstr ""
"对 `t` 进行依赖模式匹配可以分别将预期结果类型 `t.asType` 优化为 `NatOrBool.nat.asType` 和 "
"`NatOrBool.bool.asType`，它们计算为实际类型 `Nat` 和 `Bool`。"

#: src/dependent-types/universe-pattern.md:40
#, fuzzy
msgid ""
"Like any other data, codes may be recursive. The type `NestedPairs` codes "
"for any possible nesting of the pair and natural number types:"
msgstr "与任何其他数据一样，代码可以是递归的。`NestedPairs` 类型为对和自然数类型的任何可能嵌套进行编码："

#: src/dependent-types/universe-pattern.md:51
#, fuzzy
msgid ""
"In this case, the interpretation function `NestedPairs.asType` is recursive."
" This means that recursion over codes is required in order to implement "
"`BEq` for the universe:"
msgstr "在这种情况下，解释函数 `NestedPairs.asType` 是递归的。这意味着为了实现宇宙的 `BEq`，需要对代码进行递归："

#: src/dependent-types/universe-pattern.md:63
#, fuzzy
msgid ""
"Even though every type in the `NestedPairs` universe already has a `BEq` "
"instance, type class search does not automatically check every possible case"
" of a datatype in an instance declaration, because there might be infinitely"
" many such cases, as with `NestedPairs`. Attempting to appeal directly to "
"the `BEq` instances rather than explaining to Lean how to find them by "
"recursion on the codes results in an error:"
msgstr ""
"尽管 `NestedPairs` 宇宙中的每种类型都已具有 `BEq` "
"实例，但类型类搜索不会在实例声明中自动检查数据类型的每种可能情况，因为可能存在无限多个此类情况，如 `NestedPairs`。尝试直接调用 `BEq`"
" 实例，而不是向 Lean 解释如何通过对代码进行递归来查找它们，会导致错误："

#: src/dependent-types/universe-pattern.md:73
#, fuzzy
msgid ""
"The `t` in the error message stands for an unknown value of type "
"`NestedPairs`."
msgstr "错误消息中的 `t` 表示 `NestedPairs` 类型的未知值。"

#: src/dependent-types/universe-pattern.md:75
#, fuzzy
msgid "Type Classes vs Universes"
msgstr "类型类与宇宙"

#: src/dependent-types/universe-pattern.md:77
#, fuzzy
msgid ""
"Type classes allow an open-ended collection of types to be used with an API "
"as long as they have implementations of the necessary interfaces. In most "
"cases, this is preferable. It is hard to predict all use cases for an API "
"ahead of time, and type classes are a convenient way to allow library code "
"to be used with more types than the original author expected."
msgstr ""
"类型类允许一组开放的类型与 API 一起使用，只要它们实现了必要的接口。在大多数情况下，这是可取的。很难提前预测 API "
"的所有用例，而类型类是一种方便的方法，允许库代码与比原始作者预期的更多类型一起使用。"

#: src/dependent-types/universe-pattern.md:81
#, fuzzy
msgid ""
"A universe à la Tarski, on the other hand, restricts the API to be usable "
"only with a predetermined collection of types. This is useful in a few "
"situations:"
msgstr "另一方面，塔斯基式的宇宙将 API 限制为仅可与预先确定的类型集合一起使用。这在以下几种情况下很有用："

#: src/dependent-types/universe-pattern.md:83
#, fuzzy
msgid ""
"When a function should act very differently depending on which type it is "
"passed—it is impossible to pattern match on types themselves, but pattern "
"matching on codes for types is allowed"
msgstr "当一个函数应该根据传递给它的类型而表现得非常不同时——不可能对类型本身进行模式匹配，但允许对类型的代码进行模式匹配"

#: src/dependent-types/universe-pattern.md:84
#, fuzzy
msgid ""
"When an external system inherently limits the types of data that may be "
"provided, and extra flexibility is not desired"
msgstr "当外部系统本质上限制了可以提供的数据类型，并且不需要额外的灵活性时"

#: src/dependent-types/universe-pattern.md:85
#, fuzzy
msgid ""
"When additional properties of a type are required over and above the "
"implementation of some operations"
msgstr "当除了某些操作的实现之外，还需要类型的附加属性时"

#: src/dependent-types/universe-pattern.md:87
#, fuzzy
msgid ""
"Type classes are useful in many of the same situations as interfaces in Java"
" or C#, while a universe à la Tarski can be useful in cases where a sealed "
"class might be used, but where an ordinary inductive datatype is not usable."
msgstr "类型类在许多情况下与 Java 或 C# 中的接口类似，而塔斯基式的宇宙可以在可以使用密封类但无法使用普通归纳数据类型的情况下使用。"

#: src/dependent-types/universe-pattern.md:89
#, fuzzy
msgid "A Universe of Finite Types"
msgstr "有限类型宇宙"

#: src/dependent-types/universe-pattern.md:91
#, fuzzy
msgid ""
"Restricting the types that can be used with an API to a predetermined "
"collection can enable operations that would be impossible for an open-ended "
"API. For example, functions can't normally be compared for equality. "
"Functions should be considered equal when they map the same inputs to the "
"same outputs. Checking this could take infinite amounts of time, because "
"comparing two functions with type `Nat → Bool` would require checking that "
"the functions returned the same `Bool` for each and every `Nat`."
msgstr ""
"将可与 API 一起使用的类型限制为预先确定的集合可以启用对开放式 API "
"来说不可能的操作。例如，通常无法比较函数的相等性。当函数将相同的输入映射到相同的输出时，应将它们视为相等的。检查这可能需要无限量的时间，因为比较两个类型为"
" `Nat → Bool` 的函数需要检查这些函数为每个 `Nat` 返回相同的 `Bool`。"

#: src/dependent-types/universe-pattern.md:96
#, fuzzy
msgid ""
"In other words, a function from an infinite type is itself infinite. "
"Functions can be viewed as tables, and a function whose argument type is "
"infinite requires infinitely many rows to represent each case. But functions"
" from finite types require only finitely many rows in their tables, making "
"them finite. Two functions whose argument type is finite can be checked for "
"equality by enumerating all possible arguments, calling the functions on "
"each of them, and then comparing the results. Checking higher-order "
"functions for equality requires generating all possible functions of a given"
" type, which additionally requires that the return type is finite so that "
"each element of the argument type can be mapped to each element of the "
"return type. This is not a _fast_ method, but it does complete in finite "
"time."
msgstr ""
"换句话说，从无限类型来的函数本身也是无限的。函数可以看作表格，而参数类型为无限的函数需要无限多的行来表示每种情况。但从有限类型来的函数只需要有限多的行，因此是有限的。参数类型为有限的两个函数可以通过枚举所有可能的参数，对每个参数调用函数，然后比较结果来检查相等性。检查高阶函数的相等性需要生成给定类型的所有可能函数，此外还需要返回类型是有限的，以便参数类型的每个元素都可以映射到返回类型的每个元素。这不是一种快速的方法，但它确实可以在有限时间内完成。表示有限类型的一种方法是使用宇宙：在这个宇宙中，构造子"
" `arr` 表示函数类型，它用一个箭头 `arr` 来表示。比较这个宇宙中的两个值的相等性与在 `NestedPairs` "
"宇宙中几乎相同。唯一重要的区别是添加了 `arr` 的情况，它使用一个名为 `Finite.enumerate` 的帮助器来生成 `t1` "
"编码的类型中的每个值，检查这两个函数对每个可能的输入返回相等的结果：标准库函数 `List.all` 检查提供的函数是否对列表的每个条目返回 "
"`true`。此函数可用于比较布尔值上的函数是否相等："

#: src/dependent-types/universe-pattern.md:103
#, fuzzy
msgid "One way to represent finite types is by a universe:"
msgstr "?"

#: src/dependent-types/universe-pattern.md:117
#, fuzzy
msgid ""
"In this universe, the constructor `arr` stands for the function type, which "
"is written with an `arr`ow."
msgstr "?"

#: src/dependent-types/universe-pattern.md:119
#, fuzzy
msgid ""
"Comparing two values from this universe for equality is almost the same as "
"in the `NestedPairs` universe. The only important difference is the addition"
" of the case for `arr`, which uses a helper called `Finite.enumerate` to "
"generate every value from the type coded for by `t1`, checking that the two "
"functions return equal results for every possible input:"
msgstr "?"

#: src/dependent-types/universe-pattern.md:130
#, fuzzy
msgid ""
"The standard library function `List.all` checks that the provided function "
"returns `true` on every entry of a list. This function can be used to "
"compare functions on the Booleans for equality:"
msgstr "?"

#: src/dependent-types/universe-pattern.md:138
#, fuzzy
msgid "It can also be used to compare functions from the standard library:"
msgstr "它还可以用于比较标准库中的函数："

#: src/dependent-types/universe-pattern.md:145
#, fuzzy
msgid ""
"It can even compare functions built using tools such as function "
"composition:"
msgstr "它甚至可以比较使用函数组合等工具构建的函数："

#: src/dependent-types/universe-pattern.md:152
#, fuzzy
msgid ""
"This is because the `Finite` universe codes for Lean's _actual_ function "
"type, not a special analogue created by the library."
msgstr "这是因为 `Finite` 宇宙编码了 Lean 的_实际_函数类型，而不是库创建的特殊类似物。"

#: src/dependent-types/universe-pattern.md:154
#, fuzzy
msgid ""
"The implementation of `enumerate` is also by recursion on the codes from "
"`Finite`."
msgstr "`enumerate` 的实现也是通过对 `Finite` 中代码的递归。"

#: src/dependent-types/universe-pattern.md:163
#, fuzzy
msgid ""
"In the case for `Unit`, there is only a single value. In the case for "
"`Bool`, there are two values to return (`true` and `false`). In the case for"
" pairs, the result should be the Cartesian product of the values for the "
"type coded for by `t1` and the values for the type coded for by `t2`. In "
"other words, every value from `t1` should be paired with every value from "
"`t2`. The helper function `List.product` can certainly be written with an "
"ordinary recursive function, but here it is defined using `for` in the "
"identity monad:"
msgstr ""
"对于 `Unit`，只有一个值。对于 `Bool`，有两个值要返回（`true` 和 `false`）。对于对，结果应该是 `t1` 编码的类型的值和 "
"`t2` 编码的类型的值的笛卡尔积。换句话说，`t1` 中的每个值都应该与 `t2` 中的每个值配对。辅助函数 `List.product` "
"当然可以用普通递归函数编写，但这里使用恒等单子中的 `for` 定义它："

#: src/dependent-types/universe-pattern.md:176
#, fuzzy
msgid ""
"Finally, the case of `Finite.enumerate` for functions delegates to a helper "
"called `Finite.functions` that takes a list of all of the return values to "
"target as an argument."
msgstr ""
"最后，`Finite.enumerate` 的函数情况委托给一个名为 `Finite.functions` 的辅助函数，该函数将所有返回值列表作为参数。"

#: src/dependent-types/universe-pattern.md:178
#, fuzzy
msgid ""
"Generally speaking, generating all of the functions from some finite type to"
" a collection of result values can be thought of as generating the "
"functions' tables. Each function assigns an output to each input, which "
"means that a given function has \\\\( k \\\\) rows in its table when there "
"are \\\\( k \\\\) possible arguments. Because each row of the table could "
"select any of \\\\( n \\\\) possible outputs, there are \\\\( n ^ k \\\\) "
"potential functions to generate."
msgstr ""
"一般来说，将所有函数从某个有限类型生成到结果值集合可以被认为是生成函数表。每个函数将输出分配给每个输入，这意味着当有 \\\\( k \\\\) "
"个可能的参数时，给定函数在其表中有 \\\\( k \\\\) 行。因为表的每一行都可以选择 \\\\( n \\\\) "
"个可能的输出中的任何一个，所以有 \\\\( n ^ k \\\\) 个潜在函数要生成。"

#: src/dependent-types/universe-pattern.md:182
#, fuzzy
msgid ""
"Once again, generating the functions from a finite type to some list of "
"values is recursive on the code that describes the finite type:"
msgstr "再次，从有限类型生成函数到某个值列表是递归于描述有限类型的代码："

#: src/dependent-types/universe-pattern.md:188
#, fuzzy
msgid ""
"The table for functions from `Unit` contains one row, because the function "
"can't pick different results based on which input it is provided. This means"
" that one function is generated for each potential input."
msgstr "从 `Unit` 到函数的表包含一行，因为函数不能根据提供的输入选择不同的结果。这意味着为每个潜在输入生成一个函数。"

#: src/dependent-types/universe-pattern.md:195
#, fuzzy
msgid ""
"There are \\\\( n^2 \\\\) functions from `Bool` when there are \\\\( n \\\\)"
" result values, because each individual function of type `Bool → α` uses the"
" `Bool` to select between two particular `α`s:"
msgstr ""
"当有 \\\\( n \\\\) 个结果值时，从 `Bool` 到函数有 \\\\( n^2 \\\\)，因为每个类型为 `Bool → α` "
"的函数使用 `Bool` 在两个特定的 `α` 之间进行选择："

#: src/dependent-types/universe-pattern.md:203
#, fuzzy
msgid ""
"Generating the functions from pairs can be achieved by taking advantage of "
"currying. A function from a pair can be transformed into a function that "
"takes the first element of the pair and returns a function that's waiting "
"for the second element of the pair. Doing this allows `Finite.functions` to "
"be used recursively in this case:"
msgstr ""
"通过利用柯里化可以生成从对生成函数。从对的函数可以转换为一个函数，该函数获取对的第一个元素并返回一个等待对的第二个元素的函数。这样做允许 "
"`Finite.functions` 在这种情况下递归使用："

#: src/dependent-types/universe-pattern.md:214
#, fuzzy
msgid ""
"Generating higher-order functions is a bit of a brain bender. Each higher-"
"order function takes a function as its argument. This argument function can "
"be distinguished from other functions based on its input/output behavior. In"
" general, the higher-order function can apply the argument function to every"
" possible argument, and it can then carry out any possible behavior based on"
" the result of applying the argument function. This suggests a means of "
"constructing the higher-order functions:"
msgstr ""
"生成高阶函数有点费脑。每个高阶函数都将函数作为其参数。此参数函数可以根据其输入/输出行为与其他函数区分开来。通常，高阶函数可以将参数函数应用于每个可能的参数，然后它可以根据应用参数函数的结果执行任何可能的函数。这表明了构建高阶函数的方法："

#: src/dependent-types/universe-pattern.md:219
#, fuzzy
msgid ""
"Begin with a list of all possible arguments to the function that is itself "
"an argument."
msgstr "从函数的所有可能参数的列表开始，该函数本身是一个参数。"

#: src/dependent-types/universe-pattern.md:220
#, fuzzy
msgid ""
"For each possible argument, construct all possible behaviors that can result"
" from the observation of applying the argument function to the possible "
"argument. This can be done using `Finite.functions` and recursion over the "
"rest of the possible arguments, because the result of the recursion "
"represents the functions based on the observations of the rest of the "
"possible arguments. `Finite.functions` constructs all the ways of achieving "
"these based on the observation for the current argument."
msgstr ""
"对于每个可能的参数，构造所有可能的行为，这些行为可能由观察将参数函数应用于可能的参数而产生。这可以使用 `Finite.functions` "
"和对其余可能参数的递归来完成，因为递归的结果表示基于其余可能参数的观察的函数。`Finite.functions` "
"基于当前参数的观察构建了实现这些的所有方法。"

#: src/dependent-types/universe-pattern.md:221
#, fuzzy
msgid ""
"For potential behavior in response to these observations, construct a "
"higher-order function that applies the argument function to the current "
"possible argument. The result of this is then passed to the observation "
"behavior."
msgstr "针对这些观察结果的潜在行为，构造一个高阶函数，将参数函数应用于当前可能的参数。然后将结果传递给观察行为。"

#: src/dependent-types/universe-pattern.md:222
#, fuzzy
msgid ""
"The base case of the recursion is a higher-order function that observes "
"nothing for each result value—it ignores the argument function and simply "
"returns the result value."
msgstr "递归的基本情况是一个高阶函数，它对每个结果值都不进行观察——它忽略参数函数，只返回结果值。"

#: src/dependent-types/universe-pattern.md:224
#, fuzzy
msgid ""
"Defining this recursive function directly causes Lean to be unable to prove "
"that the whole function terminates. However, using a simpler form of "
"recursion called a _right fold_ can be used to make it clear to the "
"termination checker that the function terminates. A right fold takes three "
"arguments: a step function that combines the head of the list with the "
"result of the recursion over the tail, a default value to return when the "
"list is empty, and the list being processed. It then analyzes the list, "
"essentially replacing each `::` in the list with a call to the step function"
" and replacing `[]` with the default value:"
msgstr ""
"直接定义这个递归函数会导致 Lean "
"无法证明整个函数终止。然而，使用一种称为「右折叠」的更简单的递归形式可以向终止检查器清楚地表明函数终止。右折叠接受三个参数：一个将列表的头部与递归在尾部上的结果相结合的步骤函数，一个在列表为空时返回的默认值，以及正在处理的列表。然后它分析列表，实质上用对步骤函数的调用替换列表中的每个"
" `::`，并用默认值替换 `[]`："

#: src/dependent-types/universe-pattern.md:233
#, fuzzy
msgid "Finding the sum of the `Nat`s in a list can be done with `foldr`:"
msgstr "使用 `foldr` 可以找到列表中 `Nat` 的和："

#: src/dependent-types/universe-pattern.md:244
#, fuzzy
msgid "With `foldr`, the higher-order functions can be created as follows:"
msgstr "使用 `foldr`，可以按如下方式创建高阶函数："

#: src/dependent-types/universe-pattern.md:257
#, fuzzy
msgid "The complete definition of `Finite.Functions` is:"
msgstr "`Finite.Functions` 的完整定义是："

#: src/dependent-types/universe-pattern.md:288
#, fuzzy
msgid ""
"Because `Finite.enumerate` and `Finite.functions` call each other, they must"
" be defined in a `mutual` block. In other words, right before the definition"
" of `Finite.enumerate` is the `mutual` keyword:"
msgstr ""
"因为 `Finite.enumerate` 和 `Finite.functions` 相互调用，所以它们必须在一个 `mutual` "
"块中定义。换句话说，在 `Finite.enumerate` 的定义之前是 `mutual` 关键字："

#: src/dependent-types/universe-pattern.md:295
#, fuzzy
msgid ""
"and right after the definition of `Finite.functions` is the `end` keyword:"
msgstr "在 `Finite.functions` 的定义之后是 `end` 关键字："

#: src/dependent-types/universe-pattern.md:310
#, fuzzy
msgid ""
"This algorithm for comparing functions is not particularly practical. The "
"number of cases to check grows exponentially; even a simple type like "
"`((Bool × Bool) → Bool) → Bool` describes 65536 distinct functions. Why are "
"there so many? Based on the reasoning above, and using \\\\( \\\\left| T "
"\\\\right| \\\\) to represent the number of values described by the type "
"\\\\( T \\\\), we should expect that \\\\\\[ \\\\left| \\\\left( \\\\left( "
"\\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) \\\\rightarrow "
"\\\\mathtt{Bool} \\\\right) \\\\rightarrow \\\\mathtt{Bool} \\\\right| "
"\\\\\\] is  \\\\\\[ \\\\left|\\\\mathrm{Bool}\\\\right|^{\\\\left| \\\\left("
" \\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) \\\\rightarrow "
"\\\\mathtt{Bool} \\\\right| }, \\\\\\] which is \\\\\\[ 2^{2^{\\\\left| "
"\\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right| }}, \\\\\\] which is "
"\\\\\\[ 2^{2^4} \\\\\\] or 65536. Nested exponentials grow quickly, and "
"there are many higher-order functions."
msgstr ""
"这种比较函数的算法并不是特别实用。要检查的情况数呈指数增长；即使像 `((Bool × Bool) → Bool) → Bool` "
"这样的简单类型也描述了 65536 个不同的函数。为什么会有这么多？基于以上推理，并使用 \\\\( \\\\left| T \\\\right| "
"\\\\) 表示类型 \\\\( T \\\\) 描述的值的数量，我们应该预期 \\\\\\[ \\\\left| \\\\left( "
"\\\\left( \\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) "
"\\\\rightarrow \\\\mathtt{Bool} \\\\right) \\\\rightarrow \\\\mathtt{Bool} "
"\\\\right| \\\\\\] 为  \\\\\\[ \\\\left|\\\\mathrm{Bool}\\\\right|^{\\\\left|"
" \\\\left( \\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right) "
"\\\\rightarrow \\\\mathtt{Bool} \\\\right| }, \\\\\\] 即 \\\\\\[ "
"2^{2^{\\\\left| \\\\mathtt{Bool} \\\\times \\\\mathtt{Bool} \\\\right| }}, "
"\\\\\\] 即 \\\\\\[ 2^{2^4} \\\\\\] 或 65536。嵌套指数增长很快，而且有许多高阶函数。"

#: src/dependent-types/universe-pattern.md:327
#, fuzzy
msgid ""
"Write a function that converts any value from a type coded for by `Finite` "
"into a string. Functions should be represented as their tables."
msgstr "编写一个函数，将由 `Finite` 编码的任何值转换为字符串。函数应表示为其表。"

#: src/dependent-types/universe-pattern.md:328
#, fuzzy
msgid "Add the empty type `Empty` to `Finite` and `Finite.beq`."
msgstr "将空类型 `Empty` 添加到 `Finite` 和 `Finite.beq`。"

#: src/dependent-types/universe-pattern.md:329
#, fuzzy
msgid "Add `Option` to `Finite` and `Finite.beq`."
msgstr "将 `Option` 添加到 `Finite` 和 `Finite.beq`。"

#: src/dependent-types/typed-queries.md:3
#, fuzzy
msgid ""
"Indexed families are very useful when building an API that is supposed to "
"resemble some other language. They can be used to write a library of HTML "
"constructors that don't permit generating invalid HTML, to encode the "
"specific rules of a configuration file format, or to model complicated "
"business constraints. This section describes an encoding of a subset of "
"relational algebra in Lean using indexed families, as a simpler "
"demonstration of techniques that can be used to build a more powerful "
"database query language."
msgstr ""
"在构建类似于其他语言的 API 时，索引族非常有用。它们可用于编写 HTML 构造子库，不允许生成无效 "
"HTML，以对配置文件格式的特定规则进行编码，或对复杂的业务约束进行建模。本节描述了使用索引族对关系代数子集在 Lean "
"中进行编码，作为可用于构建更强大的数据库查询语言的技术的更简单的演示。"

#: src/dependent-types/typed-queries.md:7
#, fuzzy
msgid ""
"This subset uses the type system to enforce requirements such as "
"disjointness of field names, and it uses type-level computation to reflect "
"the schema into the types of values that are returned from a query. It is "
"not a realistic system, however—databases are represented as linked lists of"
" linked lists, the type system is much simpler than that of SQL, and the "
"operators of relational algebra don't really match those of SQL. However, it"
" is large enough to demonstrate useful principles and techniques."
msgstr ""
"此子集使用类型系统来强制执行诸如字段名称不相交之类的要求，并且使用类型级计算将模式反映到从查询返回的值的类型中。然而，它并不是一个现实的系统——数据库表示为链表的链表，类型系统比"
" SQL 的简单得多，并且关系代数的运算符并不真正匹配 SQL 的运算符。但是，它足够大，可以演示有用的原则和技术。"

#: src/dependent-types/typed-queries.md:11
#, fuzzy
msgid "A Universe of Data"
msgstr "数据宇宙"

#: src/dependent-types/typed-queries.md:12
#, fuzzy
msgid ""
"In this relational algebra, the base data that can be held in columns can "
"have types `Int`, `String`, and `Bool` and are described by the universe "
"`DBType`:"
msgstr "在此关系代数中，可以保存在列中的基础数据可以具有类型 `Int`、`String` 和 `Bool`，并由宇宙 `DBType` 描述："

#: src/dependent-types/typed-queries.md:23
#, fuzzy
msgid "Using `asType` allows these codes to be used for types. For example:"
msgstr "使用 `asType` 允许将这些代码用于类型。例如："

#: src/dependent-types/typed-queries.md:25
msgid ""
"```lean\n"
"#eval (\"Mount Hood\" : DBType.string.asType)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:28
msgid ""
"```output info\n"
"\"Mount Hood\"\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:32
#, fuzzy
msgid ""
"It is possible to compare the values described by any of the three database "
"types for equality. Explaining this to Lean, however, requires a bit of "
"work. Simply using `BEq` directly fails:"
msgstr "任何三种数据库类型描述的值都可以进行相等性比较。然而，向 Lean 解释这一点需要一些工作。直接使用 `BEq` 会失败："

#: src/dependent-types/typed-queries.md:43
#, fuzzy
msgid ""
"Just as in the nested pairs universe, type class search doesn't "
"automatically check each possibility for `t`'s value The solution is to use "
"pattern matching to refine the types of `x` and `y`:"
msgstr "就像在嵌套对宇宙中一样，类型类搜索不会自动检查 `t` 值的每种可能性。解决方案是使用模式匹配来细化 `x` 和 `y` 的类型："

#: src/dependent-types/typed-queries.md:52
#, fuzzy
msgid ""
"In this version of the function, `x` and `y` have types `Int`, `String`, and"
" `Bool` in the three respective cases, and these types all have `BEq` "
"instances. The definition of `dbEq` can be used to define a `BEq` instance "
"for the types that are coded for by `DBType`:"
msgstr ""
"在这个函数版本中，`x` 和 `y` 在三个各自的情况下具有类型 `Int`、`String` 和 `Bool`，并且这些类型都具有 `BEq` "
"实例。`dbEq` 的定义可用于为 `DBType` 编码的类型定义一个 `BEq` 实例："

#: src/dependent-types/typed-queries.md:58
#, fuzzy
msgid "This is not the same as an instance for the codes themselves:"
msgstr "这与代码本身的实例不同："

#: src/dependent-types/typed-queries.md:67
#, fuzzy
msgid ""
"The former instance allows comparison of values drawn from the types "
"described by the codes, while the latter allows comparison of the codes "
"themselves."
msgstr "前一个实例允许比较从代码描述的类型中提取的值，而后一个实例允许比较代码本身。"

#: src/dependent-types/typed-queries.md:69
#, fuzzy
msgid ""
"A `Repr` instance can be written using the same technique. The method of the"
" `Repr` class is called `reprPrec` because it is designed to take things "
"like operator precedence into account when displaying values. Refining the "
"type through dependent pattern matching allows the `reprPrec` methods from "
"the `Repr` instances for `Int`, `String`, and `Bool` to be used:"
msgstr ""
"可以使用相同技术编写 `Repr` 实例。`Repr` 类的函数被称为 "
"`reprPrec`，因为它旨在在显示值时考虑运算符优先级等因素。通过依赖模式匹配细化类型，可以使用 `Int`、`String` 和 `Bool` 的"
" `Repr` 实例中的 `reprPrec` 函数："

#: src/dependent-types/typed-queries.md:81
#, fuzzy
msgid "Schemas and Tables"
msgstr "模式和表"

#: src/dependent-types/typed-queries.md:83
#, fuzzy
msgid "A schema describes the name and type of each column in a database:"
msgstr "模式描述了数据库中每列的名称和类型："

#: src/dependent-types/typed-queries.md:91
#, fuzzy
msgid ""
"In fact, a schema can be seen as a universe that describes rows in a table. "
"The empty schema describes the unit type, a schema with a single column "
"describes that value on its own, and a schema with at least two columns is "
"represented by a tuple:"
msgstr "事实上，模式可以看作是描述表中行的宇宙。空模式描述单位类型，具有单列的模式单独描述该值，而具有至少两列的模式由元组表示："

#: src/dependent-types/typed-queries.md:100
#, fuzzy
msgid ""
"As described in [the initial section on product types](../getting-to-"
"know/polymorphism.md#prod), Lean's product type and tuples are right-"
"associative. This means that nested pairs are equivalent to ordinary flat "
"tuples."
msgstr ""
"如[产品类型](../getting-to-know/polymorphism.md#prod)的初始部分所述，Lean "
"的产品类型和元组是右结合的。这意味着嵌套对等同于普通扁平元组。"

#: src/dependent-types/typed-queries.md:103
#, fuzzy
msgid "A table is a list of rows that share a schema:"
msgstr "表格是共享架构的行列表："

#: src/dependent-types/typed-queries.md:107
#, fuzzy
msgid ""
"For example, a diary of visits to mountain peaks can be represented with the"
" schema `peak`:"
msgstr "例如，可以利用架构 `peak` 表示对山峰访问的日记："

#: src/dependent-types/typed-queries.md:108
msgid ""
"```lean\n"
"abbrev peak : Schema := [\n"
"  ⟨\"name\", DBType.string⟩,\n"
"  ⟨\"location\", DBType.string⟩,\n"
"  ⟨\"elevation\", DBType.int⟩,\n"
"  ⟨\"lastVisited\", .int⟩\n"
"]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:116
#, fuzzy
msgid ""
"A selection of peaks visited by the author of this book appears as an "
"ordinary list of tuples:"
msgstr "本书作者访问过的部分山峰以普通元组列表的形式出现："

#: src/dependent-types/typed-queries.md:117
msgid ""
"```lean\n"
"def mountainDiary : Table peak := [\n"
"  (\"Mount Nebo\",       \"USA\",     3637, 2013),\n"
"  (\"Moscow Mountain\",  \"USA\",     1519, 2015),\n"
"  (\"Himmelbjerget\",    \"Denmark\",  147, 2004),\n"
"  (\"Mount St. Helens\", \"USA\",     2549, 2010)\n"
"]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:125
#, fuzzy
msgid "Another example consists of waterfalls and a diary of visits to them:"
msgstr "另一个示例包括瀑布及其访问日记："

#: src/dependent-types/typed-queries.md:126
msgid ""
"```lean\n"
"abbrev waterfall : Schema := [\n"
"  ⟨\"name\", .string⟩,\n"
"  ⟨\"location\", .string⟩,\n"
"  ⟨\"lastVisited\", .int⟩\n"
"]\n"
"\n"
"def waterfallDiary : Table waterfall := [\n"
"  (\"Multnomah Falls\", \"USA\", 2018),\n"
"  (\"Shoshone Falls\",  \"USA\", 2014)\n"
"]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:139
#, fuzzy
msgid "Recursion and Universes, Revisited"
msgstr "递归和宇宙，再探"

#: src/dependent-types/typed-queries.md:141
#, fuzzy
msgid ""
"The convenient structuring of rows as tuples comes at a cost: the fact that "
"`Row` treats its two base cases separately means that functions that use "
"`Row` in their types and are defined recursively over the codes (that, is "
"the schema) need to make the same distinctions. One example of a case where "
"this matters is an equality check that uses recursion over the schema to "
"define a function that checks rows for equality. This example does not pass "
"Lean's type checker:"
msgstr ""
"将行方便地构造为元组需要付出代价：`Row` 将其两个基本情况分别处理这一事实意味着，在类型中使用 `Row` "
"并在代码（即架构）上递归定义的函数需要做出相同的区分。这种情况很重要的一个示例是使用对架构的递归来定义检查行是否相等的函数的相等性检查。此示例未通过 "
"Lean 的类型检查器："

#: src/dependent-types/typed-queries.md:161
#, fuzzy
msgid ""
"The problem is that the pattern `col :: cols` does not sufficiently refine "
"the type of the rows. This is because Lean cannot yet tell whether the "
"singleton pattern `[col]` or the `col1 :: col2 :: cols` pattern in the "
"definition of `Row` was matched, so the call to `Row` does not compute down "
"to a pair type. The solution is to mirror the structure of `Row` in the "
"definition of `Row.bEq`:"
msgstr ""
"问题在于模式 `col :: cols` 没有充分细化行的类型。这是因为 Lean 无法判断 `Row` 定义中的单例模式 `[col]` 还是 "
"`col1 :: col2 :: cols` 模式匹配，因此对 `Row` 的调用不会计算为对类型。解决方案是在 `Row.bEq` 的定义中镜像 "
"`Row` 的结构体："

#: src/dependent-types/typed-queries.md:178
#, fuzzy
msgid ""
"Unlike in other contexts, functions that occur in types cannot be considered"
" only in terms of their input/output behavior. Programs that use these types"
" will find themselves forced to mirror the algorithm used in the type-level "
"function so that their structure matches the pattern-matching and recursive "
"behavior of the type. A big part of the skill of programming with dependent "
"types is the selection of appropriate type-level functions with the right "
"computational behavior."
msgstr ""
"与其他上下文中不同，类型中出现的函数不能仅根据其输入/输出行为来考虑。使用这些类型的程序会发现自己被迫镜像类型级别函数中使用的算法，以便其结构体与类型的模式匹配和递归行为相匹配。使用依值类型编程技能的一个重要部分是选择具有正确计算行为的适当类型级别函数。"

#: src/dependent-types/typed-queries.md:182
#, fuzzy
msgid "Column Pointers"
msgstr "列指针"

#: src/dependent-types/typed-queries.md:184
#, fuzzy
msgid ""
"Some queries only make sense if a schema contains a particular column. For "
"example, a query that returns mountains with an elevation greater than 1000 "
"meters only makes sense in the context of a schema with a `\"elevation\"` "
"column that contains integers. One way to indicate that a column is "
"contained in a schema is to provide a pointer directly to it, and defining "
"the pointer as an indexed family makes it possible to rule out invalid "
"pointers."
msgstr ""
"某些查询只有在模式包含特定列时才有意义。例如，返回海拔高于 1000 米的山峰的查询仅在模式包含整数类型的 `\"elevation\"` "
"列的上下文中才有意义。指示模式中包含列的一种方法是直接提供指向该列的指针，并将指针定义为索引族可以排除无效指针。"

#: src/dependent-types/typed-queries.md:188
#, fuzzy
msgid ""
"There are two ways that a column can be present in a schema: either it is at"
" the beginning of the schema, or it is somewhere later in the schema. "
"Eventually, if a column is later in a schema, then it will be the beginning "
"of some tail of the schema."
msgstr "列可以在模式中以两种方式出现：它要么位于模式的开头，要么位于模式的后面。最终，如果一个列位于模式的后面，那么它将是模式的某个尾部的开头。"

#: src/dependent-types/typed-queries.md:191
#, fuzzy
msgid ""
"The indexed family `HasCol` is a translation of the specification into Lean "
"code:"
msgstr "索引族 `HasCol` 是规范的 Lean 代码翻译："

#: src/dependent-types/typed-queries.md:197
#, fuzzy
msgid ""
"The family's three arguments are the schema, the column name, and its type. "
"All three are indices, but re-ordering the arguments to place the schema "
"after the column name and type would allow the name and type to be "
"parameters. The constructor `here` can be used when the schema begins with "
"the column `⟨name, t⟩`; it is thus a pointer to the first column in the "
"schema that can only be used when the first column has the desired name and "
"type. The constructor `there` transforms a pointer into a smaller schema "
"into a pointer into a schema with one more column on it."
msgstr ""
"该族的三个参数是模式、列名及其类型。所有三个都是索引，但将参数重新排序以将模式放在列名和类型之后将允许名称和类型成为参数。当模式以列 `⟨name, "
"t⟩` 开头时，可以使用构造子 `here`；因此，它是模式中第一个列的指针，仅当第一个列具有所需的名称和类型时才能使用。构造子 `there` "
"将较小模式中的指针转换为具有更多列的模式中的指针。"

#: src/dependent-types/typed-queries.md:202
#, fuzzy
msgid ""
"Because `\"elevation\"` is the third column in `peak`, it can be found by "
"looking past the first two columns with `there`, after which it is the first"
" column. In other words, to satisfy the type `HasCol peak \"elevation\" "
".int`, use the expression `.there (.there .here)`. One way to think about "
"`HasCol` is as a kind of decorated `Nat`—`zero` corresponds to `here`, and "
"`succ` corresponds to `there`. The extra type information makes it "
"impossible to have off-by-one errors."
msgstr ""
"因为 `\"elevation\"` 是 `peak` 中的第三列，所以可以通过使用 `there` 查找前两列，之后它是第一列。换句话说，要满足类型 "
"`HasCol peak \"elevation\" .int`，请使用表达式 `.there (.there .here)`。考虑 `HasCol` "
"的一种方法是将其视为一种装饰的 `Nat`——`zero` 对应于 `here`，`succ` 对应于 "
"`there`。额外的类型信息使得不可能出现差一错误。"

#: src/dependent-types/typed-queries.md:207
#, fuzzy
msgid ""
"A pointer to a particular column in a schema can be used to extract that "
"column's value from a row:"
msgstr "通过指向模式中的特定列，可以从行中提取该列的值："

#: src/dependent-types/typed-queries.md:215
#, fuzzy
msgid ""
"The first step is to pattern match on the schema, because this determines "
"whether the row is a tuple or a single value. No case is needed for the "
"empty schema because there is a `HasCol` available, and both constructors of"
" `HasCol` specify non-empty schemas. If the schema has just a single column,"
" then the pointer must point to it, so only the `here` constructor of "
"`HasCol` need be matched. If the schema has two or more columns, then there "
"must be a case for `here`, in which case the value is the first one in the "
"row, and one for `there`, in which case a recursive call is used. Because "
"the `HasCol` type guarantees that the column exists in the row, `Row.get` "
"does not need to return an `Option`."
msgstr ""
"第一步是模式匹配模式，因为这决定了行是元组还是单个值。空模式不需要 case，因为有 `HasCol` 可用，并且 `HasCol` "
"的两个构造子都指定了非空模式。如果模式只有一个列，则指针必须指向它，因此只需要匹配 `HasCol` 的 `here` "
"构造子。如果模式有两个或更多列，则必须有一个 `here` 的 case，在这种情况下，值是行中的第一个值，还有一个 `there` 的 "
"case，在这种情况下，使用递归调用。由于 `HasCol` 类型保证列存在于行中，因此 `Row.get` 不需要返回 `Option`。"

#: src/dependent-types/typed-queries.md:221
#, fuzzy
msgid "`HasCol` plays two roles:"
msgstr "`HasCol` 扮演着两个角色："

#: src/dependent-types/typed-queries.md:222
#, fuzzy
msgid ""
"It serves as _evidence_ that a column with a particular name and type exists"
" in a schema."
msgstr "它作为 _证据_，证明模式中存在具有特定名称和类型的列。"

#: src/dependent-types/typed-queries.md:224
#, fuzzy
msgid ""
"It serves as _data_ that can be used to find the value associated with the "
"column in a row."
msgstr "它作为 _数据_，可用于查找与行中列关联的值。"

#: src/dependent-types/typed-queries.md:226
#, fuzzy
msgid ""
"The first role, that of evidence, is similar to way that propositions are "
"used. The definition of the indexed family `HasCol` can be read as a "
"specification of what counts as evidence that a given column exists. Unlike "
"propositions, however, it matters which constructor of `HasCol` was used. In"
" the second role, the constructors are used like `Nat`s to find data in a "
"collection. Programming with indexed families often requires the ability to "
"switch fluently between both perspectives."
msgstr ""
"第一个角色（证据）类似于命题的使用方式。索引族 `HasCol` 的定义可以理解为对给定列存在的证据的规范。然而，与命题不同，`HasCol` "
"使用哪个构造子很重要。在第二个角色中，构造子像 `Nat` 一样用于在集合中查找数据。使用索引族进行编程通常需要在两种视角之间流畅切换。"

#: src/dependent-types/typed-queries.md:232
#, fuzzy
msgid "Subschemas"
msgstr "子模式"

#: src/dependent-types/typed-queries.md:234
#, fuzzy
msgid ""
"One important operation in relational algebra is to _project_ a table or row"
" into a smaller schema. Every column not present in the smaller schema is "
"forgotten. In order for projection to make sense, the smaller schema must be"
" a subschema of the larger schema, which means that every column in the "
"smaller schema must be present in the larger schema. Just as `HasCol` makes "
"it possible to write a single-column lookup in a row that cannot fail, a "
"representation of the subschema relationship as an indexed family makes it "
"possible to write a projection function that cannot fail."
msgstr ""
"关系代数中一项重要的操作是将表或行_投影_到更小的模式中。不在较小模式中出现的每一列都会被遗忘。为了使投影有意义，较小的模式必须是较大模式的子模式，这意味着较小模式中的每一列都必须出现在较大模式中。正如"
" `HasCol` 使得可以在行中编写不会失败的单列查找一样，将子模式关系表示为索引族可以编写不会失败的投影函数。"

#: src/dependent-types/typed-queries.md:239
#, fuzzy
msgid ""
"The ways in which one schema can be a subschema of another can be defined as"
" an indexed family. The basic idea is that a smaller schema is a subschema "
"of a bigger schema if every column in the smaller schema occurs in the "
"bigger schema. If the smaller schema is empty, then it's certainly a "
"subschema of the bigger schema, represented by the constructor `nil`. If the"
" smaller schema has a column, then that column must be in the bigger schema,"
" and all the rest of the columns in the subschema must also be a subschema "
"of the bigger schema. This is represented by the constructor `cons`."
msgstr ""
"一个模式可以成为另一个模式的子模式的方式可以定义为索引族。基本思想是，如果较小模式中的每一列都出现在较大模式中，则较小模式是较大模式的子模式。如果较小模式为空，那么它肯定是大模式的子模式，由构造子"
" `nil` 表示。如果较小模式有一列，那么该列必须在大模式中，并且子模式中的所有其他列也必须是大模式的子模式。这由构造子 `cons` 表示。"

#: src/dependent-types/typed-queries.md:252
#, fuzzy
msgid ""
"In other words, `Subschema` assigns each column of the smaller schema a "
"`HasCol` that points to its location in the larger schema."
msgstr "换句话说，`Subschema` 为较小模式的每一列分配一个 `HasCol`，该 `HasCol` 指向其在大模式中的位置。"

#: src/dependent-types/typed-queries.md:254
#, fuzzy
msgid ""
"The schema `travelDiary` represents the fields that are common to both "
"`peak` and `waterfall`:"
msgstr "模式 `travelDiary` 表示 `peak` 和 `waterfall` 共有的字段："

#: src/dependent-types/typed-queries.md:255
msgid ""
"```lean\n"
"abbrev travelDiary : Schema :=\n"
"  [⟨\"name\", .string⟩, ⟨\"location\", .string⟩, ⟨\"lastVisited\", .int⟩]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:259
#, fuzzy
msgid "It is certainly a subschema of `peak`, as shown by this example:"
msgstr "它肯定是大模式的子模式，如下例所示："

#: src/dependent-types/typed-queries.md:266
#, fuzzy
msgid ""
"However, code like this is difficult to read and difficult to maintain. One "
"way to improve it is to instruct Lean to write the `Subschema` and `HasCol` "
"constructors automatically. This can be done using the tactic feature that "
"was introduced in [the Interlude on propositions and proofs](../props-"
"proofs-indexing.md). That interlude uses `by simp` to provide evidence of "
"various propositions."
msgstr ""
"但是，这样的代码难以阅读和维护。改进它的方法之一是指示 Lean 自动编写 `Subschema` 和 `HasCol` 构造子。这可以使用 "
"[命题和证明的插曲](../props-proofs-indexing.md) 中引入的策略功能来完成。该插曲使用 `by simp` "
"来提供各种命题的证据。"

#: src/dependent-types/typed-queries.md:271
#, fuzzy
msgid "In this context, two tactics are useful:"
msgstr "在此上下文中，两个策略很有用："

#: src/dependent-types/typed-queries.md:272
#, fuzzy
msgid ""
"The `constructor` tactic instructs Lean to solve the problem using the "
"constructor of a datatype."
msgstr "`constructor` 策略指示 Lean 使用数据类型的构造子来解决问题。"

#: src/dependent-types/typed-queries.md:273
#, fuzzy
msgid ""
"The `repeat` tactic instructs Lean to repeat a tactic over and over until it"
" either fails or the proof is finished."
msgstr "`repeat` 策略指示 Lean 重复执行策略，直到策略失败或证明完成。"

#: src/dependent-types/typed-queries.md:275
#, fuzzy
msgid ""
"In the next example, `by constructor` has the same effect as just writing "
"`.nil` would have:"
msgstr "在下一个示例中，`by constructor` 的效果与直接编写 `.nil` 相同："

#: src/dependent-types/typed-queries.md:279
#, fuzzy
msgid ""
"However, attempting that same tactic with a slightly more complicated type "
"fails:"
msgstr "然而，尝试使用稍微复杂一点的类型执行相同的策略会失败："

#: src/dependent-types/typed-queries.md:280
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:283
msgid ""
"```output error\n"
"unsolved goals\n"
"case a\n"
"⊢ HasCol peak \"location\" DBType.string\n"
"\n"
"case a\n"
"⊢ Subschema [] peak\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:291
#, fuzzy
msgid ""
"Errors that begin with `unsolved goals` describe tactics that failed to "
"completely build the expressions that they were supposed to. In Lean's "
"tactic language, a _goal_ is a type that a tactic is to fulfill by "
"constructing an appropriate expression behind the scenes. In this case, "
"`constructor` caused `Subschema.cons` to be applied, and the two goals "
"represent the two arguments expected by `cons`. Adding another instance of "
"`constructor` causes the first goal (`HasCol peak \\\"location\\\" "
"DBType.string`) to be addressed with `HasCol.there`, because `peak`'s first "
"column is not `\"location\"`:"
msgstr ""
"以「未解决目标」开头的错误描述了未能完全构建应构建表达式的策略。在 Lean "
"的策略语言中，_目标_是一种类型，策略通过在幕后构建适当的表达式来实现该类型。在本例中，`constructor` 导致应用了 "
"`Subschema.cons`，并且这两个目标表示 `cons` 预期的两个参数。添加另一个 `constructor` 实例会导致第一个目标 "
"(`HasCol peak \\\"location\\\" DBType.string`) 使用 `HasCol.there` 解决，因为 "
"`peak` 的第一列不是「`location`」："

#: src/dependent-types/typed-queries.md:295
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by\n"
"  constructor\n"
"  constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:300
msgid ""
"```output error\n"
"unsolved goals\n"
"case a.a\n"
"⊢ HasCol\n"
"    [{ name := \"location\", contains := DBType.string }, { name := \"elevation\", contains := DBType.int },\n"
"      { name := \"lastVisited\", contains := DBType.int }]\n"
"    \"location\" DBType.string\n"
"\n"
"case a\n"
"⊢ Subschema [] peak\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:311
#, fuzzy
msgid ""
"However, adding a third `constructor` results in the first goal being "
"solved, because `HasCol.here` is applicable:"
msgstr "然而，添加第三个 `constructor` 会导致第一个目标得到解决，因为 `HasCol.here` 是适用的："

#: src/dependent-types/typed-queries.md:312
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by\n"
"  constructor\n"
"  constructor\n"
"  constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:323
#, fuzzy
msgid ""
"A fourth instance of `constructor` solves the `Subschema peak []` goal:"
msgstr "第四个 `constructor` 实例解决了 `Subschema peak []` 目标："

#: src/dependent-types/typed-queries.md:324
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by\n"
"  constructor\n"
"  constructor\n"
"  constructor\n"
"  constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:331
#, fuzzy
msgid ""
"Indeed, a version written without the use of tactics has four constructors:"
msgstr "事实上，不使用策略编写的版本有四个构造子："

#: src/dependent-types/typed-queries.md:332
msgid ""
"```lean\n"
"example : Subschema [⟨\"location\", .string⟩] peak :=\n"
"  .cons (.there .here) .nil\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:337
#, fuzzy
msgid ""
"Instead of experimenting to find the right number of times to write "
"`constructor`, the `repeat` tactic can be used to ask Lean to just keep "
"trying `constructor` as long as it keeps making progress:"
msgstr ""
"与其尝试找到编写 `constructor` 的正确次数，不如使用 `repeat` 策略要求 Lean 只要 `constructor` "
"持续取得进展，就继续尝试 `constructor`："

#: src/dependent-types/typed-queries.md:338
msgid ""
"```leantac\n"
"example : Subschema [⟨\"location\", .string⟩] peak := by repeat constructor\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:341
#, fuzzy
msgid ""
"This more flexible version also works for more interesting `Subschema` "
"problems:"
msgstr "这个更灵活的版本也适用于更有趣的 `Subschema` 问题："

#: src/dependent-types/typed-queries.md:348
#, fuzzy
msgid ""
"The approach of blindly trying constructors until something works is not "
"very useful for types like `Nat` or `List Bool`. Just because an expression "
"has type `Nat` doesn't mean that it's the _correct_ `Nat`, after all. But "
"types like `HasCol` and `Subschema` are sufficiently constrained by their "
"indices that only one constructor will ever be applicable, which means that "
"the contents of the program itself are less interesting, and a computer can "
"pick the correct one."
msgstr ""
"盲目尝试构造子直到找到可行方案的方法对于 `Nat` 或 `List Bool` 类型的帮助不大。毕竟，仅仅因为一个表达式具有 `Nat` "
"类型并不意味着它是「正确的」`Nat`。但是，`HasCol` 和 `Subschema` "
"等类型受到其索引的充分约束，因此只有一个构造子适用，这意味着程序本身的内容不太有趣，计算机可以选择正确的构造子。"

#: src/dependent-types/typed-queries.md:352
#, fuzzy
msgid ""
"If one schema is a subschema of another, then it is also a subschema of the "
"larger schema extended with an additional column. This fact can be captured "
"as a function definition. `Subschema.addColumn` takes evidence that "
"`smaller` is a subschema of `bigger`, and then returns evidence that "
"`smaller` is a subschema of `c :: bigger`, that is, `bigger` with one "
"additional column:"
msgstr ""
"如果一个模式是另一个模式的子模式，那么它也是扩展了附加列的更大模式的子模式。这一事实可以作为函数定义来捕获。`Subschema.addColumn` "
"接受 `smaller` 是 `bigger` 的子模式的证据，然后返回 `smaller` 是 `c :: bigger` 的子模式的证据，即 "
"`bigger` 带有一个附加列："

#: src/dependent-types/typed-queries.md:361
#, fuzzy
msgid ""
"A subschema describes where to find each column from the smaller schema in "
"the larger schema. `Subschema.addColumn` must translate these descriptions "
"from the original larger schema into the extended larger schema. In the "
"`nil` case, the smaller schema is `[]`, and `nil` is also evidence that `[]`"
" is a subschema of `c :: bigger`. In the `cons` case, which describes how to"
" place one column from `smaller` into `larger`, the placement of the column "
"needs to be adjusted with `there` to account for the new column `c`, and a "
"recursive call adjusts the rest of the columns."
msgstr ""
"子模式描述了如何在更大的模式中找到较小模式中的每一列。`Subschema.addColumn` 必须将这些描述从原始的更大模式转换为扩展的更大模式。在"
" `nil` 情况下，较小模式是 `[]`，而 `nil` 也是 `[]` 是 `c :: bigger` 的子模式的证据。在 `cons` "
"情况下，它描述了如何将 `smaller` 中的一列放入 `larger` 中，列的位置需要用 `there` 调整以考虑新列 "
"`c`，递归调用调整其余列。"

#: src/dependent-types/typed-queries.md:366
#, fuzzy
msgid ""
"Another way to think about `Subschema` is that it defines a _relation_ "
"between two schemas—the existence of an expression  with type `Subschema "
"bigger smaller` means that `(bigger, smaller)` is in the relation. This "
"relation is reflexive, meaning that every schema is a subschema of itself:"
msgstr ""
"考虑 `Subschema` 的另一种方法是，它定义了两个模式之间的「关系」——具有类型 `Subschema bigger smaller` "
"的表达式的存在意味着 `(bigger, smaller)` 在关系中。这种关系是自反的，这意味着每个模式都是其自身的子模式："

#: src/dependent-types/typed-queries.md:375
#, fuzzy
msgid "Projecting Rows"
msgstr "投影行"

#: src/dependent-types/typed-queries.md:377
#, fuzzy
msgid ""
"Given evidence that `s'` is a subschema of `s`, a row in `s` can be "
"projected into a row in `s'`. This is done using the evidence that `s'` is a"
" subschema of `s`, which explains where each column of `s'` is found in `s`."
" The new row in `s'` is built up one column at a time by retrieving the "
"value from the appropriate place in the old row."
msgstr ""
"给定 `s'` 是 `s` 的子模式的证据，`s` 中的一行可以投影到 `s'` 中的一行。这是使用 `s'` 是 `s` "
"的子模式的证据来完成的，该证据解释了 `s'` 的每一列在 `s` 中的位置。`s'` 中的新行一次构建一列，通过从旧行中的适当位置检索值。"

#: src/dependent-types/typed-queries.md:381
#, fuzzy
msgid ""
"The function that performs this projection, `Row.project`, has three cases, "
"one for each case of `Row` itself. It uses `Row.get` together with each "
"`HasCol` in the `Subschema` argument to construct the projected row:"
msgstr ""
"执行此投影的函数 `Row.project` 有三个情况，每个情况对应 `Row` 本身的一个情况。它将 `Row.get` 与 `Subschema`"
" 参数中的每个 `HasCol` 一起使用来构造投影行："

#: src/dependent-types/typed-queries.md:391
#, fuzzy
msgid "Conditions and Selection"
msgstr "条件和选择"

#: src/dependent-types/typed-queries.md:393
#, fuzzy
msgid ""
"Projection removes unwanted columns from a table, but queries must also be "
"able to remove unwanted rows. This operation is called _selection_. "
"Selection relies on having a means of expressing which rows are desired."
msgstr "投影从表中删除不需要的列，但查询还必须能够删除不需要的行。此操作称为 _选择_。选择依赖于拥有表达所需行的某种方式。"

#: src/dependent-types/typed-queries.md:397
#, fuzzy
msgid ""
"The example query language contains expressions, which are analogous to what"
" can be written in a `WHERE` clause in SQL. Expressions are represented by "
"the indexed family `DBExpr`. Because expressions can refer to columns from "
"the database, but different sub-expressions all have the same schema, "
"`DBExpr` takes the database schema as a parameter. Additionally, each "
"expression has a type, and these vary, making it an index:"
msgstr ""
"示例查询语言包含表达式，类似于可以在 SQL 中的 `WHERE` 子句中编写的表达式。表达式由索引族 `DBExpr` "
"表示。因为表达式可以引用数据库中的列，但不同的子表达式都有相同的模式，所以 `DBExpr` "
"将数据库模式作为参数。此外，每个表达式都有一个类型，并且这些类型各不相同，使其成为一个索引："

#: src/dependent-types/typed-queries.md:409
#, fuzzy
msgid ""
"The `col` constructor represents a reference to a column in the database. "
"The `eq` constructor compares two expressions for equality, `lt` checks "
"whether one is less than the other, `and` is Boolean conjunction, and "
"`const` is a constant value of some type."
msgstr ""
"`col` 构造子表示对数据库中一列的引用。`eq` 构造子比较两个表达式的相等性，`lt` 检查一个是否小于另一个，`and` "
"是布尔连接，`const` 是某种类型的常量值。"

#: src/dependent-types/typed-queries.md:412
#, fuzzy
msgid ""
"For example, an expression in `peak` that checks whether the `elevation` "
"column is greater than 1000 and the location is `\"Denmark\"` can be "
"written:"
msgstr "例如，在 `peak` 中检查 `elevation` 列是否大于 1000 且位置为 `\"Denmark\"` 的表达式可以写成："

#: src/dependent-types/typed-queries.md:413
msgid ""
"```leantac\n"
"def tallInDenmark : DBExpr peak .bool :=\n"
"  .and (.lt (.const 1000) (.col \"elevation\" (by repeat constructor)))\n"
"       (.eq (.col \"location\" (by repeat constructor)) (.const \"Denmark\"))\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:418
#, fuzzy
msgid ""
"This is somewhat noisy. In particular, references to columns contain "
"boilerplate calls to `by repeat constructor`. A Lean feature called _macros_"
" can help make expressions easier to read by eliminating this boilerplate:"
msgstr ""
"此方法有些繁琐。特别是，对列的引用包含对 `by repeat constructor` 的样板调用。Lean 中一项名为 _宏_ "
"的功能可以通过消除此样板来帮助使表达式更易于阅读："

#: src/dependent-types/typed-queries.md:421
msgid ""
"```leantac\n"
"macro \"c!\" n:term : term => `(DBExpr.col $n (by repeat constructor))\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:424
#, fuzzy
msgid ""
"This declaration adds the `c!` keyword to Lean, and instructs Lean to "
"replace any instance of `c!` followed by an expression with the "
"corresponding `DBExpr.col` construction. Here, `term` stands for Lean "
"expressions, rather than commands, tactics, or some other part of the "
"language. Lean macros are a bit like C preprocessor macros, except they are "
"better integrated into the language and they automatically avoid some of the"
" pitfalls of CPP. In fact, they are very closely related to macros in Scheme"
" and Racket."
msgstr ""
"此声明将 `c!` 关键字添加到 Lean，并指示 Lean 用相应的 `DBExpr.col` 构造替换任何 `c!` "
"后跟表达式的实例。此处，`term` 表示 Lean 表达式，而不是命令、策略或语言的其他部分。Lean 宏有点像 C "
"预处理器宏，但它们更好地集成到语言中，并且自动避免了 CPP 的一些缺陷。事实上，它们与 Scheme 和 Racket 中的宏非常相似。"

#: src/dependent-types/typed-queries.md:429
#, fuzzy
msgid "With this macro, the expression can be much easier to read:"
msgstr "使用此宏，表达式可以更容易阅读："

#: src/dependent-types/typed-queries.md:430
msgid ""
"```lean\n"
"def tallInDenmark : DBExpr peak .bool :=\n"
"  .and (.lt (.const 1000) (c! \"elevation\"))\n"
"       (.eq (c! \"location\") (.const \"Denmark\"))\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:436
#, fuzzy
msgid ""
"Finding the value of an expression with respect to a given row uses "
"`Row.get` to extract column references, and it delegates to Lean's "
"operations on values for every other expression:"
msgstr "根据给定行查找表达式的值使用 `Row.get` 提取列引用，并且它将对除其他表达式之外的每个表达式的值的 Lean 操作委派："

#: src/dependent-types/typed-queries.md:446
#, fuzzy
msgid ""
"Evaluating the expression for Valby Bakke, the tallest hill in the "
"Copenhagen area, yields `false` because Valby Bakke is much less than 1 km "
"over sea level:"
msgstr ""
"针对哥本哈根地区最高的丘陵 Valby Bakke 计算表达式的值，结果为 `false`，因为 Valby Bakke 海拔远低于 1 公里："

#: src/dependent-types/typed-queries.md:447
msgid ""
"```lean\n"
"#eval tallInDenmark.evaluate (\"Valby Bakke\", \"Denmark\", 31, 2023)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:453
#, fuzzy
msgid ""
"Evaluating it for a fictional mountain of 1230m elevation yields `true`:"
msgstr "针对海拔 1230 米的虚构山峰计算表达式的值，结果为 `true`："

#: src/dependent-types/typed-queries.md:454
msgid ""
"```lean\n"
"#eval tallInDenmark.evaluate (\"Fictional mountain\", \"Denmark\", 1230, 2023)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:460
#, fuzzy
msgid ""
"Evaluating it for the highest peak in the US state of Idaho yields `false`, "
"as Idaho is not part of Denmark:"
msgstr "针对美国爱达荷州的最高峰计算表达式的值，结果为 `false`，因为爱达荷州不属于丹麦："

#: src/dependent-types/typed-queries.md:461
msgid ""
"```lean\n"
"#eval tallInDenmark.evaluate (\"Mount Borah\", \"USA\", 3859, 1996)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:468
#, fuzzy
msgid "Queries"
msgstr "查询"

#: src/dependent-types/typed-queries.md:470
#, fuzzy
msgid ""
"The query language is based on relational algebra. In addition to tables, it"
" includes the following operators:"
msgstr "查询语言基于关系代数。除了表之外，它还包括以下运算符："

#: src/dependent-types/typed-queries.md:472
#, fuzzy
msgid ""
"The union of two expressions that have the same schema combines the rows "
"that result from two queries"
msgstr "具有相同模式的两个表达式的并集合并了由两个查询产生的行"

#: src/dependent-types/typed-queries.md:473
#, fuzzy
msgid ""
"The difference of two expressions that have the same schema removes rows "
"found in the second result from the rows in the first result"
msgstr "两个具有相同模式的表达式的差集，从第一个结果中删除在第二个结果中找到的行"

#: src/dependent-types/typed-queries.md:474
#, fuzzy
msgid ""
"Selection by some criterion filters the result of a query according to an "
"expression"
msgstr "按某个条件进行选择，根据一个表达式过滤查询结果"

#: src/dependent-types/typed-queries.md:475
#, fuzzy
msgid ""
"Projection into a subschema, removing columns from the result of a query"
msgstr "投影到一个子模式，从查询结果中删除列"

#: src/dependent-types/typed-queries.md:476
#, fuzzy
msgid ""
"Cartesian product, combining every row from one query with every row from "
"another"
msgstr "笛卡尔积，将一个查询中的每一行与另一个查询中的每一行组合"

#: src/dependent-types/typed-queries.md:477
#, fuzzy
msgid "Renaming a column in the result of a query, which modifies its schema"
msgstr "重命名查询结果中的列，修改其模式"

#: src/dependent-types/typed-queries.md:478
#, fuzzy
msgid "Prefixing all columns in a query with a name"
msgstr "给查询中的所有列加上一个前缀名"

#: src/dependent-types/typed-queries.md:480
#, fuzzy
msgid ""
"The last operator is not strictly necessary, but it makes the language more "
"convenient to use."
msgstr "最后一个操作符不是严格必要的，但它使语言更方便使用。"

#: src/dependent-types/typed-queries.md:482
#, fuzzy
msgid "Once again, queries are represented by an indexed family:"
msgstr "同样，查询由一个索引族表示："

#: src/dependent-types/typed-queries.md:483
msgid ""
"```lean\n"
"inductive Query : Schema → Type where\n"
"  | table : Table s → Query s\n"
"  | union : Query s → Query s → Query s\n"
"  | diff : Query s → Query s → Query s\n"
"  | select : Query s → DBExpr s .bool → Query s\n"
"  | project : Query s → (s' : Schema) → Subschema s' s → Query s'\n"
"  | product :\n"
"      Query s1 → Query s2 →\n"
"      disjoint (s1.map Column.name) (s2.map Column.name) →\n"
"      Query (s1 ++ s2)\n"
"  | renameColumn :\n"
"      Query s → (c : HasCol s n t) → (n' : String) → !((s.map Column.name).contains n') →\n"
"      Query (s.renameColumn c n')\n"
"  | prefixWith :\n"
"      (n : String) → Query s →\n"
"      Query (s.map fun c => {c with name := n ++ \".\" ++ c.name})\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:501
#, fuzzy
msgid ""
"The `select` constructor requires that the expression used for selection "
"return a Boolean. The `product` constructor's type contains a call to "
"`disjoint`, which ensures that the two schemas don't share any names:"
msgstr ""
"`select` 构造子要求用于选择的表达式返回一个布尔值。`product` 构造子的类型包含对 `disjoint` "
"的调用，以确保两个模式不共享任何名称："

#: src/dependent-types/typed-queries.md:507
#, fuzzy
msgid ""
"The use of an expression of type `Bool` where a type is expected triggers a "
"coercion from `Bool` to `Prop`. Just as decidable propositions can be "
"considered to be Booleans, where evidence for the proposition is coerced to "
"`true` and refutations of the proposition are coerced to `false`, Booleans "
"are coerced into the proposition that states that the expression is equal to"
" `true`. Because all uses of the library are expected to occur in contexts "
"where the schemas are known ahead of time, this proposition can be proved "
"with `by simp`. Similarly, the `renameColumn` constructor checks that the "
"new name does not already exist in the schema. It uses the helper "
"`Schema.renameColumn` to change the name of the column pointed to by "
"`HasCol`:"
msgstr ""
"在期望类型的地方使用类型为 `Bool` 的表达式会触发从 `Bool` 到 `Prop` "
"的强制转换。正如可判定命题可以被认为是布尔值，其中命题的证据被强制转换为 `true`，而命题的驳斥被强制转换为 "
"`false`，布尔值被强制转换为命题，该命题指出表达式等于 `true`。由于期望库的所有使用都发生在模式已知的上下文中，因此可以使用 `by "
"simp` 证明此命题。类似地，`renameColumn` 构造子检查新名称是否已存在于模式中。它使用辅助函数 "
"`Schema.renameColumn` 来更改 `HasCol` 指向的列的名称："

#: src/dependent-types/typed-queries.md:518
#, fuzzy
msgid "Executing Queries"
msgstr "执行查询"

#: src/dependent-types/typed-queries.md:520
#, fuzzy
msgid ""
"Executing queries requires a number of helper functions. The result of a "
"query is a table; this means that each operation in the query language "
"requires a corresponding implementation that works with tables."
msgstr "执行查询需要一些辅助函数。查询结果是一个表；这意味着查询语言中的每个操作都需要一个与表一起工作的相应实现。"

#: src/dependent-types/typed-queries.md:523
#, fuzzy
msgid "Cartesian Product"
msgstr "笛卡尔积"

#: src/dependent-types/typed-queries.md:525
#, fuzzy
msgid ""
"Taking the Cartesian product of two tables is done by appending each row "
"from the first table to each row from the second. First off, due to the "
"structure of `Row`, adding a single column to a row requires pattern "
"matching on its schema in order to determine whether the result will be a "
"bare value or a tuple. Because this is a common operation, factoring the "
"pattern matching out into a helper is convenient:"
msgstr ""
"通过将第一个表中的每一行附加到第二个表中的每一行来获取两个表的笛卡尔积。首先，由于 `Row` "
"的结构体，向行中添加单个列需要对其模式进行模式匹配，以确定结果是裸值还是元组。由于这是一个常见操作，因此将模式匹配分解为一个辅助函数很方便："

#: src/dependent-types/typed-queries.md:534
#, fuzzy
msgid ""
"Appending two rows is recursive on the structure of both the first schema "
"and the first row, because the structure of the row proceeds in lock-step "
"with the structure of the schema. When the first row is empty, appending "
"returns the second row. When the first row is a singleton, the value is "
"added to the second row. When the first row contains multiple columns, the "
"first column's value is added to the result of recursion on the remainder of"
" the row."
msgstr ""
"附加两行在第一个模式和第一行的结构体上是递归的，因为行的结构体与模式的结构体同步进行。当第一行为空时，附加返回第二行。当第一行是单例时，该值将添加到第二行。当第一行包含多列时，第一列的值将添加到对该行其余部分的递归结果中。"

#: src/dependent-types/typed-queries.md:546
#, fuzzy
msgid ""
"`List.flatMap` applies a function that itself returns a list to every entry "
"in an input list, returning the result of appending the resulting lists in "
"order:"
msgstr "`List.flatMap` 将本身返回列表的函数应用于输入列表中的每个条目，按顺序返回附加结果列表的结果："

#: src/dependent-types/typed-queries.md:552
#, fuzzy
msgid ""
"The type signature suggests that `List.flatMap` could be used to implement a"
" `Monad List` instance. Indeed, together with `pure x := [x]`, "
"`List.flatMap` does implement a monad. However, it's not a very useful "
"`Monad` instance. The `List` monad is basically a version of `Many` that "
"explores _every_ possible path through the search space in advance, before "
"users have the chance to request some number of values. Because of this "
"performance trap, it's usually not a good idea to define a `Monad` instance "
"for `List`. Here, however, the query language has no operator for "
"restricting the number of results to be returned, so combining all "
"possibilities is exactly what is desired:"
msgstr ""
"类型签名表明 `List.flatMap` 可用于实现 `Monad List` 实例。事实上，与 `pure x := [x]` "
"一起，`List.flatMap` 确实实现了单子。但是，它不是一个非常有用的 `Monad` 实例。`List` 单子基本上是 `Many` "
"的一个版本，它在用户有机会请求一些值之前，预先探索搜索空间中的 _every_ 可能路径。由于这个性能陷阱，通常不建议为 `List` 定义 "
"`Monad` 实例。然而，这里查询语言没有用于限制要返回的结果数量的操作符，因此组合所有可能性正是所需要的："

#: src/dependent-types/typed-queries.md:563
#, fuzzy
msgid ""
"Just as with `List.product`, a loop with mutation in the identity monad can "
"be used as an alternative implementation technique:"
msgstr "与 `List.product` 一样，带有恒等单子中的变异循环可以用作替代实现技术："

#: src/dependent-types/typed-queries.md:574
#, fuzzy
msgid "Difference"
msgstr "差异"

#: src/dependent-types/typed-queries.md:576
#, fuzzy
msgid ""
"Removing undesired rows from a table can be done using `List.filter`, which "
"takes a list and a function that returns a `Bool`. A new list is returned "
"that contains only the entries for which the function returns `true`. For "
"instance,"
msgstr ""
"可以使用 `List.filter` 从表中删除不需要的行，它接受一个列表和一个返回 `Bool` 的函数。返回一个新列表，其中仅包含函数返回 "
"`true` 的条目。例如，"

#: src/dependent-types/typed-queries.md:579
msgid ""
"```lean\n"
"[\"Willamette\", \"Columbia\", \"Sandy\", \"Deschutes\"].filter (·.length > 8)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:583
msgid ""
"```lean\n"
"[\"Willamette\", \"Deschutes\"]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:586
#, fuzzy
msgid ""
"because `\"Columbia\"` and `\"Sandy\"` have lengths less than or equal to "
"`8`. Removing the entries of a table can be done using the helper "
"`List.without`:"
msgstr "因为 `\"Columbia\"` 和 `\"Sandy\"` 的长度小于或等于 `8`。可以使用辅助函数 `List.without` 删除表中的条目："

#: src/dependent-types/typed-queries.md:592
#, fuzzy
msgid ""
"This will be used with the `BEq` instance for `Row` when interpreting "
"queries."
msgstr "这将在解释查询时与 `Row` 的 `BEq` 实例一起使用。"

#: src/dependent-types/typed-queries.md:594
#, fuzzy
msgid "Renaming Columns"
msgstr "重命名列"

#: src/dependent-types/typed-queries.md:595
#, fuzzy
msgid ""
"Renaming a column in a row is done with a recursive function that traverses "
"the row until the column in question is found, at which point the column "
"with the new name gets the same value as the column with the old name:"
msgstr "使用递归函数重命名行中的列，该函数遍历行直到找到有问题的列，此时具有新名称的列将获得与具有旧名称的列相同的值："

#: src/dependent-types/typed-queries.md:603
#, fuzzy
msgid ""
"While this function changes the _type_ of its argument, the actual return "
"value contains precisely the same data as the original argument. From a run-"
"time perspective, `renameRow` is nothing but a slow identity function. One "
"difficulty in programming with indexed families is that when performance "
"matters, this kind of operation can get in the way. It takes a very careful,"
" often brittle, design to eliminate these kinds of \"re-indexing\" "
"functions."
msgstr ""
"虽然此函数更改了其参数的 _类型_，但实际返回值包含与原始参数完全相同的数据。从运行时角度来看，`renameRow` "
"只是一个缓慢的恒等函数。使用索引族编程的一个困难是，当性能很重要时，这种操作可能会妨碍。需要非常小心、通常很脆弱的设计才能消除这些类型的「重新索引」函数。"

#: src/dependent-types/typed-queries.md:608
#, fuzzy
msgid "Prefixing Column Names"
msgstr "为列名添加前缀"

#: src/dependent-types/typed-queries.md:610
#, fuzzy
msgid ""
"Adding a prefix to column names is very similar to renaming a column. "
"Instead of proceeding to a desired column and then returning, `prefixRow` "
"must process all columns:"
msgstr "为列名添加前缀与重命名列非常相似。`prefixRow` 必须处理所有列，而不是继续到所需列然后返回："

#: src/dependent-types/typed-queries.md:612
msgid ""
"```lean\n"
"def prefixRow (row : Row s) : Row (s.map fun c => {c with name := n ++ \".\" ++ c.name}) :=\n"
"  match s, row with\n"
"  | [], _ => ()\n"
"  | [_], v => v\n"
"  | _::_::_, (v, r) => (v, prefixRow r)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:619
#, fuzzy
msgid ""
"This can be used with `List.map` in order to add a prefix to all rows in a "
"table. Once again, this function only exists to change the type of a value."
msgstr "这可以与 `List.map` 一起使用，以便为表中的所有行添加前缀。同样，此函数仅存在于更改值类型。"

#: src/dependent-types/typed-queries.md:622
#, fuzzy
msgid "Putting the Pieces Together"
msgstr "将各个部分组合起来"

#: src/dependent-types/typed-queries.md:624
#, fuzzy
msgid ""
"With all of these helpers defined, executing a query requires only a short "
"recursive function:"
msgstr "有了这些定义好的辅助函数，执行查询只需要一个简短的递归函数："

#: src/dependent-types/typed-queries.md:636
#, fuzzy
msgid ""
"Some arguments to the constructors are not used during execution. In "
"particular, both the constructor `project` and the function `Row.project` "
"take the smaller schema as explicit arguments, but the type of the "
"_evidence_ that this schema is a subschema of the larger schema contains "
"enough information for Lean to fill out the argument automatically. "
"Similarly, the fact that the two tables have disjoint column names that is "
"required by the `product` constructor is not needed by "
"`Table.cartesianProduct`. Generally speaking, dependent types provide many "
"opportunities to have Lean fill out arguments on behalf of the programmer."
msgstr ""
"构造子的一些参数在执行过程中不会使用。特别是，构造子 `project` 和函数 `Row.project` "
"都将较小的模式作为显式参数，但此模式是较大模式的子模式的 _证据_ 的类型包含足够的信息，以便 Lean 自动填写参数。类似地，`product` "
"构造子所需的两个表具有不相交的列名这一事实对于 `Table.cartesianProduct` 来说是不需要的。一般来说，依值类型提供了许多机会，让"
" Lean 可以代表程序员填写参数。"

#: src/dependent-types/typed-queries.md:641
#, fuzzy
msgid ""
"Dot notation is used with the results of queries to call functions defined "
"both in the `Table` and `List` namespaces, such `List.map`, `List.filter`, "
"and `Table.cartesianProduct`. This works because `Table` is defined using "
"`abbrev`. Just like type class search, dot notation can see through "
"definitions created with `abbrev`. "
msgstr ""
"点表示法与查询结果一起使用，以调用在 `Table` 和 `List` 命名空间中定义的函数，例如 `List.map`、`List.filter` 和"
" `Table.cartesianProduct`。这样做是因为 `Table` 是使用 `abbrev` "
"定义的。就像类型类搜索一样，点表示法可以通过使用 `abbrev` 创建的定义。"

#: src/dependent-types/typed-queries.md:645
#, fuzzy
msgid ""
"The implementation of `select` is also quite concise. After executing the "
"query `q`, `List.filter` is used to remove the rows that do not satisfy the "
"expression. Filter expects a function from `Row s` to `Bool`, but "
"`DBExpr.evaluate` has type `Row s → DBExpr s t → t.asType`. Because the type"
" of the `select` constructor requires that the expression have type `DBExpr "
"s .bool`, `t.asType` is actually `Bool` in this context."
msgstr ""
"`select` 的实现也很简洁。在执行查询 `q` 之后，`List.filter` 用于删除不满足表达式的行。Filter 期望从 `Row s` "
"到 `Bool` 的函数，但 `DBExpr.evaluate` 的类型为 `Row s → DBExpr s t → t.asType`。因为 "
"`select` 构造子的类型要求表达式具有类型 `DBExpr s .bool`，所以 `t.asType` 在此上下文中实际上是 `Bool`。"

#: src/dependent-types/typed-queries.md:650
#, fuzzy
msgid ""
"A query that finds the heights of all mountain peaks with an elevation "
"greater than 500 meters can be written:"
msgstr "查询所有海拔高度大于 500 米的山峰高度，可以写成："

#: src/dependent-types/typed-queries.md:651
msgid ""
"```leantac\n"
"open Query in\n"
"def example1 :=\n"
"  table mountainDiary |>.select\n"
"  (.lt (.const 500) (c! \"elevation\")) |>.project\n"
"  [⟨\"elevation\", .int⟩] (by repeat constructor)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:659
#, fuzzy
msgid "Executing it returns the expected list of integers:"
msgstr "执行它会返回预期的整数列表："

#: src/dependent-types/typed-queries.md:667
#, fuzzy
msgid ""
"To plan a sightseeing tour, it may be relevant to match all pairs mountains "
"and waterfalls in the same location. This can be done by taking the "
"Cartesian product of both tables, selecting only the rows in which they are "
"equal, and then projecting out the names:"
msgstr "为了规划观光路线，匹配同一地点的所有山峰和瀑布对可能很有用。这可以通过对两个表进行笛卡尔积，仅选择其中相等的行，然后投影出名称来完成："

#: src/dependent-types/typed-queries.md:669
msgid ""
"```leantac\n"
"open Query in\n"
"def example2 :=\n"
"  let mountain := table mountainDiary |>.prefixWith \"mountain\"\n"
"  let waterfall := table waterfallDiary |>.prefixWith \"waterfall\"\n"
"  mountain.product waterfall (by simp)\n"
"    |>.select (.eq (c! \"mountain.location\") (c! \"waterfall.location\"))\n"
"    |>.project [⟨\"mountain.name\", .string⟩, ⟨\"waterfall.name\", .string⟩] (by repeat constructor)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:678
#, fuzzy
msgid ""
"Because the example data includes only waterfalls in the USA, executing the "
"query returns pairs of mountains and waterfalls in the US:"
msgstr "由于示例数据仅包含美国境内的瀑布，因此执行查询会返回美国境内山峰和瀑布对："

#: src/dependent-types/typed-queries.md:682
msgid ""
"```output info\n"
"[(\"Mount Nebo\", \"Multnomah Falls\"),\n"
" (\"Mount Nebo\", \"Shoshone Falls\"),\n"
" (\"Moscow Mountain\", \"Multnomah Falls\"),\n"
" (\"Moscow Mountain\", \"Shoshone Falls\"),\n"
" (\"Mount St. Helens\", \"Multnomah Falls\"),\n"
" (\"Mount St. Helens\", \"Shoshone Falls\")]\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:691
#, fuzzy
msgid "Errors You May Meet"
msgstr "您可能遇到的错误"

#: src/dependent-types/typed-queries.md:693
#, fuzzy
msgid ""
"Many potential errors are ruled out by the definition of `Query`. For "
"instance, forgetting the added qualifier in `\"mountain.location\"` yields a"
" compile-time error that highlights the column reference `c! \"location\"`:"
msgstr ""
"`Query` 的定义排除了许多潜在错误。例如，忘记在 `\"mountain.location\"` "
"中添加限定符会导致编译时错误，该错误突出显示列引用 `c! \"location\"`："

#: src/dependent-types/typed-queries.md:695
msgid ""
"```leantac\n"
"open Query in\n"
"def example2 :=\n"
"  let mountains := table mountainDiary |>.prefixWith \"mountain\"\n"
"  let waterfalls := table waterfallDiary |>.prefixWith \"waterfall\"\n"
"  mountains.product waterfalls (by simp)\n"
"    |>.select (.eq (c! \"location\") (c! \"waterfall.location\"))\n"
"    |>.project [⟨\"mountain.name\", .string⟩, ⟨\"waterfall.name\", .string⟩] (by repeat constructor)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:704
#, fuzzy
msgid ""
"This is excellent feedback! On the other hand, the text of the error message"
" is quite difficult to act on:"
msgstr "这是一个极好的反馈！另一方面，错误消息的文本很难采取行动："

#: src/dependent-types/typed-queries.md:706
msgid ""
"```output error\n"
"unsolved goals\n"
"case a.a.a.a.a.a.a\n"
"mountains : Query (List.map (fun c => { name := \"mountain\" ++ \".\" ++ c.name, contains := c.contains }) peak) :=\n"
"  prefixWith \"mountain\" (table mountainDiary)\n"
"waterfalls : Query (List.map (fun c => { name := \"waterfall\" ++ \".\" ++ c.name, contains := c.contains }) waterfall) :=\n"
"  prefixWith \"waterfall\" (table waterfallDiary)\n"
"⊢ HasCol (List.map (fun c => { name := \"waterfall\" ++ \".\" ++ c.name, contains := c.contains }) []) \"location\" ?m.109970\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:716
#, fuzzy
msgid ""
"Similarly, forgetting to add prefixes to the names of the two tables results"
" in an error on `by simp`, which should provide evidence that the schemas "
"are in fact disjoint;"
msgstr "类似地，忘记为两个表的名称添加前缀会导致 `by simp` 出错，这应该提供证据证明模式实际上是不相交的；"

#: src/dependent-types/typed-queries.md:717
msgid ""
"```leantac\n"
"open Query in\n"
"def example2 :=\n"
"  let mountains := table mountainDiary\n"
"  let waterfalls := table waterfallDiary\n"
"  mountains.product waterfalls (by simp)\n"
"    |>.select (.eq (c! \"mountain.location\") (c! \"waterfall.location\"))\n"
"    |>.project [⟨\"mountain.name\", .string⟩, ⟨\"waterfall.name\", .string⟩] (by repeat constructor)\n"
"```"
msgstr ""

#: src/dependent-types/typed-queries.md:726
#, fuzzy
msgid "However, the error message is similarly unhelpful:"
msgstr "但是，错误消息同样没有帮助："

#: src/dependent-types/typed-queries.md:734
#, fuzzy
msgid ""
"Lean's macro system contains everything needed not only to provide a "
"convenient syntax for queries, but also to arrange for the error messages to"
" be helpful. Unfortunately, it is beyond the scope of this book to provide a"
" description of implementing languages with Lean macros. An indexed family "
"such as `Query` is probably best as the core of a typed database interaction"
" library, rather than its user interface."
msgstr ""
"Lean 的宏系统包含了不仅可以为查询提供便捷语法，还可以安排错误消息有用的所有内容。不幸的是，用 Lean 宏实现语言的描述超出了本书的范围。像 "
"`Query` 这样的索引族可能最适合作为类型化数据库交互库的核心，而不是其用户界面。"

#: src/dependent-types/typed-queries.md:740
#, fuzzy
msgid "Dates"
msgstr "日期"

#: src/dependent-types/typed-queries.md:742
#, fuzzy
msgid ""
"Define a structure to represent dates. Add it to the `DBType` universe and "
"update the rest of the code accordingly. Provide the extra `DBExpr` "
"constructors that seem to be necessary."
msgstr "定义一个结构体来表示日期。将其添加到 `DBType` 宇宙并相应地更新其余代码。提供似乎必要的额外 `DBExpr` 构造子。"

#: src/dependent-types/typed-queries.md:744
#, fuzzy
msgid "Nullable Types"
msgstr "可空类型"

#: src/dependent-types/typed-queries.md:746
#, fuzzy
msgid ""
"Add support for nullable columns to the query language by representing "
"database types with the following structure:"
msgstr "通过使用以下结构体表示数据库类型，为查询语言添加对可空列的支持："

#: src/dependent-types/typed-queries.md:759
#, fuzzy
msgid ""
"Use this type in place of `DBType` in `Column` and `DBExpr`, and look up "
"SQL's rules for `NULL` and comparison operators to determine the types of "
"`DBExpr`'s constructors."
msgstr ""
"在 `Column` 和 `DBExpr` 中使用此类型代替 `DBType`，并查找 SQL 中 `NULL` 和比较运算符的规则以确定 "
"`DBExpr` 构造子的类型。"

#: src/dependent-types/typed-queries.md:761
#, fuzzy
msgid "Experimenting with Tactics"
msgstr "尝试策略"

#: src/dependent-types/typed-queries.md:763
#, fuzzy
msgid ""
"What is the result of asking Lean to find values of the following types "
"using `by repeat constructor`? Explain why each gives the result that it "
"does."
msgstr ""
"使用 `by repeat constructor` 让 Lean 查找以下类型的值，结果是什么？解释为什么每个给出的结果都是它给出的结果。"

#: src/dependent-types/typed-queries.md:764
#: src/programs-proofs/special-types.md:42
#, fuzzy
msgid "`Nat`"
msgstr "`Nat`"

#: src/dependent-types/typed-queries.md:765
#, fuzzy
msgid "`List Nat`"
msgstr "`List Nat`"

#: src/dependent-types/typed-queries.md:766
#, fuzzy
msgid "`Vect Nat 4`"
msgstr "`Vect Nat 4`"

#: src/dependent-types/typed-queries.md:767
#, fuzzy
msgid "`Row []`"
msgstr "`Row []`"

#: src/dependent-types/typed-queries.md:768
#, fuzzy
msgid "`Row [⟨\"price\", .int⟩]`"
msgstr "`Row [⟨\"price\", .int⟩]`"

#: src/dependent-types/typed-queries.md:769
#, fuzzy
msgid "`Row peak`"
msgstr "`Row peak`"

#: src/dependent-types/typed-queries.md:770
#, fuzzy
msgid "`HasCol [⟨\"price\", .int⟩, ⟨\"price\", .int⟩] \"price\" .int`"
msgstr "`HasCol [⟨\"price\", .int⟩, ⟨\"price\", .int⟩] \"price\" .int`"

#: src/dependent-types/indices-parameters-universes.md:3
#, fuzzy
msgid ""
"The distinction between indices and parameters of an inductive type is more "
"than just a way to describe arguments to the type that either vary or do not"
" between the constructors. Whether an argument to an inductive type is a "
"parameter or an index also matters when it comes time to determine the "
"relationships between their universe levels. In particular, an inductive "
"type may have the same universe level as a parameter, but it must be in a "
"larger universe than its indices. This restriction is necessary to ensure "
"that Lean can be used as a theorem prover as well as a programming "
"language—without it, Lean's logic would be inconsistent. Experimenting with "
"error messages is a good way to illustrate these rules, as well as the "
"precise rules that determine whether an argument to a type is a parameter or"
" an index."
msgstr ""
"归纳类型的索引和参数之间的区别不仅仅是描述类型参数的一种方式，这些参数在构造子之间变化或不变。归纳类型的参数是参数还是索引在确定它们宇宙级别之间的关系时也很重要。特别是，归纳类型可能与参数具有相同的宇宙级别，但它必须大于其索引的宇宙。此限制对于确保"
" Lean 可用作定理证明器和编程语言是必要的——如果没有它，Lean "
"的逻辑将不一致。尝试错误消息是说明这些规则的好方法，以及确定类型参数是参数还是索引的确切规则。"

#: src/dependent-types/indices-parameters-universes.md:9
#, fuzzy
msgid ""
"Generally speaking, the definition of an inductive type takes its parameters"
" before a colon and its indices after the colon. Parameters are given names "
"like function arguments, whereas indices only have their types described. "
"This can be seen in the definition of `Vect`:"
msgstr ""
"一般来说，归纳类型的定义在冒号前给出其参数，在冒号后给出其索引。参数被赋予函数参数一样的名称，而索引只描述它们的类型。这可以在 `Vect` "
"的定义中看到："

#: src/dependent-types/indices-parameters-universes.md:17
#, fuzzy
msgid ""
"In this definition, `α` is a parameter and the `Nat` is an index. Parameters"
" may be referred to throughout the definition (for example, `Vect.cons` uses"
" `α` for the type of its first argument), but they must always be used "
"consistently. Because indices are expected to change, they are assigned "
"individual values at each constructor, rather than being provided as "
"arguments at the top of the datatype definition."
msgstr ""
"在这个定义中，`α` 是一个参数，`Nat` 是一个索引。参数可以在整个定义中被引用（例如，`Vect.cons` 使用 `α` "
"作为其第一个参数的类型），但它们必须始终被一致地使用。由于索引预期会改变，因此它们在每个构造子中被分配单独的值，而不是在数据类型定义的顶部作为参数提供。"

#: src/dependent-types/indices-parameters-universes.md:22
#, fuzzy
msgid "A very simple datatype with a parameter is `WithParameter`:"
msgstr "一个带有参数的非常简单的类型是 `WithParameter`："

#: src/dependent-types/indices-parameters-universes.md:27
#, fuzzy
msgid ""
"The universe level `u` can be used for both the parameter and for the "
"inductive type itself, illustrating that parameters do not increase the "
"universe level of a datatype. Similarly, when there are multiple parameters,"
" the inductive type receives whichever universe level is greater:"
msgstr ""
"universe 级别 `u` 可以同时用于参数和归纳类型本身，这说明参数不会增加数据类型的 universe "
"级别。类似地，当有多个参数时，归纳类型接收较大的 universe 级别："

#: src/dependent-types/indices-parameters-universes.md:33
#, fuzzy
msgid ""
"Because parameters do not increase the universe level of a datatype, they "
"can be more convenient to work with. Lean attempts to identify arguments "
"that are described like indices (after the colon), but used like parameters,"
" and turn them into parameters: Both of the following inductive datatypes "
"have their parameter written after the colon:"
msgstr ""
"由于参数不会增加数据类型的 universe 级别，因此使用它们会更方便。Lean "
"尝试识别像索引（在冒号后）一样描述但像参数一样使用的参数，并将它们转换为参数：以下两个归纳数据类型都将它们的放在冒号后："

#: src/dependent-types/indices-parameters-universes.md:45
#, fuzzy
msgid ""
"When a parameter is not named in the initial datatype declaration, different"
" names may be used for it in each constructor, so long as they are used "
"consistently. The following declaration is accepted:"
msgstr "当一个参数在初始数据类型声明中没有被命名时，可以在每个构造子中使用不同的名称，只要它们被一致地使用。以下声明是可以接受的："

#: src/dependent-types/indices-parameters-universes.md:52
#, fuzzy
msgid ""
"However, this flexibility does not extend to datatypes that explicitly "
"declare the names of their parameters:"
msgstr "然而，这种灵活性不适用于明确声明其参数名称的数据类型："

#: src/dependent-types/indices-parameters-universes.md:64
#, fuzzy
msgid "Similarly, attempting to name an index results in an error:"
msgstr "同样，尝试命名索引也会导致错误："

#: src/dependent-types/indices-parameters-universes.md:77
#, fuzzy
msgid ""
"Using an appropriate universe level and placing the index after the colon "
"results in a declaration that is acceptable:"
msgstr "使用适当的宇宙级别并将索引放在冒号后面会导致可接受的声明："

#: src/dependent-types/indices-parameters-universes.md:85
#, fuzzy
msgid ""
"Even though Lean can sometimes determine that an argument after the colon in"
" an inductive type declaration is a parameter when it is used consistently "
"in all constructors, all parameters are still required to come before all "
"indices. Attempting to place a parameter after an index results in the "
"argument being considered an index itself, which would require the universe "
"level of the datatype to increase:"
msgstr ""
"尽管 Lean "
"有时可以确定归纳类型声明中冒号后面的参数在所有构造子中一致使用时是参数，但所有参数仍然需要在所有索引之前。尝试将参数放在索引之后会导致参数本身被视为索引，这将需要增加数据类型的宇宙级别："

#: src/dependent-types/indices-parameters-universes.md:101
#, fuzzy
msgid ""
"Parameters need not be types. This example shows that ordinary datatypes "
"such as `Nat` may be used as parameters:"
msgstr "参数不必是类型。此示例表明，普通数据类型（如 `Nat`）可以用作参数："

#: src/dependent-types/indices-parameters-universes.md:113
#, fuzzy
msgid "Using the `n` as suggested causes the declaration to be accepted:"
msgstr "按建议使用 `n` 会导致声明被接受："

#: src/dependent-types/indices-parameters-universes.md:122
#, fuzzy
msgid ""
"What can be concluded from these experiments? The rules of parameters and "
"indices are as follows:"
msgstr "从这些实验中可以得出什么结论？参数和索引的规则如下："

#: src/dependent-types/indices-parameters-universes.md:124
#, fuzzy
msgid "Parameters must be used identically in each constructor's type."
msgstr "参数必须在每个构造子的类型中相同使用。"

#: src/dependent-types/indices-parameters-universes.md:125
#, fuzzy
msgid "All parameters must come before all indices."
msgstr "所有参数必须在所有索引之前。"

#: src/dependent-types/indices-parameters-universes.md:126
#, fuzzy
msgid ""
"The universe level of the datatype being defined must be at least as large "
"as the largest parameter, and strictly larger than the largest index."
msgstr "正在定义的数据类型的宇宙级别必须至少与最大参数一样大，并且严格大于最大索引。"

#: src/dependent-types/indices-parameters-universes.md:127
#, fuzzy
msgid ""
"Named arguments written before the colon are always parameters, while "
"arguments after the colon are typically indices. Lean may determine that the"
" usage of arguments after the colon makes them into parameters if they are "
"used consistently in all constructors and don't come after any indices."
msgstr ""
"写在冒号之前的命名参数始终是参数，而冒号之后的参数通常是索引。如果在所有构造子中一致使用并且不位于任何索引之后，Lean "
"可能会确定冒号后面参数的使用方式使其成为参数。"

#: src/dependent-types/indices-parameters-universes.md:129
#, fuzzy
msgid ""
"When in doubt, the Lean command `#print` can be used to check how many of a "
"datatype's arguments are parameters. For example, for `Vect`, it points out "
"that the number of parameters is 1:"
msgstr "当有疑问时，可以使用 Lean 命令 `#print` 来检查数据类型的参数数量。例如，对于 `Vect`，它指出参数数量为 1："

#: src/dependent-types/indices-parameters-universes.md:142
#, fuzzy
msgid ""
"It is worth thinking about which arguments should be parameters and which "
"should be indices when choosing the order of arguments to a datatype. Having"
" as many arguments as possible be parameters helps keep universe levels "
"under control, which can make a complicated program easier to type check. "
"One way to make this possible is to ensure that all parameters come before "
"all indices in the argument list."
msgstr ""
"在选择数据类型参数的顺序时，值得考虑哪些参数应该是参数，哪些应该是索引。尽可能多地将参数作为参数有助于控制宇宙级别，这可以使复杂的程序更容易进行类型检查。实现此目的的一种方法是确保所有参数都在参数列表中的所有索引之前。"

#: src/dependent-types/indices-parameters-universes.md:146
#, fuzzy
msgid ""
"Additionally, even though Lean is capable of determining that arguments "
"after the colon are nonetheless parameters by their usage, it's a good idea "
"to write parameters with explicit names. This makes the intention clear to "
"readers, and it causes Lean to report an error if the argument is mistakenly"
" used inconsistently across the constructors."
msgstr ""
"此外，即使 Lean "
"能够确定冒号后面的参数仍然是参数，但最好使用显式名称编写参数。这可以向读者明确表达意图，并且如果在构造子中错误地不一致地使用了参数，Lean "
"会报告错误。"

#: src/dependent-types/pitfalls.md:3
#, fuzzy
msgid ""
"The flexibility of dependent types allows more useful programs to be "
"accepted by a type checker, because the language of types is expressive "
"enough to describe variations that less-expressive type systems cannot. At "
"the same time, the ability of dependent types to express very fine-grained "
"specifications allows more buggy programs to be rejected by a type checker. "
"This power comes at a cost."
msgstr ""
"依值类型的灵活性允许类型检查器接受更多有用的程序，因为类型的语言足够表达力来描述不那么表达力的类型系统无法描述的变化。同时，依值类型表达非常细粒度规范的能力允许类型检查器拒绝更多有缺陷的程序。这种能力是有代价的。"

#: src/dependent-types/pitfalls.md:7
#, fuzzy
msgid ""
"The close coupling between the internals of type-returning functions such as"
" `Row` and the types that they produce is an instance of a bigger "
"difficulty: the distinction between the interface and the implementation of "
"functions begins to break down when functions are used in types. Normally, "
"all refactorings are valid as long as they don't change the type signature "
"or input-output behavior of a function. Functions can be rewritten to use "
"more efficient algorithms and data structures, bugs can be fixed, and code "
"clarity can be improved without breaking client code. When the function is "
"used in a type, however, the internals of the function's implementation "
"become part of the type, and thus part of the _interface_ to another "
"program."
msgstr ""
"类型返回函数（如 "
"`Row`）的内部结构体与其产生的类型之间的紧密耦合是一个更大困难的一个实例：当函数用于类型时，函数的接口和实现之间的区别开始消失。通常，只要不更改函数的类型签名或输入输出行为，所有重构都是有效的。可以重写函数以使用更有效的算法和数据结构体，可以修复错误，并且可以在不破坏客户端代码的情况下提高代码清晰度。但是，当函数用于类型时，函数实现的内部结构体将成为类型的一部分，从而成为另一个程序的"
" _接口_ 的一部分。"

#: src/dependent-types/pitfalls.md:12
#, fuzzy
msgid ""
"As an example, take the following two implementations of addition on `Nat`. "
"`Nat.plusL` is recursive on its first argument:"
msgstr "以`Nat`上的加法为例，`Nat.plusL`对第一个参数进行递归："

#: src/dependent-types/pitfalls.md:19
#, fuzzy
msgid "`Nat.plusR`, on the other hand, is recursive on its second argument:"
msgstr "而`Nat.plusR`对第二个参数进行递归："

#: src/dependent-types/pitfalls.md:25
#, fuzzy
msgid ""
"Both implementations of addition are faithful to the underlying mathematical"
" concept, and they thus return the same result when given the same "
"arguments."
msgstr "这两种加法的实现都忠实于底层的数学概念，因此在给定相同参数时返回相同的结果。"

#: src/dependent-types/pitfalls.md:27
#, fuzzy
msgid ""
"However, these two implementations present quite different interfaces when "
"they are used in types. As an example, take a function that appends two "
"`Vect`s. This function should return a `Vect` whose length is the sum of the"
" length of the arguments. Because `Vect` is essentially a `List` with a more"
" informative type, it makes sense to write the function just as one would "
"for `List.append`, with pattern matching and recursion on the first "
"argument. Starting with a type signature and initial pattern match pointing "
"at placeholders yields two messages:"
msgstr ""
"然而，当在类型中使用时，这两种实现呈现出截然不同的接口。例如，考虑一个连接两个`Vect`的函数。此函数应返回一个`Vect`，其长度是参数长度的和。由于`Vect`本质上是一个具有更丰富类型的`List`，因此用模式匹配和对第一个参数进行递归来编写函数是有意义的，就像对`List.append`所做的那样。从类型签名和指向占位符的初始模式匹配开始，会产生两条消息："

#: src/dependent-types/pitfalls.md:37
#, fuzzy
msgid ""
"The first message, in the `nil` case, states that the placeholder should be "
"replaced by a `Vect` with length `plusL 0 k`:"
msgstr "在`nil`情况下，第一条消息指出占位符应替换为长度为`plusL 0 k`的`Vect`："

#: src/dependent-types/pitfalls.md:46
#, fuzzy
msgid ""
"The second message, in the `cons` case, states that the placeholder should "
"be replaced by a `Vect` with length `plusL (n✝ + 1) k`:"
msgstr "在`cons`情况下，第二条消息指出占位符应替换为长度为`plusL (n✝ + 1) k`的`Vect`："

#: src/dependent-types/pitfalls.md:57
#, fuzzy
msgid ""
"The symbol after `n`, called a _dagger_, is used to indicate names that Lean"
" has internally invented. Behind the scenes, pattern matching on the first "
"`Vect` implicitly caused the value of the first `Nat` to be refined as well,"
" because the index on the constructor `cons` is `n + 1`, with the tail of "
"the `Vect` having length `n`. Here, `n✝` represents the `Nat` that is one "
"less than the argument `n`."
msgstr ""
"`n`后面的符号称为「十字架」，用于表示Lean内部发明的新名称。在幕后，对第一个`Vect`的模式匹配隐式地导致第一个`Nat`的值也被细化，因为构造子`cons`上的索引是`n"
" + 1`，`Vect`的尾部长度为`n`。这里，`n✝`表示比参数`n`小1的`Nat`。"

#: src/dependent-types/pitfalls.md:61
#, fuzzy
msgid "Definitional Equality"
msgstr "定义相等"

#: src/dependent-types/pitfalls.md:63
#, fuzzy
msgid ""
"In the definition of `plusL`, there is a pattern case `0, k => k`. This "
"applies in the length used in the first placeholder, so another way to write"
" the underscore's type `Vect α (Nat.plusL 0 k)` is `Vect α k`. Similarly, "
"`plusL` contains a pattern case `n + 1, k => plusN n k + 1`. This means that"
" the type of the second underscore can be equivalently written `Vect α "
"(plusL n✝ k + 1)`."
msgstr ""
"在 `plusL` 的定义中，有一个模式匹配 `0, k => k`。它适用于第一个占位符中使用的长度，因此用下划线表示的类型 `Vect α "
"(Nat.plusL 0 k)` 的另一种写法是 `Vect α k`。类似地，`plusL` 包含一个模式匹配 `n + 1, k => plusN "
"n k + 1`。这意味着第二个下划线类型的等价写法是 `Vect α (plusL n✝ k + 1)`。"

#: src/dependent-types/pitfalls.md:68
#, fuzzy
msgid ""
"To expose what is going on behind the scenes, the first step is to write the"
" `Nat` arguments explicitly, which also results in daggerless error messages"
" because the names are now written explicitly in the program:"
msgstr "为了揭示幕后发生的事情，第一步是显式地写出 `Nat` 参数，这也导致了无尖括号的错误消息，因为现在名称已在程序中显式写出："

#: src/dependent-types/pitfalls.md:92
#, fuzzy
msgid ""
"Annotating the underscores with the simplified versions of the types does "
"not introduce a type error, which means that the types as written in the "
"program are equivalent to the ones that Lean found on its own:"
msgstr "用简化版本的类型对下划线进行注释不会引入类型错误，这意味着程序中编写的类型等同于 Lean 自行找到的类型："

#: src/dependent-types/pitfalls.md:117
#, fuzzy
msgid ""
"The first case demands a `Vect α k`, and `ys` has that type. This is "
"parallel to the way that appending the empty list to any other list returns "
"that other list. Refining the definition with `ys` instead of the first "
"underscore yields a program with only one remaining underscore to be filled "
"out:"
msgstr ""
"第一个匹配需要一个 `Vect α k`，而 `ys` 具有该类型。这与将空列表附加到任何其他列表并返回该其他列表的方式类似。用 `ys` "
"代替第一个下划线来优化定义，得到一个程序，其中只有一个剩余的下划线需要填充："

#: src/dependent-types/pitfalls.md:136
#, fuzzy
msgid ""
"Something very important has happened here. In a context where Lean expected"
" a `Vect α (Nat.plusL 0 k)`, it received a `Vect α k`. However, `Nat.plusL` "
"is not an `abbrev`, so it may seem like it shouldn't be running during type "
"checking. Something else is happening."
msgstr ""
"这里发生了一件非常重要的事情。在 Lean 期望 `Vect α (Nat.plusL 0 k)` 的上下文中，它接收到了 `Vect α "
"k`。但是，`Nat.plusL` 不是 `abbrev`，因此在类型检查期间它似乎不应该运行。发生了别的事情。"

#: src/dependent-types/pitfalls.md:141
#, fuzzy
msgid ""
"The key to understanding what's going on is that Lean doesn't just expand "
"`abbrev`s while type checking. It can also perform computation while "
"checking whether two types are equivalent to one another, such that any "
"expression of one type can be used in a context that expects the other type."
" This property is called _definitional equality_, and it is subtle."
msgstr ""
"理解正在发生的事情的关键在于，Lean 不仅在类型检查时扩展 "
"`abbrev`。它还可以在检查两个类型是否相等时执行计算，以便一个类型的任何表达式都可以在期望另一个类型的上下文中使用。此属性称为 "
"_定义相等_，它很微妙。"

#: src/dependent-types/pitfalls.md:145
#, fuzzy
msgid ""
"Certainly, two types that are written identically are considered to be "
"definitionally equal—`Nat` and `Nat` or `List String` and `List String` "
"should be considered equal. Any two concrete types built from different "
"datatypes are not equal, so `List Nat` is not equal to `Int`. Additionally, "
"types that differ only by renaming internal names are equal, so `(n : Nat) →"
" Vect String n` is the same as `(k : Nat) → Vect String k`. Because types "
"can contain ordinary data, definitional equality must also describe when "
"data are equal. Uses of the same constructors are equal, so `0` equals `0` "
"and `[5, 3, 1]` equals `[5, 3, 1]`."
msgstr ""
"当然，两个书写形式相同的类型被认为是定义相等的——`Nat` 和 `Nat` 或 `List String` 和 `List String` 应该被认为是相等的。任何两个由不同数据类型构建的具体类型是不相等的，所以 `List Nat` 不等于 `Int`。此外，仅通过重命名内部名称而不同的类型是相等的，所以 `(n : Nat) → Vect String n` 与 `(k : Nat) → Vect String k` 相同。由于类型可以包含普通数据，因此定义相等还必须描述何时数据相等。相同构造子的使用是相等的，所以 `0` 等于 `0`，`[5, 3, 1]` 等于 `[5, 3, 1]`。\n"
"\n"
"然而，类型包含的不仅仅是函数箭头、数据类型和构造子。它们还包含 _变量_ 和 _函数_。变量的定义相等相对简单：每个变量仅等于它自身，所以 `(n k : Nat) → Vect Int n` 与 `(n k : Nat) → Vect Int k` 在定义上不相等。另一方面，函数则更复杂。虽然数学认为如果两个函数具有相同的输入输出行为，则它们相等，但没有有效的算法来检查这一点，而定义相等性的全部意义在于让 Lean 检查两个类型是否可互换。相反，Lean 认为函数在定义上相等，当它们都是具有定义上相等的主体的 `fun` 表达式时。换句话说，两个函数必须使用 _相同的算法_ 来调用 _相同的帮助器_，才能被认为在定义上相等。这通常不是很有帮助，因此函数的定义相等主要用于在两种类型中出现完全相同的已定义函数时。"

#: src/dependent-types/pitfalls.md:151
#, fuzzy
msgid ""
"Types contain more than just function arrows, datatypes, and constructors, "
"however. They also contain _variables_ and _functions_. Definitional "
"equality of variables is relatively simple: each variable is equal only to "
"itself, so `(n k : Nat) → Vect Int n` is not definitionally equal to `(n k :"
" Nat) → Vect Int k`. Functions, on the other hand, are more complicated. "
"While mathematics considers two functions to be equal if they have identical"
" input-output behavior, there is no efficient algorithm to check that, and "
"the whole point of definitional equality is for Lean to check whether two "
"types are interchangeable. Instead, Lean considers functions to be "
"definitionally equal either when they are both `fun`\\-expressions with "
"definitionally equal bodies. In other words, two functions must use _the "
"same algorithm_ that calls _the same helpers_ to be considered "
"definitionally equal. This is not typically very helpful, so definitional "
"equality of functions is mostly used when the exact same defined function "
"occurs in two types."
msgstr "?"

#: src/dependent-types/pitfalls.md:160
#, fuzzy
msgid ""
"When functions are _called_ in a type, checking definitional equality may "
"involve reducing the function call. The type `Vect String (1 + 4)` is "
"definitionally equal to the type `Vect String (3 + 2)` because `1 + 4` is "
"definitionally equal to `3 + 2`. To check their equality, both are reduced "
"to `5`, and then the constructor rule can be used five times. Definitional "
"equality of functions applied to data can be checked first by seeing if "
"they're already the same—there's no need to reduce `[\"a\", \"b\"] ++ "
"[\"c\"]` to check that it's equal to `[\"a\", \"b\"] ++ [\"c\"]`, after all."
" If not, the function is called and replaced with its value, and the value "
"can then be checked."
msgstr ""
"当函数在类型中被调用时，检查定义相等可能涉及到化简函数调用。类型 `Vect String (1 + 4)` 与类型 `Vect String (3 +"
" 2)` 定义相等，因为 `1 + 4` 与 `3 + 2` 定义相等。为了检查它们的相等性，两者都被化简为 "
"`5`，然后构造子规则可以被使用五次。应用于数据的函数的定义相等性可以通过首先查看它们是否已经相同来检查——毕竟，没有必要将 `[\"a\", "
"\"b\"] ++ [\"c\"]` 化简为 `[\"a\", \"b\"] ++ [\"c\"]` "
"来检查它是否相等。如果不是，则调用该函数并用它的值替换它，然后可以检查该值。"

#: src/dependent-types/pitfalls.md:166
#, fuzzy
msgid ""
"Not all function arguments are concrete data. For example, types may contain"
" `Nat`s that are not built from the `zero` and `succ` constructors. In the "
"type `(n : Nat) → Vect String n`, the variable `n` is a `Nat`, but it is "
"impossible to know _which_ `Nat` it is before the function is called. "
"Indeed, the function may be called first with `0`, and then later with `17`,"
" and then again with `33`. As seen in the definition of `appendL`, variables"
" with type `Nat` may also be passed to functions such as `plusL`. Indeed, "
"the type `(n : Nat) → Vect String n` is definitionally equal to the type `(n"
" : Nat) → Vect String (Nat.plusL 0 n)`."
msgstr ""
"并非所有函数参数都是具体数据。例如，类型可能包含不是由 `zero` 和 `succ` 构造子构建的 `Nat`。在类型 `(n : Nat) → "
"Vect String n` 中，变量 `n` 是一个 `Nat`，但在调用函数之前不可能知道它是什么 `Nat`。事实上，该函数可能首先用 `0` "
"调用，然后用 `17` 调用，然后再次用 `33` 调用。如 `appendL` 的定义所示，类型为 `Nat` 的变量也可以传递给诸如 `plusL`"
" 的函数。事实上，类型 `(n : Nat) → Vect String n` 与类型 `(n : Nat) → Vect String "
"(Nat.plusL 0 n)` 定义相等。"

#: src/dependent-types/pitfalls.md:173
#, fuzzy
msgid ""
"The reason that `n` and `Nat.plusL 0 n` are definitionally equal is that "
"`plusL`'s pattern match examines its _first_ argument. This is problematic: "
"`(n : Nat) → Vect String n` is _not_ definitionally equal to `(n : Nat) → "
"Vect String (Nat.plusL n 0)`, even though zero should be both a left and a "
"right identity of addition. This happens because pattern matching gets stuck"
" when it encounters variables. Until the actual value of `n` becomes known, "
"there is no way to know which case of `Nat.plusL n 0` should be selected."
msgstr ""
"`n` 和 `Nat.plusL 0 n` 定义相等的原因是 `plusL` 的模式匹配检查它的第一个参数。这是有问题的：`(n : Nat) → "
"Vect String n` 与 `(n : Nat) → Vect String (Nat.plusL n 0)` "
"并不定义相等，即使零应该是加法的左单位元和右单位元。发生这种情况是因为当遇到变量时，模式匹配会卡住。在 `n` "
"的实际值变得已知之前，没有办法知道应该选择 `Nat.plusL n 0` 的哪种情况。"

#: src/dependent-types/pitfalls.md:178
#, fuzzy
msgid ""
"The same issue appears with the `Row` function in the query example. The "
"type `Row (c :: cs)` does not reduce to any datatype because the definition "
"of `Row` has separate cases for singleton lists and lists with at least two "
"entries. In other words, it gets stuck when trying to match the variable "
"`cs` against concrete `List` constructors. This is why almost every function"
" that takes apart or constructs a `Row` needs to match the same three cases "
"as `Row` itself: getting it unstuck reveals concrete types that can be used "
"for either pattern matching or constructors."
msgstr ""
"`Row` 函数在查询示例中也出现了同样的问题。类型 `Row (c :: cs)` 不会缩减为任何数据类型，因为 `Row` "
"的定义对单例列表和至少有两个条目的列表有单独的情况。换句话说，它在尝试将变量 `cs` 与具体的 `List` "
"构造子进行匹配时会卡住。这就是为什么几乎每个分解或构造 `Row` 的函数都需要与 `Row` "
"本身匹配相同的三种情况：解除其卡住状态会显示可用于模式匹配或构造子的具体类型。"

#: src/dependent-types/pitfalls.md:183
#, fuzzy
msgid ""
"The missing case in `appendL` requires a `Vect α (Nat.plusL n k + 1)`. The "
"`+ 1` in the index suggests that the next step is to use `Vect.cons`:"
msgstr ""
"`appendL` 中缺少的情况需要一个 `Vect α (Nat.plusL n k + 1)`。索引中的 `+ 1` 表明下一步是使用 "
"`Vect.cons`："

#: src/dependent-types/pitfalls.md:200
#, fuzzy
msgid ""
"A recursive call to `appendL` can construct a `Vect` with the desired "
"length:"
msgstr "对 `appendL` 的递归调用可以构造一个具有所需长度的 `Vect`："

#: src/dependent-types/pitfalls.md:206
#, fuzzy
msgid ""
"Now that the program is finished, removing the explicit matching on `n` and "
"`k` makes it easier to read and easier to call the function:"
msgstr "现在程序已完成，删除对 `n` 和 `k` 的显式匹配使其更易于阅读和调用函数："

#: src/dependent-types/pitfalls.md:213
#, fuzzy
msgid ""
"Comparing types using definitional equality means that everything involved "
"in definitional equality, including the internals of function definitions, "
"becomes part of the _interface_ of programs that use dependent types and "
"indexed families. Exposing the internals of a function in a type means that "
"refactoring the exposed program may cause programs that use it to no longer "
"type check. In particular, the fact that `plusL` is used in the type of "
"`appendL` means that the definition of `plusL` cannot be replaced by the "
"otherwise-equivalent `plusR`."
msgstr ""
"使用定义相等性比较类型意味着涉及定义相等性的所有内容（包括函数定义的内部）都成为使用依值类型和索引族的程序的 _接口_ "
"的一部分。在类型中公开函数的内部意味着重构公开的程序可能会导致使用它的程序不再进行类型检查。特别是，`plusL` 用于 `appendL` "
"的类型这一事实意味着 `plusL` 的定义不能被其他等效的 `plusR` 替换。"

#: src/dependent-types/pitfalls.md:217
#, fuzzy
msgid "Getting Stuck on Addition"
msgstr "卡在加法上"

#: src/dependent-types/pitfalls.md:219
#, fuzzy
msgid ""
"What happens if append is defined with `plusR` instead? Beginning in the "
"same way, with explicit lengths and placeholder underscores in each case, "
"reveals the following useful error messages:"
msgstr "如果使用 `plusR` 定义 `append` 会发生什么？同样以显式长度和占位符下划线开始，会显示以下有用的错误消息："

#: src/dependent-types/pitfalls.md:244
#, fuzzy
msgid ""
"However, attempting to place a `Vect α k` type annotation around the first "
"placeholder results in an type mismatch error:"
msgstr "然而，尝试在第一个占位符周围放置 `Vect α k` 类型标注会导致类型不匹配错误："

#: src/dependent-types/pitfalls.md:258
#, fuzzy
msgid ""
"This error is pointing out that `plusR 0 k` and `k` are _not_ definitionally"
" equal."
msgstr "此错误指出 `plusR 0 k` 和 `k` _不是_ 定义相等的。"

#: src/dependent-types/pitfalls.md:260
#, fuzzy
msgid "This is because `plusR` has the following definition:"
msgstr "这是因为 `plusR` 具有以下定义："

#: src/dependent-types/pitfalls.md:266
#, fuzzy
msgid ""
"Its pattern matching occurs on the _second_ argument, not the first "
"argument, which means that the presence of the variable `k` in that position"
" prevents it from reducing. `Nat.add` in Lean's standard library is "
"equivalent to `plusR`, not `plusL`, so attempting to use it in this "
"definition results in precisely the same difficulties:"
msgstr ""
"它的模式匹配发生在 _第二个_ 参数上，而不是第一个参数，这意味着变量 `k` 在该位置的存在阻止了它的化简。Lean 标准库中的 `Nat.add` "
"等效于 `plusR`，而不是 `plusL`，因此尝试在此定义中使用它会导致完全相同的问题："

#: src/dependent-types/pitfalls.md:282
#, fuzzy
msgid ""
"Addition is getting _stuck_ on the variables. Getting it unstuck requires "
"[propositional equality](../type-classes/standard-classes.md#equality-and-"
"ordering)."
msgstr ""
"加法在变量上 _卡住了_。要解除卡住，需要 [命题相等](../type-classes/standard-classes.md#equality-"
"and-ordering)。"

#: src/dependent-types/pitfalls.md:285
#, fuzzy
msgid "Propositional Equality"
msgstr "命题相等"

#: src/dependent-types/pitfalls.md:287
#, fuzzy
msgid ""
"Propositional equality is the mathematical statement that two expressions "
"are equal. While definitional equality is a kind of ambient fact that Lean "
"automatically checks when required, statements of propositional equality "
"require explicit proofs. Once an equality proposition has been proved, it "
"can be used in a program to modify a type, replacing one side of the "
"equality with the other, which can unstick the type checker."
msgstr ""
"命题相等是两个表达式相等的数学陈述。虽然定义相等是一种环境事实，Lean "
"在需要时会自动检查，但命题相等陈述需要明确的证明。一旦证明了一个相等命题，就可以在程序中使用它来修改类型，用相等的一侧替换另一侧，这可以解除类型检查器的卡住。"

#: src/dependent-types/pitfalls.md:291
#, fuzzy
msgid ""
"The reason why definitional equality is so limited is to enable it to be "
"checked by an algorithm. Propositional equality is much richer, but the "
"computer cannot in general check whether two expressions are propositionally"
" equal, though it can verify that a purported proof is in fact a proof. The "
"split between definitional and propositional equality represents a division "
"of labor between humans and machines: the most boring equalities are checked"
" automatically as part of definitional equality, freeing the human mind to "
"work on the interesting problems available in propositional equality. "
"Similarly, definitional equality is invoked automatically by the type "
"checker, while propositional equality must be specifically appealed to."
msgstr ""
"定义相等之所以如此有限，是为了使其能够通过算法进行检查。命题相等要丰富得多，但计算机通常无法检查两个表达式是否命题相等，尽管它可以验证一个所谓的证明实际上是一个证明。定义相等和命题相等之间的分歧代表了人机之间的分工：最无聊的相等作为定义相等的一部分自动检查，从而使人的思想可以解决命题相等中出现的有意思的问题。类似地，定义相等由类型检查器自动调用，而命题相等必须被专门调用。"

#: src/dependent-types/pitfalls.md:297
#, fuzzy
msgid ""
"In [Propositions, Proofs, and Indexing](../props-proofs-indexing.md), some "
"equality statements are proved using `simp`. All of these equality "
"statements are ones in which the propositional equality is in fact already a"
" definitional equality. Typically, statements of propositional equality are "
"proved by first getting them into a form where they are either definitional "
"or close enough to existing proved equalities, and then using tools like "
"`simp` to take care of the simplified cases. The `simp` tactic is quite "
"powerful: behind the scenes, it uses a number of fast, automated tools to "
"construct a proof. A simpler tactic called `rfl` specifically uses "
"definitional equality to prove propositional equality. The name `rfl` is "
"short for _reflexivity_, which is the property of equality that states that "
"everything equals itself."
msgstr ""
"在 [命题、证明和索引](../props-proofs-indexing.md) 中，一些等式语句使用 `simp` "
"证明。所有这些等式语句都是命题等式实际上已经是定义等式的情况。通常，命题等式的陈述首先将它们转换为定义形式或接近于现有已证明等式，然后使用 `simp`"
" 等工具来处理简化情况。`simp` 战术非常强大：在幕后，它使用许多快速、自动化的工具来构建证明。一个称为 `rfl` "
"的更简单的战术专门使用定义等式来证明命题等式。`rfl` 名称是 _自反性_ 的缩写，这是等式的属性，它指出所有事物都等于自身。"

#: src/dependent-types/pitfalls.md:304
#, fuzzy
msgid ""
"Unsticking `appendR` requires a proof that `k = Nat.plusR 0 k`, which is not"
" a definitional equality because `plusR` is stuck on the variable in its "
"second argument. To get it to compute, the `k` must become a concrete "
"constructor. This is a job for pattern matching."
msgstr ""
"取消粘贴 `appendR` 需要证明 `k = Nat.plusR 0 k`，这不是定义等式，因为 `plusR` "
"粘贴在第二个参数中的变量上。为了计算它，`k` 必须成为一个具体构造子。这是模式匹配的工作。"

#: src/dependent-types/pitfalls.md:308
#, fuzzy
msgid ""
"In particular, because `k` could be _any_ `Nat`, this task requires a "
"function that can return evidence that `k = Nat.plusR 0 k` for _any_ `k` "
"whatsoever. This should be a function that returns a proof of equality, with"
" type `(k : Nat) → k = Nat.plusR 0 k`. Getting it started with initial "
"patterns and placeholders yields the following messages:"
msgstr ""
"特别是，因为 `k` 可以是 _任何_ `Nat`，所以此任务需要一个函数，该函数可以返回证据，证明 `k = Nat.plusR 0 k` 适用于 "
"_任何_ `k`。这应该是一个返回等式证明的函数，类型为 `(k : Nat) → k = Nat.plusR 0 "
"k`。使用初始模式和占位符开始它会产生以下消息："

#: src/dependent-types/pitfalls.md:327
#, fuzzy
msgid ""
"Having refined `k` to `0` via pattern matching, the first placeholder stands"
" for evidence of a statement that does hold definitionally. The `rfl` tactic"
" takes care of it, leaving only the second placeholder:"
msgstr "通过模式匹配将 `k` 细化为 `0`，第一个占位符代表对定义上成立的语句的证据。`rfl` 战术处理它，只留下第二个占位符："

#: src/dependent-types/pitfalls.md:335
#, fuzzy
msgid ""
"The second placeholder is a bit trickier. The expression `Nat.plusR 0 k + 1`"
" is definitionally equal to `Nat.plusR 0 (k + 1)`. This means that the goal "
"could also be written `k + 1 = Nat.plusR 0 k + 1`:"
msgstr ""
"第二个占位符有点棘手。表达式 `Nat.plusR 0 k + 1` 在定义上等于 `Nat.plusR 0 (k + 1)`。这意味着目标也可以写成 "
"`k + 1 = Nat.plusR 0 k + 1`："

#: src/dependent-types/pitfalls.md:350
#, fuzzy
msgid ""
"Underneath the `+ 1` on each side of the equality statement is another "
"instance of what the function itself returns. In other words, a recursive "
"call on `k` would return evidence that `k = Nat.plusR 0 k`. Equality "
"wouldn't be equality if it didn't apply to function arguments.  In other "
"words, if `x = y`, then `f x = f y`. The standard library contains a "
"function `congrArg` that takes a function and an equality proof and returns "
"a new proof where the function has been applied to both sides of the "
"equality. In this case, the function is `(· + 1)`:"
msgstr ""
"等式语句两边的 `+ 1` 下面是函数本身返回的另一个实例。换句话说，对 `k` 的递归调用将返回 `k = Nat.plusR 0 k` "
"的证据。如果不适用于函数参数，等式就不再是等式。换句话说，如果 `x = y`，则 `f x = f y`。标准库包含一个函数 "
"`congrArg`，它接受一个函数和一个相等证明，并返回一个新的证明，其中函数已应用于等式的双方。在这种情况下，函数是 `(· + 1)`："

#: src/dependent-types/pitfalls.md:363
#, fuzzy
msgid ""
"Propositional equalities can be deployed in a program using the rightward "
"triangle operator `▸`. Given an equality proof as its first argument and "
"some other expression as its second, this operator replaces instances of the"
" left side of the equality with the right side of the equality in the second"
" argument's type. In other words, the following definition contains no type "
"errors:"
msgstr ""
"命题等式可以使用右三角形运算符 `▸` "
"在程序中部署。给定一个相等证明作为其第一个参数和一些其他表达式作为其第二个参数，此运算符将第二个参数类型中相等性的左侧实例替换为相等性的右侧。换句话说，以下定义不包含类型错误："

#: src/dependent-types/pitfalls.md:371
#, fuzzy
msgid "The first placeholder has the expected type:"
msgstr "第一个占位符具有预期的类型："

#: src/dependent-types/pitfalls.md:380
#, fuzzy
msgid "It can now be filled in with `ys`:"
msgstr "现在可以用 `ys` 填充它："

#: src/dependent-types/pitfalls.md:387
#, fuzzy
msgid ""
"Filling in the remaining placeholder requires unsticking another instance of"
" addition:"
msgstr "填充剩余的占位符需要取消另一个加法实例："

#: src/dependent-types/pitfalls.md:398
#, fuzzy
msgid ""
"Here, the statement to be proved is that `Nat.plusR (n + 1) k = Nat.plusR n "
"k + 1`, which can be used with `▸` to draw the `+ 1` out to the top of the "
"expression so that it matches the index of `cons`."
msgstr ""
"这里，要证明的陈述是 `Nat.plusR (n + 1) k = Nat.plusR n k + 1`，它可以与 `▸` 一起使用，将 `+ 1` "
"绘制到表达式的顶部，以便它与 `cons` 的索引匹配。"

#: src/dependent-types/pitfalls.md:400
#, fuzzy
msgid ""
"The proof is a recursive function that pattern matches on the second "
"argument to `plusR`, namely `k`. This is because `plusR` itself pattern "
"matches on its second argument, so the proof can \"unstick\" it through "
"pattern matching, exposing the computational behavior. The skeleton of the "
"proof is very similar to that of `plusR_zero_left`:"
msgstr ""
"证明是一个递归函数，它对 `plusR` 的第二个参数（即 `k`）进行模式匹配。这是因为 `plusR` "
"本身对其第二个参数进行模式匹配，因此证明可以通过模式匹配「取消」它，从而暴露计算行为。证明的骨架与 `plusR_zero_left` 非常相似："

#: src/dependent-types/pitfalls.md:409
#, fuzzy
msgid ""
"The remaining case's type is definitionally equal to `Nat.plusR (n + 1) k + "
"1 = Nat.plusR n (k + 1) + 1`, so it can be solved with `congrArg`, just as "
"in `plusR_zero_left`:"
msgstr ""
"剩余情况的类型定义上等于 `Nat.plusR (n + 1) k + 1 = Nat.plusR n (k + 1) + 1`，因此可以使用 "
"`congrArg` 来解决，就像在 `plusR_zero_left` 中一样："

#: src/dependent-types/pitfalls.md:416
#, fuzzy
msgid "This results in a finished proof:"
msgstr "这导致了一个完成的证明："

#: src/dependent-types/pitfalls.md:423
#, fuzzy
msgid ""
"The finished proof can be used to unstick the second case in `appendR`:"
msgstr "完成的证明可以用来取消 `appendR` 中的第二个情况："

#: src/dependent-types/pitfalls.md:429
#, fuzzy
msgid ""
"When making the length arguments to `appendR` implicit again, they are no "
"longer explicitly named to be appealed to in the proofs. However, Lean's "
"type checker has enough information to fill them in automatically behind the"
" scenes, because no other values would allow the types to match:"
msgstr ""
"当再次使 `appendR` 的长度参数变为隐式时，它们不再被显式命名，以便在证明中被调用。然而，Lean "
"的类型检查器有足够的信息在幕后自动填充它们，因为没有其他值允许类型匹配："

#: src/dependent-types/pitfalls.md:437
#, fuzzy
msgid "Pros and Cons"
msgstr "优缺点"

#: src/dependent-types/pitfalls.md:439
#, fuzzy
msgid ""
"Indexed families have an important property: pattern matching on them "
"affects definitional equality. For example, in the `nil` case in a `match` "
"expression on a `Vect`, the length simply _becomes_ `0`. Definitional "
"equality can be very convenient, because it is always active and does not "
"need to be invoked explicitly."
msgstr ""
"索引族有一个重要的属性：模式匹配会影响定义上的相等性。例如，在 `Vect` 上的 `match` 表达式的 `nil` "
"情况下，长度简单地「变成」`0`。定义上的相等性非常方便，因为它总是处于活动状态，不需要显式调用。"

#: src/dependent-types/pitfalls.md:443
#, fuzzy
msgid ""
"However, the use of definitional equality with dependent types and pattern "
"matching has serious software engineering drawbacks. First off, functions "
"must be written especially to be used in types, and functions that are "
"convenient to use in types may not use the most efficient algorithms. Once a"
" function has been exposed through using it in a type, its implementation "
"has become part of the interface, leading to difficulties in future "
"refactoring. Secondly, definitional equality can be slow. When asked to "
"check whether two expressions are definitionally equal, Lean may need to run"
" large amounts of code if the functions in question are complicated and have"
" many layers of abstraction. Third, error messages that result from failures"
" of definitional equality are not always very easy to understand, because "
"they may be phrased in terms of the internals of functions. It is not always"
" easy to understand the provenance of the expressions in the error messages."
" Finally, encoding non-trivial invariants in a collection of indexed "
"families and dependently-typed functions can often be brittle. It is often "
"necessary to change early definitions in a system when the exposed reduction"
" behavior of functions proves to not provide convenient definitional "
"equalities. The alternative is to litter the program with appeals to "
"equality proofs, but these can become quite unwieldy."
msgstr ""
"然而，在依值类型和模式匹配中使用定义上的相等性有严重的软件工程缺点。首先，必须专门编写函数以用于类型中，并且在类型中方便使用的函数可能不会使用最有效的算法。一旦通过在类型中使用函数公开函数，其实现就成为接口的一部分，导致未来重构的困难。其次，定义上的相等性可能很慢。当要求检查两个表达式是否在定义上相等时，如果所讨论的函数很复杂并且具有多层抽象，Lean"
" "
"可能需要运行大量的代码。第三，由定义上的相等性失败导致的错误消息并不总是很容易理解，因为它们可能用函数内部的术语表述。理解错误消息中表达式的来源并不总是容易的。最后，在索引族和依值类型函数的集合中对非平凡的不变式进行编码通常是脆弱的。当函数的公开归约行为被证明不能提供方便的定义上的相等性时，通常需要更改系统中的早期定义。另一种方法是在程序中散布对相等性证明的调用，但这些调用可能会变得相当笨拙。"

#: src/dependent-types/pitfalls.md:454
#, fuzzy
msgid ""
"In idiomatic Lean code, indexed datatypes are not used very often. Instead, "
"subtypes and explicit propositions are typically used to enforce important "
"invariants. This approach involves many explicit proofs, and very few "
"appeals to definitional equality. As befits an interactive theorem prover, "
"Lean has been designed to make explicit proofs convenient. Generally "
"speaking, this approach should be preferred in most cases."
msgstr ""
"在惯用的 Lean "
"代码中，很少使用索引数据类型。相反，通常使用子类型和显式命题来强制执行重要的不变量。这种方法涉及许多显式证明，很少诉诸定义相等。正如交互式定理证明器所应有的，Lean"
" 被设计为使显式证明变得方便。一般来说，在大多数情况下都应该优先采用这种方法。"

#: src/dependent-types/pitfalls.md:460
#, fuzzy
msgid ""
"However, understanding indexed families of datatypes is important. Recursive"
" functions such as `plusR_zero_left` and `plusR_succ_left` are in fact "
"_proofs by mathematical induction_. The base case of the recursion "
"corresponds to the base case in induction, and the recursive call represents"
" an appeal to the induction hypothesis. More generally, new propositions in "
"Lean are often defined as inductive types of evidence, and these inductive "
"types usually have indices. The process of proving theorems is in fact "
"constructing expressions with these types behind the scenes, in a process "
"not unlike the proofs in this section. Also, indexed datatypes are sometimes"
" exactly the right tool for the job. Fluency in their use is an important "
"part of knowing when to use them."
msgstr ""
"然而，理解数据类型的索引族非常重要。诸如 `plusR_zero_left` 和 `plusR_succ_left` 之类的递归函数实际上是 "
"_数学归纳法证明_。递归的基本情况对应于归纳法中的基本情况，递归调用表示对归纳假设的诉求。更一般地说，Lean "
"中的新命题通常被定义为归纳证据类型，这些归纳类型通常有索引。证明定理的过程实际上是在幕后构造具有这些类型的表达式，这个过程与本节中的证明非常相似。此外，索引数据类型有时正是这项工作的正确工具。熟练使用它们是知道何时使用它们的重要组成部分。"

#: src/dependent-types/pitfalls.md:472
#, fuzzy
msgid ""
"Using a recursive function in the style of `plusR_succ_left`, prove that for"
" all `Nat`s `n` and `k`, `n.plusR k = n + k`."
msgstr ""
"使用 `plusR_succ_left` 样式的递归函数，证明对于所有 `Nat` 的 `n` 和 `k`，`n.plusR k = n + k`。"

#: src/dependent-types/pitfalls.md:473
#, fuzzy
msgid ""
"Write a function on `Vect` for which `plusR` is more natural than `plusL`, "
"where `plusL` would require proofs to be used in the definition."
msgstr "为 `Vect` 编写一个函数，其中 `plusR` 比 `plusL` 更自然，其中 `plusL` 需要在定义中使用证明。"

#: src/dependent-types/summary.md:3
#, fuzzy
msgid "Dependent Types"
msgstr "依值类型"

#: src/dependent-types/summary.md:5
#, fuzzy
msgid ""
"Dependent types, where types contain non-type code such as function calls "
"and ordinary data constructors, lead to a massive increase in the expressive"
" power of a type system. The ability to _compute_ a type from the _value_ of"
" an argument means that the return type of a function can vary based on "
"which argument is provided. This can be used, for example, to have the "
"result type of a database query depend on the database's schema and the "
"specific query issued, without needing any potentially-failing cast "
"operations on the result of the query. When the query changes, so does the "
"type that results from running it, enabling immediate compile-time feedback."
msgstr ""
"依值类型，其中类型包含非类型代码（例如函数调用和普通数据构造子），导致类型系统的表达能力大幅提升。从参数的 _值_ _计算_ "
"类型的功能意味着函数的返回类型可以根据提供的参数而变化。例如，这可用于使数据库查询的结果类型取决于数据库的架构和发出的特定查询，而无需对查询结果执行任何可能失败的强制转换操作。当查询更改时，运行它所产生的类型也会更改，从而实现立即的编译时反馈。"

#: src/dependent-types/summary.md:10
#, fuzzy
msgid ""
"When a function's return type depends on a value, analyzing the value with "
"pattern matching can result in the type being _refined_, as a variable that "
"stands for a value is replaced by the constructors in the pattern. The type "
"signature of a function documents the way that the return type depends on "
"the argument value, and pattern matching then explains how the return type "
"can be fulfilled for each potential argument."
msgstr ""
"当函数的返回类型依赖于某个值时，使用模式匹配分析该值可以使类型得到「精炼」，因为代表值的变量被模式中的构造子替换。函数的类型签名记录了返回类型依赖于参数值的方式，然后模式匹配解释了如何为每个潜在参数实现返回类型。"

#: src/dependent-types/summary.md:13
#, fuzzy
msgid ""
"Ordinary code that occurs in types is run during type checking, though "
"`partial` functions that might loop infinitely are not called. Mostly, this "
"computation follows the rules of ordinary evaluation that were introduced in"
" [the very beginning of this book](../getting-to-know/evaluating.md), with "
"expressions being progressively replaced by their values until a final value"
" is found. Computation during type checking has an important difference from"
" run-time computation: some values in types may be _variables_ whose values "
"are not yet known. In these cases, pattern-matching gets \"stuck\" and does "
"not proceed until or unless a particular constructor is selected, e.g. by "
"pattern matching. Type-level computation can be seen as a kind of partial "
"evaluation, where only the parts of the program that are sufficiently known "
"need to be evaluated and other parts are left alone."
msgstr ""
"在类型检查期间发生的普通代码在类型检查期间运行，尽管可能无限循环的「部分」函数不会被调用。通常，此计算遵循本书[开头](../getting-to-"
"know/evaluating.md)中介绍的普通求值规则，表达式逐渐被其值替换，直到找到最终值。类型检查期间的计算与运行时计算有一个重要区别：类型中的一些值可能是其值尚未确定的「变量」。在这些情况下，模式匹配会「卡住」，直到或除非选择了一个特定的构造子，例如通过模式匹配。类型级计算可以看作是一种部分求值，其中只需要求值程序中已知的部分，而其他部分则保持不变。"

#: src/dependent-types/summary.md:19
#, fuzzy
msgid "The Universe Pattern"
msgstr "宇宙模式"

#: src/dependent-types/summary.md:21
#, fuzzy
msgid ""
"A common pattern when working with dependent types is to section off some "
"subset of the type system. For example, a database query library might be "
"able to return varying-length strings, fixed-length strings, or numbers in "
"certain ranges, but it will never return a function, a user-defined "
"datatype, or an `IO` action. A domain-specific subset of the type system can"
" be defined by first defining a datatype with constructors that match the "
"structure of the desired types, and then defining a function that interprets"
" values from this datatype into honest-to-goodness types. The constructors "
"are referred to as _codes_ for the types in question, and the entire pattern"
" is sometimes referred to as a _universe à la Tarski_, or just as a "
"_universe_ when context makes it clear that universes such as `Type 3` or "
"`Prop` are not what's meant."
msgstr ""
"使用依值类型时的一个常见模式是划分类型系统的一部分。例如，数据库查询库可以返回变长字符串、定长字符串或特定范围内的数字，但它永远不会返回函数、用户定义的数据类型或`IO`操作。可以通过首先定义一个具有与所需类型结构体匹配的构造子的类型，然后定义一个将此类型中的值解释为诚实类型的值的函数来定义类型系统的特定于域的子集。构造子被称为相关类型的「代码」，并且整个模式有时被称为“Tarski"
" 风格的宇宙”，或者当上下文清楚地表明诸如`Type 3`或`Prop`之类的宇宙不是指代时，简称为「宇宙」。"

#: src/dependent-types/summary.md:26
#, fuzzy
msgid ""
"Custom universes are an alternative to defining a type class with instances "
"for each type of interest. Type classes are extensible, but extensibility is"
" not always desired. Defining a custom universe has a number of advantages "
"over using the types directly:"
msgstr ""
"自定义宇宙是为每种感兴趣的类型定义类型类及其实例的替代方案。类型类是可扩展的，但可扩展性并不总是需要的。与直接使用类型相比，定义自定义宇宙有许多优势："

#: src/dependent-types/summary.md:29
#, fuzzy
msgid ""
"Generic operations that work for _any_ type in the universe, such as "
"equality testing and serialization, can be implemented by recursion on "
"codes."
msgstr "对宇宙中任何类型的通用操作（例如相等性测试和序列化）可以通过对代码的递归来实现。"

#: src/dependent-types/summary.md:30
#, fuzzy
msgid ""
"The types accepted by external systems can be represented precisely, and the"
" definition of the code datatype serves to document what can be expected."
msgstr "外部系统接受的类型可以精确表示，并且代码数据类型的定义有助于记录可以预期的内容。"

#: src/dependent-types/summary.md:31
#, fuzzy
msgid ""
"Lean's pattern matching completeness checker ensures that no codes are "
"forgotten, while solutions based on type classes defer missing instance "
"errors to client code."
msgstr "Lean 的模式匹配完整性检查器确保不会忘记任何代码，而基于类型类的解决方案将丢失的实例错误推迟到客户端代码。"

#: src/dependent-types/summary.md:36
#, fuzzy
msgid ""
"Datatypes can take two separate kinds of arguments: _parameters_ are "
"identical in each constructor of the datatype, while _indices_ may vary "
"between constructors. For a given choice of index, only some constructors of"
" the datatype are available. As an example, `Vect.nil` is available only "
"when the length index is `0`, and `Vect.cons` is available only when the "
"length index is `n+1` for some `n`. While parameters are typically written "
"as named arguments before the colon in a datatype declaration, and indices "
"as arguments in a function type after the colon, Lean can infer when an "
"argument after the colon is used as a parameter."
msgstr ""
"数据类型可以采用两种不同类型的参数：参数在数据类型的每个构造子中都是相同的，而索引在构造子之间可能不同。对于给定的索引选择，只有数据类型的某些构造子可用。例如，`Vect.nil`"
" 仅在长度索引为 `0` 时可用，而 `Vect.cons` 仅在长度索引为 `n+1` 时可用，其中 `n` "
"为某个数字。虽然参数通常在数据类型声明中的冒号之前作为命名参数编写，而索引作为冒号之后的函数类型中的参数编写，但 Lean "
"可以推断出冒号之后的参数何时用作参数。"

#: src/dependent-types/summary.md:41
#, fuzzy
msgid ""
"Indexed families allow the expression of complicated relationships between "
"data, all checked by the compiler. The datatype's invariants can be encoded "
"directly, and there is no way to violate them, not even temporarily. "
"Informing the compiler about the datatype's invariants brings a major "
"benefit: the compiler can now inform the programmer about what must be done "
"to satisfy them. The strategic use of compile-time errors, especially those "
"resulting from underscores, can make it possible to offload some of the "
"programming thought process to Lean, freeing up the programmer's mind to "
"worry about other things."
msgstr ""
"索引族允许表达数据之间的复杂关系，所有这些关系都由编译器检查。数据类型的变量可以被直接编码，并且没有办法违反它们，甚至暂时也不行。告知编译器有关数据类型的变量的主要好处是：编译器现在可以告知程序员必须做什么才能满足它们。战略性地使用编译时错误，尤其是由下划线引起的错误，可以将一些编程思想过程卸载到"
" Lean，从而释放程序员的思想去考虑其他事情。"

#: src/dependent-types/summary.md:46
#, fuzzy
msgid ""
"Encoding invariants using indexed families can lead to difficulties. First "
"off, each invariant requires its own datatype, which then requires its own "
"support libraries. `List.append` and `Vect.append` are not interchangeable, "
"after all. This can lead to code duplication. Secondly, convenient use of "
"indexed families requires that the recursive structure of functions used in "
"types match the recursive structure of the programs being type checked. "
"Programming with indexed families is the art of arranging for the right "
"coincidences to occur. While it's possible to work around missing "
"coincidences with appeals to equality proofs, it is difficult, and it leads "
"to programs littered with cryptic justifications. Thirdly, running "
"complicated code on large values during type checking can lead to compile-"
"time slowdowns. Avoiding these slowdowns for complicated programs can "
"require specialized techniques."
msgstr ""
"使用索引族编码不变量可能会带来困难。首先，每个不变量都需要自己的数据类型，然后需要自己的支持库。毕竟，`List.append` 和 "
"`Vect.append` "
"是不可互换的。这会导致代码重复。其次，方便地使用索引族需要在类型中使用的函数的递归结构体与正在类型检查的程序的递归结构体相匹配。使用索引族进行编程就是安排正确的巧合发生的艺术。虽然可以通过诉诸相等证明来解决缺失的巧合，但这很困难，并且会导致程序中充斥着难以理解的理由。第三，在类型检查期间对大值运行复杂代码会导致编译时速度变慢。对于复杂的程序，避免这些速度变慢可能需要专门的技术。"

#: src/dependent-types/summary.md:56
#, fuzzy
msgid "Definitional and Propositional Equality"
msgstr "定义和命题相等"

#: src/dependent-types/summary.md:58
#, fuzzy
msgid ""
"Lean's type checker must, from time to time, check whether two types should "
"be considered interchangeable. Because types can contain arbitrary programs,"
" it must therefore be able to check arbitrary programs for equality. "
"However, there is no efficient algorithm to check arbitrary programs for "
"fully-general mathematical equality. To work around this, Lean contains two "
"notions of equality:"
msgstr ""
"Lean "
"的类型检查器必须不时检查两个类型是否应该被认为是可互换的。因为类型可以包含任意程序，所以它必须能够检查任意程序的相等性。但是，没有有效的算法来检查任意程序的完全通用的数学相等性。为了解决这个问题，Lean"
" 包含了两个相等的概念："

#: src/dependent-types/summary.md:63
#, fuzzy
msgid ""
"_Definitional equality_ is an underapproximation of equality that "
"essentially checks for equality of syntactic representation modulo "
"computation and renaming of bound variables. Lean automatically checks for "
"definitional equality in situations where it is required."
msgstr "_定义相等_是相等性的近似，它本质上检查语法表示的相等性，模计算和重命名绑定变量。Lean 在需要时会自动检查定义相等性。"

#: src/dependent-types/summary.md:65
#, fuzzy
msgid ""
"_Propositional equality_ must be explicitly proved and explicitly invoked by"
" the programmer. In return, Lean automatically checks that the proofs are "
"valid and that the invocations accomplish the right goal."
msgstr "命题等价性必须由程序员明确证明和调用。作为回报，Lean 会自动检查证明是否有效，以及调用是否实现了正确目标。"

#: src/dependent-types/summary.md:67
#, fuzzy
msgid ""
"The two notions of equality represent a division of labor between "
"programmers and Lean itself. Definitional equality is simple, but automatic,"
" while propositional equality is manual, but expressive. Propositional "
"equality can be used to unstick otherwise-stuck programs in types."
msgstr ""
"等价性的两个概念代表了程序员和 Lean 本身之间的分工。定义等价性简单，但自动，而命题等价性是手动，但表达力强。命题等价性可用于取消类型中卡住的程序。"

#: src/dependent-types/summary.md:71
#, fuzzy
msgid ""
"However, the frequent use of propositional equality to unstick type-level "
"computation is typically a code smell. It typically means that coincidences "
"were not well-engineered, and it's usually a better idea to either redesign "
"the types and indices or to use a different technique to enforce the needed "
"invariants. When propositional equality is instead used to prove that a "
"program meets a specification, or as part of a subtype, there is less reason"
" to be suspicious."
msgstr ""
"然而，频繁使用命题等价性来取消类型级计算通常是一种代码异味。它通常意味着巧合没有得到很好的设计，并且通常更好的想法是重新设计类型和索引或使用不同的技术来强制执行所需的变量。当命题等价性被用来证明程序满足规范或作为子类型的部分时，就没有理由怀疑。"

#: src/tactics-induction-proofs.md:3
#, fuzzy
msgid "A Note on Proofs and User Interfaces"
msgstr "关于证明和用户界面的说明"

#: src/tactics-induction-proofs.md:5
#, fuzzy
msgid ""
"This book presents the process of writing proofs as if they are written in "
"one go and submitted to Lean, which then replies with error messages that "
"describe what remains to be done. The actual process of interacting with "
"Lean is much more pleasant. Lean provides information about the proof as the"
" cursor is moved through it and there are a number of interactive features "
"that make proving easier. Please consult the documentation of your Lean "
"development environment for more information."
msgstr ""
"本书介绍了编写证明的过程，就好像它们一次性编写并提交给 Lean，然后 Lean 用描述剩余工作的错误消息进行回复。与 Lean "
"交互的实际过程要愉快得多。当光标在证明中移动时，Lean 会提供有关证明的信息，并且有一些交互式功能可以使证明更容易。有关更多信息，请查阅 Lean "
"开发环境的文档。"

#: src/tactics-induction-proofs.md:10
#, fuzzy
msgid ""
"The approach in this book that focuses on incrementally building a proof and"
" showing the messages that result demonstrates the kinds of interactive "
"feedback that Lean provides while writing a proof, even though it is much "
"slower than the process used by experts. At the same time, seeing incomplete"
" proofs evolve towards completeness is a useful perspective on proving. As "
"your skill in writing proofs increases, Lean's feedback will come to feel "
"less like errors and more like support for your own thought processes. "
"Learning the interactive approach is very important."
msgstr ""
"本书中专注于逐步构建证明并显示结果消息的方法演示了 Lean "
"在编写证明时提供的交互式反馈类型，即使它比专家使用的过程慢得多。同时，看到不完整的证明向完整性演变是对证明的有用视角。随着您编写证明的技能提高，Lean"
" 的反馈将不再像错误，而更像是对您自己思维过程的支持。学习交互式方法非常重要。"

#: src/tactics-induction-proofs.md:15
#, fuzzy
msgid "Recursion and Induction"
msgstr "递归和归纳"

#: src/tactics-induction-proofs.md:17
#, fuzzy
msgid ""
"The functions `plusR_succ_left` and `plusR_zero_left` from the preceding "
"chapter can be seen from two perspectives. On the one hand, they are "
"recursive functions that build up evidence for a proposition, just as other "
"recursive functions might construct a list, a string, or any other data "
"structure. On the other, they also correspond to proofs by _mathematical "
"induction_."
msgstr ""
"前一章中的函数 `plusR_succ_left` 和 `plusR_zero_left` "
"可以从两个角度来看。一方面，它们是递归函数，用于为命题建立证据，就像其他递归函数可能构造列表、字符串或任何其他数据结构体一样。另一方面，它们也对应于数学归纳法的证明。"

#: src/tactics-induction-proofs.md:21
#, fuzzy
msgid ""
"Mathematical induction is a proof technique where a statement is proven for "
"_all_ natural numbers in two steps:"
msgstr "数学归纳法是一种证明技术，其中一个陈述被证明适用于所有自然数，分为两步："

#: src/tactics-induction-proofs.md:22
#, fuzzy
msgid ""
"The statement is shown to hold for \\\\( 0 \\\\). This is called the _base "
"case_."
msgstr "证明该陈述对 \\\\( 0 \\\\) 成立。这称为基本情况。"

#: src/tactics-induction-proofs.md:23
#, fuzzy
msgid ""
"Under the assumption that the statement holds for some arbitrarily chosen "
"number \\\\( n \\\\), it is shown to hold for \\\\( n + 1 \\\\). This is "
"called the _induction step_. The assumption that the statement holds for "
"\\\\( n \\\\) is called the _induction hypothesis_."
msgstr ""
"在假设该陈述对任意选定的数字 \\\\( n \\\\) 成立的情况下，证明它对 \\\\( n + 1 \\\\) 成立。这称为归纳步骤。假设该陈述对"
" \\\\( n \\\\) 成立称为归纳假设。"

#: src/tactics-induction-proofs.md:25
#, fuzzy
msgid ""
"Because it's impossible to check the statement for _every_ natural number, "
"induction provides a means of writing a proof that could, in principle, be "
"expanded to any particular natural number. For example, if a concrete proof "
"were desired for the number 3, then it could be constructed by using first "
"the base case and then the induction step three times, to show the statement"
" for 0, 1, 2, and finally 3. Thus, it proves the statement for all natural "
"numbers."
msgstr ""
"由于不可能检查每个自然数的陈述，因此归纳提供了一种编写证明的方法，原则上可以扩展到任何特定的自然数。例如，如果需要对数字 3 "
"进行具体证明，则可以通过首先使用基本情况，然后使用归纳步骤三次来构造它，以显示 0、1、2 和最终 3 的陈述。因此，它证明了所有自然数的陈述。"

#: src/tactics-induction-proofs.md:29
#, fuzzy
msgid "The Induction Tactic"
msgstr "归纳策略"

#: src/tactics-induction-proofs.md:31
#, fuzzy
msgid ""
"Writing proofs by induction as recursive functions that use helpers such as "
"`congrArg` does not always do a good job of expressing the intentions behind"
" the proof. While recursive functions indeed have the structure of "
"induction, they should probably be viewed as an _encoding_ of a proof. "
"Furthermore, Lean's tactic system provides a number of opportunities to "
"automate the construction of a proof that are not available when writing the"
" recursive function explicitly. Lean provides an induction _tactic_ that can"
" carry out an entire proof by induction in a single tactic block. Behind the"
" scenes, Lean constructs the recursive function that corresponds the use of "
"induction."
msgstr ""
"将归纳证明写为使用诸如 `congrArg` "
"之类的帮助程序的递归函数并不总是能够很好地表达证明背后的意图。虽然递归函数确实具有归纳的结构体，但它们可能应该被视为证明的编码。此外，Lean "
"的策略系统提供了许多机会来自动化证明的构建，而这些机会在显式编写递归函数时不可用。Lean "
"提供了一个归纳策略，可以在一个策略块中执行整个归纳证明。在幕后，Lean 构造了与使用归纳相对应的递归函数。"

#: src/tactics-induction-proofs.md:37
#, fuzzy
msgid ""
"To prove `plusR_zero_left` with the induction tactic, begin by writing its "
"signature (using `theorem`, because this really is a proof). Then, use `by "
"induction k` as the body of the definition:"
msgstr ""
"使用归纳法证明 `plusR_zero_left`，首先写出它的签名（使用 `theorem`，因为它确实是一个证明）。然后，使用 `by "
"induction k` 作为定义的主体："

#: src/tactics-induction-proofs.md:43
#, fuzzy
msgid "The resulting message states that there are two goals:"
msgstr "生成的提示指出有两个目标："

#: src/tactics-induction-proofs.md:54
#, fuzzy
msgid ""
"A tactic block is a program that is run while the Lean type checker "
"processes a file, somewhat like a much more powerful C preprocessor macro. "
"The tactics generate the actual program."
msgstr "策略块是一个程序，它在 Lean 类型检查器处理文件时运行，有点像一个功能更强大的 C 预处理器宏。策略生成实际程序。"

#: src/tactics-induction-proofs.md:57
#, fuzzy
msgid ""
"In the tactic language, there can be a number of goals. Each goal consists "
"of a type together with some assumptions. These are analogous to using "
"underscores as placeholders—the type in the goal represents what is to be "
"proved, and the assumptions represent what is in-scope and can be used. In "
"the case of the goal `case zero`, there are no assumptions and the type is "
"`Nat.zero = Nat.plusR 0 Nat.zero`—this is the theorem statement with `0` "
"instead of `k`. In the goal `case succ`, there are two assumptions, named "
"`n✝` and `n_ih✝`. Behind the scenes, the `induction` tactic creates a "
"dependent pattern match that refines the overall type, and `n✝` represents "
"the argument to `Nat.succ` in the pattern. The assumption `n_ih✝` represents"
" the result of calling the generated function recursively on `n✝`. Its type "
"is the overall type of the theorem, just with `n✝` instead of `k`. The type "
"to be fulfilled as part of the goal `case succ` is the overall theorem "
"statement, with `Nat.succ n✝` instead of `k`."
msgstr ""
"在策略语言中，可以有多个目标。每个目标由一个类型和一些假设组成。这些类似于使用下划线作为占位符——目标中的类型表示要证明的内容，而假设表示范围内可以使用的内容。在目标"
" `case zero` 的情况下，没有假设，类型为 `Nat.zero = Nat.plusR 0 Nat.zero`——这是定理陈述，其中 `0` "
"代替了 `k`。在目标 `case succ` 中，有两个假设，分别命名为 `n✝` 和 `n_ih✝`。在幕后，`induction` "
"策略创建了一个依赖模式匹配，它细化了整体类型，`n✝` 表示模式中 `Nat.succ` 的参数。假设 `n_ih✝` 表示在 `n✝` "
"上递归调用生成函数的结果。它的类型是定理的整体类型，只是用 `n✝` 代替了 `k`。作为目标 `case succ` "
"的一部分要实现的类型是整体定理陈述，其中 `Nat.succ n✝` 代替了 `k`。"

#: src/tactics-induction-proofs.md:67
#, fuzzy
msgid ""
"The two goals that result from the use of the `induction` tactic correspond "
"to the base case and the induction step in the description of mathematical "
"induction. The base case is `case zero`. In `case succ`, `n_ih✝` corresponds"
" to the induction hypothesis, while the whole of `case succ` is the "
"induction step."
msgstr ""
"使用 `induction` 策略产生的两个目标对应于数学归纳法描述中的基本情况和归纳步骤。基本情况是 `case zero`。在 `case "
"succ` 中，`n_ih✝` 对应于归纳假设，而整个 `case succ` 是归纳步骤。"

#: src/tactics-induction-proofs.md:71
#, fuzzy
msgid ""
"The next step in writing the proof is to focus on each of the two goals in "
"turn. Just as `pure ()` can be used in a `do` block to indicate \"do "
"nothing\", the tactic language has a statement `skip` that also does "
"nothing. This can be used when Lean's syntax requires a tactic, but it's not"
" yet clear which one should be used. Adding `with` to the end of the "
"`induction` statement provides a syntax that is similar to pattern matching:"
msgstr ""
"接下来，证明的步骤是依次关注两个目标。正如 `pure ()` 可用于 `do` 块中以表示「什么都不做」，策略语言有一个语句 "
"`skip`，它也什么都不做。当 Lean 的语法需要一个策略，但尚不清楚应该使用哪一个策略时，可以使用它。在 `induction` 语句的末尾添加 "
"`with` 提供了一个类似于模式匹配的语法："

#: src/tactics-induction-proofs.md:81
#, fuzzy
msgid ""
"Each of the two `skip` statements has a message associated with it. The "
"first shows the base case:"
msgstr "每个 `skip` 语句都有一个关联的消息。第一个显示基本情况："

#: src/tactics-induction-proofs.md:88
#, fuzzy
msgid "The second shows the induction step:"
msgstr "第二个显示归纳步骤："

#: src/tactics-induction-proofs.md:96
#, fuzzy
msgid ""
"In the induction step, the inaccessible names with daggers have been "
"replaced with the names provided after `succ`, namely `n` and `ih`."
msgstr "在归纳步骤中，带匕首的不可访问名称已被替换为 `succ` 后提供的名称，即 `n` 和 `ih`。"

#: src/tactics-induction-proofs.md:98
#, fuzzy
msgid ""
"The cases after `induction ... with` are not patterns: they consist of the "
"name of a goal followed by zero or more names. The names are used for "
"assumptions introduced in the goal; it is an error to provide more names "
"than the goal introduces:"
msgstr ""
"`induction ... with` 之后的 case "
"不是模式：它们由目标名称后跟零个或多个名称组成。这些名称用于目标中引入的假设；提供比目标引入的更多名称是错误的："

#: src/tactics-induction-proofs.md:110
#, fuzzy
msgid ""
"Focusing on the base case, the `rfl` tactic works just as well inside of the"
" `induction` tactic as it does in a recursive function:"
msgstr "关注基本情况，`rfl` 策略在 `induction` 策略中与在递归函数中一样有效："

#: src/tactics-induction-proofs.md:117
#, fuzzy
msgid ""
"In the recursive function version of the proof, a type annotation made the "
"expected type something that was easier to understand. In the tactic "
"language, there are a number of specific ways to transform a goal to make it"
" easier to solve. The `unfold` tactic replaces a defined name with its "
"definition:"
msgstr ""
"在证明的递归函数版本中，类型标注使预期类型变得更容易理解。在策略语言中，有许多特定方法可以转换目标以使其更容易求解。`unfold` "
"策略用其定义替换已定义的名称："

#: src/tactics-induction-proofs.md:127
#, fuzzy
msgid ""
"Now, the right-hand side of the equality in the goal has become `Nat.plusR 0"
" n + 1` instead of `Nat.plusR 0 (Nat.succ n)`:"
msgstr "现在，目标中等式的右侧已变为 `Nat.plusR 0 n + 1`，而不是 `Nat.plusR 0 (Nat.succ n)`："

#: src/tactics-induction-proofs.md:136
#, fuzzy
msgid ""
"Instead of appealing to functions like `congrArg` and operators like `▸`, "
"there are tactics that allow equality proofs to be used to transform proof "
"goals. One of the most important is `rw`, which takes a list of equality "
"proofs and replaces the left side with the right side in the goal. This "
"almost does the right thing in `plusR_zero_left`:"
msgstr ""
"与其诉诸于 `congrArg` 等函数和 `▸` 等运算符，有一些策略允许使用等式证明来转换证明目标。其中最重要的一个策略是 "
"`rw`，它获取一个等式证明列表，并在目标中用右侧替换左侧。这几乎在 `plusR_zero_left` 中做了正确的事情："

#: src/tactics-induction-proofs.md:147
#, fuzzy
msgid ""
"However, the direction of the rewrite was incorrect. Replacing `n` with "
"`Nat.plusR 0 n` made the goal more complicated rather than less complicated:"
msgstr "然而，重写的方向不正确。将 `n` 替换为 `Nat.plusR 0 n` 使得目标变得更加复杂，而不是更简单："

#: src/tactics-induction-proofs.md:156
#, fuzzy
msgid ""
"This can be remedied by placing a left arrow before `ih` in the call to "
"`rewrite`, which instructs it to replace the right-hand side of the equality"
" with the left-hand side:"
msgstr "这可以通过在 `rewrite` 调用中在 `ih` 之前放置一个左箭头来补救，它指示用等式的右侧替换左侧："

#: src/tactics-induction-proofs.md:165
#, fuzzy
msgid ""
"This rewrite makes both sides of the equation identical, and Lean takes care"
" of the `rfl` on its own. The proof is complete."
msgstr "此重写使等式的两边相同，Lean 自行处理 `rfl`。证明完成。"

#: src/tactics-induction-proofs.md:168
#, fuzzy
msgid "Tactic Golf"
msgstr "策略高尔夫"

#: src/tactics-induction-proofs.md:170
#, fuzzy
msgid ""
"So far, the tactic language has not shown its true value. The above proof is"
" no shorter than the recursive function; it's merely written in a domain-"
"specific language instead of the full Lean language. But proofs with tactics"
" can be shorter, easier, and more maintainable. Just as a lower score is "
"better in the game of golf, a shorter proof is better in the game of tactic "
"golf."
msgstr ""
"到目前为止，策略语言还没有显示其真正的价值。上述证明并不比递归函数短；它只是用特定于领域的语言而不是完整的 Lean "
"语言编写的。但是，使用策略的证明可以更短、更容易和更易于维护。就像在高尔夫球比赛中较低的分数更好一样，在策略高尔夫球比赛中较短的证明更好。"

#: src/tactics-induction-proofs.md:175
#, fuzzy
msgid ""
"The induction step of `plusR_zero_left` can be proved using the "
"simplification tactic `simp`. Using `simp` on its own does not help:"
msgstr "`plusR_zero_left` 的归纳步骤可以使用简化策略 `simp` 来证明。单独使用 `simp` 并没有帮助："

#: src/tactics-induction-proofs.md:187
#, fuzzy
msgid ""
"However, `simp` can be configured to make use of a set of definitions. Just "
"like `rw`, these arguments are provided in a list. Asking `simp` to take the"
" definition of `Nat.plusR` into account leads to a simpler goal:"
msgstr ""
"但是，可以配置 `simp` 以使用一组定义。就像 `rw` 一样，这些参数在列表中提供。要求 `simp` 考虑 `Nat.plusR` "
"的定义会导致一个更简单的目标："

#: src/tactics-induction-proofs.md:204
#, fuzzy
msgid ""
"In particular, the goal is now identical to the induction hypothesis. In "
"addition to automatically proving simple equality statements, the simplifier"
" automatically replaces goals like `Nat.succ A = Nat.succ B` with `A = B`. "
"Because the induction hypothesis `ih` has exactly the right type, the "
"`exact` tactic can indicate that it should be used:"
msgstr ""
"特别是，目标现在与归纳假设相同。除了自动证明简单的等式语句外，简化器还会自动将 `Nat.succ A = Nat.succ B` 这样的目标替换为 "
"`A = B`。因为归纳假设 `ih` 恰好具有正确的类型，所以 `exact` 策略可以指示应该使用它："

#: src/tactics-induction-proofs.md:216
#, fuzzy
msgid ""
"However, the use of `exact` is somewhat fragile. Renaming the induction "
"hypothesis, which may happen while \"golfing\" the proof, would cause this "
"proof to stop working. The `assumption` tactic solves the current goal if "
"_any_ of the assumptions match it:"
msgstr ""
"然而，使用 `exact` 有些脆弱。重命名归纳假设（这可能发生在「高尔夫」证明时）会导致此证明停止工作。`assumption` "
"策略解决了当前目标，如果 _任何_ 假设与之匹配："

#: src/tactics-induction-proofs.md:228
#, fuzzy
msgid ""
"This proof is no shorter than the prior proof that used unfolding and "
"explicit rewriting. However, a series of transformations can make it much "
"shorter, taking advantage of the fact that `simp` can solve many kinds of "
"goals. The first step is to drop the `with` at the end of `induction`. For "
"structured, readable proofs, the `with` syntax is convenient. It complains "
"if any cases are missing, and it shows the structure of the induction "
"clearly. But shortening proofs can often require a more liberal approach."
msgstr ""
"此证明并不比使用展开和显式重写的先前证明短。然而，一系列变换可以使它更短，利用 `simp` 可以解决多种目标这一事实。第一步是在 "
"`induction` 末尾删除 `with`。对于结构体化、可读的证明，`with` "
"语法很方便。如果缺少任何情况，它会抱怨，并且它清楚地显示了归纳的结构体。但缩短证明通常需要更自由的方法。"

#: src/tactics-induction-proofs.md:235
#, fuzzy
msgid ""
"Using `induction` without `with` simply results in a proof state with two "
"goals. The `case` tactic can be used to select one of them, just as in the "
"branches of the `induction ... with` tactic. In other words, the following "
"proof is equivalent to the prior proof:"
msgstr ""
"在没有 `with` 的情况下使用 `induction` 只会产生一个有两个目标的证明状态。`case` 策略可用于选择其中一个，就像 "
"`induction ... with` 策略的分支一样。换句话说，以下证明等效于先前的证明："

#: src/tactics-induction-proofs.md:247
#, fuzzy
msgid ""
"In a context with a single goal (namely, `k = Nat.plusR 0 k`), the "
"`induction k` tactic yields two goals. In general, a tactic will either fail"
" with an error or take a goal and transform it into zero or more new goals. "
"Each new goal represents what remains to be proved. If the result is zero "
"goals, then the tactic was a success, and that part of the proof is done."
msgstr ""
"在具有单个目标（即 `k = Nat.plusR 0 k`）的上下文中，`induction k` "
"策略产生两个目标。通常，策略要么失败并出现错误，要么获取目标并将其转换为零个或多个新目标。每个新目标代表待证明的内容。如果结果是零个目标，则策略成功，并且证明的那部分就完成了。"

#: src/tactics-induction-proofs.md:252
#, fuzzy
msgid ""
"The `<;>` operator takes two tactics as arguments, resulting in a new "
"tactic. `T1 <;> T2` applies `T1` to the current goal, and then applies `T2` "
"in _all_ goals created by `T1`. In other words, `<;>` enables a general "
"tactic that can solve many kinds of goals to be used on multiple new goals "
"all at once. One such general tactic is `simp`."
msgstr ""
"`<;>` 运算符将两个策略作为参数，从而产生一个新策略。`T1 <;> T2` 将 `T1` 应用于当前目标，然后将 `T2` 应用于 `T1` "
"创建的所有目标。换句话说，`<;>` 允许可以解决多种目标的通用策略一次用于多个新目标。`simp` 就是这样一个通用策略。"

#: src/tactics-induction-proofs.md:257
#, fuzzy
msgid ""
"Because `simp` can both complete the proof of the base case and make "
"progress on the proof of the induction step, using it with `induction` and "
"`<;>` shortens the proof:"
msgstr ""
"由于 `simp` 既能完成基本情况的证明，又能推进归纳步骤的证明，因此将其与 `induction` 和 `<;>` 一起使用可以缩短证明过程："

#: src/tactics-induction-proofs.md:262
#, fuzzy
msgid "This results in only a single goal, the transformed induction step:"
msgstr "这仅产生了一个目标，即转换后的归纳步骤："

#: src/tactics-induction-proofs.md:270
#, fuzzy
msgid "Running `assumption` in this goal completes the proof:"
msgstr "在此目标中运行 `assumption` 可以完成证明："

#: src/tactics-induction-proofs.md:275
#, fuzzy
msgid ""
"Here, `exact` would not have been possible, because `ih` was never "
"explicitly named."
msgstr "此处，`exact` 不可能，因为从未明确命名 `ih`。"

#: src/tactics-induction-proofs.md:277
#, fuzzy
msgid ""
"For beginners, this proof is not easier to read. However, a common pattern "
"for expert users is to take care of a number of simple cases with powerful "
"tactics like `simp`, allowing them to focus the text of the proof on the "
"interesting cases. Additionally, these proofs tend to be more robust in the "
"face of small changes to the functions and datatypes involved in the proof. "
"The game of tactic golf is a useful part of developing good taste and style "
"when writing proofs."
msgstr ""
"对于初学者来说，此证明并不容易理解。然而，专家用户的一个常见模式是用 `simp` "
"等强大的策略处理一些简单的情况，从而使他们能够将证明的重点放在有趣的情况上。此外，这些证明在面对证明中涉及的函数和数据类型的细微更改时往往更加稳健。策略高尔夫游戏是培养编写证明时的良好品味和风格的有用部分。"

#: src/tactics-induction-proofs.md:282
#, fuzzy
msgid "Induction on Other Datatypes"
msgstr "其他数据类型的归纳"

#: src/tactics-induction-proofs.md:284
#, fuzzy
msgid ""
"Mathematical induction proves a statement for natural numbers by providing a"
" base case for `Nat.zero` and an induction step for `Nat.succ`. The "
"principle of induction is also valid for other datatypes. Constructors "
"without recursive arguments form the base cases, while constructors with "
"recursive arguments form the induction steps. The ability to carry out "
"proofs by induction is the very reason why they are called _inductive_ "
"datatypes."
msgstr ""
"数学归纳通过为 `Nat.zero` 提供基本情况和为 `Nat.succ` "
"提供归纳步骤来证明自然数的陈述。归纳原理也适用于其他数据类型。没有递归参数的构造子形成基本情况，而有递归参数的构造子形成归纳步骤。通过归纳进行证明的能力正是它们被称为"
" _归纳_ 数据类型的原因。"

#: src/tactics-induction-proofs.md:289
#, fuzzy
msgid ""
"One example of this is induction on binary trees. Induction on binary trees "
"is a proof technique where a statement is proven for _all_ binary trees in "
"two steps:"
msgstr "二叉树归纳就是一个例子。二叉树归纳是一种证明技术，其中一个陈述通过两个步骤被证明适用于 _所有_ 二叉树："

#: src/tactics-induction-proofs.md:291
#, fuzzy
msgid ""
"The statement is shown to hold for `BinTree.leaf`. This is called the base "
"case."
msgstr "该陈述被证明适用于 `BinTree.leaf`。这称为基本情况。"

#: src/tactics-induction-proofs.md:292
#, fuzzy
msgid ""
"Under the assumption that the statement holds for some arbitrarily chosen "
"trees `l` and `r`, it is shown to hold for `BinTree.branch l x r`, where `x`"
" is an arbitrarily-chosen new data point. This is called the _induction "
"step_. The assumptions that the statement holds for `l` and `r` are called "
"the _induction hypotheses_."
msgstr ""
"在假设该陈述对任意选定的树 `l` 和 `r` 成立的情况下，已证明它对 `BinTree.branch l x r` 成立，其中 `x` "
"是任意选定的新数据点。这称为_归纳步骤_。假设该陈述对 `l` 和 `r` 成立称为_归纳假设_。"

#: src/tactics-induction-proofs.md:294
#, fuzzy
msgid "`BinTree.count` counts the number of branches in a tree:"
msgstr "`BinTree.count` 统计树中的分支数："

#: src/tactics-induction-proofs.md:301
#, fuzzy
msgid ""
"[Mirroring a tree](monads/conveniences.md#leading-dot-notation) does not "
"change the number of branches in it. This can be proven using induction on "
"trees. The first step is to state the theorem and invoke `induction`:"
msgstr ""
"[镜像树](monads/conveniences.md#leading-dot-notation) "
"不会改变其中的分支数。这可以通过对树进行归纳来证明。第一步是陈述定理并调用 `induction`："

#: src/tactics-induction-proofs.md:310
#, fuzzy
msgid ""
"The base case states that counting the mirror of a leaf is the same as "
"counting the leaf:"
msgstr "基本情况指出，统计镜像叶与统计叶相同："

#: src/tactics-induction-proofs.md:317
#, fuzzy
msgid ""
"The induction step allows the assumption that mirroring the left and right "
"subtrees won't affect their branch counts, and requests a proof that "
"mirroring a branch with these subtrees also preserves the overall branch "
"count:"
msgstr "归纳步骤允许假设镜像左右子树不会影响它们的分支计数，并要求证明镜像具有这些子树的分支也保留了整体分支计数："

#: src/tactics-induction-proofs.md:331
#, fuzzy
msgid ""
"The base case is true because mirroring `leaf` results in `leaf`, so the "
"left and right sides are definitionally equal. This can be expressed by "
"using `simp` with instructions to unfold `BinTree.mirror`:"
msgstr ""
"基本情况为真，因为镜像 `leaf` 会生成 `leaf`，所以左右两侧在定义上相等。这可以通过使用 `simp` 和展开 "
"`BinTree.mirror` 的指令来表示："

#: src/tactics-induction-proofs.md:339
#, fuzzy
msgid ""
"In the induction step, nothing in the goal immediately matches the induction"
" hypotheses. Simplifying using the definitions of `BinTree.count` and "
"`BinTree.mirror` reveals the relationship:"
msgstr ""
"在归纳步骤中，目标中的任何内容都不立即匹配归纳假设。使用 `BinTree.count` 和 `BinTree.mirror` "
"的定义进行简化，揭示了关系："

#: src/tactics-induction-proofs.md:359
#, fuzzy
msgid ""
"Both induction hypotheses can be used to rewrite the left-hand side of the "
"goal into something almost like the right-hand side:"
msgstr "两个归纳假设都可以用来将目标的左侧重写为几乎类似于右侧的东西："

#: src/tactics-induction-proofs.md:380
#, fuzzy
msgid ""
"The `simp_arith` tactic, a version of `simp` that can use additional "
"arithmetic identities, is enough to prove this goal, yielding:"
msgstr "`simp_arith` 策略（一种可以使用其他算术恒等式的 `simp`）足以证明此目标，产生："

#: src/tactics-induction-proofs.md:391
#, fuzzy
msgid ""
"In addition to definitions to be unfolded, the simplifier can also be passed"
" names of equality proofs to use as rewrites while it simplifies proof "
"goals. `BinTree.mirror_count` can also be written:"
msgstr ""
"除了要展开的定义外，简化器还可以传递等式证明的名称，以便在简化证明目标时用作重写。`BinTree.mirror_count` 还可以写成："

#: src/tactics-induction-proofs.md:400
#, fuzzy
msgid ""
"As proofs grow more complicated, listing assumptions by hand can become "
"tedious. Furthermore, manually writing assumption names can make it more "
"difficult to re-use proof steps for multiple subgoals. The argument `*` to "
"`simp` or `simp_arith` instructs them to use _all_ assumptions while "
"simplifying or solving the goal. In other words, the proof could also be "
"written:"
msgstr ""
"随着证明变得越来越复杂，手动列出假设会变得很繁琐。此外，手动编写假设名称会使为多个子目标重用证明步骤变得更加困难。`simp` 或 "
"`simp_arith` 的参数 `*` 指示它们在简化或求解目标时使用 _所有_假设。换句话说，证明也可以写成："

#: src/tactics-induction-proofs.md:411
#, fuzzy
msgid ""
"Because both branches are using the simplifier, the proof can be reduced to:"
msgstr "由于两个分支都使用简化器，因此可以将证明简化为："

#: src/tactics-induction-proofs.md:420
#, fuzzy
msgid "Prove `plusR_succ_left` using the `induction ... with` tactic."
msgstr "使用 `induction ... with` 策略证明 `plusR_succ_left`。"

#: src/tactics-induction-proofs.md:421
#, fuzzy
msgid "Rewrite the proof of `plus_succ_left` to use `<;>` in a single line."
msgstr "重写 `plus_succ_left` 的证明，在单行中使用 `<;>`。"

#: src/tactics-induction-proofs.md:422
#, fuzzy
msgid ""
"Prove that appending lists is associative using induction on lists: `theorem"
" List.append_assoc (xs ys zs : List α) : xs ++ (ys ++ zs) = (xs ++ ys) ++ "
"zs`"
msgstr ""
"使用列表归纳法证明追加列表是关联的：`theorem List.append_assoc (xs ys zs : List α) : xs ++ (ys"
" ++ zs) = (xs ++ ys) ++ zs`"

#: src/programs-proofs.md:3
#, fuzzy
msgid ""
"This chapter is about programming. Programs need to compute the correct "
"result, but they also need to do so efficiently. To write efficient "
"functional programs, it's important to know both how to use data structures "
"appropriately and how to think about the time and space needed to run a "
"program."
msgstr ""
"本章是关于编程的。程序需要计算出正确的结果，但它们还需要高效地执行。为了编写高效的功能程序，了解如何适当地使用数据结构体以及如何考虑运行程序所需的时间和空间非常重要。"

#: src/programs-proofs.md:7
#, fuzzy
msgid ""
"This chapter is also about proofs. One of the most important data structures"
" for efficient programming in Lean is the array, but safe use of arrays "
"requires proving that array indices are in bounds. Furthermore, most "
"interesting algorithms on arrays do not follow the pattern of structural "
"recursion—instead, they iterate over the array. While these algorithms "
"terminate, Lean will not necessarily be able to automatically check this. "
"Proofs can be used to demonstrate why a program terminates."
msgstr ""
"本章也是关于证明的。在 Lean "
"中进行高效编程最重要的数据结构体之一是数组，但安全使用数组需要证明数组索引在边界内。此外，大多数有趣的数组算法并不遵循结构体递归模式——相反，它们会遍历数组。虽然这些算法会终止，但"
" Lean 不一定能够自动检查这一点。证明可以用来证明程序为什么终止。"

#: src/programs-proofs.md:13
#, fuzzy
msgid ""
"Rewriting programs to make them faster often results in code that is more "
"difficult to understand. Proofs can also show that two programs always "
"compute the same answers, even if they do so with different algorithms or "
"implementation techniques. In this way, the slow, straightforward program "
"can serve as a specification for the fast, complicated version."
msgstr ""
"重写程序以使其运行得更快通常会导致代码更难理解。证明还可以表明两个程序始终计算出相同的答案，即使它们使用不同的算法或实现技术。通过这种方式，缓慢、直接的程序可以作为快速、复杂版本的规范。"

#: src/programs-proofs.md:17
#, fuzzy
msgid ""
"Combining proofs and programming allows programs to be both safe and "
"efficient. Proofs allow elision of run-time bounds checks, they render many "
"tests unnecessary, and they provide an extremely high level of confidence in"
" a program without introducing any runtime performance overhead. However, "
"proving theorems about programs can be time consuming and expensive, so "
"other tools are often more economical."
msgstr ""
"将证明和编程相结合，可以使程序既安全又高效。证明允许省略运行时边界检查，它们使许多测试变得不必要，并且它们在不引入任何运行时性能开销的情况下为程序提供了极高的置信度。然而，证明程序的定理可能是耗时且昂贵的，因此其他工具通常更经济。"

#: src/programs-proofs.md:21
#, fuzzy
msgid ""
"Interactive theorem proving is a deep topic. This chapter provides only a "
"taste, oriented towards the proofs that come up in practice while "
"programming in Lean. Most interesting theorems are not closely related to "
"programming. Please refer to [Next Steps](next-steps.md) for a list of "
"resources for learning more. Just as when learning programming, however, "
"there's no substitute for hands-on experience when learning to write "
"proofs—it's time to get started!"
msgstr ""
"交互式定理证明是一个深刻的话题。本章仅提供一个示例，面向在 Lean 中编程时出现的证明。大多数有趣的定理与编程没有密切关系。请参阅 "
"[下一步](next-steps.md) "
"以获取更多学习资源的列表。然而，就像学习编程一样，在学习编写证明时，没有什么是可以替代实践经验的——是时候开始了！"

#: src/programs-proofs/tail-recursion.md:3
#, fuzzy
msgid ""
"While Lean's `do`\\-notation makes it possible to use traditional loop "
"syntax such as `for` and `while`, these constructs are translated behind the"
" scenes to invocations of recursive functions. In most programming "
"languages, recursive functions have a key disadvantage with respect to "
"loops: loops consume no space on the stack, while recursive functions "
"consume stack space proportional to the number of recursive calls. Stack "
"space is typically limited, and it is often necessary to take algorithms "
"that are naturally expressed as recursive functions and rewrite them as "
"loops paired with an explicit mutable heap-allocated stack."
msgstr ""
"虽然 Lean 的 `do` 符号允许使用传统的循环语法，例如 `for` 和 "
"`while`，但这些结构体在幕后被转换为递归函数的调用。在大多数编程语言中，递归函数相对于循环有一个关键缺点：循环不消耗堆栈空间，而递归函数消耗与递归调用次数成正比的堆栈空间。堆栈空间通常是有限的，通常有必要采用自然表示为递归函数的算法，并将其重写为与显式可变堆栈分配配对的循环。"

#: src/programs-proofs/tail-recursion.md:7
#, fuzzy
msgid ""
"In functional programming, the opposite is typically true. Programs that are"
" naturally expressed as mutable loops may consume stack space, while "
"rewriting them to recursive functions can cause them to run quickly. This is"
" due to a key aspect of functional programming languages: _tail-call "
"elimination_. A tail call is a call from one function to another that can be"
" compiled to an ordinary jump, replacing the current stack frame rather than"
" pushing a new one, and tail-call elimination is the process of implementing"
" this transformation."
msgstr ""
"函数式编程中，情况通常相反。以可变循环自然表达的程序可能会消耗堆栈空间，而将它们重写为递归函数可以使它们快速运行。这是函数式编程语言的一个关键方面：_尾调用消除_。尾调用是从一个函数到另一个函数的调用，可以编译成一个普通的跳转，替换当前的堆栈帧而不是压入一个新的堆栈帧，而尾调用消除就是实现此转换的过程。"

#: src/programs-proofs/tail-recursion.md:12
#, fuzzy
msgid ""
"Tail-call elimination is not just merely an optional optimization. Its "
"presence is a fundamental part of being able to write efficient functional "
"code. For it to be useful, it must be reliable. Programmers must be able to "
"reliably identify tail calls, and they must be able to trust that the "
"compiler will eliminate them."
msgstr ""
"尾调用消除不仅仅是一种可选的优化。它的存在是编写高效函数式代码的基础部分。为了使其有用，它必须是可靠的。程序员必须能够可靠地识别尾调用，并且他们必须相信编译器会消除它们。"

#: src/programs-proofs/tail-recursion.md:17
#, fuzzy
msgid "The function `NonTail.sum` adds the contents of a list of `Nat`s:"
msgstr "函数 `NonTail.sum` 添加 `Nat` 列表的内容："

#: src/programs-proofs/tail-recursion.md:23
#, fuzzy
msgid ""
"Applying this function to the list `[1, 2, 3]` results in the following "
"sequence of evaluation steps:"
msgstr "将此函数应用于列表 `[1, 2, 3]` 会产生以下求值步骤序列："

#: src/programs-proofs/tail-recursion.md:41
#, fuzzy
msgid ""
"In the evaluation steps, parentheses indicate recursive calls to "
"`NonTail.sum`. In other words, to add the three numbers, the program must "
"first check that the list is non-empty. To add the head of the list (`1`) to"
" the sum of the tail of the list, it is first necessary to compute the sum "
"of the tail of the list:"
msgstr ""
"在求值步骤中，括号表示对 `NonTail.sum` "
"的递归调用。换句话说，要添加这三个数字，程序必须首先检查列表是否非空。要将列表的头部（`1`）添加到列表尾部的和，首先需要计算列表尾部的和："

#: src/programs-proofs/tail-recursion.md:47
#, fuzzy
msgid ""
"But to compute the sum of the tail of the list, the program must check "
"whether it is empty. It is not - the tail is itself a list with `2` at its "
"head. The resulting step is waiting for the return of `NonTail.sum [3]`:"
msgstr ""
"但是要计算列表尾部的和，程序必须检查它是否为空。它不是 - 尾部本身是一个列表，头部为 `2`。结果步骤正在等待 `NonTail.sum [3]` "
"的返回："

#: src/programs-proofs/tail-recursion.md:53
#, fuzzy
msgid ""
"The whole point of the run-time call stack is to keep track of the values "
"`1`, `2`, and `3` along with the instruction to add them to the result of "
"the recursive call. As recursive calls are completed, control returns to the"
" stack frame that made the call, so each step of addition is performed. "
"Storing the heads of the list and the instructions to add them is not free; "
"it takes space proportional to the length of the list."
msgstr ""
"运行时调用栈的全部意义在于跟踪值 `1`、`2` 和 "
"`3`，以及将它们添加到递归调用的结果中的指令。随着递归调用的完成，控制权返回到发出调用的栈帧，因此执行了每一步的加法。存储列表的头部和将它们相加的指令并不是免费的；它占用的空间与列表的长度成正比。"

#: src/programs-proofs/tail-recursion.md:57
#, fuzzy
msgid "The function `Tail.sum` also adds the contents of a list of `Nat`s:"
msgstr "函数 `Tail.sum` 也添加了 `Nat` 列表的内容："

#: src/programs-proofs/tail-recursion.md:66
#, fuzzy
msgid ""
"Applying it to the list `[1, 2, 3]` results in the following sequence of "
"evaluation steps:"
msgstr "将其应用于列表 `[1, 2, 3]` 会产生以下评估步骤序列："

#: src/programs-proofs/tail-recursion.md:86
#, fuzzy
msgid ""
"The internal helper function calls itself recursively, but it does so in a "
"way where nothing needs to be remembered in order to compute the final "
"result. When `Tail.sumHelper` reaches its base case, control can be returned"
" directly to `Tail.sum`, because the intermediate invocations of "
"`Tail.sumHelper` simply return the results of their recursive calls "
"unmodified. In other words, a single stack frame can be re-used for each "
"recursive invocation of `Tail.sumHelper`. Tail-call elimination is exactly "
"this re-use of the stack frame, and `Tail.sumHelper` is referred to as a "
"_tail-recursive function_."
msgstr ""
"内部帮助函数以递归方式调用自身，但它以一种方式执行此操作，无需记住任何内容即可计算最终结果。当 `Tail.sumHelper` "
"达到其基本情况时，控制权可以直接返回到 `Tail.sum`，因为 `Tail.sumHelper` "
"的中间调用只是返回其递归调用的结果，而不会修改。换句话说，可以为 `Tail.sumHelper` "
"的每个递归调用重新使用一个栈帧。尾调用消除正是这种栈帧的重新使用，而 `Tail.sumHelper` 被称为 _尾递归函数_。"

#: src/programs-proofs/tail-recursion.md:91
#, fuzzy
msgid ""
"The first argument to `Tail.sumHelper` contains all of the information that "
"would otherwise need to be tracked in the call stack—namely, the sum of the "
"numbers encountered so far. In each recursive call, this argument is updated"
" with new information, rather than adding new information to the call stack."
" Arguments like `soFar` that replace the information from the call stack are"
" called _accumulators_."
msgstr ""
"`Tail.sumHelper` "
"的第一个参数包含所有其他需要在调用栈中跟踪的信息，即到目前为止遇到的数字的总和。在每个递归调用中，此参数都会使用新信息进行更新，而不是将新信息添加到调用栈中。替换调用栈中信息的"
" `soFar` 等参数称为 _累加器_。"

#: src/programs-proofs/tail-recursion.md:95
#, fuzzy
msgid ""
"At the time of writing and on the author's computer, `NonTail.sum` crashes "
"with a stack overflow when passed a list with 216,856 or more entries. "
"`Tail.sum`, on the other hand, can sum a list of 100,000,000 elements "
"without a stack overflow. Because no new stack frames need to be pushed "
"while running `Tail.sum`, it is completely equivalent to a `while` loop with"
" a mutable variable that holds the current list. At each recursive call, the"
" function argument on the stack is simply replaced with the next node of the"
" list."
msgstr ""
"在撰写本文时，在作者的计算机上，当传入包含 216,856 个或更多条目的列表时，`NonTail.sum` "
"会因堆栈溢出而崩溃。另一方面，`Tail.sum` 可以对包含 100,000,000 个元素的列表求和，而不会发生堆栈溢出。由于在运行 "
"`Tail.sum` 时不需要压入新的堆栈帧，因此它完全等同于一个 `while` "
"循环，其中一个可变变量保存当前列表。在每次递归调用中，堆栈上的函数参数都会被简单地替换为列表的下一个节点。"

#: src/programs-proofs/tail-recursion.md:101
#, fuzzy
msgid "Tail and Non-Tail Positions"
msgstr "尾部和非尾部位置"

#: src/programs-proofs/tail-recursion.md:103
#, fuzzy
msgid ""
"The reason why `Tail.sumHelper` is tail recursive is that the recursive call"
" is in _tail position_. Informally speaking, a function call is in tail "
"position when the caller does not need to modify the returned value in any "
"way, but will just return it directly. More formally, tail position can be "
"defined explicitly for expressions."
msgstr ""
"`Tail.sumHelper` 是尾递归的原因在于递归调用处于 "
"_尾部位置_。非正式地说，当调用者不需要以任何方式修改返回值，而是会直接返回它时，函数调用就处于尾部位置。更正式地说，可以明确地为表达式定义尾部位置。"

#: src/programs-proofs/tail-recursion.md:107
#, fuzzy
msgid ""
"If a `match`\\-expression is in tail position, then each of its branches is "
"also in tail position. Once a `match` has selected a branch, control "
"proceeds immediately to it. Similarly, both branches of an `if`\\-expression"
" are in tail position if the `if`\\-expression itself is in tail position. "
"Finally, if a `let`\\-expression is in tail position, then its body is as "
"well."
msgstr ""
"如果 `match` 表达式处于尾部位置，那么它的每个分支也处于尾部位置。一旦 `match` 选择了一个分支，控制权就会立即传递给它。类似地，如果 "
"`if` 表达式本身处于尾部位置，那么 `if` 表达式的两个分支都处于尾部位置。最后，如果 `let` 表达式处于尾部位置，那么它的主体也是如此。"

#: src/programs-proofs/tail-recursion.md:112
#, fuzzy
msgid ""
"All other positions are not in tail position. The arguments to a function or"
" a constructor are not in tail position because evaluation must track the "
"function or constructor that will be applied to the argument's value. The "
"body of an inner function is not in tail position because control may not "
"even pass to it: function bodies are not evaluated until the function is "
"called. Similarly, the body of a function type is not in tail position. To "
"evaluate `E` in `(x : α) → E`, it is necessary to track that the resulting "
"type must have `(x : α) → ...` wrapped around it."
msgstr ""
"所有其他位置都不处于尾部位置。函数或构造子的参数不处于尾部位置，因为求值必须跟踪将应用于参数值的函数或构造子。内部函数的主体不处于尾部位置，因为控制权甚至可能不会传递给它：函数主体在函数被调用之前不会被求值。类似地，函数类型的函数主体不处于尾部位置。要求值"
" `(x : α) → E` 中的 `E`，有必要跟踪结果类型必须在其周围包装 `(x : α) → ...`。"

#: src/programs-proofs/tail-recursion.md:118
#, fuzzy
msgid ""
"In `NonTail.sum`, the recursive call is not in tail position because it is "
"an argument to `+`. In `Tail.sumHelper`, the recursive call is in tail "
"position because it is immediately underneath a pattern match, which itself "
"is the body of the function."
msgstr ""
"在 `NonTail.sum` 中，递归调用不在尾部位置，因为它是一个 `+` 的参数。在 `Tail.sumHelper` "
"中，递归调用在尾部位置，因为它紧跟在模式匹配之后，而模式匹配本身是函数的主体。"

#: src/programs-proofs/tail-recursion.md:121
#, fuzzy
msgid ""
"At the time of writing, Lean only eliminates direct tail calls in recursive "
"functions. This means that tail calls to `f` in `f`'s definition will be "
"eliminated, but not tail calls to some other function `g`. While it is "
"certainly possible to eliminate a tail call to some other function, saving a"
" stack frame, this is not yet implemented in Lean."
msgstr ""
"在撰写本文时，Lean 仅消除了递归函数中的直接尾部调用。这意味着在 `f` 的定义中对 `f` 的尾部调用将被消除，但对其他函数 `g` "
"的尾部调用不会被消除。虽然消除对其他函数的尾部调用以节省堆栈帧当然是有可能的，但这尚未在 Lean 中实现。"

#: src/programs-proofs/tail-recursion.md:125
#: src/programs-proofs/tail-recursion-proofs.md:472
#, fuzzy
msgid "Reversing Lists"
msgstr "反转列表"

#: src/programs-proofs/tail-recursion.md:127
#, fuzzy
msgid ""
"The function `NonTail.reverse` reverses lists by appending the head of each "
"sub-list to the end of the result:"
msgstr "函数 `NonTail.reverse` 通过将每个子列表的头部追加到结果的末尾来反转列表："

#: src/programs-proofs/tail-recursion.md:133
#, fuzzy
msgid ""
"Using it to reverse `[1, 2, 3]` yields the following sequence of steps:"
msgstr "使用它来反转 `[1, 2, 3]` 会产生以下步骤序列："

#: src/programs-proofs/tail-recursion.md:152
#, fuzzy
msgid ""
"The tail-recursive version uses `x :: ·` instead of `· ++ [x]` on the "
"accumulator at each step:"
msgstr "尾递归版本在每一步的累加器上使用 `x :: ·` 而不是 `· ++ [x]`："

#: src/programs-proofs/tail-recursion.md:161
#, fuzzy
msgid ""
"This is because the context saved in each stack frame while computing with "
"`NonTail.reverse` is applied beginning at the base case. Each \"remembered\""
" piece of context is executed in last-in, first-out order. On the other "
"hand, the accumulator-passing version modifies the accumulator beginning "
"from the first entry in the list, rather than the original base case, as can"
" be seen in the series of reduction steps:"
msgstr ""
"这是因为在使用 `NonTail.reverse` "
"计算时保存在每个堆栈帧中的上下文从基本情况开始应用。每个「记住的」上下文片段都按照后进先出的顺序执行。另一方面，累加器传递版本从列表中的第一个条目而不是原始基本情况开始修改累加器，如一系列归约步骤所示："

#: src/programs-proofs/tail-recursion.md:177
#, fuzzy
msgid ""
"In other words, the non-tail-recursive version starts at the base case, "
"modifying the result of recursion from right to left through the list. The "
"entries in the list affect the accumulator in a first-in, first-out order. "
"The tail-recursive version with the accumulator starts at the head of the "
"list, modifying an initial accumulator value from left to right through the "
"list."
msgstr ""
"换句话说，非尾递归版本从基本情况开始，从右到左通过列表修改递归结果。列表中的条目以先入先出的顺序影响累加器。带有累加器的尾递归版本从列表的头部开始，从左到右通过列表修改初始累加器值。"

#: src/programs-proofs/tail-recursion.md:181
#, fuzzy
msgid ""
"Because addition is commutative, nothing needed to be done to account for "
"this in `Tail.sum`. Appending lists is not commutative, so care must be "
"taken to find an operation that has the same effect when run in the opposite"
" direction. Appending `[x]` after the result of the recursion in "
"`NonTail.reverse` is analogous to adding `x` to the beginning of the list "
"when the result is built in the opposite order."
msgstr ""
"由于加法具有交换律，因此无需在 `Tail.sum` 中对此进行处理。列表追加不具有交换律，因此必须小心找到一个在相反方向运行时具有相同效果的操作。在 "
"`NonTail.reverse` 中，在递归结果后追加 `[x]` 与在相反顺序构建结果时将 `x` 添加到列表开头类似。"

#: src/programs-proofs/tail-recursion.md:185
#, fuzzy
msgid "Multiple Recursive Calls"
msgstr "多个递归调用"

#: src/programs-proofs/tail-recursion.md:187
#, fuzzy
msgid "In the definition of `BinTree.mirror`, there are two recursive calls:"
msgstr "在 `BinTree.mirror` 的定义中，有两个递归调用："

#: src/programs-proofs/tail-recursion.md:193
#, fuzzy
msgid ""
"Just as imperative languages would typically use a while loop for functions "
"like `reverse` and `sum`, they would typically use recursive functions for "
"this kind of traversal. This function cannot be straightforwardly rewritten "
"to be tail recursive using accumulator-passing style."
msgstr ""
"就像命令式语言通常会对 `reverse` 和 `sum` 等函数使用 while "
"循环一样，它们通常会对这种遍历使用递归函数。无法使用累加器传递样式直接将此函数重写为尾递归。"

#: src/programs-proofs/tail-recursion.md:196
#, fuzzy
msgid ""
"Typically, if more than one recursive call is required for each recursive "
"step, then it will be difficult to use accumulator-passing style. This "
"difficulty is similar to the difficulty of rewriting a recursive function to"
" use a loop and an explicit data structure, with the added complication of "
"convincing Lean that the function terminates. However, as in "
"`BinTree.mirror`, multiple recursive calls often indicate a data structure "
"that has a constructor with multiple recursive occurrences of itself. In "
"these cases, the depth of the structure is often logarithmic with respect to"
" its overall size, which makes the tradeoff between stack and heap less "
"stark. There are systematic techniques for making these functions tail-"
"recursive, such as using _continuation-passing style_, but they are outside "
"the scope of this chapter."
msgstr ""
"通常，如果每个递归步骤需要多个递归调用，那么将很难使用累加器传递样式。这种困难类似于使用循环和显式数据结构体重写递归函数的困难，增加了说服 Lean "
"函数终止的复杂性。但是，就像在 `BinTree.mirror` "
"中一样，多个递归调用通常表示一个数据结构体，其构造子具有多次递归出现的情况。在这些情况下，结构体的深度通常与其整体大小成对数关系，这使得堆栈和堆之间的权衡不那么明显。有一些系统化的技术可以使这些函数成为尾递归，例如使用"
" _延续传递样式_，但它们超出了本章的范围。"

#: src/programs-proofs/tail-recursion.md:204
#, fuzzy
msgid ""
"Translate each of the following non-tail-recursive functions into "
"accumulator-passing tail-recursive functions:"
msgstr "将以下非尾递归函数转换为累加器传递尾递归函数："

#: src/programs-proofs/tail-recursion.md:218
#, fuzzy
msgid ""
"The translation of `NonTail.filter` should result in a program that takes "
"constant stack space through tail recursion, and time linear in the length "
"of the input list. A constant factor overhead is acceptable relative to the "
"original:"
msgstr ""
"`NonTail.filter` "
"的转换应生成一个通过尾递归占用常量堆栈空间的程序，并且时间与输入列表的长度成线性关系。相对于原始程序，常量因子开销是可以接受的："

#: src/programs-proofs/tail-recursion-proofs.md:3
#, fuzzy
msgid ""
"Programs that have been rewritten to use tail recursion and an accumulator "
"can look quite different from the original program. The original recursive "
"function is often much easier to understand, but it runs the risk of "
"exhausting the stack at run time. After testing both versions of the program"
" on examples to rule out simple bugs, proofs can be used to show once and "
"for all that the programs are equivalent."
msgstr ""
"已重写为使用尾递归和累加器的程序可能看起来与原始程序非常不同。原始递归函数通常更容易理解，但它有在运行时耗尽堆栈的风险。在示例上测试程序的两个版本以排除简单错误后，可以使用证明来一劳永逸地证明程序是等价的。"

#: src/programs-proofs/tail-recursion-proofs.md:7
#, fuzzy
msgid "Proving `sum` Equal"
msgstr "证明 `sum` 相等"

#: src/programs-proofs/tail-recursion-proofs.md:9
#, fuzzy
msgid ""
"To prove that both versions of `sum` are equal, begin by writing the theorem"
" statement with a stub proof:"
msgstr "要证明 `sum` 的两个版本相等，首先用存根证明编写定理陈述："

#: src/programs-proofs/tail-recursion-proofs.md:14
#, fuzzy
msgid "As expected, Lean describes an unsolved goal:"
msgstr "正如预期的那样，Lean 描述了一个未解决的目标："

#: src/programs-proofs/tail-recursion-proofs.md:20
#, fuzzy
msgid ""
"The `rfl` tactic cannot be applied here, because `NonTail.sum` and "
"`Tail.sum` are not definitionally equal. Functions can be equal in more ways"
" than just definitional equality, however. It is also possible to prove that"
" two functions are equal by proving that they produce equal outputs for the "
"same input. In other words, \\\\( f = g \\\\) can be proved by proving that "
"\\\\( f(x) = g(x) \\\\) for all possible inputs \\\\( x \\\\). This "
"principle is called _function extensionality_. Function extensionality is "
"exactly the reason why `NonTail.sum` equals `Tail.sum`: they both sum lists "
"of numbers."
msgstr ""
"`rfl` 战术无法在此处应用，因为 `NonTail.sum` 和 `Tail.sum` "
"在定义上不相等。然而，函数可以以不止定义相等的方式相等。还可以通过证明两个函数对相同输入产生相等输出，来证明它们相等。换句话说，\\\\( f = g "
"\\\\) 可以通过证明 \\\\( f(x) = g(x) \\\\) 对于所有可能的输入 \\\\( x \\\\) 来证明。此原理称为 "
"_函数扩展性_。函数扩展性正是 `NonTail.sum` 等于 `Tail.sum` 的原因：它们都对数字列表求和。"

#: src/programs-proofs/tail-recursion-proofs.md:27
#, fuzzy
msgid ""
"In Lean's tactic language, function extensionality is invoked using "
"`funext`, followed by a name to be used for the arbitrary argument. The "
"arbitrary argument is added as an assumption to the context, and the goal "
"changes to require a proof that the functions applied to this argument are "
"equal:"
msgstr ""
"在 Lean 的策略语言中，使用 `funext` "
"调用函数扩展性，后跟一个用于任意参数的名称。任意参数作为假设添加到上下文中，目标变为要求证明应用于此参数的函数相等："

#: src/programs-proofs/tail-recursion-proofs.md:40
#, fuzzy
msgid ""
"This goal can be proved by induction on the argument `xs`. Both `sum` "
"functions return `0` when applied to the empty list, which serves as a base "
"case. Adding a number to the beginning of the input list causes both "
"functions to add that number to the result, which serves as an induction "
"step. Invoking the `induction` tactic results in two goals:"
msgstr ""
"此目标可以通过对参数 `xs` 进行归纳来证明。当应用于空列表时，`sum` 函数都返回 "
"`0`，这作为基本情况。在输入列表的开头添加一个数字会导致两个函数都将该数字添加到结果中，这作为归纳步骤。调用 `induction` "
"策略会导致两个目标："

#: src/programs-proofs/tail-recursion-proofs.md:65
#, fuzzy
msgid ""
"The base case for `nil` can be solved using `rfl`, because both functions "
"return `0` when passed the empty list:"
msgstr "`nil` 的基本情况可以使用 `rfl` 解决，因为当传递空列表时，两个函数都返回 `0`："

#: src/programs-proofs/tail-recursion-proofs.md:74
#, fuzzy
msgid ""
"The first step in solving the induction step is to simplify the goal, asking"
" `simp` to unfold `NonTail.sum` and `Tail.sum`:"
msgstr "解决归纳步骤的第一步是简化目标，要求 `simp` 展开 `NonTail.sum` 和 `Tail.sum`："

#: src/programs-proofs/tail-recursion-proofs.md:91
#, fuzzy
msgid ""
"Unfolding `Tail.sum` revealed that it immediately delegates to "
"`Tail.sumHelper`, which should also be simplified:"
msgstr "展开 `Tail.sum` 显示它立即委托给 `Tail.sumHelper`，也应该简化它："

#: src/programs-proofs/tail-recursion-proofs.md:100
#, fuzzy
msgid ""
"In the resulting goal, `sumHelper` has taken a step of computation and added"
" `y` to the accumulator:"
msgstr "在结果目标中，`sumHelper` 执行了一步计算并将 `y` 添加到累加器中："

#: src/programs-proofs/tail-recursion-proofs.md:109
#, fuzzy
msgid ""
"Rewriting with the induction hypothesis removes all mentions of "
"`NonTail.sum` from the goal:"
msgstr "使用归纳假设重写会从目标中删除所有 `NonTail.sum` 的引用："

#: src/programs-proofs/tail-recursion-proofs.md:127
#, fuzzy
msgid ""
"This new goal states that adding some number to the sum of a list is the "
"same as using that number as the initial accumulator in `sumHelper`. For the"
" sake of clarity, this new goal can be proved as a separate theorem:"
msgstr ""
"这个新目标表明，将某个数字添加到列表的和中与在 `sumHelper` "
"中使用该数字作为初始累加器相同。为了清晰起见，这个新目标可以作为单独的定理来证明："

#: src/programs-proofs/tail-recursion-proofs.md:140
#, fuzzy
msgid ""
"Once again, this is a proof by induction where the base case uses `rfl`:"
msgstr "这又一次是归纳证明，其中基本情况使用 `rfl`："

#: src/programs-proofs/tail-recursion-proofs.md:156
#, fuzzy
msgid ""
"Because this is an inductive step, the goal should be simplified until it "
"matches the induction hypothesis `ih`. Simplifying, using the definitions of"
" `Tail.sum` and `Tail.sumHelper`, results in the following:"
msgstr ""
"因为这是一个归纳步骤，所以目标应该被简化，直到它与归纳假设 `ih` 匹配。简化，使用 `Tail.sum` 和 `Tail.sumHelper` "
"的定义，得到以下结果："

#: src/programs-proofs/tail-recursion-proofs.md:174
#, fuzzy
msgid ""
"Ideally, the induction hypothesis could be used to replace `Tail.sumHelper "
"(y + n) ys`, but they don't match. The induction hypothesis can be used for "
"`Tail.sumHelper n ys`, not `Tail.sumHelper (y + n) ys`. In other words, this"
" proof is stuck."
msgstr ""
"理想情况下，归纳假设可以用来替换 `Tail.sumHelper (y + n) ys`，但它们不匹配。归纳假设可用于 `Tail.sumHelper "
"n ys`，而不是 `Tail.sumHelper (y + n) ys`。换句话说，这个证明被卡住了。"

#: src/programs-proofs/tail-recursion-proofs.md:178
#, fuzzy
msgid "A Second Attempt"
msgstr "第二次尝试"

#: src/programs-proofs/tail-recursion-proofs.md:180
#, fuzzy
msgid ""
"Rather than attempting to muddle through the proof, it's time to take a step"
" back and think. Why is it that the tail-recursive version of the function "
"is equal to the non-tail-recursive version? Fundamentally speaking, at each "
"entry in the list, the accumulator grows by the same amount as would be "
"added to the result of the recursion. This insight can be used to write an "
"elegant proof. Crucially, the proof by induction must be set up such that "
"the induction hypothesis can be applied to _any_ accumulator value."
msgstr ""
"与其试图弄清楚证明，不如退一步思考。为什么函数的尾递归版本等于非尾递归版本？从根本上讲，在列表中的每个条目中，累加器都会增加与递归结果中添加的量相同的值。这个见解可以用来写一个优雅的证明。至关重要的是，归纳证明必须设置成归纳假设可以应用于_任何_累加器值。"

#: src/programs-proofs/tail-recursion-proofs.md:186
#, fuzzy
msgid ""
"Discarding the prior attempt, the insight can be encoded as the following "
"statement:"
msgstr "放弃之前的尝试，这个见解可以编码为以下语句："

#: src/programs-proofs/tail-recursion-proofs.md:192
#, fuzzy
msgid ""
"In this statement, it's very important that `n` is part of the type that's "
"after the colon. The resulting goal begins with `∀ (n : Nat)`, which is "
"short for \"For all `n`\":"
msgstr ""
"在这个语句中，非常重要的是 `n` 是冒号后面类型的组成部分。产生的目标以 `∀ (n : Nat)` 开头，这是「对于所有 `n`」的缩写："

#: src/programs-proofs/tail-recursion-proofs.md:199
#, fuzzy
msgid ""
"Using the induction tactic results in goals that include this \"for all\" "
"statement:"
msgstr "使用归纳策略会导致包含这个「对于所有」语句的目标："

#: src/programs-proofs/tail-recursion-proofs.md:207
#, fuzzy
msgid "In the `nil` case, the goal is:"
msgstr "在 `nil` 情况下，目标是："

#: src/programs-proofs/tail-recursion-proofs.md:213
#, fuzzy
msgid ""
"For the induction step for `cons`, both the induction hypothesis and the "
"specific goal contain the \"for all `n`\":"
msgstr "对于 `cons` 的归纳步骤，归纳假设和具体目标都包含「对于所有 `n`」："

#: src/programs-proofs/tail-recursion-proofs.md:222
#, fuzzy
msgid ""
"In other words, the goal has become more challenging to prove, but the "
"induction hypothesis is correspondingly more useful."
msgstr "换句话说，目标变得更难证明，但归纳假设相应地更有用。"

#: src/programs-proofs/tail-recursion-proofs.md:224
#, fuzzy
msgid ""
"A mathematical proof for a statement that beings with \"for all \\\\( x "
"\\\\)\" should assume some arbitrary \\\\( x \\\\), and prove the statement."
" \"Arbitrary\" means that no additional properties of \\\\( x \\\\) are "
"assumed, so the resulting statement will work for _any_ \\\\( x \\\\). In "
"Lean, a \"for all\" statement is a dependent function: no matter which "
"specific value it is applied to, it will return evidence of the proposition."
" Similarly, the process of picking an arbitrary \\\\( x \\\\) is the same as"
" using `fun x => ...`. In the tactic language, this process of selecting an "
"arbitrary \\\\( x \\\\) is performed using the `intro` tactic, which "
"produces the function behind the scenes when the tactic script has "
"completed. The `intro` tactic should be provided with the name to be used "
"for this arbitrary value."
msgstr ""
"对于以「对于所有 \\\\( x \\\\)」开头的语句的数学证明应该假设一些任意的 \\\\( x \\\\)，并证明该语句。「任意」意味着不假设 "
"\\\\( x \\\\) 的任何附加属性，因此结果语句将适用于_任何_ \\\\( x \\\\)。在 Lean "
"中，「对于所有」语句是一个依赖函数：无论将其应用于哪个特定值，它都将返回命题的证据。类似地，选择任意 \\\\( x \\\\) 的过程与使用 `fun"
" x => ...` 相同。在策略语言中，使用 `intro` 策略执行选择任意 \\\\( x \\\\) "
"的过程，当策略脚本完成后，它会在幕后生成函数。`intro` 策略应该提供用于此任意值的名称。"

#: src/programs-proofs/tail-recursion-proofs.md:231
#, fuzzy
msgid ""
"Using the `intro` tactic in the `nil` case removes the `∀ (n : Nat),` from "
"the goal, and adds an assumption `n : Nat`:"
msgstr "使用 `intro` 策略在 `nil` 情况下，从目标中移除 `∀ (n : Nat),`，并添加假设 `n : Nat`："

#: src/programs-proofs/tail-recursion-proofs.md:245
#, fuzzy
msgid ""
"Both sides of this propositional equality are definitionally equal to `n`, "
"so `rfl` suffices:"
msgstr "此命题等式的两边在定义上等于 `n`，因此 `rfl` 就足够了："

#: src/programs-proofs/tail-recursion-proofs.md:255
#, fuzzy
msgid "The `cons` goal also contains a \"for all\":"
msgstr "`cons` 目标也包含一个「对所有」："

#: src/programs-proofs/tail-recursion-proofs.md:264
#, fuzzy
msgid "This suggests the use of `intro`."
msgstr "这表明可以使用 `intro`。"

#: src/programs-proofs/tail-recursion-proofs.md:284
#, fuzzy
msgid ""
"The proof goal now contains both `NonTail.sum` and `Tail.sumHelper` applied "
"to `y :: ys`. The simplifier can make the next step more clear:"
msgstr ""
"现在，证明目标包含应用于 `y :: ys` 的 `NonTail.sum` 和 `Tail.sumHelper`。简化器可以使下一步更清晰："

#: src/programs-proofs/tail-recursion-proofs.md:306
#, fuzzy
msgid ""
"This goal is very close to matching the induction hypothesis. There are two "
"ways in which it does not match:"
msgstr "此目标非常接近于匹配归纳假设。它不匹配的方面有两个："

#: src/programs-proofs/tail-recursion-proofs.md:308
#, fuzzy
msgid ""
"The left-hand side of the equation is `n + (y + NonTail.sum ys)`, but the "
"induction hypothesis needs the left-hand side to be a number added to "
"`NonTail.sum ys`. In other words, this goal should be rewritten to `(n + y) "
"+ NonTail.sum ys`, which is valid because addition of natural numbers is "
"associative."
msgstr ""
"等式的左侧是 `n + (y + NonTail.sum ys)`，但归纳假设需要左侧是一个添加到 `NonTail.sum ys` "
"的数字。换句话说，此目标应重写为 `(n + y) + NonTail.sum ys`，这是有效的，因为自然数的加法是结合的。"

#: src/programs-proofs/tail-recursion-proofs.md:310
#, fuzzy
msgid ""
"When the left side has been rewritten to `(y + n) + NonTail.sum ys`, the "
"accumulator argument on the right side should be `n + y` rather than `y + n`"
" in order to match. This rewrite is valid because addition is also "
"commutative."
msgstr ""
"当左侧重写为 `(y + n) + NonTail.sum ys` 时，右侧的累加器参数应为 `n + y` 而不是 `y + n` "
"以进行匹配。此重写是有效的，因为加法也是可交换的。"

#: src/programs-proofs/tail-recursion-proofs.md:313
#, fuzzy
msgid ""
"The associativity and commutativity of addition have already been proved in "
"Lean's standard library. The proof of associativity is named "
"`Nat.add_assoc`, and its type is `(n m k : Nat) → (n + m) + k = n + (m + "
"k)`, while the proof of commutativity is called `Nat.add_comm` and has type "
"`(n m : Nat) → n + m = m + n`. Normally, the `rw` tactic is provided with an"
" expression whose type is an equality. However, if the argument is instead a"
" dependent function whose return type is an equality, it attempts to find "
"arguments to the function that would allow the equality to match something "
"in the goal. There is only one opportunity to apply associativity, though "
"the direction of the rewrite must be reversed because the right side of the "
"equality in `Nat.add_assoc` is the one that matches the proof goal:"
msgstr ""
"加法的结合性和交换性已在 Lean 的标准库中得到证明。结合性的证明名为 `Nat.add_assoc`，其类型为 `(n m k : Nat) → "
"(n + m) + k = n + (m + k)`，而交换性的证明称为 `Nat.add_comm`，其类型为 `(n m : Nat) → n + "
"m = m + n`。通常，`rw` "
"策略会提供一个类型为等式的表达式。但是，如果参数是一个返回类型为等式的相关函数，它会尝试找到函数的参数，以便等式可以匹配目标中的某个内容。虽然必须反转重写方向，但只有一种机会应用结合性，因为"
" `Nat.add_assoc` 中等式的右侧是与证明目标匹配的："

#: src/programs-proofs/tail-recursion-proofs.md:339
#, fuzzy
msgid ""
"Rewriting directly with `Nat.add_comm`, however, leads to the wrong result. "
"The `rw` tactic guesses the wrong location for the rewrite, leading to an "
"unintended goal:"
msgstr "然而，直接使用 `Nat.add_comm` 重写会导致错误的结果。`rw` 策略猜测了错误的重写位置，导致了意外的目标："

#: src/programs-proofs/tail-recursion-proofs.md:363
#, fuzzy
msgid ""
"This can be fixed by explicitly providing `y` and `n` as arguments to "
"`Nat.add_comm`:"
msgstr "可以通过显式地将 `y` 和 `n` 作为参数提供给 `Nat.add_comm` 来解决此问题："

#: src/programs-proofs/tail-recursion-proofs.md:386
#, fuzzy
msgid ""
"The goal now matches the induction hypothesis. In particular, the induction "
"hypothesis's type is a dependent function type. Applying `ih` to `n + y` "
"results in exactly the desired type. The `exact` tactic completes a proof "
"goal if its argument has exactly the desired type:"
msgstr ""
"目标现在与归纳假设相匹配。特别是，归纳假设的类型是一个依赖函数类型。将 `ih` 应用于 `n + y` "
"会产生完全期望的类型。如果其参数具有完全期望的类型，`exact` 策略会完成证明目标："

#: src/programs-proofs/tail-recursion-proofs.md:403
#, fuzzy
msgid ""
"The actual proof requires only a little additional work to get the goal to "
"match the helper's type. The first step is still to invoke function "
"extensionality:"
msgstr "实际证明只需要一些额外的工作即可使目标与辅助类型的匹配。第一步仍然是调用函数扩展性："

#: src/programs-proofs/tail-recursion-proofs.md:415
#, fuzzy
msgid "The next step is unfold `Tail.sum`, exposing `Tail.sumHelper`:"
msgstr "下一步是展开 `Tail.sum`，公开 `Tail.sumHelper`："

#: src/programs-proofs/tail-recursion-proofs.md:427
#, fuzzy
msgid ""
"Having done this, the types almost match. However, the helper has an "
"additional addend on the left side. In other words, the proof goal is "
"`NonTail.sum xs = Tail.sumHelper 0 xs`, but applying "
"`non_tail_sum_eq_helper_accum` to `xs` and `0` yields the type `0 + "
"NonTail.sum xs = Tail.sumHelper 0 xs`. Another standard library proof, "
"`Nat.zero_add`, has type `(n : Nat) → 0 + n = n`. Applying this function to "
"`NonTail.sum xs` results in an expression with type `0 + NonTail.sum xs = "
"NonTail.sum xs`, so rewriting from right to left results in the desired "
"goal:"
msgstr ""
"完成此操作后，类型几乎匹配。但是，辅助类型在左侧有一个额外的加数。换句话说，证明目标是 `NonTail.sum xs = Tail.sumHelper"
" 0 xs`，但将 `non_tail_sum_eq_helper_accum` 应用于 `xs` 和 `0` 会产生类型 `0 + "
"NonTail.sum xs = Tail.sumHelper 0 xs`。另一个标准库证明 `Nat.zero_add` 的类型为 `(n : "
"Nat) → 0 + n = n`。将此函数应用于 `NonTail.sum xs` 会产生类型为 `0 + NonTail.sum xs = "
"NonTail.sum xs` 的表达式，因此从右到左重写会产生期望的目标："

#: src/programs-proofs/tail-recursion-proofs.md:444
#, fuzzy
msgid "Finally, the helper can be used to complete the proof:"
msgstr "最后，可以使用辅助类型来完成证明："

#: src/programs-proofs/tail-recursion-proofs.md:453
#, fuzzy
msgid ""
"This proof demonstrates a general pattern that can be used when proving that"
" an accumulator-passing tail-recursive function is equal to the non-tail-"
"recursive version. The first step is to discover the relationship between "
"the starting accumulator argument and the final result. For instance, "
"beginning `Tail.sumHelper` with an accumulator of `n` results in the final "
"sum being added to `n`, and beginning `Tail.reverseHelper` with an "
"accumulator of `ys` results in the final reversed list being prepended to "
"`ys`. The second step is to write down this relationship as a theorem "
"statement and prove it by induction. While the accumulator is always "
"initialized with some neutral value in practice, such as `0` or `[]`, this "
"more general statement that allows the starting accumulator to be any value "
"is what's needed to get a strong enough induction hypothesis. Finally, using"
" this helper theorem with the actual initial accumulator value results in "
"the desired proof. For example, in `non_tail_sum_eq_tail_sum`, the "
"accumulator is specified to be `0`. This may require rewriting the goal to "
"make the neutral initial accumulator values occur in the right place."
msgstr ""
"此证明演示了在证明累加器传递尾递归函数等于非尾递归版本时可以使用的通用模式。第一步是发现起始累加器参数和最终结果之间的关系。例如，以 `n` "
"的累加器开始 `Tail.sumHelper` 会导致最终和被添加到 `n` 中，并且以 `ys` 的累加器开始 "
"`Tail.reverseHelper` 会导致最终反转的列表被前置到 `ys` "
"中。第二步是将此关系写成定理陈述，并通过归纳法证明它。虽然在实践中，累加器总是用一些中性值（例如 `0` 或 "
"`[]`）初始化，但允许起始累加器为任何值的更通用陈述是获得足够强的归纳假设所需要的。最后，将此辅助定理与实际初始累加器值一起使用会产生期望的证明。例如，在"
" `non_tail_sum_eq_tail_sum` 中，累加器指定为 `0`。这可能需要重写目标以使中性初始累加器值出现在正确的位置。"

#: src/programs-proofs/tail-recursion-proofs.md:466
#, fuzzy
msgid "Warming Up"
msgstr "热身"

#: src/programs-proofs/tail-recursion-proofs.md:468
#, fuzzy
msgid ""
"Write your own proofs for `Nat.zero_add`, `Nat.add_assoc`, and "
"`Nat.add_comm` using the `induction` tactic."
msgstr ""
"使用 `induction` 策略编写你自己的 `Nat.zero_add`、`Nat.add_assoc` 和 `Nat.add_comm` 证明。"

#: src/programs-proofs/tail-recursion-proofs.md:470
#, fuzzy
msgid "More Accumulator Proofs"
msgstr "更多累加器证明"

#: src/programs-proofs/tail-recursion-proofs.md:474
#, fuzzy
msgid ""
"Adapt the proof for `sum` into a proof for `NonTail.reverse` and "
"`Tail.reverse`. The first step is to think about the relationship between "
"the accumulator value being passed to `Tail.reverseHelper` and the non-tail-"
"recursive reverse. Just as adding a number to the accumulator in "
"`Tail.sumHelper` is the same as adding it to the overall sum, using "
"`List.cons` to add a new entry to the accumulator in `Tail.reverseHelper` is"
" equivalent to some change to the overall result. Try three or four "
"different accumulator values with pencil and paper until the relationship "
"becomes clear. Use this relationship to prove a suitable helper theorem. "
"Then, write down the overall theorem. Because `NonTail.reverse` and "
"`Tail.reverse` are polymorphic, stating their equality requires the use of "
"`@` to stop Lean from trying to figure out which type to use for `α`. Once "
"`α` is treated as an ordinary argument, `funext` should be invoked with both"
" `α` and `xs`:"
msgstr ""
"将 `sum` 的证明调整为 `NonTail.reverse` 和 `Tail.reverse` 的证明。第一步是思考传递给 "
"`Tail.reverseHelper` 的累加器值与非尾递归反转之间的关系。正如在 `Tail.sumHelper` "
"中将数字添加到累加器中与将其添加到整体和中相同，在 `Tail.reverseHelper` 中使用 `List.cons` "
"将新条目添加到累加器中相当于对整体结果进行了一些更改。用铅笔和纸尝试三个或四个不同的累加器值，直到关系变得清晰。使用此关系来证明一个合适的帮助者定理。然后，写下整体定理。因为"
" `NonTail.reverse` 和 `Tail.reverse` 是多态的，所以声明它们的相等性需要使用 `@` 来阻止 Lean 尝试找出为 "
"`α` 使用哪种类型。一旦 `α` 被视为一个普通参数，`funext` 应该与 `α` 和 `xs` 一起调用："

#: src/programs-proofs/tail-recursion-proofs.md:486
#, fuzzy
msgid "This results in a suitable goal:"
msgstr "这导致了一个合适的目标："

#: src/programs-proofs/tail-recursion-proofs.md:496
#, fuzzy
msgid "Factorial"
msgstr "阶乘"

#: src/programs-proofs/tail-recursion-proofs.md:498
#, fuzzy
msgid ""
"Prove that `NonTail.factorial` from the exercises in the previous section is"
" equal to your tail-recursive solution by finding the relationship between "
"the accumulator and the result and proving a suitable helper theorem."
msgstr ""
"通过找到累加器和结果之间的关系并证明一个合适的帮助者定理，证明上一节练习中的 `NonTail.factorial` 等于你的尾递归解决方案。"

#: src/programs-proofs/arrays-termination.md:3
#, fuzzy
msgid ""
"To write efficient code, it is important to select appropriate data "
"structures. Linked lists have their place: in some applications, the ability"
" to share the tails of lists is very important. However, most use cases for "
"a variable-length sequential collection of data are better served by arrays,"
" which have both less memory overhead and better locality."
msgstr ""
"为了编写高效的代码，选择合适的数据结构体非常重要。链表有其用途：在某些应用程序中，共享列表尾部非常重要。但是，大多数可变长度顺序数据集合的用例都由数组更好地提供服务，数组既有较少的内存开销，又有更好的局部性。"

#: src/programs-proofs/arrays-termination.md:7
#, fuzzy
msgid "Arrays, however, have two drawbacks relative to lists:"
msgstr "数组相对于列表有两个缺点："

#: src/programs-proofs/arrays-termination.md:8
#, fuzzy
msgid ""
"Arrays are accessed through indexing, rather than by pattern matching, which"
" imposes [proof obligations](../props-proofs-indexing.md) in order to "
"maintain safety."
msgstr "数组是通过索引访问的，而不是通过模式匹配，这为了保持安全性而施加了[证明义务](../props-proofs-indexing.md)。"

#: src/programs-proofs/arrays-termination.md:9
#, fuzzy
msgid ""
"A loop that processes an entire array from left to right is a tail-recursive"
" function, but it does not have an argument that decreases on each call."
msgstr "从左到右处理整个数组的循环是一个尾递归函数，但它没有在每次调用时递减的参数。"

#: src/programs-proofs/arrays-termination.md:11
#, fuzzy
msgid ""
"Making effective use of arrays requires knowing how to prove to Lean that an"
" array index is in bounds, and how to prove that an array index that "
"approaches the size of the array also causes the program to terminate. Both "
"of these are expressed using an inequality proposition, rather than "
"propositional equality."
msgstr ""
"有效使用数组需要知道如何向 Lean "
"证明数组索引在范围内，以及如何证明接近数组大小的数组索引也会导致程序终止。这两个都使用不等式命题表示，而不是命题等式。"

#: src/programs-proofs/arrays-termination.md:14
#, fuzzy
msgid "Inequality"
msgstr "不等式"

#: src/programs-proofs/arrays-termination.md:16
#, fuzzy
msgid ""
"Because different types have different notions of ordering, inequality is "
"governed by two type classes, called `LE` and `LT`. The table in the section"
" on [standard type classes](../type-classes/standard-classes.md#equality-"
"and-ordering) describes how these classes relate to the syntax:"
msgstr ""
"由于不同的类型有不同的排序概念，因此不等式由两个类型类控制，称为 `LE` 和 `LT`。[标准类型类](../type-"
"classes/standard-classes.md#equality-and-ordering) 部分中的表格描述了这些类与语法之间的关系："

#: src/programs-proofs/arrays-termination.md:26
#, fuzzy
msgid ""
"In other words, a type may customize the meaning of the `<` and `≤` "
"operators, while `>` and `≥` derive their meanings from `<` and `≤`. The "
"classes `LT` and `LE` have methods that return propositions rather than "
"`Bool`s:"
msgstr ""
"换句话说，一个类型可以定制 `<` 和 `≤` 运算符的含义，而 `>` 和 `≥` 从 `<` 和 `≤` 中派生它们的含义。`LT` 和 `LE` "
"类具有返回命题而不是 `Bool` 的方法："

#: src/programs-proofs/arrays-termination.md:36
#, fuzzy
msgid "The instance of `LE` for `Nat` delegates to `Nat.le`:"
msgstr "`Nat` 的 `LE` 实例委托给 `Nat.le`："

#: src/programs-proofs/arrays-termination.md:41
#, fuzzy
msgid ""
"Defining `Nat.le` requires a feature of Lean that has not yet been "
"presented: it is an inductively-defined relation."
msgstr "定义 `Nat.le` 需要 Lean 中尚未介绍的一个特性：它是归纳定义的关系。"

#: src/programs-proofs/arrays-termination.md:43
#, fuzzy
msgid "Inductively-Defined Propositions, Predicates, and Relations"
msgstr "归纳定义的命题、谓词和关系"

#: src/programs-proofs/arrays-termination.md:45
#, fuzzy
msgid ""
"`Nat.le` is an _inductively-defined relation_. Just as `inductive` can be "
"used to create new datatypes, it can also be used to create new "
"propositions. When a proposition takes an argument, it is referred to as a "
"_predicate_ that may be true for some, but not all, potential arguments. "
"Propositions that take multiple arguments are called _relations_."
msgstr ""
"`Nat.le` 是一个 _归纳定义的关系_。就像 `inductive` "
"可以用来创建新的数据类型一样，它也可以用来创建新的命题。当一个命题接受一个参数时，它被称为 "
"_谓词_，它可能对某些潜在参数为真，但并非对所有参数都为真。接受多个参数的命题称为 _关系_。"

#: src/programs-proofs/arrays-termination.md:50
#, fuzzy
msgid ""
"Each constructor of an inductively defined proposition is a way to prove it."
" In other words, the declaration of the proposition describes the different "
"forms of evidence that it is true. A proposition with no arguments that has "
"a single constructor can be quite easy to prove:"
msgstr ""
"每个归纳定义命题的构造子都是证明它的方法。换句话说，命题的声明描述了它为真的不同形式的证据。一个没有参数且只有一个构造子的命题很容易证明："

#: src/programs-proofs/arrays-termination.md:57
#, fuzzy
msgid "The proof consists of using its constructor:"
msgstr "证明包括使用其构造子："

#: src/programs-proofs/arrays-termination.md:62
#, fuzzy
msgid ""
"In fact, the proposition `True`, which should always be easy to prove, is "
"defined just like `EasyToProve`:"
msgstr "事实上，命题 `True` 应该总是很容易证明，它被定义得就像 `EasyToProve`："

#: src/programs-proofs/arrays-termination.md:68
#, fuzzy
msgid ""
"Inductively-defined propositions that don't take arguments are not nearly as"
" interesting as inductively-defined datatypes. This is because data is "
"interesting in its own right—the natural number `3` is different from the "
"number `35`, and someone who has ordered 3 pizzas will be upset if 35 arrive"
" at their door 30 minutes later. The constructors of a proposition describe "
"ways in which the proposition can be true, but once a proposition has been "
"proved, there is no need to know _which_ underlying constructors were used. "
"This is why most interesting inductively-defined types in the `Prop` "
"universe take arguments."
msgstr ""
"不带参数的归纳定义命题远不如归纳定义的数据类型有趣。这是因为数据本身很有趣——自然数 `3` 不同于数字 `35`，而订购了 3 个披萨的人如果 30 "
"分钟后收到 35 个披萨会很沮丧。命题的构造子描述了命题可以为真的方式，但一旦命题被证明，就不需要知道使用了哪些底层构造子。这就是为什么 "
"`Prop` 宇宙中最有趣的归纳定义类型带参数的原因。"

#: src/programs-proofs/arrays-termination.md:73
#, fuzzy
msgid ""
"The inductively-defined predicate `IsThree` states that its argument is "
"three:"
msgstr "归纳定义谓词 `IsThree` 指出其参数为三个："

#: src/programs-proofs/arrays-termination.md:78
#, fuzzy
msgid ""
"The mechanism used here is just like [indexed families such as "
"`HasCol`](../dependent-types/typed-queries.md#column-pointers), except the "
"resulting type is a proposition that can be proved rather than data that can"
" be used."
msgstr ""
"这里使用的机制就像 [索引族，如 `HasCol`](../dependent-types/typed-queries.md#column-"
"pointers)，除了结果类型是一个可以被证明的命题，而不是可以被使用的数据。"

#: src/programs-proofs/arrays-termination.md:80
#, fuzzy
msgid ""
"Using this predicate, it is possible to prove that three is indeed three:"
msgstr "使用这个谓词，可以证明三个确实等于三个："

#: src/programs-proofs/arrays-termination.md:85
#, fuzzy
msgid ""
"Similarly, `IsFive` is a predicate that states that its argument is `5`:"
msgstr "类似地，`IsFive` 是一个谓词，它指出其参数是 `5`："

#: src/programs-proofs/arrays-termination.md:91
#, fuzzy
msgid ""
"If a number is three, then the result of adding two to it should be five. "
"This can be expressed as a theorem statement:"
msgstr "如果一个数字是三个，那么将它加二的结果应该是五个。这可以表示为定理陈述："

#: src/programs-proofs/arrays-termination.md:97
#, fuzzy
msgid "The resulting goal has a function type:"
msgstr "由此产生的目标具有函数类型："

#: src/programs-proofs/arrays-termination.md:103
#, fuzzy
msgid ""
"Thus, the `intro` tactic can be used to convert the argument into an "
"assumption:"
msgstr "因此，`intro` 策略可用于将参数转换为假设："

#: src/programs-proofs/arrays-termination.md:114
#, fuzzy
msgid ""
"Given the assumption that `n` is three, it should be possible to use the "
"constructor of `IsFive` to complete the proof:"
msgstr "假设 `n` 为三，则应该可以使用 `IsFive` 的构造子来完成证明："

#: src/programs-proofs/arrays-termination.md:120
#, fuzzy
msgid "However, this results in an error:"
msgstr "然而，这会导致一个错误："

#: src/programs-proofs/arrays-termination.md:127
#, fuzzy
msgid ""
"This error occurs because `n + 2` is not definitionally equal to `5`. In an "
"ordinary function definition, dependent pattern matching on the assumption "
"`three` could be used to refine `n` to `3`. The tactic equivalent of "
"dependent pattern matching is `cases`, which has a syntax similar to that of"
" `induction`:"
msgstr ""
"此错误发生是因为 `n + 2` 与 `5` 在定义上不相等。在普通的函数定义中，可以对假设 `three` 使用依赖模式匹配来将 `n` 细化为 "
"`3`。`cases` 是依赖模式匹配的策略等价物，其语法类似于 `induction`："

#: src/programs-proofs/arrays-termination.md:136
#, fuzzy
msgid "In the remaining case, `n` has been refined to `3`:"
msgstr "在剩余情况下，`n` 已细化为 `3`："

#: src/programs-proofs/arrays-termination.md:142
#, fuzzy
msgid ""
"Because `3 + 2` is definitionally equal to `5`, the constructor is now "
"applicable:"
msgstr "因为 `3 + 2` 在定义上等于 `5`，所以构造子现在适用："

#: src/programs-proofs/arrays-termination.md:150
#, fuzzy
msgid ""
"The standard false proposition `False` has no constructors, making it "
"impossible to provide direct evidence for. The only way to provide evidence "
"for `False` is if an assumption is itself impossible, similarly to how "
"`nomatch` can be used to mark code that the type system can see is "
"unreachable. As described in [the initial Interlude on proofs](../props-"
"proofs-indexing.md#connectives), the negation `Not A` is short for `A → "
"False`. `Not A` can also be written `¬A`."
msgstr ""
"标准假命题 `False` 没有构造子，因此无法提供直接证据。提供 `False` 证据的唯一方法是假设本身不可能，类似于如何使用 `nomatch`"
" 标记类型系统认为无法访问的代码。如 [证明的初始插曲](../props-proofs-indexing.md#connectives) 中所述，否定"
" `Not A` 是 `A → False` 的缩写。`Not A` 也可以写成 `¬A`。"

#: src/programs-proofs/arrays-termination.md:155
#, fuzzy
msgid "It is not the case that four is three:"
msgstr "四不是三："

#: src/programs-proofs/arrays-termination.md:160
#, fuzzy
msgid "The initial proof goal contains `Not`:"
msgstr "初始证明目标包含 `Not`："

#: src/programs-proofs/arrays-termination.md:165
#, fuzzy
msgid ""
"The fact that it's actually a function type can be exposed using `simp`:"
msgstr "它实际上是一个函数类型的事实可以使用 `simp` 暴露："

#: src/programs-proofs/arrays-termination.md:174
#, fuzzy
msgid ""
"Because the goal is a function type, `intro` can be used to convert the "
"argument into an assumption. There is no need to keep `simp`, as `intro` can"
" unfold the definition of `Not` itself:"
msgstr ""
"因为目标是一个函数类型，所以 `intro` 可用于将参数转换为假设。无需保留 `simp`，因为 `intro` 可以展开 `Not` 本身的定义："

#: src/programs-proofs/arrays-termination.md:185
#, fuzzy
msgid "In this proof, the `cases` tactic solves the goal immediately:"
msgstr "在这个证明中，`cases` 战术立即解决了目标："

#: src/programs-proofs/arrays-termination.md:191
#, fuzzy
msgid ""
"Just as a pattern match on a `Vect String 2` doesn't need to include a case "
"for `Vect.nil`, a proof by cases over `IsThree 4` doesn't need to include a "
"case for `isThree`."
msgstr ""
"就像对 `Vect String 2` 的模式匹配不需要包含 `Vect.nil` 的情况一样，对 `IsThree 4` 的情况证明不需要包含 "
"`isThree` 的情况。"

#: src/programs-proofs/arrays-termination.md:193
#, fuzzy
msgid "Inequality of Natural Numbers"
msgstr "自然数的不相等"

#: src/programs-proofs/arrays-termination.md:195
#, fuzzy
msgid "The definition of `Nat.le` has a parameter and an index:"
msgstr "`Nat.le` 的定义有一个参数和一个索引："

#: src/programs-proofs/arrays-termination.md:201
#, fuzzy
msgid ""
"The parameter `n` is the number that should be smaller, while the index is "
"the number that should be greater than or equal to `n`. The `refl` "
"constructor is used when both numbers are equal, while the `step` "
"constructor is used when the index is greater than `n`."
msgstr ""
"参数 `n` 是应该更小的数字，而索引是应该大于或等于 `n` 的数字。当两个数字相等时使用 `refl` 构造子，而当索引大于 `n` 时使用 "
"`step` 构造子。"

#: src/programs-proofs/arrays-termination.md:204
#, fuzzy
msgid ""
"From the perspective of evidence, a proof that \\\\( n \\leq k \\\\) "
"consists of finding some number \\\\( d \\\\) such that \\\\( n + d = m "
"\\\\). In Lean, the proof then consists of a `Nat.le.refl` constructor "
"wrapped by \\\\( d \\\\) instances of `Nat.le.step`. Each `step` constructor"
" adds one to its index argument, so \\\\( d \\\\) `step` constructors adds "
"\\\\( d \\\\) to the larger number. For example, evidence that four is less "
"than or equal to seven consists of three `step`s around a `refl`:"
msgstr ""
"从证据的角度来看，证明 \\\\( n \\leq k \\\\) 包括找到一些数字 \\\\( d \\\\) 使得 \\\\( n + d = m "
"\\\\)。在 Lean 中，证明由 \\\\( d \\\\) 个 `Nat.le.step` 实例包装的 `Nat.le.refl` "
"构造子组成。每个 `step` 构造子将其索引参数加一，因此 \\\\( d \\\\) 个 `step` 构造子将 \\\\( d \\\\) "
"加到较大的数字上。例如，证明四小于或等于七由 `refl` 周围的三个 `step` 组成："

#: src/programs-proofs/arrays-termination.md:214
#, fuzzy
msgid ""
"The strict less-than relation is defined by adding one to the number on the "
"left:"
msgstr "严格小于关系通过在左侧数字上加一来定义："

#: src/programs-proofs/arrays-termination.md:222
#, fuzzy
msgid ""
"Evidence that four is strictly less than seven consists of two `step`'s "
"around a `refl`:"
msgstr "证明四严格小于七由 `refl` 周围的两个 `step` 组成："

#: src/programs-proofs/arrays-termination.md:228
#, fuzzy
msgid "This is because `4 < 7` is equivalent to `5 ≤ 7`."
msgstr "这是因为 `4 < 7` 等价于 `5 ≤ 7`。"

#: src/programs-proofs/arrays-termination.md:230
#: src/programs-proofs/summary.md:72
#, fuzzy
msgid "Proving Termination"
msgstr "证明终止"

#: src/programs-proofs/arrays-termination.md:232
#, fuzzy
msgid ""
"The function `Array.map` transforms an array with a function, returning a "
"new array that contains the result of applying the function to each element "
"of the input array. Writing it as a tail-recursive function follows the "
"usual pattern of delegating to a function that passes the output array in an"
" accumulator. The accumulator is initialized with an empty array. The "
"accumulator-passing helper function also takes an argument that tracks the "
"current index into the array, which starts at `0`:"
msgstr ""
"`Array.map` "
"函数使用函数转换数组，返回一个包含将函数应用于输入数组的每个元素的结果的新数组。将其写为尾递归函数遵循将输出数组传递给累加器的函数的委托的通常模式。累加器用空数组初始化。传递累加器的辅助函数还采用一个参数来跟踪数组中的当前索引，该索引从"
" `0` 开始："

#: src/programs-proofs/arrays-termination.md:241
#, fuzzy
msgid ""
"The helper should, at each iteration, check whether the index is still in "
"bounds. If so, it should loop again with the transformed element added to "
"the end of the accumulator and the index incremented by `1`. If not, then it"
" should terminate and return the accumulator. An initial implementation of "
"this code fails because Lean is unable to prove that the array index is "
"valid:"
msgstr ""
"助手应在每次迭代时检查索引是否仍在范围内。如果是，则应再次循环，将转换后的元素添加到累加器的末尾，并将索引增加 "
"`1`。如果不是，则应终止并返回累加器。此代码的初始实现失败，因为 Lean 无法证明数组索引有效："

#: src/programs-proofs/arrays-termination.md:265
#, fuzzy
msgid ""
"However, the conditional expression already checks the precise condition "
"that the array index's validity demands (namely, `i < arr.size`). Adding a "
"name to the `if` resolves the issue, because it adds an assumption that the "
"array indexing tactic can use:"
msgstr ""
"然而，条件表达式已经检查了数组索引的有效性所要求的精确条件（即 `i < arr.size`）。为 `if` "
"添加一个名称可以解决此问题，因为它添加了一个数组索引策略可以使用的前提："

#: src/programs-proofs/arrays-termination.md:273
#, fuzzy
msgid ""
"Lean does not, however, accept the modified program, because the recursive "
"call is not made on an argument to one of the input constructors. In fact, "
"both the accumulator and the index grow, rather than shrinking:"
msgstr "但是，Lean 不接受修改后的程序，因为递归调用不是针对输入构造子之一的参数进行的。事实上，累加器和索引都在增长，而不是缩小："

#: src/programs-proofs/arrays-termination.md:287
#, fuzzy
msgid ""
"Nevertheless, this function terminates, so simply marking it `partial` would"
" be unfortunate."
msgstr "尽管如此，此函数会终止，因此简单地将其标记为 `partial` 非常不幸。"

#: src/programs-proofs/arrays-termination.md:289
#, fuzzy
msgid ""
"Why does `arrayMapHelper` terminate? Each iteration checks whether the index"
" `i` is still in bounds for the array `arr`. If so, `i` is incremented and "
"the loop repeats. If not, the program terminates. Because `arr.size` is a "
"finite number, `i` can be incremented only a finite number of times. Even "
"though no argument to the function decreases on each call, `arr.size - i` "
"decreases toward zero."
msgstr ""
"为什么 `arrayMapHelper` 会终止？每次迭代都会检查索引 `i` 是否仍在数组 `arr` 的范围内。如果是，则 `i` "
"将增加并且循环将重复。如果不是，则程序将终止。因为 `arr.size` 是一个有限数，所以 `i` "
"只可以增加有限次。即使函数的每个参数在每次调用时都不会减少，`arr.size - i` 也会减小到零。"

#: src/programs-proofs/arrays-termination.md:296
#, fuzzy
msgid ""
"Lean can be instructed to use another expression for termination by "
"providing a `termination_by` clause at the end of a definition. The "
"`termination_by` clause has two components: names for the function's "
"arguments and an expression using those names that should decrease on each "
"call. For `arrayMapHelper`, the final definition looks like this:"
msgstr ""
"可以通过在定义的末尾提供 `termination_by` 子句来指示 Lean 使用另一个表达式进行终止。`termination_by` "
"子句有两个组成部分：函数参数的名称和使用这些名称的表达式，该表达式应在每次调用时减少。对于 `arrayMapHelper`，最终定义如下所示："

#: src/programs-proofs/arrays-termination.md:307
#, fuzzy
msgid ""
"A similar termination proof can be used to write `Array.find`, a function "
"that finds the first element in an array that satisfies a Boolean function "
"and returns both the element and its index:"
msgstr "类似的终止证明可用于编写 `Array.find`，这是一个在数组中查找满足布尔函数的第一个元素并返回该元素及其索引的函数："

#: src/programs-proofs/arrays-termination.md:312
#, fuzzy
msgid ""
"Once again, the helper function terminates because `arr.size - i` decreases "
"as `i` increases:"
msgstr "辅助函数再次终止，因为随着 `i` 的增加，`arr.size - i` 会减少："

#: src/programs-proofs/arrays-termination.md:324
#, fuzzy
msgid ""
"Not all termination arguments are as quite as simple as this one. However, "
"the basic structure of identifying some expression based on the function's "
"arguments that will decrease in each call occurs in all termination proofs. "
"Sometimes, creativity can be required in order to figure out just why a "
"function terminates, and sometimes Lean requires additional proofs in order "
"to accept the termination argument."
msgstr ""
"并非所有终止参数都像这个参数一样简单。但是，在所有终止证明中，都会出现基于函数参数识别在每次调用中都会减少的某个表达式的基本结构体。有时，为了弄清楚函数为何终止，可能需要创造力，有时"
" Lean 需要额外的证明才能接受终止参数。"

#: src/programs-proofs/arrays-termination.md:332
#, fuzzy
msgid ""
"Implement a `ForM (Array α)` instance on arrays using a tail-recursive "
"accumulator-passing function and a `termination_by` clause."
msgstr "使用尾递归累加器传递函数和 `termination_by` 子句在数组上实现 `ForM (Array α)` 实例。"

#: src/programs-proofs/arrays-termination.md:333
#, fuzzy
msgid ""
"Implement a function to reverse arrays using a tail-recursive accumulator-"
"passing function that _doesn't_ need a `termination_by` clause."
msgstr "使用 _不需要_ `termination_by` 子句的尾递归累加器传递函数实现一个用于反转数组的函数。"

#: src/programs-proofs/arrays-termination.md:334
#, fuzzy
msgid ""
"Reimplement `Array.map`, `Array.find`, and the `ForM` instance using `for "
"... in ...` loops in the identity monad and compare the resulting code."
msgstr ""
"使用恒等单子中的 `for ... in ...` 循环重新实现 `Array.map`、`Array.find` 和 `ForM` "
"实例，并比较结果代码。"

#: src/programs-proofs/arrays-termination.md:335
#, fuzzy
msgid ""
"Reimplement array reversal using a `for ... in ...` loop in the identity "
"monad. Compare it to the tail-recursive function."
msgstr "使用恒等单子中的 `for ... in ...` 循环重新实现数组反转。将其与尾递归函数进行比较。"

#: src/programs-proofs/inequalities.md:3
#, fuzzy
msgid ""
"Lean's built-in proof automation is sufficient to check that "
"`arrayMapHelper` and `findHelper` terminate. All that was needed was to "
"provide an expression whose value decreases with each recursive call. "
"However, Lean's built-in automation is not magic, and it often needs some "
"help."
msgstr ""
"Lean 的内置证明自动化足以检查 `arrayMapHelper` 和 `findHelper` "
"是否终止。所需要做的就是提供一个其值随着每次递归调用而减小的表达式。但是，Lean 的内置自动化不是万能的，它通常需要一些帮助。"

#: src/programs-proofs/inequalities.md:7
#, fuzzy
msgid "Merge Sort"
msgstr "归并排序"

#: src/programs-proofs/inequalities.md:9
#, fuzzy
msgid ""
"One example of a function whose termination proof is non-trivial is merge "
"sort on `List`. Merge sort consists of two phases: first, a list is split in"
" half. Each half is sorted using merge sort, and then the results are merged"
" using a function that combines two sorted lists into a larger sorted list. "
"The base cases are the empty list and the singleton list, both of which are "
"already considered to be sorted."
msgstr ""
"一个终止证明非平凡的函数示例是 `List` "
"上的归并排序。归并排序包含两个阶段：首先，将列表分成两半。使用归并排序对每一半进行排序，然后使用一个将两个已排序列表合并为一个更大的已排序列表的函数合并结果。基本情况是空列表和单元素列表，它们都被认为已经排序。"

#: src/programs-proofs/inequalities.md:14
#, fuzzy
msgid "To merge two sorted lists, there are two basic cases to consider:"
msgstr "要合并两个已排序列表，需要考虑两个基本情况："

#: src/programs-proofs/inequalities.md:15
#, fuzzy
msgid "If one of the input lists is empty, then the result is the other list."
msgstr "如果一个输入列表为空，则结果是另一个列表。"

#: src/programs-proofs/inequalities.md:16
#, fuzzy
msgid ""
"If both lists are non-empty, then their heads should be compared. The result"
" of the function is the smaller of the two heads, followed by the result of "
"merging the remaining entries of both lists."
msgstr "如果两个列表都不为空，则应比较它们的头部。该函数的结果是两个头部中较小的一个，后面是合并两个列表的剩余项的结果。"

#: src/programs-proofs/inequalities.md:18
#, fuzzy
msgid ""
"This is not structurally recursive on either list. The recursion terminates "
"because an entry is removed from one of the two lists in each recursive "
"call, but it could be either list. The `termination_by` clause uses the sum "
"of the length of both lists as a decreasing value:"
msgstr ""
"这在任何列表上都不是结构体递归。递归终止是因为在每次递归调用中都会从两个列表中的一个中删除一个项，但它可能是任何一个列表。`termination_by`"
" 子句使用两个列表长度的和作为递减值："

#: src/programs-proofs/inequalities.md:33
#, fuzzy
msgid ""
"In addition to using the lengths of the lists, a pair that contains both "
"lists can also be provided:"
msgstr "除了使用列表的长度，还可以提供包含两个列表的元组："

#: src/programs-proofs/inequalities.md:45
#, fuzzy
msgid ""
"This works because Lean has a built-in notion of sizes of data, expressed "
"through a type class called `WellFoundedRelation`. The instance for pairs "
"automatically considers them to be smaller if either the first or the second"
" item in the pair shrinks."
msgstr ""
"这有效是因为 Lean 有一个内置的数据大小概念，通过一个称为 `WellFoundedRelation` "
"的类型类来表示。元组的实例会自动认为它们更小，如果元组中的第一个或第二个项缩小。"

#: src/programs-proofs/inequalities.md:48
#, fuzzy
msgid ""
"A simple way to split a list is to add each entry in the input list to two "
"alternating output lists:"
msgstr "分割列表的一个简单方法是将输入列表中的每个项添加到两个交替的输出列表中："

#: src/programs-proofs/inequalities.md:58
#, fuzzy
msgid ""
"Merge sort checks whether a base case has been reached. If so, it returns "
"the input list. If not, it splits the input, and merges the result of "
"sorting each half:"
msgstr "归并排序检查是否已达到基本情况。如果是，则返回输入列表。如果不是，则分割输入，并合并对每一半排序的结果："

#: src/programs-proofs/inequalities.md:71
#, fuzzy
msgid ""
"Lean's pattern match compiler is able to tell that the assumption `h` "
"introduced by the `if` that tests whether `xs.length < 2` rules out lists "
"longer than one entry, so there is no \"missing cases\" error. However, even"
" though this program always terminates, it is not structurally recursive:"
msgstr ""
"Lean 的模式匹配编译器能够判断由测试 `xs.length < 2` 的 `if` 引入的前提 `h` "
"排除了长度超过一个条目的列表，因此没有「缺少情况」错误。然而，即使此程序总是终止，它也不是结构体递归的："

#: src/programs-proofs/inequalities.md:85
#, fuzzy
msgid ""
"The reason it terminates is that `splitList` always returns lists that are "
"shorter than its input. Thus, the length of `halves.fst` and `halves.snd` "
"are less than the length of `xs`. This can be expressed using a "
"`termination_by` clause:"
msgstr ""
"它终止的原因是 `splitList` 总是返回比其输入短的列表。因此，`halves.fst` 和 `halves.snd` 的长度小于 `xs` "
"的长度。这可以使用 `termination_by` 子句来表示："

#: src/programs-proofs/inequalities.md:99
#, fuzzy
msgid ""
"With this clause, the error message changes. Instead of complaining that the"
" function isn't structurally recursive, Lean instead points out that it was "
"unable to automatically prove that `(splitList xs).fst.length < xs.length`:"
msgstr ""
"有了这个子句，错误信息就变了。Lean 不会抱怨函数不是结构体递归的，而是指出它无法自动证明 `(splitList xs).fst.length < "
"xs.length`："

#: src/programs-proofs/inequalities.md:113
#, fuzzy
msgid "Splitting a List Makes it Shorter"
msgstr "分割列表使其变短"

#: src/programs-proofs/inequalities.md:115
#, fuzzy
msgid ""
"It will also be necessary to prove that `(splitList xs).snd.length < "
"xs.length`. Because `splitList` alternates between adding entries to the two"
" lists, it is easiest to prove both statements at once, so the structure of "
"the proof can follow the algorithm used to implement `splitList`. In other "
"words, it is easiest to prove that `∀(lst : List), (splitList "
"lst).fst.length < lst.length ∧ (splitList lst).snd.length < lst.length`."
msgstr ""
"还需要证明 `(splitList xs).snd.length < xs.length`。由于 `splitList` "
"在向两个列表添加条目之间交替进行，因此最简单的方法是同时证明这两个语句，这样证明的结构体就可以遵循用于实现 `splitList` "
"的算法。换句话说，最简单的方法是证明 `∀(lst : List), (splitList lst).fst.length < lst.length ∧"
" (splitList lst).snd.length < lst.length`。"

#: src/programs-proofs/inequalities.md:119
#, fuzzy
msgid ""
"Unfortunately, the statement is false. In particular, `splitList []` is "
"`([], [])`. Both output lists have length `0`, which is not less than `0`, "
"the length of the input list. Similarly, `splitList [\"basalt\"]` evaluates "
"to `([\"basalt\"], [])`, and `[\"basalt\"]` is not shorter than "
"`[\"basalt\"]`. However, `splitList [\"basalt\", \"granite\"]` evaluates to "
"`([\"basalt\"], [\"granite\"])`, and both of these output lists are shorter "
"than the input list."
msgstr ""
"不幸的是，这个说法是错误的。特别是，`splitList []` 是 `([], [])`。两个输出列表的长度都是 `0`，这并不小于输入列表的长度 "
"`0`。类似地，`splitList [\"basalt\"]` 计算为 `([\"basalt\"], [])`，而 `[\"basalt\"]` "
"并不比 `[\"basalt\"]` 短。然而，`splitList [\"basalt\", \"granite\"]` 计算为 "
"`([\"basalt\"], [\"granite\"])`，这两个输出列表都比输入列表短。"

#: src/programs-proofs/inequalities.md:124
#, fuzzy
msgid ""
"It turns out that the lengths of the output lists are always less than or "
"equal to the length of the input list, but they are only strictly shorter "
"when the input list contains at least two entries. It turns out to be "
"easiest to prove the former statement, then extend it to the latter "
"statement. Begin with a theorem statement:"
msgstr ""
"输出列表的长度始终小于或等于输入列表的长度，但仅当输入列表至少包含两个条目时，它们才严格较短。事实证明，最容易证明前一个陈述，然后将其扩展到后一个陈述。从定理陈述开始："

#: src/programs-proofs/inequalities.md:139
#, fuzzy
msgid ""
"Because `splitList` is structurally recursive on the list, the proof should "
"use induction. The structural recursion in `splitList` fits a proof by "
"induction perfectly: the base case of the induction matches the base case of"
" the recursion, and the inductive step matches the recursive call. The "
"`induction` tactic gives two goals:"
msgstr ""
"由于 `splitList` 在列表上是结构体递归的，因此证明应使用归纳法。`splitList` "
"中的结构体递归非常适合归纳证明：归纳法的基本情况与递归的基本情况匹配，归纳步骤与递归调用匹配。`induction` 战术给出了两个目标："

#: src/programs-proofs/inequalities.md:167
#, fuzzy
msgid ""
"The goal for the `nil` case can be proved by invoking the simplifier and "
"instructing it to unfold the definition of `splitList`, because the length "
"of the empty list is less than or equal to the length of the empty list. "
"Similarly, simplifying with `splitList` in the `cons` case places `Nat.succ`"
" around the lengths in the goal:"
msgstr ""
"可以通过调用简化器并指示它展开 `splitList` 的定义来证明 `nil` 情况的目标，因为空列表的长度小于或等于空列表的长度。类似地，在 "
"`cons` 情况下使用 `splitList` 简化会在目标中的长度周围放置 `Nat.succ`："

#: src/programs-proofs/inequalities.md:188
#, fuzzy
msgid ""
"This is because the call to `List.length` consumes the head of the list `x "
":: xs`, converting it to a `Nat.succ`, in both the length of the input list "
"and the length of the first output list."
msgstr ""
"这是因为对 `List.length` 的调用消耗了列表 `x :: xs` 的头部，将其转换为 "
"`Nat.succ`，既在输入列表的长度中，也在第一个输出列表的长度中。"

#: src/programs-proofs/inequalities.md:190
#, fuzzy
msgid ""
"Writing `A ∧ B` in Lean is short for `And A B`. `And` is a structure type in"
" the `Prop` universe:"
msgstr "在 Lean 中编写 `A ∧ B` 是 `And A B` 的缩写。`And` 是 `Prop` 宇宙中的一个结构体类型："

#: src/programs-proofs/inequalities.md:198
#, fuzzy
msgid ""
"In other words, a proof of `A ∧ B` consists of the `And.intro` constructor "
"applied to a proof of `A` in the `left` field and a proof of `B` in the "
"`right` field."
msgstr ""
"换句话说，`A ∧ B` 的证明包括应用于 `left` 域中 `A` 的证明和应用于 `right` 域中 `B` 的证明的 `And.intro` "
"构造子。"

#: src/programs-proofs/inequalities.md:200
#, fuzzy
msgid ""
"The `cases` tactic allows a proof to consider each constructor of a datatype"
" or each potential proof of a proposition in turn. It corresponds to a "
"`match` expression without recursion. Using `cases` on a structure results "
"in the structure being broken apart, with an assumption added for each field"
" of the structure, just as a pattern match expression extracts the field of "
"a structure for use in a program. Because structures have only one "
"constructor, using `cases` on a structure does not result in additional "
"goals."
msgstr ""
"`cases` 战术允许证明依次考虑数据类型的每个构造子或命题的每个潜在证明。它对应于没有递归的 `match` 表达式。对结构体使用 `cases` "
"会导致结构体被分解，并为结构体的每个字段添加一个假设，就像模式匹配表达式提取结构体的字段以用于程序中一样。由于结构体只有一个构造子，因此对结构体使用 "
"`cases` 不会产生额外的目标。"

#: src/programs-proofs/inequalities.md:205
#, fuzzy
msgid ""
"Because `ih` is a proof of `List.length (splitList xs).fst ≤ List.length xs "
"∧ List.length (splitList xs).snd ≤ List.length xs`, using `cases ih` results"
" in an assumption that `List.length (splitList xs).fst ≤ List.length xs` and"
" an assumption that `List.length (splitList xs).snd ≤ List.length xs`:"
msgstr ""
"由于 `ih` 是 `List.length (splitList xs).fst ≤ List.length xs ∧ List.length "
"(splitList xs).snd ≤ List.length xs` 的证明，使用 `cases ih` 会产生一个假设 `List.length "
"(splitList xs).fst ≤ List.length xs` 和一个假设 `List.length (splitList xs).snd ≤"
" List.length xs`："

#: src/programs-proofs/inequalities.md:228
#, fuzzy
msgid ""
"Because the goal of the proof is also an `And`, the `constructor` tactic can"
" be used to apply `And.intro`, resulting in a goal for each argument:"
msgstr ""
"由于证明的目标也是一个 `And`，因此可以使用 `constructor` 策略应用 `And.intro`，从而为每个参数生成一个目标："

#: src/programs-proofs/inequalities.md:259
#, fuzzy
msgid ""
"The `left` goal is very similar to the `left✝` assumption, except the goal "
"wraps both sides of the inequality in `Nat.succ`. Likewise, the `right` goal"
" resembles the `right✝` assumption, except the goal adds a `Nat.succ` only "
"to the length of the input list. It's time to prove that these wrappings of "
"`Nat.succ` preserve the truth of the statement."
msgstr ""
"`left` 目标与 `left✝` 假设非常相似，除了目标用 `Nat.succ` 包装不等式的两侧。同样，`right` 目标类似于 "
"`right✝` 假设，除了目标仅将 `Nat.succ` 添加到输入列表的长度。现在是时候证明 `Nat.succ` 的这些包装保留了语句的真值。"

#: src/programs-proofs/inequalities.md:263
#, fuzzy
msgid "Adding One to Both Sides"
msgstr "在两边都加一"

#: src/programs-proofs/inequalities.md:265
#, fuzzy
msgid ""
"For the `left` goal, the statement to prove is `Nat.succ_le_succ : n ≤ m → "
"Nat.succ n ≤ Nat.succ m`. In other words, if `n ≤ m`, then adding one to "
"both sides doesn't change this fact. Why is this true? The proof that `n ≤ "
"m` is a `Nat.le.refl` constructor with `m - n` instances of the "
"`Nat.le.step` constructor wrapped around it. Adding one to both sides simply"
" means that the `refl` applies to a number that's one larger than before, "
"with the same number of `step` constructors."
msgstr ""
"对于 `left` 目标，要证明的语句是 `Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ "
"m`。换句话说，如果 `n ≤ m`，那么在两边都加一并不会改变这一事实。为什么这是真的？证明 `n ≤ m` 是一个 `Nat.le.refl` "
"构造子，周围有 `m - n` 个 `Nat.le.step` 构造子的实例。在两边都加一只是意味着 `refl` "
"应用于比之前大一个数的数，并且具有相同数量的 `step` 构造子。"

#: src/programs-proofs/inequalities.md:271
#, fuzzy
msgid ""
"More formally, the proof is by induction on the evidence that `n ≤ m`. If "
"the evidence is `refl`, then `n = m`, so `Nat.succ n = Nat.succ m` and "
"`refl` can be used again. If the evidence is `step`, then the induction "
"hypothesis provides evidence that `Nat.succ n ≤ Nat.succ m`, and the goal is"
" to show that `Nat.succ n ≤ Nat.succ (Nat.succ m)`. This can be done by "
"using `step` together with the induction hypothesis."
msgstr ""
"更正式地说，证明是通过归纳法来证明 `n ≤ m` 的证据。如果证据是 `refl`，则 `n = m`，所以 `Nat.succ n = "
"Nat.succ m`，并且可以再次使用 `refl`。如果证据是 `step`，则归纳假设提供了 `Nat.succ n ≤ Nat.succ m` "
"的证据，并且目标是证明 `Nat.succ n ≤ Nat.succ (Nat.succ m)`。这可以通过将 `step` 与归纳假设一起使用来完成。"

#: src/programs-proofs/inequalities.md:276
#, fuzzy
msgid "In Lean, the theorem statement is:"
msgstr "在 Lean 中，定理陈述为："

#: src/programs-proofs/inequalities.md:281
#, fuzzy
msgid "and the error message recapitulates it:"
msgstr "错误信息对其进行了概括："

#: src/programs-proofs/inequalities.md:288
#, fuzzy
msgid ""
"The first step is to use the `intro` tactic, bringing the hypothesis that `n"
" ≤ m` into scope and giving it a name:"
msgstr "第一步是使用 `intro` 策略，将假设 `n ≤ m` 引入作用域并为其命名："

#: src/programs-proofs/inequalities.md:300
#, fuzzy
msgid ""
"Because the proof is by induction on the evidence that `n ≤ m`, the next "
"tactic is `induction h`:"
msgstr "由于证明是通过归纳法对证据 `n ≤ m` 进行的，因此下一个策略是 `induction h`："

#: src/programs-proofs/inequalities.md:306
#, fuzzy
msgid "This results in two goals, once for each constructor of `Nat.le`:"
msgstr "这会产生两个目标，每个目标对应于 `Nat.le` 的一个构造子："

#: src/programs-proofs/inequalities.md:319
#, fuzzy
msgid ""
"The goal for `refl` can itself be solved using `refl`, which the "
"`constructor` tactic selects. The goal for `step` will also require a use of"
" the `step` constructor:"
msgstr ""
"`refl` 的目标可以使用 `refl` 本身来解决，`constructor` 策略会选择它。`step` 的目标还需要使用 `step` 构造子："

#: src/programs-proofs/inequalities.md:336
#, fuzzy
msgid ""
"The goal is no longer shown using the `≤` operator, but it is equivalent to "
"the induction hypothesis `ih`. The `assumption` tactic automatically selects"
" an assumption that fulfills the goal, and the proof is complete:"
msgstr "该目标不再使用 `≤` 运算符显示，但它等价于归纳假设 `ih`。`assumption` 策略会自动选择一个满足目标的假设，证明完成："

#: src/programs-proofs/inequalities.md:348
#, fuzzy
msgid "Written as a recursive function, the proof is:"
msgstr "写成递归函数，证明如下："

#: src/programs-proofs/inequalities.md:354
#, fuzzy
msgid ""
"It can be instructional to compare the tactic-based proof by induction with "
"this recursive function. Which proof steps correspond to which parts of the "
"definition?"
msgstr "将基于策略的归纳证明与这个递归函数进行比较是有指导意义的。哪些证明步骤对应于定义的哪些部分？"

#: src/programs-proofs/inequalities.md:357
#, fuzzy
msgid "Adding One to the Greater Side"
msgstr "将 1 加到较大的一侧"

#: src/programs-proofs/inequalities.md:359
#, fuzzy
msgid ""
"The second inequality needed to prove `splitList_shorter_le` is `∀(n m : "
"Nat), n ≤ m → n ≤ Nat.succ m`. This proof is almost identical to "
"`Nat.succ_le_succ`. Once again, the incoming assumption that `n ≤ m` "
"essentially tracks the difference between `n` and `m` in the number of "
"`Nat.le.step` constructors. Thus, the proof should add an extra "
"`Nat.le.step` in the base case. The proof can be written:"
msgstr ""
"证明 `splitList_shorter_le` 所需的第二个不等式是 `∀(n m : Nat), n ≤ m → n ≤ Nat.succ "
"m`。这个证明几乎与 `Nat.succ_le_succ` 相同。同样，传入的假设 `n ≤ m` 基本上跟踪了 `n` 和 `m` 在 "
"`Nat.le.step` 构造子数量上的差异。因此，证明应该在基本情况下添加一个额外的 `Nat.le.step`。证明可以写成："

#: src/programs-proofs/inequalities.md:372
#, fuzzy
msgid ""
"To reveal what's going on behind the scenes, the `apply` and `exact` tactics"
" can be used to indicate exactly which constructor is being applied. The "
"`apply` tactic solves the current goal by applying a function or constructor"
" whose return type matches, creating new goals for each argument that was "
"not provided, while `exact` fails if any new goals would be needed:"
msgstr ""
"为了揭示幕后发生的事情，`apply` 和 `exact` 策略可用于准确指示正在应用哪个构造子。`apply` "
"策略通过应用一个返回类型匹配的函数或构造子来解决当前目标，为每个未提供的参数创建新的目标，而如果需要任何新目标，`exact` 就会失败："

#: src/programs-proofs/inequalities.md:382
#, fuzzy
msgid "The proof can be golfed:"
msgstr "证明可以简化："

#: src/programs-proofs/inequalities.md:387
#, fuzzy
msgid ""
"In this short tactic script, both goals introduced by `induction` are "
"addressed using `repeat (first | constructor | assumption)`. The tactic "
"`first | T1 | T2 | ... | Tn` means to use try `T1` through `Tn` in order, "
"using the first tactic that succeeds. In other words, `repeat (first | "
"constructor | assumption)` applies constructors as long as it can, and then "
"attempts to solve the goal using an assumption."
msgstr ""
"在这个简短的策略脚本中，由 `induction` 引入的两个目标都使用 `repeat (first | constructor | "
"assumption)` 来解决。策略 `first | T1 | T2 | ... | Tn` 表示按顺序尝试 `T1` 到 "
"`Tn`，使用第一个成功的策略。换句话说，`repeat (first | constructor | assumption)` "
"会尽可能地应用构造子，然后尝试使用假设来解决目标。"

#: src/programs-proofs/inequalities.md:391
#, fuzzy
msgid "Finally, the proof can be written as a recursive function:"
msgstr "最后，证明可以写成一个递归函数："

#: src/programs-proofs/inequalities.md:398
#, fuzzy
msgid ""
"Each style of proof can be appropriate to different circumstances. The "
"detailed proof script is useful in cases where beginners may be reading the "
"code, or where the steps of the proof provide some kind of insight. The "
"short, highly-automated proof script is typically easier to maintain, "
"because automation is frequently both flexible and robust in the face of "
"small changes to definitions and datatypes. The recursive function is "
"typically both harder to understand from the perspective of mathematical "
"proofs and harder to maintain, but it can be a useful bridge for programmers"
" who are beginning to work with interactive theorem proving."
msgstr ""
"每种证明风格都适用于不同的情况。详细的证明脚本在初学者阅读代码或证明步骤提供某种见解的情况下很有用。简短、高度自动化的证明脚本通常更容易维护，因为自动化通常在面对定义和数据类型的细微更改时既灵活又健壮。递归函数通常从数学证明的角度来看更难理解，也更难维护，但对于开始使用交互式定理证明的程序员来说，它可能是一个有用的桥梁。"

#: src/programs-proofs/inequalities.md:403
#, fuzzy
msgid "Finishing the Proof"
msgstr "完成证明"

#: src/programs-proofs/inequalities.md:405
#, fuzzy
msgid ""
"Now that both helper theorems have been proved, the rest of "
"`splitList_shorter_le` will be completed quickly. The current proof state "
"has two goals, for the left and right sides of the `And`:"
msgstr ""
"现在已经证明了两个辅助定理，`splitList_shorter_le` 的其余部分将很快完成。当前的证明状态有两个目标，用于 `And` "
"的左侧和右侧："

#: src/programs-proofs/inequalities.md:426
#, fuzzy
msgid ""
"The goals are named for the fields of the `And` structure. This means that "
"the `case` tactic (not to be confused with `cases`) can be used to focus on "
"each of them in turn:"
msgstr "目标以 `And` 结构体的字段命名。这意味着 `case` 策略（不要与 `cases` 混淆）可用于依次关注每个目标："

#: src/programs-proofs/inequalities.md:439
#, fuzzy
msgid ""
"Instead of a single error that lists both unsolved goals, there are now two "
"messages, one on each `skip`. For the `left` goal, `Nat.succ_le_succ` can be"
" used:"
msgstr ""
"现在不再是单一的错误列出所有未解决的目标，而是有两个消息，每个`skip`上一个。对于`left`目标，可以使用`Nat.succ_le_succ`："

#: src/programs-proofs/inequalities.md:450
#, fuzzy
msgid "In the right goal, `Nat.le_suc_of_le` fits:"
msgstr "在右侧目标中，`Nat.le_suc_of_le`适合："

#: src/programs-proofs/inequalities.md:460
#, fuzzy
msgid ""
"Both theorems include the precondition that `n ≤ m`. These can be found as "
"the `left✝` and `right✝` assumptions, which means that the `assumption` "
"tactic takes care of the final goals:"
msgstr ""
"这两个定理都包含前提条件`n ≤ m`。这些可以作为`left✝`和`right✝`假设找到，这意味着`assumption`策略处理最终目标："

#: src/programs-proofs/inequalities.md:475
#, fuzzy
msgid ""
"The next step is to return to the actual theorem that is needed to prove "
"that merge sort terminates: that so long as a list has at least two entries,"
" both results of splitting it are strictly shorter."
msgstr "下一步是返回到证明归并排序终止所需的实际定理：只要一个列表至少有两个条目，则分割它的两个结果都严格短于它。"

#: src/programs-proofs/inequalities.md:489
#, fuzzy
msgid ""
"Pattern matching works just as well in tactic scripts as it does in "
"programs. Because `lst` has at least two entries, they can be exposed with "
"`match`, which also refines the type through dependent pattern matching:"
msgstr ""
"模式匹配在策略脚本中与在程序中一样有效。因为`lst`至少有两个条目，所以它们可以用`match`暴露出来，它还通过依赖模式匹配来细化类型："

#: src/programs-proofs/inequalities.md:509
#, fuzzy
msgid ""
"Simplifying using `splitList` removes `x` and `y`, resulting in the computed"
" lengths of lists each gaining a `Nat.succ`:"
msgstr "使用`splitList`简化会删除`x`和`y`，导致列表的计算长度每个都获得`Nat.succ`："

#: src/programs-proofs/inequalities.md:528
#, fuzzy
msgid ""
"Replacing `simp` with `simp_arith` removes these `Nat.succ` constructors, "
"because `simp_arith` makes use of the fact that `n + 1 < m + 1` implies `n <"
" m`:"
msgstr ""
"用`simp_arith`替换`simp`会删除这些`Nat.succ`构造子，因为`simp_arith`利用了`n + 1 < m + "
"1`意味着`n < m`的事实："

#: src/programs-proofs/inequalities.md:546
#, fuzzy
msgid ""
"This goal now matches `splitList_shorter_le`, which can be used to conclude "
"the proof:"
msgstr "此目标现在匹配`splitList_shorter_le`，可用于结束证明："

#: src/programs-proofs/inequalities.md:557
#, fuzzy
msgid ""
"The facts needed to prove that `mergeSort` terminates can be pulled out of "
"the resulting `And`:"
msgstr "证明`mergeSort`终止所需的事实可以从结果`And`中提取出来："

#: src/programs-proofs/inequalities.md:568
#, fuzzy
msgid "Merge Sort Terminates"
msgstr "归并排序终止"

#: src/programs-proofs/inequalities.md:570
#, fuzzy
msgid ""
"Merge sort has two recursive calls, one for each sub-list returned by "
"`splitList`. Each recursive call will require a proof that the length of the"
" list being passed to it is shorter than the length of the input list. It's "
"usually convenient to write a termination proof in two steps: first, write "
"down the propositions that will allow Lean to verify termination, and then "
"prove them. Otherwise, it's possible to put a lot of effort into proving the"
" propositions, only to find out that they aren't quite what's needed to "
"establish that the recursive calls are on smaller inputs."
msgstr ""
"归并排序有两个递归调用，一个用于`splitList`返回的每个子列表。每个递归调用都需要证明传递给它的列表的长度短于输入列表的长度。通常方便分两步编写终止证明：首先，写下允许"
" Lean 验证终止的命题，然后证明它们。否则，可能会投入大量精力来证明命题，却发现它们并不是建立递归调用在较小输入上的所需内容。"

#: src/programs-proofs/inequalities.md:575
#, fuzzy
msgid ""
"The `sorry` tactic can prove any goal, even false ones. It isn't intended "
"for use in production code or final proofs, but it is a convenient way to "
"\"sketch out\" a proof or program ahead of time. Any definitions or theorems"
" that use `sorry` are annotated with a warning."
msgstr ""
"`sorry` 战术可以证明任何目标，即使是错误的目标。它不适用于生产代码或最终证明，但它是一种方便的方法，可以提前「勾勒出」证明或程序。任何使用 "
"`sorry` 的定义或定理都会附有警告。"

#: src/programs-proofs/inequalities.md:579
#, fuzzy
msgid ""
"The initial sketch of `mergeSort`'s termination argument that uses `sorry` "
"can be written by copying the goals that Lean couldn't prove into "
"`have`\\-expressions. In Lean, `have` is similar to `let`. When using "
"`have`, the name is optional. Typically, `let` is used to define names that "
"refer to interesting values, while `have` is used to locally prove "
"propositions that can be found when Lean is searching for evidence that an "
"array lookup is in-bounds or that a function terminates."
msgstr ""
"使用 `sorry` 的 `mergeSort` 终止论证的初始草图可以通过将 Lean 无法证明的目标复制到 `have` 表达式中来编写。在 "
"Lean 中，`have` 类似于 `let`。使用 `have` 时，名称是可选的。通常，`let` 用于定义引用有趣值的名称，而 `have` "
"用于局部证明命题，当 Lean 寻找数组查找是否在范围内或函数是否终止的证据时，可以找到这些命题。"

#: src/programs-proofs/inequalities.md:598
#, fuzzy
msgid "The warning is located on the name `mergeSort`:"
msgstr "警告位于名称 `mergeSort` 上："

#: src/programs-proofs/inequalities.md:602
#, fuzzy
msgid ""
"Because there are no errors, the proposed propositions are enough to "
"establish termination."
msgstr "因为没有错误，所以建议的命题足以建立终止。"

#: src/programs-proofs/inequalities.md:604
#, fuzzy
msgid "The proofs begin by applying the helper theorems:"
msgstr "证明从应用辅助定理开始："

#: src/programs-proofs/inequalities.md:620
#, fuzzy
msgid ""
"Both proofs fail, because `splitList_shorter_fst` and "
"`splitList_shorter_snd` both require a proof that `xs.length ≥ 2`:"
msgstr ""
"两个证明都失败了，因为 `splitList_shorter_fst` 和 `splitList_shorter_snd` 都需要证明 "
"`xs.length ≥ 2`："

#: src/programs-proofs/inequalities.md:631
#, fuzzy
msgid ""
"To check that this will be enough to complete the proof, add it using "
"`sorry` and check for errors:"
msgstr "要检查这是否足以完成证明，请使用 `sorry` 添加它并检查错误："

#: src/programs-proofs/inequalities.md:650
#, fuzzy
msgid "Once again, there is only a warning."
msgstr "同样，只会有一个警告。"

#: src/programs-proofs/inequalities.md:655
#, fuzzy
msgid ""
"There is one promising assumption available: `h : ¬List.length xs < 2`, "
"which comes from the `if`. Clearly, if it is not the case that `xs.length < "
"2`, then `xs.length ≥ 2`. The Lean library provides this theorem under the "
"name `Nat.ge_of_not_lt`. The program is now complete:"
msgstr ""
"有一个有希望的假设可用：`h : ¬List.length xs < 2`，它来自 `if`。显然，如果不是 `xs.length < 2`，那么 "
"`xs.length ≥ 2`。Lean 库以 `Nat.ge_of_not_lt` 的名称提供了此定理。程序现在已完成："

#: src/programs-proofs/inequalities.md:680
#, fuzzy
msgid "The function can be tested on examples:"
msgstr "该函数可以在示例上进行测试："

#: src/programs-proofs/inequalities.md:681
msgid ""
"```lean\n"
"#eval mergeSort [\"soapstone\", \"geode\", \"mica\", \"limestone\"]\n"
"```"
msgstr ""

#: src/programs-proofs/inequalities.md:684
msgid ""
"```output info\n"
"[\"geode\", \"limestone\", \"mica\", \"soapstone\"]\n"
"```"
msgstr ""

#: src/programs-proofs/inequalities.md:694
#, fuzzy
msgid "Division as Iterated Subtraction"
msgstr "除法作为迭代减法"

#: src/programs-proofs/inequalities.md:696
#, fuzzy
msgid ""
"Just as multiplication is iterated addition and exponentiation is iterated "
"multiplication, division can be understood as iterated subtraction. The "
"[very first description of recursive functions in this book](../getting-to-"
"know/datatypes-and-patterns.md#recursive-functions) presents a version of "
"division that terminates when the divisor is not zero, but that Lean does "
"not accept. Proving that division terminates requires the use of a fact "
"about inequalities."
msgstr ""
"正如乘法是迭代加法，指数是迭代乘法，除法可以理解为迭代减法。[本书中对递归函数的第一个描述](../getting-to-know/datatypes-"
"and-patterns.md#recursive-functions)给出了一个除法版本，当除数不为零时终止，但 Lean "
"并不接受。证明除法终止需要使用关于不等式的事实。"

#: src/programs-proofs/inequalities.md:700
#, fuzzy
msgid ""
"The first step is to refine the definition of division so that it requires "
"evidence that the divisor is not zero:"
msgstr "第一步是细化除法的定义，使其需要证据证明除数不为零："

#: src/programs-proofs/inequalities.md:708
#, fuzzy
msgid ""
"The error message is somewhat longer, due to the additional argument, but it"
" contains essentially the same information:"
msgstr "由于增加了参数，错误信息会稍长一些，但它包含基本相同的信息："

#: src/programs-proofs/inequalities.md:736
#, fuzzy
msgid ""
"This definition of `div` terminates because the first argument `n` is "
"smaller on each recursive call. This can be expressed using a "
"`termination_by` clause:"
msgstr "`div` 的这个定义终止，因为第一个参数 `n` 在每次递归调用时都更小。这可以使用 `termination_by` 子句来表示："

#: src/programs-proofs/inequalities.md:746
#, fuzzy
msgid "Now, the error is confined to the recursive call:"
msgstr "现在，错误仅限于递归调用："

#: src/programs-proofs/inequalities.md:758
#, fuzzy
msgid ""
"This can be proved using a theorem from the standard library, `Nat.sub_lt`. "
"This theorem states that `∀ {n k : Nat}, 0 < n → 0 < k → n - k < n` (the "
"curly braces indicate that `n` and `k` are implicit arguments). Using this "
"theorem requires demonstrating that both `n` and `k` are greater than zero. "
"Because `k > 0` is syntactic sugar for `0 < k`, the only necessary goal is "
"to show that `0 < n`. There are two possibilities: either `n` is `0`, or it "
"is `n' + 1` for some other `Nat` `n'`. But `n` cannot be `0`. The fact that "
"the `if` selected the second branch means that `¬ n < k`, but if `n = 0` and"
" `k > 0` then `n` must be less than `k`, which would be a contradiction. "
"This, `n = Nat.succ n'`, and `Nat.succ n'` is clearly greater than `0`."
msgstr ""
"这可以使用标准库中的定理 `Nat.sub_lt` 来证明。该定理指出 `∀ {n k : Nat}, 0 < n → 0 < k → n - k < "
"n`（花括号表示 `n` 和 `k` 是隐式参数）。使用此定理需要证明 `n` 和 `k` 都大于零。因为 `k > 0` 是 `0 < k` "
"的语法糖，所以唯一必要的目标是证明 `0 < n`。有两种可能性：`n` 为 `0`，或它为某个其他 `Nat` `n'` 的 `n' + 1`。但 "
"`n` 不能为 `0`。`if` 选择第二个分支的事实意味着 `¬ n < k`，但如果 `n = 0` 且 `k > 0`，则 `n` 必须小于 "
"`k`，这将是一个矛盾。这，`n = Nat.succ n'`，并且 `Nat.succ n'` 明显大于 `0`。"

#: src/programs-proofs/inequalities.md:767
#, fuzzy
msgid "The full definition of `div`, including the termination proof, is:"
msgstr "`div` 的完整定义，包括终止证明："

#: src/programs-proofs/inequalities.md:786
#, fuzzy
msgid "Prove the following theorems:"
msgstr "证明以下定理："

#: src/programs-proofs/inequalities.md:788
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\), \\\\( 0 \\< n + 1 \\\\)."
msgstr "对于所有自然数 \\\\( n \\\\)，\\\\( 0 \\< n + 1 \\\\)。"

#: src/programs-proofs/inequalities.md:789
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\), \\\\( 0 \\\\leq n \\\\)."
msgstr "对于所有自然数 \\\\( n \\\\)，\\\\( 0 \\\\leq n \\\\)。"

#: src/programs-proofs/inequalities.md:790
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), \\\\( (n + 1) - (k + 1) = n - k \\\\)"
msgstr "对于所有自然数 \\\\( n \\\\) 和 \\\\( k \\\\)，\\\\( (n + 1) - (k + 1) = n - k \\\\)"

#: src/programs-proofs/inequalities.md:791
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), if \\\\( k \\< n \\\\) then \\\\( n \\neq 0 \\\\)"
msgstr "对于所有自然数 \\\\( n \\\\) 和 \\\\( k \\\\)，如果 \\\\( k \\< n \\\\)，则 \\\\( n \\neq 0 \\\\)"

#: src/programs-proofs/inequalities.md:792
#, fuzzy
msgid "For all natural numbers \\\\( n \\\\), \\\\( n - n = 0 \\\\)"
msgstr "对于所有自然数 \\\\( n \\\\)，\\\\( n - n = 0 \\\\)"

#: src/programs-proofs/inequalities.md:793
#, fuzzy
msgid ""
"For all natural numbers \\\\( n \\\\) and \\\\( k \\\\), if \\\\( n + 1 \\< "
"k \\\\) then \\\\( n \\< k \\\\)"
msgstr "对于所有自然数 \\\\( n \\\\) 和 \\\\( k \\\\)，如果 \\\\( n + 1 \\< k \\\\)，则 \\\\( n \\< k \\\\)"

#: src/programs-proofs/fin.md:3
#, fuzzy
msgid ""
"The `GetElem` instance for `Array` and `Nat` requires a proof that the "
"provided `Nat` is smaller than the array. In practice, these proofs often "
"end up being passed to functions along with the indices. Rather than passing"
" an index and a proof separately, a type called `Fin` can be used to bundle "
"up the index and the proof into a single value. This can make code easier to"
" read. Additionally, many of the built-in operations on arrays take their "
"index arguments as `Fin` rather than as `Nat`, so using these built-in "
"operations requires understanding how to use `Fin`."
msgstr ""
"`Array` 和 `Nat` 的 `GetElem` 实例需要证明提供的 `Nat` "
"小于数组。在实践中，这些证明通常最终会连同索引一起传递给函数。与其分别传递索引和证明，可以使用名为 `Fin` "
"的类型将索引和证明捆绑到单个值中。这可以使代码更易于阅读。此外，许多对数组的内置操作将其索引参数作为 `Fin` 而不是 "
"`Nat`，因此使用这些内置操作需要了解如何使用 `Fin`。"

#: src/programs-proofs/fin.md:9
#, fuzzy
msgid ""
"The type `Fin n` represents numbers that are strictly less than `n`. In "
"other words, `Fin 3` describes `0`, `1`, and `2`, while `Fin 0` has no "
"values at all. The definition of `Fin` resembles `Subtype`, as a `Fin n` is "
"a structure that contains a `Nat` and a proof that it is less than `n`:"
msgstr ""
"类型 `Fin n` 表示严格小于 `n` 的数字。换句话说，`Fin 3` 描述 `0`、`1` 和 `2`，而 `Fin 0` "
"没有任何值。`Fin` 的定义类似于 `Subtype`，因为 `Fin n` 是一个包含 `Nat` 和小于 `n` 的证明的结构体："

#: src/programs-proofs/fin.md:18
#, fuzzy
msgid ""
"Lean includes instances of `ToString` and `OfNat` that allow `Fin` values to"
" be conveniently used as numbers. In other words, the output of `#eval (5 : "
"Fin 8)` is `5`, rather than something like `{val := 5, isLt := _}`."
msgstr ""
"Lean 包含 `ToString` 和 `OfNat` 的实例，允许将 `Fin` 值方便地用作数字。换句话说，`#eval (5 : Fin 8)`"
" 的输出是 `5`，而不是类似 `{val := 5, isLt := _}` 的东西。"

#: src/programs-proofs/fin.md:21
#, fuzzy
msgid ""
"Instead of failing when the provided number is larger than the bound, the "
"`OfNat` instance for `Fin` returns a value modulo the bound. This means that"
" `#eval (45 : Fin 10)` results in `5` rather than a compile-time error."
msgstr ""
"`OfNat` 实例对于 `Fin`，当提供的数字大于边界时，不会失败，而是返回一个模边界的值。这意味着 `#eval (45 : Fin 10)` "
"的结果是 `5`，而不是编译时错误。"

#: src/programs-proofs/fin.md:24
#, fuzzy
msgid ""
"In a return type, a `Fin` returned as a found index makes its connection to "
"the data structure in which it was found more clear. The `Array.find` in the"
" [previous section](./arrays-termination.md#proving-termination) returns an "
"index that the caller cannot immediately use to perform lookups into the "
"array, because the information about its validity has been lost. A more "
"specific type results in a value that can be used without making the program"
" significantly more complicated:"
msgstr ""
"在返回类型中，作为找到的索引返回的 `Fin` 使其与找到它的数据结构体的连接更加清晰。[上一节](./arrays-"
"termination.md#proving-termination)中的 `Array.find` "
"返回一个索引，调用者不能立即使用它来执行数组查找，因为有关其有效性的信息已丢失。更具体类型的值可以使用，而不会使程序变得复杂得多："

#: src/programs-proofs/fin.md:43
#, fuzzy
msgid ""
"Write a function `Fin.next? : Fin n → Option (Fin n)` that returns the next "
"largest `Fin` when it would be in bounds, or `none` if not. Check that"
msgstr ""
"编写一个函数 `Fin.next? : Fin n → Option (Fin n)`，当它在边界内时返回下一个最大的 `Fin`，否则返回 "
"`none`。检查"

#: src/programs-proofs/fin.md:52
#, fuzzy
msgid "and that"
msgstr "和"

#: src/programs-proofs/insertion-sort.md:3
#, fuzzy
msgid ""
"While insertion sort does not have the optimal worst-case time complexity "
"for a sorting algorithm, it still has a number of useful properties:"
msgstr "虽然插入排序没有排序算法最优的糟糕情况时间复杂度，但它仍然有一些有用的属性："

#: src/programs-proofs/insertion-sort.md:4
#, fuzzy
msgid "It is simple and straightforward to implement and understand"
msgstr "它简单明了，易于实现和理解"

#: src/programs-proofs/insertion-sort.md:5
#, fuzzy
msgid "It is an in-place algorithm, requiring no additional space to run"
msgstr "它是一种就地算法，不需要额外的空间来运行"

#: src/programs-proofs/insertion-sort.md:6
#, fuzzy
msgid "It is a stable sort"
msgstr "它是一种稳定的排序"

#: src/programs-proofs/insertion-sort.md:7
#, fuzzy
msgid "It is fast when the input is already almost sorted"
msgstr "当输入几乎已经排序时，它很快"

#: src/programs-proofs/insertion-sort.md:9
#, fuzzy
msgid ""
"In-place algorithms are particularly useful in Lean due to the way it "
"manages memory. In some cases, operations that would normally copy an array "
"can be optimized into mutation. This includes swapping elements in an array."
msgstr "就地算法在 Lean 中特别有用，因为它管理内存的方式。在某些情况下，通常会复制数组的操作可以优化为变异。这包括交换数组中的元素。"

#: src/programs-proofs/insertion-sort.md:13
#, fuzzy
msgid ""
"Most languages and run-time systems with automatic memory management, "
"including JavaScript, the JVM, and .NET, use tracing garbage collection. "
"When memory needs to be reclaimed, the system starts at a number of _roots_ "
"(such as the call stack and global values) and then determines which values "
"can be reached by recursively chasing pointers. Any values that can't be "
"reached are deallocated, freeing memory."
msgstr ""
"大多数语言和具有自动内存管理的运行时系统，包括 JavaScript、JVM 和 .NET，都使用跟踪垃圾回收。当需要回收内存时，系统从许多 "
"_根_（例如调用堆栈和全局值）开始，然后通过递归地追逐指针来确定可以到达哪些值。任何无法到达的值都会被释放，从而释放内存。"

#: src/programs-proofs/insertion-sort.md:17
#, fuzzy
msgid ""
"Reference counting is an alternative to tracing garbage collection that is "
"used by a number of languages, including Python, Swift, and Lean. In a "
"system with reference counting, each object in memory has a field that "
"tracks how many references there are to it. When a new reference is "
"established, the counter is incremented. When a reference ceases to exist, "
"the counter is decremented. When the counter reaches zero, the object is "
"immediately deallocated."
msgstr ""
"引用计数是追踪垃圾回收的替代方法，它被许多语言使用，包括 Python、Swift 和 "
"Lean。在引用计数系统中，内存中的每个对象都有一个字段来跟踪对它的引用数。当建立一个新引用时，计数器会增加。当一个引用不再存在时，计数器会减少。当计数器达到零时，对象会立即被释放。"

#: src/programs-proofs/insertion-sort.md:23
#, fuzzy
msgid ""
"Reference counting has one major disadvantage compared to a tracing garbage "
"collector: circular references can lead to memory leaks. If object \\\\( A "
"\\\\) references object \\\\( B \\\\) , and object \\\\( B \\\\) references "
"object \\\\( A \\\\), they will never be deallocated, even if nothing else "
"in the program references either \\\\( A \\\\) or \\\\( B \\\\). Circular "
"references result either from uncontrolled recursion or from mutable "
"references. Because Lean supports neither, it is impossible to construct "
"circular references."
msgstr ""
"与追踪垃圾回收器相比，引用计数有一个主要的缺点：循环引用会导致内存泄漏。如果对象 \\\\( A \\\\) 引用对象 \\\\( B "
"\\\\)，而对象 \\\\( B \\\\) 引用对象 \\\\( A \\\\)，它们将永远不会被释放，即使程序中没有其他内容引用 \\\\( A "
"\\\\) 或 \\\\( B \\\\)。循环引用要么是由不受控制的递归引起的，要么是由可变引用引起的。由于 Lean "
"不支持这两者，因此不可能构造循环引用。"

#: src/programs-proofs/insertion-sort.md:28
#, fuzzy
msgid ""
"Reference counting means that the Lean runtime system's primitives for "
"allocating and deallocating data structures can check whether a reference "
"count is about to fall to zero, and re-use an existing object instead of "
"allocating a new one. This is particularly important when working with large"
" arrays."
msgstr ""
"引用计数意味着 Lean "
"运行时系统用于分配和释放数据结构体的原语可以检查引用计数是否即将降至零，并重新使用现有对象而不是分配一个新对象。当使用大型数组时，这一点尤其重要。"

#: src/programs-proofs/insertion-sort.md:32
#, fuzzy
msgid ""
"An implementation of insertion sort for Lean arrays should satisfy the "
"following criteria:"
msgstr "针对 Lean 数组的插入排序实现应满足以下条件："

#: src/programs-proofs/insertion-sort.md:33
#, fuzzy
msgid "Lean should accept the function without a `partial` annotation"
msgstr "Lean 应接受没有 `partial` 注释的函数"

#: src/programs-proofs/insertion-sort.md:34
#, fuzzy
msgid ""
"If passed an array to which there are no other references, it should modify "
"the array in-place rather than allocating a new one"
msgstr "如果传递了一个没有其他引用的数组，它应就地修改数组，而不是分配一个新数组"

#: src/programs-proofs/insertion-sort.md:36
#, fuzzy
msgid ""
"The first criterion is easy to check: if Lean accepts the definition, then "
"it is satisfied. The second, however, requires a means of testing it. Lean "
"provides a built-in function called `dbgTraceIfShared` with the following "
"signature:"
msgstr ""
"第一个条件很容易检查：如果 Lean 接受该定义，则满足该条件。然而，第二个条件需要一种测试方法。Lean 提供了一个名为 "
"`dbgTraceIfShared` 的内置函数，其签名如下："

#: src/programs-proofs/insertion-sort.md:45
#, fuzzy
msgid ""
"It takes a string and a value as arguments, and prints a message that uses "
"the string to standard error if the value has more than one reference, "
"returning the value. This is not, strictly speaking, a pure function. "
"However, it is intended to be used only during development to check that a "
"function is in fact able to re-use memory rather than allocating and "
"copying."
msgstr ""
"它以一个字符串和一个值作为参数，如果该值有多个引用，则使用该字符串打印一条消息到标准错误，并返回该值。严格来说，这不是一个纯函数。但是，它仅在开发期间用于检查函数实际上能够重用内存而不是分配和复制。"

#: src/programs-proofs/insertion-sort.md:49
#, fuzzy
msgid ""
"When learning to use `dbgTraceIfShared`, it's important to know that `#eval`"
" will report that many more values are shared than in compiled code. This "
"can be confusing. It's important to build an executable with `lake` rather "
"than experimenting in an editor."
msgstr ""
"在学习使用 `dbgTraceIfShared` 时，重要的是要知道 `#eval` 会报告比已编译代码中共享的更多值。这可能会令人困惑。重要的是使用 "
"`lake` 构建可执行文件，而不是在编辑器中进行实验。"

#: src/programs-proofs/insertion-sort.md:53
#, fuzzy
msgid ""
"Insertion sort consists of two loops. The outer loop moves a pointer from "
"left to right across the array to be sorted. After each iteration, the "
"region of the array to the left of the pointer is sorted, while the region "
"to the right may not yet be sorted. The inner loop takes the element pointed"
" to by the pointer and moves it to the left until the appropriate location "
"has been found and the loop invariant has been restored. In other words, "
"each iteration inserts the next element of the array into the appropriate "
"location in the sorted region."
msgstr ""
"插入排序由两个循环组成。外循环将指针从左向右移动到要排序的数组中。每次迭代后，指针左边的数组区域都会被排序，而右边的区域可能尚未被排序。内循环获取指针指向的元素，并将其向左移动，直到找到合适的位置并恢复循环不变式。换句话说，每次迭代都会将数组的下一个元素插入到已排序区域的合适位置。"

#: src/programs-proofs/insertion-sort.md:59
#, fuzzy
msgid "The Inner Loop"
msgstr "内循环"

#: src/programs-proofs/insertion-sort.md:61
#, fuzzy
msgid ""
"The inner loop of insertion sort can be implemented as a tail-recursive "
"function that takes the array and the index of the element being inserted as"
" arguments. The element being inserted is repeatedly swapped with the "
"element to its left until either the element to the left is smaller or the "
"beginning of the array is reached. The inner loop is structurally recursive "
"on the `Nat` that is inside the `Fin` used to index into the array:"
msgstr ""
"插入排序的内循环可以实现为一个尾递归函数，该函数将数组和要插入的元素的索引作为参数。要插入的元素会与它左边的元素反复交换，直到左边的元素更小或到达数组的开头。内循环在用于对数组进行索引的"
" `Fin` 中的 `Nat` 上进行结构体递归："

#: src/programs-proofs/insertion-sort.md:76
#, fuzzy
msgid ""
"If the index `i` is `0`, then the element being inserted into the sorted "
"region has reached the beginning of the region and is the smallest. If the "
"index is `i' + 1`, then the element at `i'` should be compared to the "
"element at `i`. Note that while `i` is a `Fin arr.size`, `i'` is just a "
"`Nat` because it results from the `val` field of `i`. It is thus necessary "
"to prove that `i' < arr.size` before `i'` can be used to index into `arr`."
msgstr ""
"如果索引 `i` 为 `0`，则插入到已排序区域的元素已到达该区域的开头，并且是最小的。如果索引为 `i' + 1`，则应将 `i'` 处的元素与 "
"`i` 处的元素进行比较。请注意，虽然 `i` 是 `Fin arr.size`，但 `i'` 只是一个 `Nat`，因为它是由 `i` 的 `val`"
" 字段产生的。因此，在使用 `i'` 对 `arr` 进行索引之前，有必要证明 `i' < arr.size`。"

#: src/programs-proofs/insertion-sort.md:81
#, fuzzy
msgid ""
"Omitting the `have`\\-expression with the proof that `i' < arr.size` reveals"
" the following goal:"
msgstr "省略带有证明 `i' < arr.size` 的 `have` 表达式，将显示以下目标："

#: src/programs-proofs/insertion-sort.md:93
#, fuzzy
msgid ""
"The hint `Nat.lt_of_succ_lt` is a theorem from Lean's standard library. Its "
"signature, found by `#check Nat.lt_of_succ_lt`, is"
msgstr ""
"提示 `Nat.lt_of_succ_lt` 是 Lean 标准库中的一个定理。它的签名，通过 `#check Nat.lt_of_succ_lt` "
"找到，是"

#: src/programs-proofs/insertion-sort.md:98
#, fuzzy
msgid ""
"In other words, it states that if `n + 1 < m`, then `n < m`. The `*` passed "
"to `simp` causes it to combine `Nat.lt_of_succ_lt` with the `isLt` field "
"from `i` to get the final proof."
msgstr ""
"换句话说，它指出如果 `n + 1 < m`，则 `n < m`。传递给 `simp` 的 `*` 导致它将 `Nat.lt_of_succ_lt` 与"
" `i` 中的 `isLt` 字段结合起来以获得最终证明。"

#: src/programs-proofs/insertion-sort.md:101
#, fuzzy
msgid ""
"Having established that `i'` can be used to look up the element to the left "
"of the element being inserted, the two elements are looked up and compared."
"  If the element to the left is less than or equal to the element being "
"inserted, then the loop is finished and the invariant has been restored. If "
"the element to the left is greater than the element being inserted, then the"
" elements are swapped and the inner loop begins again. `Array.swap` takes "
"both of its indices as `Fin`s, and the `by assumption` that establishes that"
" `i' < arr.size` makes use of the `have`. The index to be examined on the "
"next round through the inner loop is also `i'`, but `by assumption` is not "
"sufficient in this case. This is because the proof was written for the "
"original array `arr`, not the result of swapping two elements. The `simp` "
"tactic's database contains the fact that swapping two elements of an array "
"doesn't change its size, and the `[*]` argument instructs it to additionally"
" use the assumption introduced by `have`."
msgstr ""
"在确定 `i'` "
"可用于查找要插入元素左侧的元素后，查找并比较这两个元素。如果左侧元素小于或等于要插入的元素，则循环结束并且不变量已恢复。如果左侧元素大于要插入的元素，则交换元素并重新开始内部循环。`Array.swap`"
" 将其两个索引都作为 `Fin`，并且建立 `i' < arr.size` 的 `by assumption` 利用了 "
"`have`。在内部循环的下一轮中要检查的索引也是 `i'`，但在这种情况下 `by assumption` 并不足够。这是因为该证明是针对原始数组 "
"`arr` 编写的，而不是交换两个元素的结果。`simp` 战术的数据库包含这样一个事实：交换数组的两个元素不会改变其大小，并且 `[*]` "
"参数指示它另外使用 `have` 引入的假设。"

#: src/programs-proofs/insertion-sort.md:109
#, fuzzy
msgid "The Outer Loop"
msgstr "外层循环"

#: src/programs-proofs/insertion-sort.md:111
#, fuzzy
msgid ""
"The outer loop of insertion sort moves the pointer from left to right, "
"invoking `insertSorted` at each iteration to insert the element at the "
"pointer into the correct position in the array. The basic form of the loop "
"resembles the implementation of `Array.map`:"
msgstr ""
"插入排序的外层循环将指针从左向右移动，在每次迭代中调用 `insertSorted` 将指针处的元素插入到数组中的正确位置。循环的基本形式类似于 "
"`Array.map` 的实现："

#: src/programs-proofs/insertion-sort.md:120
#, fuzzy
msgid ""
"The resulting error is also the same as the error that occurs without a "
"`termination_by` clause on `Array.map`, because there is no argument that "
"decreases at every recursive call:"
msgstr ""
"产生的错误也与在 `Array.map` 上没有 `termination_by` 子句时发生的错误相同，因为没有参数在每次递归调用时都会减少："

#: src/programs-proofs/insertion-sort.md:134
#, fuzzy
msgid ""
"Before constructing the termination proof, it can be convenient to test the "
"definition with a `partial` modifier to make sure that it returns the "
"expected answers:"
msgstr "在构建终止证明之前，可以使用 `partial` 修饰符测试定义以确保它返回预期的答案："

#: src/programs-proofs/insertion-sort.md:148
msgid ""
"```lean\n"
"#eval insertionSortLoop #[\"metamorphic\", \"igneous\", \"sedentary\"] 0\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:151
msgid ""
"```output info\n"
"#[\"igneous\", \"metamorphic\", \"sedentary\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:155
#, fuzzy
msgid "Termination"
msgstr "终止"

#: src/programs-proofs/insertion-sort.md:157
#, fuzzy
msgid ""
"Once again, the function terminates because the difference between the index"
" and the size of the array being processed decreases on each recursive call."
" This time, however, Lean does not accept the `termination_by`:"
msgstr ""
"同样，该函数终止是因为正在处理的数组的索引和大小之间的差异在每次递归调用时都会减小。然而，这一次，Lean 不接受 `termination_by`："

#: src/programs-proofs/insertion-sort.md:179
#, fuzzy
msgid ""
"The problem is that Lean has no way to know that `insertSorted` returns an "
"array that's the same size as the one it is passed. In order to prove that "
"`insertionSortLoop` terminates, it is necessary to first prove that "
"`insertSorted` doesn't change the size of the array. Copying the unproved "
"termination condition from the error message to the function and \"proving\""
" it with `sorry` allows the function to be temporarily accepted:"
msgstr ""
"问题在于 Lean 无法知道 `insertSorted` 返回的数组与传递给它的数组大小相同。为了证明 `insertionSortLoop` "
"终止，有必要首先证明 `insertSorted` 不会改变数组的大小。将未经证实的终止条件从错误消息复制到函数中，并使用 `sorry` "
"「证明」它，可以暂时接受该函数："

#: src/programs-proofs/insertion-sort.md:196
#, fuzzy
msgid ""
"Because `insertSorted` is structurally recursive on the index of the element"
" being inserted, the proof should be by induction on the index. In the base "
"case, the array is returned unchanged, so its length certainly does not "
"change. For the inductive step, the induction hypothesis is that a recursive"
" call on the next smaller index will not change the length of the array. "
"There are two cases two consider: either the element has been fully inserted"
" into the sorted region and the array is returned unchanged, in which case "
"the length is also unchanged, or the element is swapped with the next one "
"before the recursive call. However, swapping two elements in an array "
"doesn't change the size of it, and the induction hypothesis states that the "
"recursive call with the next index returns an array that's the same size as "
"its argument. Thus, the size remains unchanged."
msgstr ""
"因为 `insertSorted` "
"在要插入的元素的索引上是结构体递归的，所以证明应该是通过索引归纳进行的。在基本情况下，数组返回不变，因此其长度肯定不会改变。对于归纳步骤，归纳假设是下一个小索引上的递归调用不会改变数组的长度。有两种情况需要考虑：要么元素已完全插入到已排序区域中，并且数组返回不变，在这种情况下长度也不会改变，要么元素在递归调用之前与下一个元素交换。然而，在数组中交换两个元素不会改变它的大小，并且归纳假设指出具有下一个索引的递归调用返回的数组与其参数大小相同。因此，大小保持不变。"

#: src/programs-proofs/insertion-sort.md:203
#, fuzzy
msgid ""
"Translating this English-language theorem statement to Lean and proceeding "
"using the techniques from this chapter is enough to prove the base case and "
"make progress in the inductive step:"
msgstr "翻译此英语定理陈述为 Lean，并使用本章中的技术进行操作，足以证明基本情况并在归纳步骤中取得进展："

#: src/programs-proofs/insertion-sort.md:214
#, fuzzy
msgid ""
"The simplification using `insertSorted` in the inductive step revealed the "
"pattern match in `insertSorted`:"
msgstr "归纳步骤中使用 `insertSorted` 的简化揭示了 `insertSorted` 中的模式匹配："

#: src/programs-proofs/insertion-sort.md:241
#, fuzzy
msgid ""
"When faced with a goal that includes `if` or `match`, the `split` tactic "
"(not to be confused with the `split` function used in the definition of "
"merge sort) replaces the goal with one new goal for each path of control "
"flow:"
msgstr ""
"当面对包含 `if` 或 `match` 的目标时，`split` 策略（不要与归并排序定义中使用的 `split` "
"函数混淆）用一个新目标替换目标，用于控制流的每条路径："

#: src/programs-proofs/insertion-sort.md:253
#, fuzzy
msgid ""
"Additionally, each new goal has an assumption that indicates which branch "
"led to that goal, named `heq✝` in this case:"
msgstr "此外，每个新目标都有一个假设，表明哪个分支导致了该目标，在本例中命名为 `heq✝`："

#: src/programs-proofs/insertion-sort.md:302
#, fuzzy
msgid ""
"Rather than write proofs for both simple cases, adding `<;> try rfl` after "
"`split` causes the two straightforward cases to disappear immediately, "
"leaving only a single goal:"
msgstr "与其为这两个简单情况编写证明，不如在 `split` 后添加 `<;> try rfl`，这样这两个直接的情况会立即消失，只留下一个目标："

#: src/programs-proofs/insertion-sort.md:339
#, fuzzy
msgid ""
"Unfortunately, the induction hypothesis is not strong enough to prove this "
"goal. The induction hypothesis states that calling `insertSorted` on `arr` "
"leaves the size unchanged, but the proof goal is to show that the result of "
"the recursive call with the result of swapping leaves the size unchanged. "
"Successfully completing the proof requires an induction hypothesis that "
"works for _any_ array that is passed to `insertSorted` together with the "
"smaller index as an argument"
msgstr ""
"不幸的是，归纳假设不足以证明这个目标。归纳假设指出对 `arr` 调用 `insertSorted` "
"不会改变大小，但证明目标是要证明用交换结果进行递归调用的结果不会改变大小。成功完成证明需要一个归纳假设，该假设适用于传递给 `insertSorted`"
" 的任何数组以及作为参数的较小索引"

#: src/programs-proofs/insertion-sort.md:343
#, fuzzy
msgid ""
"It is possible to get a strong induction hypothesis by using the "
"`generalizing` option to the `induction` tactic. This option brings "
"additional assumptions from the context into the statement that's used to "
"generate the base case, the induction hypothesis, and the goal to be shown "
"in the inductive step. Generalizing over `arr` leads to a stronger "
"hypothesis:"
msgstr ""
"可以使用 `induction` 策略的 `generalizing` "
"选项来获得强归纳假设。此选项将上下文中的附加假设引入到用于生成基本情况、归纳假设和在归纳步骤中显示的目标的语句中。对 `arr` "
"进行泛化会导致更强的假设："

#: src/programs-proofs/insertion-sort.md:357
#, fuzzy
msgid ""
"In the resulting goal, `arr` is now part of a \"for all\" statement in the "
"inductive hypothesis:"
msgstr "在生成的证明目标中，`arr` 现在是归纳假设中「对所有」语句的一部分："

#: src/programs-proofs/insertion-sort.md:386
#, fuzzy
msgid ""
"However, this whole proof is beginning to get unmanageable. The next step "
"would be to introduce a variable standing for the length of the result of "
"swapping, show that it is equal to `arr.size`, and then show that this "
"variable is also equal to the length of the array that results from the "
"recursive call. These equality statement can then be chained together to "
"prove the goal. It's much easier, however, to carefully reformulate the "
"theorem statement such that the induction hypothesis is automatically strong"
" enough and the variables are already introduced. The reformulated statement"
" reads:"
msgstr ""
"然而，整个证明开始变得难以管理。下一步是引入一个变量表示交换结果的长度，证明它等于 "
"`arr.size`，然后证明这个变量也等于递归调用产生的数组的长度。然后可以将这些相等语句链接在一起来证明目标。然而，仔细重新表述定理陈述以使归纳假设自动足够强并且已经引入变量要容易得多。重新表述的陈述如下："

#: src/programs-proofs/insertion-sort.md:397
#, fuzzy
msgid ""
"This version of the theorem statement is easier to prove for a few reasons:"
msgstr "这个版本的定理陈述更容易证明，原因有以下几个："

#: src/programs-proofs/insertion-sort.md:398
#, fuzzy
msgid ""
"Rather than bundling up the index and the proof of its validity in a `Fin`, "
"the index comes before the array. This allows the induction hypothesis to "
"naturally generalize over the array and the proof that `i` is in bounds."
msgstr "与其将索引及其有效性证明捆绑在 `Fin` 中，不如将索引放在数组之前。这允许归纳假设自然地概括数组和证明 `i` 在范围内。"

#: src/programs-proofs/insertion-sort.md:400
#, fuzzy
msgid ""
"An abstract length `len` is introduced to stand for `array.size`. Proof "
"automation is often better at working with explicit statements of equality."
msgstr "引入一个抽象长度 `len` 来表示 `array.size`。证明自动化通常更擅长处理显式相等语句。"

#: src/programs-proofs/insertion-sort.md:403
#, fuzzy
msgid ""
"The resulting proof state shows the statement that will be used to generate "
"the induction hypothesis, as well as the base case and the goal of the "
"inductive step:"
msgstr "生成的证明状态显示了将用于生成归纳假设的语句，以及基本情况和归纳步骤的目标："

#: src/programs-proofs/insertion-sort.md:413
#, fuzzy
msgid ""
"Compare the statement with the goals that result from the `induction` "
"tactic:"
msgstr "将该语句与 `induction` 策略产生的目标进行比较："

#: src/programs-proofs/insertion-sort.md:422
#, fuzzy
msgid ""
"In the base case, each occurrence of `i` has been replaced by `0`. Using "
"`intro` to introduce each assumption and then simplifying using "
"`insertSorted` will prove the goal, because `insertSorted` at index `zero` "
"returns its argument unchanged:"
msgstr ""
"在基本情况下，每个 `i` 的出现都被替换为 `0`。使用 `intro` 引入每个假设，然后使用 `insertSorted` "
"简化将证明目标，因为在索引 `zero` 处的 `insertSorted` 返回其参数不变："

#: src/programs-proofs/insertion-sort.md:433
#, fuzzy
msgid ""
"In the inductive step, the induction hypothesis has exactly the right "
"strength. It will be useful for _any_ array, so long as that array has "
"length `len`:"
msgstr "归纳步骤中，归纳假设具有恰当的强度。它对_任何_数组都适用，只要该数组的长度为 `len`："

#: src/programs-proofs/insertion-sort.md:448
#, fuzzy
msgid "In the base case, `simp` reduces the goal to `arr.size = len`:"
msgstr "在基本情况下，`simp` 将目标简化为 `arr.size = len`："

#: src/programs-proofs/insertion-sort.md:470
#, fuzzy
msgid ""
"This can be proved using the assumption `hLen`. Adding the `*` parameter to "
"`simp` instructs it to additionally use assumptions, which solves the goal:"
msgstr "这可以使用假设 `hLen` 来证明。向 `simp` 添加 `*` 参数指示它另外使用假设，这解决了目标："

#: src/programs-proofs/insertion-sort.md:483
#, fuzzy
msgid ""
"In the inductive step, introducing assumptions and simplifying the goal "
"results once again in a goal that contains a pattern match:"
msgstr "在归纳步骤中，引入假设并简化目标再次导致包含模式匹配的目标："

#: src/programs-proofs/insertion-sort.md:524
#, fuzzy
msgid ""
"Using the `split` tactic results in one goal for each pattern. Once again, "
"the first two goals result from branches without recursive calls, so the "
"induction hypothesis is not necessary:"
msgstr "使用 `split` 策略会为每个模式生成一个目标。同样，前两个目标来自没有递归调用的分支，因此不需要归纳假设："

#: src/programs-proofs/insertion-sort.md:593
#, fuzzy
msgid ""
"Running `try assumption` in each goal that results from `split` eliminates "
"both of the non-recursive goals:"
msgstr "在 `split` 产生的每个目标中运行 `try assumption` 消除了两个非递归目标："

#: src/programs-proofs/insertion-sort.md:634
#, fuzzy
msgid ""
"The new formulation of the proof goal, in which a constant `len` is used for"
" the lengths of all the arrays involved in the recursive function, falls "
"nicely within the kinds of problems that `simp` can solve. This final proof "
"goal can be solved by `simp [*]`, because the assumptions that relate the "
"array's length to `len` are important:"
msgstr ""
"证明目标的新表述，其中常量 `len` 用于递归函数中涉及的所有数组的长度，恰好属于 `simp` 可以解决的问题类型。这个最终的证明目标可以通过 "
"`simp [*]` 来解决，因为将数组的长度与 `len` 联系起来的假设很重要："

#: src/programs-proofs/insertion-sort.md:651
#, fuzzy
msgid ""
"Finally, because `simp [*]` can use assumptions, the `try assumption` line "
"can be replaced by `simp [*]`, shortening the proof:"
msgstr "最后，因为 `simp [*]` 可以使用假设，所以 `try assumption` 行可以用 `simp [*]` 替换，缩短证明："

#: src/programs-proofs/insertion-sort.md:666
#, fuzzy
msgid ""
"This proof can now be used to replace the `sorry` in `insertionSortLoop`. "
"Providing `arr.size` as the `len` argument to the theorem causes the final "
"conclusion to be `(insertSorted arr ⟨i, isLt⟩).size = arr.size`, so the "
"rewrite ends with a very manageable proof goal:"
msgstr ""
"现在可以使用这个证明来替换 `insertionSortLoop` 中的 `sorry`。将 `arr.size` 作为定理的 `len` "
"参数会导致最终结论为 `(insertSorted arr ⟨i, isLt⟩).size = "
"arr.size`，因此重写以一个非常易于管理的证明目标结束："

#: src/programs-proofs/insertion-sort.md:687
#, fuzzy
msgid ""
"The proof `Nat.sub_succ_lt_self` is part of Lean's standard library. It's "
"type is `∀ (a i : Nat), i < a → a - (i + 1) < a - i`, which is exactly "
"what's needed:"
msgstr ""
"`Nat.sub_succ_lt_self` 证明是 Lean 标准库的一部分。它的类型是 `∀ (a i : Nat), i < a → a - (i"
" + 1) < a - i`，这正是所需要的："

#: src/programs-proofs/insertion-sort.md:702
#, fuzzy
msgid "The Driver Function"
msgstr "驱动函数"

#: src/programs-proofs/insertion-sort.md:704
#, fuzzy
msgid ""
"Insertion sort itself calls `insertionSortLoop`, initializing the index that"
" demarcates the sorted region of the array from the unsorted region to `0`:"
msgstr "插入排序本身调用 `insertionSortLoop`，将数组中已排序区域与未排序区域的分界索引初始化为 `0`："

#: src/programs-proofs/insertion-sort.md:710
#, fuzzy
msgid "A few quick tests show the function is at least not blatantly wrong:"
msgstr "一些快速测试表明该函数至少不是明显错误的："

#: src/programs-proofs/insertion-sort.md:717
msgid ""
"```lean\n"
"#eval insertionSort #[ \"quartz\", \"marble\", \"granite\", \"hematite\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:720
msgid ""
"```output info\n"
"#[\"granite\", \"hematite\", \"marble\", \"quartz\"]\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:724
#, fuzzy
msgid "Is This Really Insertion Sort?"
msgstr "这真的是插入排序吗？"

#: src/programs-proofs/insertion-sort.md:726
#, fuzzy
msgid ""
"Insertion sort is _defined_ to be an in-place sorting algorithm. What makes "
"it useful, despite its quadratic worst-case run time, is that it is a stable"
" sorting algorithm that doesn't allocate extra space and that handles "
"almost-sorted data efficiently. If each iteration of the inner loop "
"allocated a new array, then the algorithm wouldn't _really_ be insertion "
"sort."
msgstr ""
"插入排序被定义为就地排序算法。尽管它具有二次最坏情况运行时间，但它仍然有用，因为它是一种稳定的排序算法，不会分配额外的空间，并且可以有效处理几乎已排序的数据。如果内部循环的每次迭代都分配一个新数组，那么该算法就不会真正成为插入排序。"

#: src/programs-proofs/insertion-sort.md:730
#, fuzzy
msgid ""
"Lean's array operations, such as `Array.set` and `Array.swap`, check whether"
" the array in question has a reference count that is greater than one. If "
"so, then the array is visible to multiple parts of the code, which means "
"that it must be copied. Otherwise, Lean would no longer be a pure functional"
" language. However, when the reference count is exactly one, there are no "
"other potential observers of the value. In these cases, the array primitives"
" mutate the array in place. What other parts of the program don't know can't"
" hurt them."
msgstr ""
"Lean 的数组操作（例如 `Array.set` 和 `Array.swap`）检查所讨论的数组的引用计数是否大于 "
"1。如果是，则该数组对代码的多个部分可见，这意味着它必须被复制。否则，Lean 将不再是一种纯函数式语言。但是，当引用计数恰好为 1 "
"时，没有其他潜在的值观察者。在这些情况下，数组基元会就地改变数组。程序的其他部分不知道的不会伤害它们。"

#: src/programs-proofs/insertion-sort.md:737
#, fuzzy
msgid ""
"Lean's proof logic works at the level of pure functional programs, not the "
"underlying implementation. This means that the best way to discover whether "
"a program unnecessarily copies data is to test it. Adding calls to "
"`dbgTraceIfShared` at each point where mutation is desired causes the "
"provided message to be printed to `stderr` when the value in question has "
"more than one reference."
msgstr ""
"Lean 的证明逻辑在纯函数式程序的级别上工作，而不是底层实现。这意味着发现程序是否不必要地复制数据最好的方法是测试它。在需要变异的每个点添加对 "
"`dbgTraceIfShared` 的调用，当所讨论的值有多个引用时，会导致将提供的消息打印到 `stderr`。"

#: src/programs-proofs/insertion-sort.md:741
#, fuzzy
msgid ""
"Insertion sort has precisely one place that is at risk of copying rather "
"than mutating: the call to `Array.swap`. Replacing `arr.swap ⟨i', by "
"assumption⟩ i` with `((dbgTraceIfShared \"array to swap\" arr).swap ⟨i', by "
"assumption⟩ i)` causes the program to emit `shared RC array to swap` "
"whenever it is unable to mutate the array. However, this change to the "
"program changes the proofs as well, because now there's a call to an "
"additional function. Because `dbgTraceIfShared` returns its second argument "
"directly, adding it to the calls to `simp` is enough to fix the proofs."
msgstr ""
"插入排序有一个地方有复制而不是变异的风险：调用 `Array.swap`。将 `arr.swap ⟨i', by assumption⟩ i` 替换为 "
"`((dbgTraceIfShared \"array to swap\" arr).swap ⟨i', by assumption⟩ i)` "
"会导致程序在无法变异数组时发出 `shared RC array to swap`。但是，对程序的这一更改也会更改证明，因为现在调用了一个附加函数。由于"
" `dbgTraceIfShared` 直接返回其第二个参数，因此将其添加到对 `simp` 的调用中足以修复证明。"

#: src/programs-proofs/insertion-sort.md:746
#, fuzzy
msgid "The complete instrumented code for insertion sort is:"
msgstr "插入排序的完整检测代码为："

#: src/programs-proofs/insertion-sort.md:747
msgid ""
"```leantacnorfl\n"
"def insertSorted [Ord α] (arr : Array α) (i : Fin arr.size) : Array α :=\n"
"  match i with\n"
"  | ⟨0, _⟩ => arr\n"
"  | ⟨i' + 1, _⟩ =>\n"
"    have : i' < arr.size := by\n"
"      simp [Nat.lt_of_succ_lt, *]\n"
"    match Ord.compare arr[i'] arr[i] with\n"
"    | .lt | .eq => arr\n"
"    | .gt =>\n"
"      insertSorted\n"
"        ((dbgTraceIfShared \"array to swap\" arr).swap ⟨i', by assumption⟩ i)\n"
"        ⟨i', by simp [dbgTraceIfShared, *]⟩\n"
"\n"
"theorem insert_sorted_size_eq [Ord α] (len : Nat) (i : Nat) :\n"
"    (arr : Array α) → (isLt : i < arr.size) → (arr.size = len) →\n"
"    (insertSorted arr ⟨i, isLt⟩).size = len := by\n"
"  induction i with\n"
"  | zero =>\n"
"    intro arr isLt hLen\n"
"    simp [insertSorted, *]\n"
"  | succ i' ih =>\n"
"    intro arr isLt hLen\n"
"    simp [insertSorted, dbgTraceIfShared]\n"
"    split <;> simp [*]\n"
"\n"
"def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=\n"
"  if h : i < arr.size then\n"
"    have : (insertSorted arr ⟨i, h⟩).size - (i + 1) < arr.size - i := by\n"
"      rw [insert_sorted_size_eq arr.size i arr h rfl]\n"
"      simp [Nat.sub_succ_lt_self, *]\n"
"    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)\n"
"  else\n"
"    arr\n"
"termination_by insertionSortLoop arr i => arr.size - i\n"
"\n"
"def insertionSort [Ord α] (arr : Array α) : Array α :=\n"
"  insertionSortLoop arr 0\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:787
#, fuzzy
msgid ""
"A bit of cleverness is required to check whether the instrumentation "
"actually works. First off, the Lean compiler aggressively optimizes function"
" calls away when all their arguments are known at compile time. Simply "
"writing a program that applies `insertionSort` to a large array is not "
"sufficient, because the resulting compiled code may contain only the sorted "
"array as a constant. The easiest way to ensure that the compiler doesn't "
"optimize away the sorting routine is to read the array from `stdin`. "
"Secondly, the compiler performs dead code elimination. Adding extra `let`s "
"to the program won't necessarily result in more references in running code "
"if the `let`\\-bound variables are never used. To ensure that the extra "
"reference is not eliminated entirely, it's important to ensure that the "
"extra reference is somehow used."
msgstr ""
"要检查检测是否实际起作用，需要一点技巧。首先，当所有参数在编译时都已知时，Lean 编译器会积极地优化函数调用。仅仅编写一个将 "
"`insertionSort` 应用于大数组的程序是不够的，因为生成的编译代码可能只包含已排序的数组作为常量。确保编译器不会优化排序例程的最简单方法是从"
" `stdin` 读取数组。其次，编译器执行死代码消除。如果从未使用 `let` 绑定的变量，则向程序中添加额外的 `let` "
"并不一定会导致运行代码中更多的引用。为了确保不会完全消除额外的引用，重要的是确保以某种方式使用了额外的引用。"

#: src/programs-proofs/insertion-sort.md:795
#, fuzzy
msgid ""
"The first step in testing the instrumentation is to write `getLines`, which "
"reads an array of lines from standard input:"
msgstr "测试检测的第一步是编写 `getLines`，它从标准输入读取一行数组："

#: src/programs-proofs/insertion-sort.md:807
#, fuzzy
msgid ""
"`IO.FS.Stream.getLine` returns a complete line of text, including the "
"trailing newline. It returns `\"\"` when the end-of-file marker has been "
"reached."
msgstr "`IO.FS.Stream.getLine` 返回一行完整的文本，包括结尾的新行。当到达文件结尾标记时，它返回 `\"\"`。"

#: src/programs-proofs/insertion-sort.md:810
#, fuzzy
msgid ""
"Next, two separate `main` routines are needed. Both read the array to be "
"sorted from standard input, ensuring that the calls to `insertionSort` won't"
" be replaced by their return values at compile time. Both then print to the "
"console, ensuring that the calls to `insertionSort` won't be optimized away "
"entirely. One of them prints only the sorted array, while the other prints "
"both the sorted array and the original array. The second function should "
"trigger a warning that `Array.swap` had to allocate a new array:"
msgstr ""
"接下来，需要两个单独的 `main` 例程。两者都从标准输入读取要排序的数组，确保在编译时不会用它们的返回值替换对 `insertionSort` "
"的调用。然后两者都打印到控制台，确保对 `insertionSort` "
"的调用不会被完全优化掉。其中一个只打印排序后的数组，而另一个同时打印排序后的数组和原始数组。第二个函数应该触发一个警告，即 `Array.swap` "
"必须分配一个新数组："

#: src/programs-proofs/insertion-sort.md:815
msgid ""
"```lean\n"
"def mainUnique : IO Unit := do\n"
"  let lines ← getLines\n"
"  for line in insertionSort lines do\n"
"    IO.println line\n"
"\n"
"def mainShared : IO Unit := do\n"
"  let lines ← getLines\n"
"  IO.println \"--- Sorted lines: ---\"\n"
"  for line in insertionSort lines do\n"
"    IO.println line\n"
"\n"
"  IO.println \"\"\n"
"  IO.println \"--- Original data: ---\"\n"
"  for line in lines do\n"
"    IO.println line\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:833
#, fuzzy
msgid ""
"The actual `main` simply selects one of the two main actions based on the "
"provided command-line arguments:"
msgstr "实际的 `main` 只需根据提供的命令行参数选择两个主操作之一："

#: src/programs-proofs/insertion-sort.md:834
msgid ""
"```lean\n"
"def main (args : List String) : IO UInt32 := do\n"
"  match args with\n"
"  | [\"--shared\"] => mainShared; pure 0\n"
"  | [\"--unique\"] => mainUnique; pure 0\n"
"  | _ =>\n"
"    IO.println \"Expected single argument, either \\\"--shared\\\" or \\\"--unique\\\"\"\n"
"    pure 1\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:844
#, fuzzy
msgid "Running it with no arguments produces the expected usage information:"
msgstr "在没有参数的情况下运行它会产生预期的用法信息："

#: src/programs-proofs/insertion-sort.md:845
msgid ""
"```\n"
"$ sort\n"
"Expected single argument, either \"--shared\" or \"--unique\"\n"
"```"
msgstr ""

#: src/programs-proofs/insertion-sort.md:850
#, fuzzy
msgid "The file `test-data` contains the following rocks:"
msgstr "`test-data` 文件包含以下岩石："

#: src/programs-proofs/insertion-sort.md:863
#, fuzzy
msgid ""
"Using the instrumented insertion sort on these rocks results them being "
"printed in alphabetical order:"
msgstr "对这些岩石使用经过检测的插入排序，结果按字母顺序打印出来："

#: src/programs-proofs/insertion-sort.md:877
#, fuzzy
msgid ""
"However, the version in which a reference is retained to the original array "
"results in a notification on `stderr` (namely, `shared RC array to swap`) "
"from the first call to `Array.swap`:"
msgstr ""
"然而，保留对原始数组的引用的版本导致对 `Array.swap` 的第一次调用在 `stderr` 上发出通知（即 `shared RC array "
"to swap`）："

#: src/programs-proofs/insertion-sort.md:903
#, fuzzy
msgid ""
"The fact that only a single `shared RC` notification appears means that the "
"array is copied only once. This is because the copy that results from the "
"call to `Array.swap` is itself unique, so no further copies need to be made."
" In an imperative language, subtle bugs can result from forgetting to "
"explicitly copy an array before passing it by reference. When running `sort "
"--shared`, the array is copied as needed to preserve the pure functional "
"meaning of Lean programs, but no more."
msgstr ""
"仅出现一个 `shared RC` 通知这一事实意味着数组仅被复制一次。这是因为由对 `Array.swap` "
"的调用产生的副本本身是唯一的，因此不需要进行进一步的复制。在命令式语言中，由于忘记在按引用传递数组之前显式复制数组，可能会导致细微的错误。在运行 "
"`sort --shared` 时，数组会根据需要被复制，以保留 Lean 程序的纯函数含义，但不会更多。"

#: src/programs-proofs/insertion-sort.md:909
#, fuzzy
msgid "Other Opportunities for Mutation"
msgstr "其他突变机会"

#: src/programs-proofs/insertion-sort.md:911
#, fuzzy
msgid ""
"The use of mutation instead of copying when references are unique is not "
"limited to array update operators. Lean also attempts to \"recycle\" "
"constructors whose reference counts are about to fall to zero, reusing them "
"instead of allocating new data. This means, for instance, that `List.map` "
"will mutate a linked list in place, at least in cases when nobody could "
"possibly notice. One of the most important steps in optimizing hot loops in "
"Lean code is making sure that the data being modified is not referred to "
"from multiple locations."
msgstr ""
"当引用是唯一的时，使用突变而不是复制并不局限于数组更新运算符。Lean "
"还尝试「回收」引用计数即将降至零的构造子，重新使用它们而不是分配新数据。这意味着，例如，`List.map` "
"将就地突变一个链表，至少在没有人可能注意到的情况下。优化 Lean 代码中的热点循环的最重要步骤之一是确保正在修改的数据不会被多个位置引用。"

#: src/programs-proofs/insertion-sort.md:918
#, fuzzy
msgid ""
"Write a function that reverses arrays. Test that if the input array has a "
"reference count of one, then your function does not allocate a new array."
msgstr "编写一个反转数组的函数。测试如果输入数组的引用计数为一，则你的函数不会分配一个新数组。"

#: src/programs-proofs/insertion-sort.md:920
#, fuzzy
msgid ""
"Implement either merge sort or quicksort for arrays. Prove that your "
"implementation terminates, and test that it doesn't allocate more arrays "
"than expected. This is a challenging exercise!"
msgstr "为数组实现归并排序或快速排序。证明你的实现终止，并测试它不会分配比预期更多的数组。这是一个具有挑战性的练习！"

#: src/programs-proofs/special-types.md:3
#, fuzzy
msgid ""
"Understanding the representation of data in memory is very important. "
"Usually, the representation can be understood from the definition of a "
"datatype. Each constructor corresponds to an object in memory that has a "
"header that includes a tag and a reference count. The constructor's "
"arguments are each represented by a pointer to some other object. In other "
"words, `List` really is a linked list and extracting a field from a "
"`structure` really does just chase a pointer."
msgstr ""
"理解数据在内存中的表示非常重要。通常，可以从数据类型的定义中理解表示。每个构造子对应于内存中的一个对象，该对象有一个包含标记和引用计数的头。构造子的参数分别由指向其他对象的指针表示。换句话说，`List`"
" 实际上是一个链表，从 `structure` 中提取一个字段实际上只是追逐一个指针。"

#: src/programs-proofs/special-types.md:9
#, fuzzy
msgid ""
"There are, however, some important exceptions to this rule. A number of "
"types are treated specially by the compiler. For example, the type `UInt32` "
"is defined as `Fin (2 ^ 32)`, but it is replaced at run-time with an actual "
"native implementation based on machine words. Similarly, even though the "
"definition of `Nat` suggests an implementation similar to `List Unit`, the "
"actual run-time representation uses immediate machine words for "
"sufficiently-small numbers and an efficient arbitrary-precision arithmetic "
"library for larger numbers. The Lean compiler translates from definitions "
"that use pattern matching into the appropriate operations for this "
"representation, and calls to operations like addition and subtraction are "
"mapped to fast operations from the underlying arithmetic library. After all,"
" addition should not take time linear in the size of the addends."
msgstr ""
"然而，这个规则有一些重要的例外。编译器对许多类型进行了特殊处理。例如，类型 `UInt32` 被定义为 `Fin (2 ^ "
"32)`，但在运行时它被替换为基于机器字的实际原生实现。类似地，尽管 `Nat` 的定义暗示了一个类似于 `List Unit` "
"的实现，但实际的运行时表示对足够小的数字使用立即机器字，对较大的数字使用高效的任意精度算术库。Lean "
"编译器从使用模式匹配的定义转换为针对此表示的适当操作，并且对加法和减法等操作的调用被映射到底层算术库中的快速操作。毕竟，加法不应该花费与加数大小成线性的时间。"

#: src/programs-proofs/special-types.md:16
#, fuzzy
msgid ""
"The fact that some types have special representations also means that care "
"is needed when working with them. Most of these types consist of a "
"`structure` that is treated specially by the compiler. With these "
"structures, using the constructor or the field accessors directly can "
"trigger an expensive conversion from an efficient representation to a slow "
"one that is convenient for proofs. For example, `String` is defined as a "
"structure that contains a list of characters, but the run-time "
"representation of strings uses UTF-8, not linked lists of pointers to "
"characters. Applying the constructor to a list of characters creates a byte "
"array that encodes them in UTF-8, and accessing the field of the structure "
"takes time linear in the length of the string to decode the UTF-8 "
"representation and allocate a linked list. Arrays are represented similarly."
" From the logical perspective, arrays are structures that contain a list of "
"array elements, but the run-time representation is a dynamically-sized "
"array. At run time, the constructor translates the list into an array, and "
"the field accessor allocates a linked list from the array. The various array"
" operations are replaced with efficient versions by the compiler that mutate"
" the array when possible instead of allocating a new one."
msgstr ""
"由于某些类型具有特殊表示，因此在使用它们时需要小心。这些类型中的大多数由编译器特殊处理的 `structure` "
"组成。对于这些结构体，直接使用构造子或字段访问器可能会触发从高效表示到方便证明的低效表示的昂贵转换。例如，`String` "
"被定义为包含字符列表的结构体，但字符串的运行时表示使用 UTF-8，而不是指向字符的指针链表。将构造子应用于字符列表会创建一个以 UTF-8 "
"编码它们的字节数组，而访问结构体的字段需要线性时间来解码 UTF-8 "
"表示并分配一个链表。数组的表示方式类似。从逻辑角度来看，数组是包含数组元素列表的结构体，但运行时表示是一个动态大小的数组。在运行时，构造子将列表转换为数组，而字段访问器从数组中分配一个链表。编译器用高效版本替换了各种数组操作，这些版本在可能的情况下会改变数组，而不是分配一个新数组。"

#: src/programs-proofs/special-types.md:26
#, fuzzy
msgid ""
"Both types themselves and proofs of propositions are completely erased from "
"compiled code. In other words, they take up no space, and any computations "
"that might have been performed as part of a proof are similarly erased. This"
" means that proofs can take advantage of the convenient interface to strings"
" and arrays as inductively-defined lists, including using induction to prove"
" things about them, without imposing slow conversion steps while the program"
" is running. For these built-in types, a convenient logical representation "
"of the data does not imply that the program must be slow."
msgstr ""
"类型本身和命题的证明都从编译后的代码中完全擦除。换句话说，它们不占用任何空间，并且作为证明的一部分可能执行的任何计算也会被类似地擦除。这意味着证明可以利用字符串和数组作为归纳定义列表的便捷接口，包括使用归纳来证明它们，而不会在程序运行时施加缓慢的转换步骤。对于这些内置类型，数据的便捷逻辑表示并不意味着程序必须很慢。"

#: src/programs-proofs/special-types.md:31
#, fuzzy
msgid ""
"If a structure type has only a single non-type non-proof field, then the "
"constructor itself disappears at run time, being replaced with its single "
"argument. In other words, a subtype is represented identically to its "
"underlying type, rather than with an extra layer of indirection. Similarly, "
"`Fin` is just `Nat` in memory, and single-field structures can be created to"
" keep track of different uses of `Nat`s or `String`s without paying a "
"performance penalty. If a constructor has no non-type non-proof arguments, "
"then the constructor also disappears and is replaced with a constant value "
"where the pointer would otherwise be used. This means that `true`, `false`, "
"and `none` are constant values, rather than pointers to heap-allocated "
"objects."
msgstr ""
"如果一个结构体类型只有一个非类型非证明字段，那么构造子本身在运行时会消失，并被其单个参数替换。换句话说，一个子类型与其底层类型完全相同，而不是带有额外的间接层。类似地，`Fin`"
" 在内存中只是 `Nat`，并且可以创建单字段结构体来跟踪 `Nat` 或 `String` "
"的不同用法，而无需支付性能损失。如果一个构造子没有非类型非证明参数，那么该构造子也会消失，并被一个常量值替换，否则指针将用于该常量值。这意味着 "
"`true`、`false` 和 `none` 是常量值，而不是指向堆分配对象的指针。"

#: src/programs-proofs/special-types.md:38
#, fuzzy
msgid "The following types have special representations:"
msgstr "以下类型具有特殊表示："

#: src/programs-proofs/special-types.md:40
#, fuzzy
msgid "Type"
msgstr "类型"

#: src/programs-proofs/special-types.md:40
#, fuzzy
msgid "Logical representation"
msgstr "逻辑表示"

#: src/programs-proofs/special-types.md:40
#, fuzzy
msgid "Run-time Representation"
msgstr "运行时表示"

#: src/programs-proofs/special-types.md:42
#, fuzzy
msgid "Unary, with one pointer from each `Nat.succ`"
msgstr "一元，每个 `Nat.succ` 有一个指针"

#: src/programs-proofs/special-types.md:42
#: src/programs-proofs/special-types.md:43
#, fuzzy
msgid "Efficient arbitrary-precision integers"
msgstr "高效任意精度整数"

#: src/programs-proofs/special-types.md:43
#, fuzzy
msgid "`Int`"
msgstr "`Int`"

#: src/programs-proofs/special-types.md:43
#, fuzzy
msgid ""
"A sum type with constructors for positive or negative values, each "
"containing a `Nat`"
msgstr "一个具有正值或负值构造子的和类型，每个构造子都包含一个 `Nat`"

#: src/programs-proofs/special-types.md:44
#, fuzzy
msgid "`UInt8`, `UInt16`, `UInt32`, `UInt64`"
msgstr "`UInt8`、`UInt16`、`UInt32`、`UInt64`"

#: src/programs-proofs/special-types.md:44
#, fuzzy
msgid "A `Fin` with an appropriate bound"
msgstr "具有适当界限的 `Fin`"

#: src/programs-proofs/special-types.md:44
#, fuzzy
msgid "Fixed-precision machine integers"
msgstr "定点机器整数"

#: src/programs-proofs/special-types.md:45
#, fuzzy
msgid "`Char`"
msgstr "`Char`"

#: src/programs-proofs/special-types.md:45
#, fuzzy
msgid "A `UInt32` paired with a proof that it's a valid code point"
msgstr "与证明其为有效代码点的 `UInt32` 配对"

#: src/programs-proofs/special-types.md:45
#, fuzzy
msgid "Ordinary characters"
msgstr "普通字符"

#: src/programs-proofs/special-types.md:46
#, fuzzy
msgid "`String`"
msgstr "`String`"

#: src/programs-proofs/special-types.md:46
#, fuzzy
msgid "A structure that contains a `List Char` in a field called `data`"
msgstr "一个结构体，它在一个名为 `data` 的字段中包含一个 `List Char`"

#: src/programs-proofs/special-types.md:46
#, fuzzy
msgid "UTF-8-encoded string"
msgstr "UTF-8 编码字符串"

#: src/programs-proofs/special-types.md:47
#, fuzzy
msgid "`Array α`"
msgstr "`Array α`"

#: src/programs-proofs/special-types.md:47
#, fuzzy
msgid "A structure that contains a `List α` in a field called `data`"
msgstr "一个结构体，它在一个名为 `data` 的字段中包含一个 `List α`"

#: src/programs-proofs/special-types.md:47
#, fuzzy
msgid "Packed arrays of pointers to `α` values"
msgstr "指向 `α` 值的指针的打包数组"

#: src/programs-proofs/special-types.md:48
#, fuzzy
msgid "`Sort u`"
msgstr "`Sort u`"

#: src/programs-proofs/special-types.md:48
#, fuzzy
msgid "A type"
msgstr "一个类型"

#: src/programs-proofs/special-types.md:48
#: src/programs-proofs/special-types.md:49
#, fuzzy
msgid "Erased completely"
msgstr "完全擦除"

#: src/programs-proofs/special-types.md:49
#, fuzzy
msgid "Proofs of propositions"
msgstr "命题的证明"

#: src/programs-proofs/special-types.md:49
#, fuzzy
msgid ""
"Whatever data is suggested by the proposition when considered as a type of "
"evidence"
msgstr "当命题被视为证据类型时，命题所暗示的任何数据"

#: src/programs-proofs/special-types.md:53
#, fuzzy
msgid ""
"The [definition of `Pos`](../type-classes/pos.html) does not take advantage "
"of Lean's compilation of `Nat` to an efficient type. At run time, it is "
"essentially a linked list. Alternatively, a subtype can be defined that "
"allows Lean's fast `Nat` type to be used internally, as described [in the "
"initial section on subtypes](../functor-applicative-"
"monad/applicative.md#subtypes). At run time, the proof will be erased. "
"Because the resulting structure has only a single data field, it is "
"represented as that field, which means that this new representation of `Pos`"
" is identical to that of `Nat`."
msgstr ""
"`Pos` 的 [定义](../type-classes/pos.html) 并没有利用 Lean 将 `Nat` "
"编译成高效类型的优势。在运行时，它本质上是一个链表。或者，可以定义一个子类型，允许在内部使用 Lean 的快速 `Nat` 类型，如 "
"[子类型初始部分](../functor-applicative-monad/applicative.md#subtypes) "
"中所述。在运行时，证明将被擦除。由于结果结构体只有一个数据字段，因此它表示为该字段，这意味着 `Pos` 的这种新表示与 `Nat` 的表示相同。"

#: src/programs-proofs/special-types.md:59
#, fuzzy
msgid ""
"After proving the theorem `∀ {n k : Nat}, n ≠ 0 → k ≠ 0 → n + k ≠ 0`, define"
" instances of `ToString`, and `Add` for this new representation of `Pos`. "
"Then, define an instance of `Mul`, proving any necessary theorems along the "
"way."
msgstr ""
"在证明定理 `∀ {n k : Nat}, n ≠ 0 → k ≠ 0 → n + k ≠ 0` 后，为 `Pos` 的这种新表示定义 "
"`ToString` 和 `Add` 的实例。然后，定义 `Mul` 的实例，在此过程中证明任何必要的定理。"

#: src/programs-proofs/summary.md:5
#, fuzzy
msgid ""
"Tail recursion is recursion in which the results of recursive calls are "
"returned immediately, rather than being used in some other way. These "
"recursive calls are called _tail calls_. Tail calls are interesting because "
"they can be compiled to a jump instruction rather than a call instruction, "
"and the current stack frame can be re-used instead of pushing a new frame. "
"In other words, tail-recursive functions are actually loops."
msgstr ""
"尾递归是一种递归，其中递归调用的结果会立即返回，而不是以其他方式使用。这些递归调用称为「尾调用」。尾调用很有趣，因为它们可以编译成跳转指令而不是调用指令，并且可以重新使用当前堆栈帧，而不是推送新帧。换句话说，尾递归函数实际上是循环。"

#: src/programs-proofs/summary.md:10
#, fuzzy
msgid ""
"A common way to make a recursive function faster is to rewrite it in "
"accumulator-passing style. Instead of using the call stack to remember what "
"is to be done with the result of a recursive call, an additional argument "
"called an _accumulator_ is used to collect this information. For example, an"
" accumulator for a tail-recursive function that reverses a list contains the"
" already-seen list entries, in reverse order."
msgstr ""
"使递归函数更快的常用方法是使用累加器传递样式对其进行重写。它不使用调用堆栈来记住如何处理递归调用的结果，而是使用一个名为「累加器」的附加参数来收集此信息。例如，用于反转列表的尾递归函数的累加器包含已看到的列表项，按相反顺序排列。"

#: src/programs-proofs/summary.md:14
#, fuzzy
msgid ""
"In Lean, only self-tail-calls are optimized into loops. In other words, two "
"functions that each end with a tail call to the other will not be optimized."
msgstr "在 Lean 中，只有自尾调用会被优化为循环。换句话说，两个函数都以尾调用彼此结束，不会被优化。"

#: src/programs-proofs/summary.md:17
#, fuzzy
msgid "Reference Counting and In-Place Updates"
msgstr "引用计数和就地更新"

#: src/programs-proofs/summary.md:19
#, fuzzy
msgid ""
"Rather than using a tracing garbage collector, as is done in Java, C#, and "
"most JavaScript implementations, Lean uses reference counting for memory "
"management. This means that each value in memory contains a field that "
"tracks how many other values refer to it, and the run-time system maintains "
"these counts as references appear or disappear. Reference counting is also "
"used in Python, PHP, and Swift."
msgstr ""
"与 Java、C# 和大多数 JavaScript 实现中所做的那样使用跟踪垃圾收集器不同，Lean "
"使用引用计数进行内存管理。这意味着内存中的每个值都包含一个字段，该字段跟踪引用它的其他值的数目，并且运行时系统在引用出现或消失时维护这些计数。引用计数也用于"
" Python、PHP 和 Swift。"

#: src/programs-proofs/summary.md:23
#, fuzzy
msgid ""
"When asked to allocate a fresh object, Lean's run-time system is able to "
"recycle existing objects whose reference counts are falling to zero. "
"Additionally, array operations such as `Array.set` and `Array.swap` will "
"mutate an array if its reference count is one, rather than allocating a "
"modified copy. If `Array.swap` holds the only reference to an array, then no"
" other part of the program can tell that it was mutated rather than copied."
msgstr ""
"当要求分配一个新对象时，Lean 的运行时系统能够回收引用计数降为零的现有对象。此外，如果数组的引用计数为一，则数组操作（如 `Array.set` 和"
" `Array.swap`）将改变数组，而不是分配一个修改后的副本。如果 `Array.swap` "
"持有对数组的唯一引用，那么程序的其他部分无法分辨它是被改变了还是被复制了。"

#: src/programs-proofs/summary.md:27
#, fuzzy
msgid ""
"Writing efficient code in Lean requires the use of tail recursion and being "
"careful to ensure that large arrays are used uniquely. While tail calls can "
"be identified by inspecting the function's definition, understanding whether"
" a value is referred to uniquely may require reading the whole program. The "
"debugging helper `dbgTraceIfShared` can be used at key locations in the "
"program to check that a value is not shared."
msgstr ""
"在 Lean "
"中编写高效的代码需要使用尾递归，并小心确保大数组被唯一使用。虽然可以通过检查函数的定义来识别尾调用，但了解一个值是否被唯一引用可能需要阅读整个程序。调试助手"
" `dbgTraceIfShared` 可以用在程序的关键位置来检查一个值是否被共享。"

#: src/programs-proofs/summary.md:31
#, fuzzy
msgid "Proving Programs Correct"
msgstr "证明程序正确"

#: src/programs-proofs/summary.md:33
#, fuzzy
msgid ""
"Rewriting a program in accumulator-passing style, or making other "
"transformations that make it run faster, can also make it more difficult to "
"understand. It can be useful to keep the original version of the program "
"that is more clearly correct, and then use it as an executable specification"
" for the optimized version. While techniques such as unit testing work just "
"as well in Lean as in any other language, Lean also enables the use of "
"mathematical proofs that completely ensure that both versions of the "
"function return the same result for _all possible_ inputs."
msgstr ""
"以累加器传递样式重写程序，或进行其他使程序运行更快的转换，也可能使程序更难理解。保留程序的原始版本（更明显地正确）是有用的，然后将其用作优化版本的可执行规范。虽然单元测试等技术在"
" Lean 中与在任何其他语言中一样有效，但 Lean 还允许使用数学证明来完全确保函数的两个版本对所有可能的输入返回相同的结果。"

#: src/programs-proofs/summary.md:37
#, fuzzy
msgid ""
"Typically, proving that two functions are equal is done using function "
"extensionality (the `funext` tactic), which is the principle that two "
"functions are equal if they return the same values for every input. If the "
"functions are recursive, then induction is usually a good way to prove that "
"their outputs are the same. Usually, the recursive definition of the "
"function will make recursive calls on one particular argument; this argument"
" is a good choice for induction. In some cases, the induction hypothesis is "
"not strong enough. Fixing this problem usually requires thought about how to"
" construct a more general version of the theorem statement that provides "
"induction hypotheses that are strong enough. In particular, to prove that a "
"function is equivalent to an accumulator-passing version, a theorem "
"statement that relates arbitrary initial accumulator values to the final "
"result of the original function is needed."
msgstr ""
"通常，证明两个函数相等是使用函数扩展性（`funext` "
"策略）完成的，即如果两个函数对每个输入返回相同的值，则它们相等。如果函数是递归的，那么归纳通常是证明其输出相同的好方法。通常，函数的递归定义将对一个特定参数进行递归调用；这个参数是归纳的一个好选择。在某些情况下，归纳假设不够充分。解决这个问题通常需要考虑如何构建定理陈述的更通用版本，以提供足够充分的归纳假设。特别是，为了证明一个函数等价于一个累加器传递版本，需要一个将任意初始累加器值与原始函数的最终结果联系起来的定理陈述。"

#: src/programs-proofs/summary.md:46
#, fuzzy
msgid ""
"The type `Fin n` represents natural numbers that are strictly less than `n`."
" `Fin` is short for \"finite\". As with subtypes, a `Fin n` is a structure "
"that contains a `Nat` and a proof that this `Nat` is less than `n`. There "
"are no values of type `Fin 0`."
msgstr ""
"类型 `Fin n` 表示严格小于 `n` 的自然数。`Fin` 是「有限」的缩写。与子类型一样，`Fin n` 是一个包含 `Nat` 和证明这个 "
"`Nat` 小于 `n` 的结构体。没有类型为 `Fin 0` 的值。"

#: src/programs-proofs/summary.md:51
#, fuzzy
msgid ""
"If `arr` is an `Array α`, then `Fin arr.size` always contains a number that "
"is a suitable index into `arr`. Many of the built-in array operators, such "
"as `Array.swap`, take `Fin` values as arguments rather than separated proof "
"objects."
msgstr ""
"如果 `arr` 是一个 `Array α`，那么 `Fin arr.size` 总是包含一个适合作为 `arr` 索引的数字。许多内置数组运算符（例如"
" `Array.swap`）将 `Fin` 值作为参数，而不是分离的证明对象。"

#: src/programs-proofs/summary.md:54
#, fuzzy
msgid ""
"Lean provides instances of most of the useful numeric type classes for "
"`Fin`. The `OfNat` instances for `Fin` perform modular arithmetic rather "
"than failing at compile time if the number provided is larger than the `Fin`"
" can accept."
msgstr ""
"Lean 为 `Fin` 提供了大多数有用的数字类型类的实例。`Fin` 的 `OfNat` 实例执行模运算，而不是在提供的数字大于 `Fin` "
"可接受的数字时在编译时失败。"

#: src/programs-proofs/summary.md:57
#, fuzzy
msgid "Provisional Proofs"
msgstr "临时证明"

#: src/programs-proofs/summary.md:59
#, fuzzy
msgid ""
"Sometimes, it can be useful to pretend that a statement is proved without "
"actually doing the work of proving it. This can be useful when making sure "
"that a proof of a statement would be suitable for some task, such as a "
"rewrite in another proof, determining that an array access is safe, or "
"showing that a recursive call is made on a smaller value than the original "
"argument. It's very frustrating to spend time proving something, only to "
"discover that some other proof would have been more useful."
msgstr ""
"有时，假装一个陈述已被证明是有用的，而实际上并没有进行证明工作。这在确保一个陈述的证明是否适用于某些任务时很有用，例如在另一个证明中重写，确定数组访问是否安全，或显示递归调用是在比原始参数更小的值上进行的。花时间证明某件事，却发现其他一些证明更有用，这是非常令人沮丧的。"

#: src/programs-proofs/summary.md:63
#, fuzzy
msgid ""
"The `sorry` tactic causes Lean to provisionally accept a statement as if it "
"were a real proof. It can be seen as analogous to a stub method that throws "
"a `NotImplementedException` in C#. Any proof that relies on `sorry` includes"
" a warning in Lean."
msgstr ""
"`sorry` 策略使 Lean 临时接受一个陈述，就好像它是真正的证明一样。它可以看作类似于在 C# 中抛出 "
"`NotImplementedException` 的存根方法。任何依赖于 `sorry` 的证明都会在 Lean 中包含一个警告。"

#: src/programs-proofs/summary.md:67
#, fuzzy
msgid ""
"Be careful! The `sorry` tactic can prove _any_ statement, even false "
"statements. Proving that `3 < 2` can cause an out-of-bounds array access to "
"persist to runtime, unexpectedly crashing a program. Using `sorry` is "
"convenient during development, but keeping it in the code is dangerous."
msgstr ""
"小心！`sorry` 策略可以证明 _任何_ 陈述，甚至是错误的陈述。证明 `3 < 2` "
"可能会导致数组越界访问持续到运行时，意外地使程序崩溃。在开发过程中使用 `sorry` 很方便，但将其保留在代码中很危险。"

#: src/programs-proofs/summary.md:74
#, fuzzy
msgid ""
"When a recursive function does not use structural recursion, Lean cannot "
"automatically determine that it terminates. In these situations, the "
"function could just be marked `partial`. However, it is also possible to "
"provide a proof that the function terminates."
msgstr ""
"当一个递归函数不使用结构体递归时，Lean 无法自动确定它是否终止。在这些情况下，该函数可以标记为 "
"`partial`。但是，也可以提供证明函数终止的证明。"

#: src/programs-proofs/summary.md:78
#, fuzzy
msgid ""
"Partial functions have a key downside: they can't be unfolded during type "
"checking or in proofs. This means that Lean's value as an interactive "
"theorem prover can't be applied to them. Additionally, showing that a "
"function that is expected to terminate actually always does terminate "
"removes one more potential source of bugs."
msgstr ""
"部分函数有一个关键的缺点：它们不能在类型检查或证明中展开。这意味着 Lean "
"作为交互式定理证明器的价值不能应用于它们。此外，证明一个预期终止的函数实际上总是终止，消除了另一个潜在的错误来源。"

#: src/programs-proofs/summary.md:82
#, fuzzy
msgid ""
"The `termination_by` clause that's allowed at the end of a function can be "
"used to specify the reason why a recursive function terminates. The clause "
"maps the function's arguments to an expression that is expected to be "
"smaller for each recursive call. Some examples of expressions that might "
"decrease are the difference between a growing index into an array and the "
"array's size, the length of a list that's cut in half at each recursive "
"call, or a pair of lists, exactly one of which shrinks on each recursive "
"call."
msgstr ""
"递归函数末尾允许的 `termination_by` "
"子句可用于指定递归函数终止的原因。该子句将函数的参数映射到一个表达式，该表达式预期在每次递归调用时都会变小。可能减小的表达式的示例包括不断增长的数组索引与数组大小之间的差、每次递归调用时减半的列表长度，或一对列表，其中恰好一个在每次递归调用时缩小。"

#: src/programs-proofs/summary.md:86
#, fuzzy
msgid ""
"Lean contains proof automation that can automatically determine that some "
"expressions shrink with each call, but many interesting programs will "
"require manual proofs. These proofs can be provided with `have`, a version "
"of `let` that's intended for locally providing proofs rather than values."
msgstr ""
"Lean 包含证明自动化，可以自动确定某些表达式在每次调用时都会缩小，但许多有趣的程序需要手动证明。这些证明可以使用 `have` 提供，`have` "
"是 `let` 的一个版本，旨在局部提供证明而不是值。"

#: src/programs-proofs/summary.md:89
#, fuzzy
msgid ""
"A good way to write recursive functions is to begin by declaring them "
"`partial` and debugging them with testing until they return the right "
"answers. Then, `partial` can be removed and replaced with a `termination_by`"
" clause. Lean will place error highlights on each recursive call for which a"
" proof is needed that contains the statement that needs to be proved. Each "
"of these statements can be placed in a `have`, with the proof being `sorry`."
" If Lean accepts the program and it still passes its tests, the final step "
"is to actually prove the theorems that enable Lean to accept it. This "
"approach can prevent wasting time on proving that a buggy program "
"terminates."
msgstr ""
"编写递归函数的一个好方法是从声明它们为 `partial` 开始，并通过测试调试它们，直到它们返回正确的答案。然后，可以删除 `partial` 并用 "
"`termination_by` 子句替换它。Lean 会在需要证明的每个递归调用上放置错误高亮，其中包含需要证明的语句。每个这样的语句都可以放在 "
"`have` 中，证明为 `sorry`。如果 Lean 接受该程序并且它仍然通过测试，最后一步就是实际证明使 Lean "
"接受它的定理。这种方法可以防止浪费时间来证明一个有缺陷的程序终止。"

#: src/next-steps.md:3
#, fuzzy
msgid ""
"This book introduces the very basics of functional programming in Lean, "
"including a tiny amount of interactive theorem proving. Using dependently-"
"typed functional languages like Lean is a deep topic, and much can be said. "
"Depending on your interests, the following resources might be useful for "
"learning Lean 4."
msgstr ""
"本书介绍了 Lean 中函数式编程的基础知识，包括少量的交互式定理证明。使用像 Lean "
"这样的依值类型函数式语言是一个深入的话题，有很多内容可以讨论。根据您的兴趣，以下资源可能有助于学习 Lean 4。"

#: src/next-steps.md:7
#, fuzzy
msgid "Learning Lean"
msgstr "学习 Lean"

#: src/next-steps.md:9
#, fuzzy
msgid "Lean 4 itself is described in the following resources:"
msgstr "Lean 4 本身在以下资源中进行了描述："

#: src/next-steps.md:11
#, fuzzy
msgid ""
"[Theorem Proving in Lean 4](https://lean-lang.org/theorem_proving_in_lean4/)"
" is a tutorial on writing proofs using Lean."
msgstr ""
"[Lean 4 中的定理证明](https://lean-lang.org/theorem_proving_in_lean4/) 是一个使用 Lean "
"编写证明的教程。"

#: src/next-steps.md:12
#, fuzzy
msgid ""
"[The Lean 4 Manual](https://lean-lang.org/lean4/doc/) provides a reference "
"for the language and its features. At the time of writing, it is still "
"incomplete, but it describes many aspects of Lean in greater detail than "
"this book."
msgstr ""
"[Lean 4 手册](https://lean-lang.org/lean4/doc/) "
"提供了该语言及其特性的参考。在撰写本文时，它仍不完整，但它比本书更详细地描述了 Lean 的许多方面。"

#: src/next-steps.md:13
#, fuzzy
msgid ""
"[How To Prove It With Lean](https://djvelleman.github.io/HTPIwL/) is a Lean-"
"based accompaniment to the well-regarded textbook [_How To Prove "
"It_](https://www.cambridge.org/highereducation/books/how-to-prove-"
"it/6D2965D625C6836CD4A785A2C843B3DA) that provides an introduction to "
"writing paper-and-pencil mathematical proofs."
msgstr ""
"[用 Lean 证明](https://djvelleman.github.io/HTPIwL/) 是备受推崇的教科书 "
"[如何证明](https://www.cambridge.org/highereducation/books/how-to-prove-"
"it/6D2965D625C6836CD4A785A2C843B3DA) 的基于 Lean 的伴随教材，它提供了用纸笔编写数学证明的简介。"

#: src/next-steps.md:14
#, fuzzy
msgid ""
"[Metaprogramming in Lean "
"4](https://github.com/arthurpaulino/lean4-metaprogramming-book) provides an "
"overview of Lean's extension mechanisms, from infix operators and notations "
"to macros, custom tactics, and full-on custom embedded languages."
msgstr ""
"[Lean 4 中的元编程](https://github.com/arthurpaulino/lean4-metaprogramming-book) "
"提供了 Lean 扩展机制的概述，从中缀运算符和符号到宏、自定义策略和完全自定义的嵌入式语言。"

#: src/next-steps.md:15
#, fuzzy
msgid ""
"[Functional Programming in Lean](https://lean-"
"lang.org/functional_programming_in_lean/) may be interesting to readers who "
"enjoy jokes about recursion."
msgstr ""
"[Lean 中的函数式编程](https://lean-lang.org/functional_programming_in_lean/) "
"可能对喜欢递归笑话的读者感兴趣。"

#: src/next-steps.md:17
#, fuzzy
msgid ""
"However, the best way to continue learning Lean is to start reading and "
"writing code, consulting the documentation when you get stuck. Additionally,"
" the [Lean Zulip](https://leanprover.zulipchat.com/) is an excellent place "
"to meet other Lean users, ask for help, and help others."
msgstr ""
"然而，继续学习 Lean 的最佳方法是开始阅读和编写代码，在遇到困难时查阅文档。此外，[Lean "
"Zulip](https://leanprover.zulipchat.com/) 是结识其他 Lean 用户、寻求帮助和帮助他人的绝佳场所。"

#: src/next-steps.md:20
#, fuzzy
msgid "The Standard Library"
msgstr "标准库"

#: src/next-steps.md:22
#, fuzzy
msgid ""
"Out of the box, Lean itself includes a fairly minimal library. Lean is self-"
"hosted, and the included code is just enough to implement Lean itself. For "
"many applications, a larger standard library is needed."
msgstr ""
"开箱即用，Lean 本身包含一个相当小的库。Lean 是自托管的，并且包含的代码仅足以实现 Lean 本身。对于许多应用程序，需要更大的标准库。"

#: src/next-steps.md:26
#, fuzzy
msgid ""
"[std4](https://github.com/leanprover/std4) is an in-progress standard "
"library that includes many data structures, tactics, type class instances, "
"and functions that are out of scope for the Lean compiler itself. To use "
"`std4`, the first step is to find a commit in its history that's compatible "
"with the version of Lean 4 that you're using (that is, one in which the "
"`lean-toolchain` file matches the one in your project). Then, add the "
"following to the top level of your `lakefile.lean`, where `COMMIT_HASH` is "
"the appropriate version:"
msgstr ""
"[std4](https://github.com/leanprover/std4) "
"是一个正在进行中的标准库，其中包含许多数据结构体、策略、类型类实例和超出 Lean 编译器本身范围的函数。要使用 "
"`std4`，第一步是找到其历史记录中与你正在使用的 Lean 4 版本兼容的提交（即，其中 `lean-toolchain` "
"文件与你的项目中的文件匹配）。然后，将以下内容添加到 `lakefile.lean` 的顶层，其中 `COMMIT_HASH` 是适当的版本："

#: src/next-steps.md:29
msgid ""
"```lean\n"
"require std from git\n"
"  \"https://github.com/leanprover/std4/\" @ \"COMMIT_HASH\"\n"
"```"
msgstr ""

#: src/next-steps.md:35
#, fuzzy
msgid "Mathematics in Lean"
msgstr "数学在 Lean 中"

#: src/next-steps.md:37
#, fuzzy
msgid ""
"Most resources for mathematicians are written for Lean 3. A wide selection "
"are available at [the community site](https://leanprover-"
"community.github.io/learn.html). To get started doing mathematics in Lean 4,"
" it is probably easiest to participate in the process of porting the "
"mathematics library `mathlib` from Lean 3 to Lean 4. Please see the "
"[`mathlib4` README](https://github.com/leanprover-community/mathlib4) for "
"further information."
msgstr ""
"大多数数学家资源都是为 Lean 3 编写的。[社区网站](https://leanprover-"
"community.github.io/learn.html) 上提供了广泛的选择。要开始在 Lean 4 "
"中进行数学运算，最简单的方法可能是参与将数学库 `mathlib` 从 Lean 3 移植到 Lean 4 的过程。有关更多信息，请参阅 "
"[`mathlib4` 自述文件](https://github.com/leanprover-community/mathlib4)。"

#: src/next-steps.md:42
#, fuzzy
msgid "Using Dependent Types in Computer Science"
msgstr "在计算机科学中使用依值类型"

#: src/next-steps.md:44
#, fuzzy
msgid ""
"Coq is a language that has a lot in common with Lean. For computer "
"scientists, the [Software "
"Foundations](https://softwarefoundations.cis.upenn.edu/) series of "
"interactive textbooks provides an excellent introduction to applications of "
"Coq in computer science. The fundamental ideas of Lean and Coq are very "
"similar, and skills are readily transferable between the systems."
msgstr ""
"Coq 是一种与 Lean "
"有很多共同点的语言。对于计算机科学家来说，[软件基础](https://softwarefoundations.cis.upenn.edu/) "
"系列互动教科书提供了 Coq 在计算机科学中的应用的精彩介绍。Lean 和 Coq 的基本思想非常相似，技能可以在系统之间轻松转移。"

#: src/next-steps.md:50
#, fuzzy
msgid ""
"For programmers who are interested in learning to use indexed families and "
"dependent types to structure programs, Edwin Brady's [_Type Driven "
"Development with Idris_](https://www.manning.com/books/type-driven-"
"development-with-idris) provides an excellent introduction. Like Coq, Idris "
"is a close cousin of Lean, though it lacks tactics."
msgstr ""
"对于有兴趣学习使用索引族和依值类型来构建程序的程序员，埃德温·布雷迪的 [_使用 Idris "
"进行类型驱动开发_](https://www.manning.com/books/type-driven-development-with-idris)"
" 提供了一个精彩的介绍。与 Coq 一样，Idris 是 Lean 的近亲，尽管它缺乏策略。"

#: src/next-steps.md:53
msgid "Understanding Dependent Types"
msgstr ""

#: src/next-steps.md:55
msgid ""
"[_The Little Typer_](https://thelittletyper.com/) is a book for programmers "
"who haven't formally studied logic or the theory of programming languages, "
"but who want to build an understanding of the core ideas of dependent type "
"theory. While all of the above resources aim to be as practical as possible,"
" _The Little Typer_ presents an approach to dependent type theory where the "
"very basics are built up from scratch, using only concepts from programming."
" Disclaimer: the author of _Functional Programming in Lean_ is also an "
"author of _The Little Typer_."
msgstr ""
