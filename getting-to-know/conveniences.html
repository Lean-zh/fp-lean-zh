<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>其他便利功能 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html" class="active"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的法则</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/getting-to-know/conveniences.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Additional Conveniences
-->
<h1 id="其他便利功能"><a class="header" href="#其他便利功能">其他便利功能</a></h1>
<!--
Lean contains a number of convenience features that make programs much more concise.
-->
<p>Lean 包含许多便利功能，能够让程序更加简洁。</p>
<!--
## Automatic Implicit Arguments
-->
<h2 id="自动隐式参数"><a class="header" href="#自动隐式参数">自动隐式参数</a></h2>
<!--
When writing polymorphic functions in Lean, it is typically not necessary to list all the implicit arguments.
Instead, they can simply be mentioned.
If Lean can determine their type, then they are automatically inserted as implicit arguments.
In other words, the previous definition of `length`:
-->
<p>在 Lean 中编写多态函数时，通常不必列出所有隐式参数。相反，它们可以简单地被提及。
如果 Lean 可以确定它们的类型，那么它们将自动插入为隐式参数。换句话说，<code>length</code> 的先前定义：</p>
<pre><code class="language-lean">def length {α : Type} (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<!--
can be written without `{α : Type}`:
-->
<p>可以不写 <code>{α : Type}</code>:</p>
<pre><code class="language-lean">def length (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<!--
This can greatly simplify highly polymorphic definitions that take many implicit arguments.
-->
<p>这能极大简化地需要很多隐式参数的高级多态定义。</p>
<!--
## Pattern-Matching Definitions
-->
<h2 id="模式匹配定义"><a class="header" href="#模式匹配定义">模式匹配定义</a></h2>
<!--
When defining functions with `def`, it is quite common to name an argument and then immediately use it with pattern matching.
For instance, in `length`, the argument `xs` is used only in `match`.
In these situations, the cases of the `match` expression can be written directly, without naming the argument at all.
-->
<p>用 <code>def</code> 定义函数时，通常会给参数命名，然后立即用模式匹配使用它。
例如，在 <code>length</code> 中，参数 <code>xs</code> 仅在 <code>match</code> 中使用。在这些情况下，<code>match</code>
表达式的 <code>case</code> 可以直接编写，而无需给参数命名。</p>
<!--
The first step is to move the arguments' types to the right of the colon, so the return type is a function type.
For instance, the type of `length` is `List α → Nat`.
Then, replace the `:=` with each case of the pattern match:
-->
<p>第一步是将参数类型移到冒号的右侧，因此返回类型是函数类型。例如，<code>length</code> 的类型是
<code>List α → Nat</code>。然后，用模式匹配的每个 case 替换 <code>:=</code>：</p>
<pre><code class="language-lean">def length : List α → Nat
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<!--
This syntax can also be used to define functions that take more than one argument.
In this case, their patterns are separated by commas.
For instance, `drop` takes a number \\( n \\) and a list, and returns the list after removing the first \\( n \\) entries.
-->
<p>此语法还可用于定义接受多个参数的函数。在这种情况下，它们的模式用逗号分隔。
例如，<code>drop</code> 接受一个数字 \( n \) 和一个列表，并返回删除前 \( n \) 个条目的列表。</p>
<pre><code class="language-lean">def drop : Nat → List α → List α
  | Nat.zero, xs =&gt; xs
  | _, [] =&gt; []
  | Nat.succ n, x :: xs =&gt; drop n xs
</code></pre>
<!--
Named arguments and patterns can also be used in the same definition.
For instance, a function that takes a default value and an optional value, and returns the default when the optional value is `none`, can be written:
-->
<p>已命名的参数和模式也可以在同一定义中使用。例如，一个函数接受一个默认值和一个可选值，
当可选值为 <code>none</code> 时返回默认值，可以写成：</p>
<pre><code class="language-lean">def fromOption (default : α) : Option α → α
  | none =&gt; default
  | some x =&gt; x
</code></pre>
<!--
This function is called `Option.getD` in the standard library, and can be called with dot notation:
-->
<p>此函数在标准库中称为 <code>Option.getD</code>，可以用点表示法调用：</p>
<pre><code class="language-lean">#eval (some &quot;salmonberry&quot;).getD &quot;&quot;
</code></pre>
<pre><code class="language-output info">&quot;salmonberry&quot;
</code></pre>
<pre><code class="language-lean">#eval none.getD &quot;&quot;
</code></pre>
<pre><code class="language-output info">&quot;&quot;
</code></pre>
<!--
## Local Definitions
-->
<h2 id="局部定义"><a class="header" href="#局部定义">局部定义</a></h2>
<!--
It is often useful to name intermediate steps in a computation.
In many cases, intermediate values represent useful concepts all on their own, and naming them explicitly can make the program easier to read.
In other cases, the intermediate value is used more than once.
As in most other languages, writing down the same code twice in Lean causes it to be computed twice, while saving the result in a variable leads to the result of the computation being saved and re-used.
-->
<p>在计算中对中间步骤命名通常很有用。在许多情况下，中间值本身就代表有用的概念，
明确地命名它们可以使程序更易于阅读。在其他情况下，中间值被使用多次。与大多数其他语言一样，
在 Lean 中两次写下相同的代码会导致计算两次，而将结果保存在变量中会导致计算的结果被保存并重新使用。</p>
<!--
For instance, `unzip` is a function that transforms a list of pairs into a pair of lists.
When the list of pairs is empty, then the result of `unzip` is a pair of empty lists.
When the list of pairs has a pair at its head, then the two fields of the pair are added to the result of unzipping the rest of the list.
This definition of `unzip` follows that description exactly:
-->
<p>例如，<code>unzip</code> 是一个将偶对的列表转换为一对列表的函数。当偶对列表为空时，
<code>unzip</code> 的结果是一对空列表。当偶对列表的头部有一个偶对时，
则该偶对的两个字段将添加到列表的其余部分 <code>unzip</code> 后的结果中。
以下 <code>unzip</code> 的定义完全遵循该描述：</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    (x :: (unzip xys).fst, y :: (unzip xys).snd)
</code></pre>
<!--
Unfortunately, there is a problem: this code is slower than it needs to be.
Each entry in the list of pairs leads to two recursive calls, which makes this function take exponential time.
However, both recursive calls will have the same result, so there is no reason to make the recursive call twice.
-->
<p>不幸的是，这里存在一个问题：此代码比预期的速度要慢。
对列表中的每个条目都会导致两个递归调用，这使得此函数需要指数时间。
然而，两个递归调用都会有相同的结果，因此没有理由进行两次递归调用。</p>
<!--
In Lean, the result of the recursive call can be named, and thus saved, using `let`.
Local definitions with `let` resemble top-level definitions with `def`: it takes a name to be locally defined, arguments if desired, a type signature, and then a body following `:=`.
After the local definition, the expression in which the local definition is available (called the _body_ of the `let`-expression) must be on a new line, starting at a column in the file that is less than or equal to that of the `let` keyword.
For instance, `let` can be used in `unzip` like this:
-->
<p>在 Lean 中，可以使用 <code>let</code> 命名递归调用的结果，从而保存它。
使用 <code>let</code> 的局部定义类似于使用 <code>def</code> 的顶层定义：它需要一个局部定义的名称，
如果需要的话，还有参数、类型签名，然后是 <code>:=</code> 后面的主体。在局部定义之后，
局部定义可用的表达式（称为 <code>let</code> 表达式的 <strong>主体</strong> ）必须在新行上，
从文件中的列开始，该列小于或等于 <code>let</code> 关键字的列。
例如，<code>let</code> 可以像这样用于 <code>unzip</code>：</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped : List α × List β := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<!--
To use `let` on a single line, separate the local definition from the body with a semicolon.
-->
<p>要在单行中使用 <code>let</code>，请使用分号将局部定义与主体分隔开。</p>
<!--
Local definitions with `let` may also use pattern matching when one pattern is enough to match all cases of a datatype.
In the case of `unzip`, the result of the recursive call is a pair.
Because pairs have only a single constructor, the name `unzipped` can be replaced with a pair pattern:
-->
<p>当一个模式足以匹配数据类型的全部情况时，使用 <code>let</code> 的局部定义也可以使用模式匹配。
在 <code>unzip</code> 的情况下，递归调用的结果是个偶对。因为偶对只有一个构造子，所以名称
<code>unzipped</code> 可以替换为偶对模式：</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let (xs, ys) : List α × List β := unzip xys
    (x :: xs, y :: ys)
</code></pre>
<!--
Judicious use of patterns with `let` can make code easier to read, compared to writing the accessor calls by hand.
-->
<p>巧妙地使用带有 <code>let</code> 的模式可以使代码更易读，而无需手动编写访问器调用。</p>
<!--
The biggest difference between `let` and `def` is that recursive `let` definitions must be explicitly indicated by writing `let rec`.
For instance, one way to reverse a list involves a recursive helper function, as in this definition:
-->
<p><code>let</code> 和 <code>def</code> 之间最大的区别在于，递归 <code>let</code> 定义必须通过编写 <code>let rec</code> 明确表示。
例如，反转列表的一种方法涉及递归辅助函数，如下所示：</p>
<pre><code class="language-lean">def reverse (xs : List α) : List α :=
  let rec helper : List α → List α → List α
    | [], soFar =&gt; soFar
    | y :: ys, soFar =&gt; helper ys (y :: soFar)
  helper xs []
</code></pre>
<!--
The helper function walks down the input list, moving one entry at a time over to `soFar`.
When it reaches the end of the input list, `soFar` contains a reversed version of the input.
-->
<p>辅助函数遍历输入列表，一次将一个条目移动到 <code>soFar</code>。
当它到达输入列表的末尾时，<code>soFar</code> 包含输入的反转版本。</p>
<!--
## Type Inference
-->
<h2 id="类型推断"><a class="header" href="#类型推断">类型推断</a></h2>
<!--
In many situations, Lean can automatically determine an expression's type.
In these cases, explicit types may be omitted from both top-level definitions (with `def`) and local definitions (with `let`).
For instance, the recursive call to `unzip` does not need an annotation:
-->
<p>在许多情况下，Lean 可以自动确定表达式的类型。在这些情况下，
可以从顶层定义（使用 <code>def</code>）和局部定义（使用 <code>let</code>）中省略显式类型。
例如，对 <code>unzip</code> 的递归调用不需要标注：</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<!--
As a rule of thumb, omitting the types of literal values (like strings and numbers) usually works, although Lean may pick a type for literal numbers that is more specific than the intended type.
Lean can usually determine a type for a function application, because it already knows the argument types and the return type.
Omitting return types for function definitions will often work, but function arguments typically require annotations.
Definitions that are not functions, like `unzipped` in the example, do not need type annotations if their bodies do not need type annotations, and the body of this definition is a function application.
-->
<p>根据经验，省略字面量（如字符串和数字）的类型通常有效，
尽管 Lean 可能会为字面量数字选择比预期类型更具体的类型。
Lean 通常可以确定函数应用的类型，因为它已经知道参数类型和返回类型。
省略函数定义的返回类型通常有效，但函数参数通常需要标注。
对于非函数的定义（如示例中的 <code>unzipped</code>），若其主体不需要类型标注，
且该定义的主体是一个函数应用，则该定义不需要类型标注</p>
<!--
Omitting the return type for `unzip` is possible when using an explicit `match` expression:
-->
<p>在使用显式 <code>match</code> 表达式时，可省略 <code>unzip</code> 的返回类型：</p>
<pre><code class="language-lean">def unzip (pairs : List (α × β)) :=
  match pairs with
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<!--
Generally speaking, it is a good idea to err on the side of too many, rather than too few, type annotations.
First off, explicit types communicate assumptions about the code to readers.
Even if Lean can determine the type on its own, it can still be easier to read code without having to repeatedly query Lean for type information.
Secondly, explicit types help localize errors.
The more explicit a program is about its types, the more informative the error messages can be.
This is especially important in a language like Lean that has a very expressive type system.
Thirdly, explicit types make it easier to write the program in the first place.
The type is a specification, and the compiler's feedback can be a helpful tool in writing a program that meets the specification.
Finally, Lean's type inference is a best-effort system.
Because Lean's type system is so expressive, there is no "best" or most general type to find for all expressions.
This means that even if you get a type, there's no guarantee that it's the _right_ type for a given application.
For instance, `14` can be a `Nat` or an `Int`:
-->
<p>一般来说，宁可多加类型标注，也不要太少。首先，显式类型向读者传达了对代码的假设。
即使 Lean 可以自行确定类型，但无需反复查询 Lean 以获取类型信息，代码仍然更容易阅读。
其次，显式类型有助于定位错误。程序对其类型越明确，错误消息就越有信息量。
这在 Lean 这样的具有非常丰富的类型系统的语言中尤为重要。第三，显式类型使编写程序变得更容易。
类型是一种规范，编译器的反馈可以成为编写符合规范的程序的有用工具。
最后，Lean 的类型推断是一种尽力而为的系统。由于 Lean 的类型系统非常丰富，
因此无法为所有表达式找到「最佳」或最通用的类型。这意味着即使你得到了一个类型，
也不能保证它是给定应用的「正确」类型。例如，<code>14</code> 可以是 <code>Nat</code> 或 <code>Int</code>：</p>
<pre><code class="language-lean">#check 14
</code></pre>
<pre><code class="language-output info">14 : Nat
</code></pre>
<pre><code class="language-lean">#check (14 : Int)
</code></pre>
<pre><code class="language-output info">14 : Int
</code></pre>
<!--
Missing type annotations can give confusing error messages.
Omitting all types from the definition of `unzip`:
-->
<p>缺少类型标注可能会产生令人困惑的错误信息。从 <code>unzip</code> 的定义中省略所有类型：</p>
<pre><code class="language-lean">def unzip pairs :=
  match pairs with
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>会产生有关 <code>match</code> 表达式的信息：</p>
<pre><code class="language-output error">invalid match-expression, pattern contains metavariables
  []
</code></pre>
<!--
This is because `match` needs to know the type of the value being inspected, but that type was not available.
A "metavariable" is an unknown part of a program, written `?m.XYZ` in error messages—they are described in the [section on Polymorphism](polymorphism.md).
In this program, the type annotation on the argument is required.
-->
<p>这是因为 <code>match</code> 需要知道正在检查的值的类型，但该类型不可用。
「元变量」是程序中未知的部分，在错误消息中写为 <code>?m.XYZ</code>，
它们在<a href="polymorphism.html">多态性</a>一节中进行了描述。
在此程序中，参数上的类型标注是必需的。</p>
<!--
Even some very simple programs require type annotations.
For instance, the identity function just returns whatever argument it is passed.
With argument and type annotations, it looks like this:
-->
<p>即使一些非常简单的程序也需要类型标注。例如，恒等函数只返回传递给它的任何参数。
使用参数和类型标注，它看起来像这样：</p>
<pre><code class="language-lean">def id (x : α) : α := x
</code></pre>
<!--
Lean is capable of determining the return type on its own:
-->
<p>Lean 能够自行确定返回类型：</p>
<pre><code class="language-lean">def id (x : α) := x
</code></pre>
<!--
Omitting the argument type, however, causes an error:
-->
<p>然而，省略参数类型会导致错误：</p>
<pre><code class="language-lean">def id x := x
</code></pre>
<pre><code class="language-output error">failed to infer binder type
</code></pre>
<!--
In general, messages that say something like "failed to infer" or that mention metavariables are often a sign that more type annotations are necessary.
Especially while still learning Lean, it is useful to provide most types explicitly.
-->
<p>一般来说，类似于「无法推断」或提及元变量的消息通常表示需要更多类型标注。
特别是在学习 Lean 时，显式提供大多数类型是很有用的。</p>
<!--
## Simultaneous Matching
-->
<h2 id="同时匹配"><a class="header" href="#同时匹配">同时匹配</a></h2>
<!--
Pattern-matching expressions, just like pattern-matching definitions, can match on multiple values at once.
Both the expressions to be inspected and the patterns that they match against are written with commas between them, similarly to the syntax used for definitions.
Here is a version of `drop` that uses simultaneous matching:
-->
<p>模式匹配表达式，和模式匹配定义一样，可以一次匹配多个值。
要检查的表达式和它们匹配的模式都用逗号分隔，类似于用于定义的语法。
以下是使用同时匹配的 <code>drop</code> 版本：</p>
<pre><code class="language-lean">def drop (n : Nat) (xs : List α) : List α :=
  match n, xs with
  | Nat.zero, ys =&gt; ys
  | _, [] =&gt; []
  | Nat.succ n , y :: ys =&gt; drop n ys
</code></pre>
<!--
## Natural Number Patterns
-->
<h2 id="自然数模式"><a class="header" href="#自然数模式">自然数模式</a></h2>
<!--
In the section on [datatypes and patterns](datatypes-and-patterns.md), `even` was defined like this:
-->
<p>在<a href="datatypes-and-patterns.html">数据类型与模式</a>一节中，<code>even</code> 被定义为：</p>
<pre><code class="language-lean">def even (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (even k)
</code></pre>
<!--
Just as there is special syntax to make list patterns more readable than using `List.cons` and `List.nil` directly, natural numbers can be matched using literal numbers and `+`.
For instance, `even` can also be defined like this:
-->
<p>就像列表模式的特殊语法比直接使用 <code>List.cons</code> 和 <code>List.nil</code> 更具可读性一样，
自然数可以使用字面数字和 <code>+</code> 进行匹配。例如，<code>even</code> 也可以这样定义：</p>
<pre><code class="language-lean">def even : Nat → Bool
  | 0 =&gt; true
  | n + 1 =&gt; not (even n)
</code></pre>
<!--
In this notation, the arguments to the `+` pattern serve different roles.
Behind the scenes, the left argument (`n` above) becomes an argument to some number of `Nat.succ` patterns, and the right argument (`1` above) determines how many `Nat.succ`s to wrap around the pattern.
The explicit patterns in `halve`, which divides a `Nat` by two and drops the remainder:
-->
<p>在此记法中，<code>+</code> 模式的参数扮演着不同的角色。在幕后，左参数（上面的 <code>n</code>）成为一些
<code>Nat.succ</code> 模式的参数，右参数（上面的 <code>1</code>）确定包裹该模式的 <code>Nat.succ</code> 数量有多少。
<code>halve</code> 中的显式模式将 <code>Nat</code> 除以二并丢弃余数：</p>
<pre><code class="language-lean">def halve : Nat → Nat
  | Nat.zero =&gt; 0
  | Nat.succ Nat.zero =&gt; 0
  | Nat.succ (Nat.succ n) =&gt; halve n + 1
</code></pre>
<!--
can be replaced by numeric literals and `+`:
-->
<p>可用数值字面量和 <code>+</code> 代替：</p>
<pre><code class="language-lean">def halve : Nat → Nat
  | 0 =&gt; 0
  | 1 =&gt; 0
  | n + 2 =&gt; halve n + 1
</code></pre>
<!--
Behind the scenes, both definitions are completely equivalent.
Remember: `halve n + 1` is equivalent to `(halve n) + 1`, not `halve (n + 1)`.
-->
<p>在幕后，这两个定义完全等价。记住：<code>halve n + 1</code> 等价于 <code>(halve n) + 1</code>，而非 <code>halve (n + 1)</code>。</p>
<!--
When using this syntax, the second argument to `+` should always be a literal `Nat`.
Even though addition is commutative, flipping the arguments in a pattern can result in errors like the following:
-->
<p>在使用这个语法时，<code>+</code>的第二个参数应始终是一个字面量 <code>Nat</code>。
尽管加法是可交换的，但是在模式中交换参数可能会产生以下错误：</p>
<pre><code class="language-lean">def halve : Nat → Nat
  | 0 =&gt; 0
  | 1 =&gt; 0
  | 2 + n =&gt; halve n + 1
</code></pre>
<pre><code class="language-output error">invalid patterns, `n` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching
  .(Nat.add 2 n)
</code></pre>
<!--
This restriction enables Lean to transform all uses of the `+` notation in a pattern into uses of the underlying `Nat.succ`, keeping the language simpler behind the scenes.
-->
<p>此限制使 Lean 能够将模式中所有 <code>+</code> 号的用法转换为底层 <code>Nat.succ</code> 的用法，
从而在幕后使语言更简单。</p>
<!--
## Anonymous Functions
-->
<h2 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h2>
<!--
Functions in Lean need not be defined at the top level.
As expressions, functions are produced with the `fun` syntax.
Function expressions begin with the keyword `fun`, followed by one or more arguments, which are separated from the return expression using `=>`.
For instance, a function that adds one to a number can be written:
-->
<p>Lean 中的函数不必在顶层定义。作为表达式，函数使用 <code>fun</code> 语法定义。
函数表达式以关键字 <code>fun</code> 开头，后跟一个或多个参数，这些参数使用 <code>=&gt;</code> 与返回表达式分隔。
例如，可以编写一个将数字加 1 的函数：</p>
<pre><code class="language-lean">#check fun x =&gt; x + 1
</code></pre>
<pre><code class="language-output info">fun x =&gt; x + 1 : Nat → Nat
</code></pre>
<!--
Type annotations are written the same way as on `def`, using parentheses and colons:
-->
<p>类型标注的写法与 <code>def</code> 相同，使用括号和冒号：</p>
<pre><code class="language-lean">#check fun (x : Int) =&gt; x + 1
</code></pre>
<pre><code class="language-output info">fun x =&gt; x + 1 : Int → Int
</code></pre>
<!--
Similarly, implicit arguments may be written with curly braces:
-->
<p>同样，隐式参数可以用大括号编写：</p>
<pre><code class="language-lean">#check fun {α : Type} (x : α) =&gt; x
</code></pre>
<pre><code class="language-output info">fun {α} x =&gt; x : {α : Type} → α → α
</code></pre>
<!--
This style of anonymous function expression is often referred to as a _lambda expression_, because the typical notation used in mathematical descriptions of programming languages uses the Greek letter λ (lambda) where Lean has the keyword `fun`.
Even though Lean does permit `λ` to be used instead of `fun`, it is most common to write `fun`.
-->
<p>这种匿名函数表达式风格通常称为 <strong>λ-表达式（Lambda Expression）</strong> ，
因为编程语言在数学描述中使用的典型符号，将 Lean 中使用关键字 <code>fun</code>
的地方换成了希腊字母 λ（Lambda）。即使 Lean 允许使用 <code>λ</code> 代替 <code>fun</code>，
但最常见的仍然是写作 <code>fun</code>。</p>
<!--
Anonymous functions also support the multiple-pattern style used in `def`.
For instance, a function that returns the predecessor of a natural number if it exists can be written:
-->
<p>匿名函数还支持 <code>def</code> 中使用的多模式风格。例如，可以编写一个返回自然数的前驱（如果存在）的函数：</p>
<pre><code class="language-lean">#check fun
  | 0 =&gt; none
  | n + 1 =&gt; some n
</code></pre>
<pre><code class="language-output info">fun x =&gt;
  match x with
  | 0 =&gt; none
  | Nat.succ n =&gt; some n : Nat → Option Nat
</code></pre>
<!--
Note that Lean's own description of the function has a named argument and a `match` expression.
Many of Lean's convenient syntactic shorthands are expanded to simpler syntax behind the scenes, and the abstraction sometimes leaks.
-->
<p>注意，Lean 函数的描述本身有一个命名参数和一个 <code>match</code> 表达式。
Lean 的许多便捷语法缩写都会在幕后扩展为更简单的语法，但有时会泄漏抽象，暴露出具体细节。</p>
<!--
Definitions using `def` that take arguments may be rewritten as function expressions.
For instance, a function that doubles its argument can be written as follows:
-->
<p>使用 <code>def</code> 定义带有参数的函数可以重写为函数表达式。例如，一个将其参数翻倍的函数可以写成以下形式：</p>
<pre><code class="language-lean">def double : Nat → Nat := fun
  | 0 =&gt; 0
  | k + 1 =&gt; double k + 2
</code></pre>
<!--
When an anonymous function is very simple, like `fun x => x + 1`, the syntax for creating the function can be fairly verbose.
In that particular example, six non-whitespace characters are used to introduce the function, and its body consists of only three non-whitespace characters.
For these simple cases, Lean provides a shorthand.
In an expression surrounded by parentheses, a centered dot character `·` can stand for an argument, and the expression inside the parentheses becomes the function's body.
That particular function can also be written `(· + 1)`.
-->
<p>当匿名函数非常简单时，例如 <code>fun x =&gt; x + 1</code>，
创建函数的语法会相当冗长。在此例中，有六个非空白字符用于引入函数，
其函数体仅包含三个非空白字符。对于这些简单的情况，Lean 提供了一个简写。
在括号包围的表达式中，间点号 <code>·</code> 可以表示一个参数，括号内的表达式为函数体，
因此该函数也可以写成 <code>(· + 1)</code>。</p>
<!--
The centered dot always creates a function out of the _closest_ surrounding set of parentheses.
For instance, `(· + 5, 3)` is a function that returns a pair of numbers, while `((· + 5), 3)` is a pair of a function and a number.
If multiple dots are used, then they become arguments from left to right:
-->
<p>间点号总是将 <strong>最靠近</strong> 的一对括号创建为函数。
例如，<code>(· + 5, 3)</code> 是返回一对数字的函数，
而 <code>((· + 5), 3)</code> 是一个函数和一个数字的偶对。
如果使用多个点，则它们按从左到右的顺序成为参数：</p>
<pre><code class="language-lean">(· , ·) 1 2
===&gt;
(1, ·) 2
===&gt;
(1, 2)
</code></pre>
<!--
Anonymous functions can be applied in precisely the same way as functions defined using `def` or `let`.
The command `#eval (fun x => x + x) 5` results in:
-->
<p>匿名函数的应用方式与 <code>def</code> 或 <code>let</code> 定义的函数完全相同。
命令 <code>#eval (fun x =&gt; x + x) 5</code> 的结果是：</p>
<pre><code class="language-output info">10
</code></pre>
<!--
while `#eval (· * 2) 5` results in:
-->
<p>而 <code>#eval (· * 2) 5</code> 的结果是：</p>
<pre><code class="language-output info">10
</code></pre>
<!--
## Namespaces
-->
<h2 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h2>
<!--
Each name in Lean occurs in a _namespace_, which is a collection of names.
Names are placed in namespaces using `.`, so `List.map` is the name `map` in the `List` namespace.
Names in different namespaces do not conflict with each other, even if they are otherwise identical.
This means that `List.map` and `Array.map` are different names.
Namespaces may be nested, so `Project.Frontend.User.loginTime` is the name `loginTime` in the nested namespace `Project.Frontend.User`.
-->
<p>Lean 中的每个名称都出现在一个 <strong>命名空间（Namespace）</strong> 中，它是一个名称的集合。
名称使用 <code>.</code> 放在命名空间中，因此 <code>List.map</code> 是 <code>List</code> 命名空间中的名称 <code>map</code>。
不同命名空间中的名称不会相互冲突，即使它们在其他方面是相同的。
这意味着 <code>List.map</code> 和 <code>Array.map</code> 是不同的名称。
命名空间可以嵌套，因此 <code>Project.Frontend.User.loginTime</code> 是嵌套命名空间
<code>Project.Frontend.User</code> 中的名称 <code>loginTime</code>。</p>
<!--
Names can be directly defined within a namespace.
For instance, the name `double` can be defined in the `Nat` namespace:
-->
<p>命名空间中可以直接定义名称。例如，名称 <code>double</code> 可以定义在 <code>Nat</code> 命名空间中：</p>
<pre><code class="language-lean">def Nat.double (x : Nat) : Nat := x + x
</code></pre>
<!--
Because `Nat` is also the name of a type, dot notation is available to call `Nat.double` on expressions with type `Nat`:
-->
<p>由于 <code>Nat</code> 也是一个类型的名称，因此可以使用点记法对类型为 <code>Nat</code> 的表达式调用 <code>Nat.double</code>：</p>
<pre><code class="language-lean">#eval (4 : Nat).double
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<!--
In addition to defining names directly in a namespace, a sequence of declarations can be placed in a namespace using the `namespace` and `end` commands.
For instance, this defines `triple` and `quadruple` in the namespace `NewNamespace`:
-->
<p>除了直接在命名空间中定义名称外，还可以使用 <code>namespace</code> 和 <code>end</code>
命令将一系列声明放在命名空间中。例如，以下代码在 <code>NewNamespace</code> 命名空间中定义了
<code>triple</code> 和 <code>quadruple</code>：</p>
<pre><code class="language-lean">namespace NewNamespace
def triple (x : Nat) : Nat := 3 * x
def quadruple (x : Nat) : Nat := 2 * x + 2 * x
end NewNamespace
</code></pre>
<!--
To refer to them, prefix their names with `NewNamespace.`:
-->
<p>要引用它们，请在其名称前加上 <code>NewNamespace.</code>：</p>
<pre><code class="language-lean">#check NewNamespace.triple
</code></pre>
<pre><code class="language-output info">NewNamespace.triple (x : Nat) : Nat
</code></pre>
<pre><code class="language-lean">#check NewNamespace.quadruple
</code></pre>
<pre><code class="language-output info">NewNamespace.quadruple (x : Nat) : Nat
</code></pre>
<!--
Namespaces may be _opened_, which allows the names in them to be used without explicit qualification.
Writing `open MyNamespace in` before an expression causes the contents of `MyNamespace` to be available in the expression.
For example, `timesTwelve` uses both `quadruple` and `triple` after opening `NewNamespace`:
-->
<p>命名空间可以 <strong>打开</strong> ，这允许在不显式指定的情况下使用其中的名称。
在表达式之前编写 <code>open MyNamespace in</code> 会使 <code>MyNamespace</code>
中的内容在表达式中可用。例如，<code>timesTwelve</code> 在打开 <code>NewNamespace</code> 后同时使用了
<code>quadruple</code> 和 <code>triple</code>：</p>
<pre><code class="language-lean">def timesTwelve (x : Nat) :=
  open NewNamespace in
  quadruple (triple x)
</code></pre>
<!--
Namespaces can also be opened prior to a command.
This allows all parts of the command to refer to the contents of the namespace, rather than just a single expression.
To do this, place the `open ... in` prior to the command.
-->
<p>命名空间也可以在命令之前打开。这能让命令中的所有部分引用命名空间的内容，
而不仅仅是一个表达式。为此，请在命令之前写上 <code>open ... in</code>。</p>
<pre><code class="language-lean">open NewNamespace in
#check quadruple
</code></pre>
<pre><code class="language-output info">NewNamespace.quadruple (x : Nat) : Nat
</code></pre>
<!--
Function signatures show the name's full namespace.
Namespaces may additionally be opened for _all_ following commands for the rest of the file.
To do this, simply omit the `in` from a top-level usage of `open`.
-->
<p>函数签名会显示名称的完整命名空间，还可以为文件其余部分的所有后续命令打开命名空间。
为此，只需从 <code>open</code> 的顶级用法中省略 <code>in</code>。</p>
<!--
## if let
-->
<h2 id="if-let"><a class="header" href="#if-let">if let</a></h2>
<!--
When consuming values that have a sum type, it is often the case that only a single constructor is of interest.
For instance, given this type that represents a subset of Markdown inline elements:
-->
<p>在使用具有和类型的值时，通常只对一个构造子感兴趣。
例如，给定一个表示 Markdown 内联元素子集的类型：</p>
<pre><code class="language-lean">inductive Inline : Type where
  | lineBreak
  | string : String → Inline
  | emph : Inline → Inline
  | strong : Inline → Inline
</code></pre>
<!--
a function that recognizes string elements and extracts their contents can be written:
-->
<p>可以编写一个识别字符串元素并提取其内容的函数：</p>
<pre><code class="language-lean">def Inline.string? (inline : Inline) : Option String :=
  match inline with
  | Inline.string s =&gt; some s
  | _ =&gt; none
</code></pre>
<!--
An alternative way of writing this function's body uses `if` together with `let`:
-->
<p>另一种编写此函数体的方法是将 <code>if</code> 与 <code>let</code> 联用：</p>
<pre><code class="language-lean">def Inline.string? (inline : Inline) : Option String :=
  if let Inline.string s := inline then
    some s
  else none
</code></pre>
<!--
This is very much like the pattern-matching `let` syntax.
The difference is that it can be used with sum types, because a fallback is provided in the `else` case.
In some contexts, using `if let` instead of `match` can make code easier to read.
-->
<p>这与模式匹配 <code>let</code> 的语法非常相似，不同之处在于它可以与和类型一起使用，
因为在 <code>else</code> 的情况中提供了备选项。在某些情况下，使用 <code>if let</code> 代替
<code>match</code> 可以让代码更易读。</p>
<!--
## Positional Structure Arguments
-->
<h2 id="带位置的结构体参数"><a class="header" href="#带位置的结构体参数">带位置的结构体参数</a></h2>
<!--
The [section on structures](structures.md) presents two ways of constructing structures:

 1. The constructor can be called directly, as in `Point.mk 1 2`.
 2. Brace notation can be used, as in `{ x := 1, y := 2 }`.
-->
<p><a href="structures.html">结构体</a>一节中介绍了构造结构体的两种方法：</p>
<ol>
<li>构造子可以直接调用，如 <code>Point.mk 1 2</code>.</li>
<li>可以使用大括号记法，如 <code>{ x := 1, y := 2 }</code>.</li>
</ol>
<!--
In some contexts, it can be convenient to pass arguments positionally, rather than by name, but without naming the constructor directly.
For instance, defining a variety of similar structure types can help keep domain concepts separate, but the natural way to read the code may treat each of them as being essentially a tuple.
In these contexts, the arguments can be enclosed in angle brackets `⟨` and `⟩`.
A `Point` can be written `⟨1, 2⟩`.
Be careful!
Even though they look like the less-than sign `<` and greater-than sign `>`, these brackets are different.
They can be input using `\<` and `\>`, respectively.
-->
<p>在某些情况下，按位置传递参数要比按名称传递参数更方便，因为无需直接命名构造子。
例如，定义各种相似的结构体类型有助于保持领域概念的隔离，
但阅读代码的自然方式可能是将它们都视为本质上是一个元组。
在这种情况下，参数可以用尖括号 <code>⟨</code> 和 <code>⟩</code> 括起来，如 <code>Point</code> 可以写成 <code>⟨1, 2⟩</code>。
注意！即使它们看起来像小于号 <code>&lt;</code> 和大于号 <code>&gt;</code>，这些括号也不同。
它们可以分别使用 <code>\&lt;</code> 和 <code>\&gt;</code> 来输入。</p>
<!--
Just as with the brace notation for named constructor arguments, this positional syntax can only be used in a context where Lean can determine the structure's type, either from a type annotation or from other type information in the program.
For instance, `#eval ⟨1, 2⟩` yields the following error:
-->
<p>与命名构造子参数的大括号记法一样，此位置语法只能在 Lean
可以根据类型标注或程序中的其他类型信息，来确定结构体类型的语境中使用。
例如，<code>#eval ⟨1, 2⟩</code> 会产生以下错误：</p>
<pre><code class="language-output error">invalid constructor ⟨...⟩, expected type must be an inductive type 
  ?m.34991
</code></pre>
<!--
The metavariable in the error is because there is no type information available.
Adding an annotation, such as in `#eval (⟨1, 2⟩ : Point)`, solves the problem:
-->
<p>错误中出现元变量是因为没有可用的类型信息。添加标注，例如
<code>#eval (⟨1, 2⟩ : Point)</code>，可以解决此问题：</p>
<pre><code class="language-output info">{ x := 1.000000, y := 2.000000 }
</code></pre>
<!--
## String Interpolation
-->
<h2 id="字符串插值"><a class="header" href="#字符串插值">字符串插值</a></h2>
<!--
In Lean, prefixing a string with `s!` triggers _interpolation_, where expressions contained in curly braces inside the string are replaced with their values.
This is similar to `f`-strings in Python and `$`-prefixed strings in C#.
For instance,
-->
<p>在 Lean 中，在字符串前加上 <code>s!</code> 会触发 <strong>插值（Interpolation）</strong> ，
其中字符串中大括号内的表达式会被其值替换。这类似于 Python 中的 <code>f</code> 字符串和
C# 中以 <code>$</code> 为前缀的字符串。例如，</p>
<pre><code class="language-lean">#eval s!&quot;three fives is {NewNamespace.triple 5}&quot;
</code></pre>
<!--
yields the output
-->
<p>会产生输出</p>
<pre><code class="language-output info">&quot;three fives is 15&quot;
</code></pre>
<!--
Not all expressions can be interpolated into a string.
For instance, attempting to interpolate a function results in an error.
-->
<p>并非所有的表达式都可以插值到字符串中。例如，尝试插值一个函数会产生错误。</p>
<pre><code class="language-lean">#check s!&quot;three fives is {NewNamespace.triple}&quot;
</code></pre>
<!--
yields the output
-->
<p>会产生输出</p>
<pre><code class="language-output info">failed to synthesize instance
  ToString (Nat → Nat)
</code></pre>
<!--
This is because there is no standard way to convert functions into strings.
The Lean compiler maintains a table that describes how to convert values of various types into strings, and the message `failed to synthesize instance` means that the Lean compiler didn't find an entry in this table for the given type.
This uses the same language feature as the `deriving Repr` syntax that was described in the [section on structures](structures.md).
-->
<p>这是因为没有将函数转换为字符串的标准方法。Lean 编译器维护了一个表，
描述如何将各种类型的值转换为字符串，而消息 <code>failed to synthesize instance</code>
意味着 Lean 编译器未在此表中找到给定类型的条目。
这使用了与<a href="structures.html">结构体</a>一节中描述的 <code>deriving Repr</code> 语法相同的语言特性。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-to-know/polymorphism.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../getting-to-know/summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-to-know/polymorphism.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../getting-to-know/summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
