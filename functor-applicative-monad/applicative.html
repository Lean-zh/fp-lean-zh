<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>应用函子 - Lean 函数式编程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Lean 函数式编程</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">引言</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">鸣谢</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> 了解 Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 求值表达式</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 函数与定义</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-and-patterns.html"><strong aria-hidden="true">1.5.</strong> 数据类型、模式匹配与递归</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多态</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> 运行程序</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> 逐步执行</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> 创建项目</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 现实示例：cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 插曲：命题、证明与索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> 重载与类型类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 类型类与多态</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> 控制实例搜索</a></li><li class="chapter-item expanded "><a href="../type-classes/indexing.html"><strong aria-hidden="true">4.4.</strong> 数组与索引</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 标准类</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> 单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/class.html"><strong aria-hidden="true">5.1.</strong> 单子类型类</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic.html"><strong aria-hidden="true">5.2.</strong> 示例：用单子表达算术运算</a></li><li class="chapter-item expanded "><a href="../monads/do.html"><strong aria-hidden="true">5.3.</strong> 单子的 do-记法</a></li><li class="chapter-item expanded "><a href="../monads/io.html"><strong aria-hidden="true">5.4.</strong> IO 单子</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 函子、应用函子与单子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/inheritance.html"><strong aria-hidden="true">6.1.</strong> 结构体和继承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative.html" class="active"><strong aria-hidden="true">6.2.</strong> 应用函子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> 应用函子的契约</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 选择子</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete.html"><strong aria-hidden="true">6.6.</strong> 完整定义</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> 单子变换器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> 组合 IO 与 Reader</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers.html"><strong aria-hidden="true">7.2.</strong> 单子构建工具包</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order.html"><strong aria-hidden="true">7.3.</strong> 对单子变换器排序</a></li><li class="chapter-item expanded "><a href="../monad-transformers/do.html"><strong aria-hidden="true">7.4.</strong> 更多 do 的特性</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 其他便利功能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依值类型编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> 索引族</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙设计模式</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries.html"><strong aria-hidden="true">8.3.</strong> 现实示例：类型化查询</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> 索引、形参与宇宙层级</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls.html"><strong aria-hidden="true">8.5.</strong> 依值类型编程的陷阱</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 插曲：策略、归纳与证明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> 编程、证明与性能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 尾递归</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 证明等价</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-termination.html"><strong aria-hidden="true">10.3.</strong> 数组与停机性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> 更多不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全数组索引</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 插入排序与数组可变性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊类型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">下一步</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 函数式编程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/fp-lean-zh/edit/master/functional-programming-lean/src/functor-applicative-monad/applicative.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Applicative Functors
-->
<h1 id="应用函子"><a class="header" href="#应用函子">应用函子</a></h1>
<!--
An _applicative functor_ is a functor that has two additional operations available: `pure` and `seq`.
`pure` is the same operator used in `Monad`, because `Monad` in fact inherits from `Applicative`.
`seq` is much like `map`: it allows a function to be used in order to transform the contents of a datatype.
However, with `seq`, the function is itself contained in the datatype: `f (α → β) → (Unit → f α) → f β`.
Having the function under the type `f` allows the `Applicative` instance to control how the function is applied, while `Functor.map` unconditionally applies a function.
The second argument has a type that begins with `Unit →` to allow the definition of `seq` to short-circuit in cases where the function will never be applied.
-->
<p><strong>应用函子 (Applicative Functor)</strong> 是一种具有两个附加操作的函子：<code>pure</code> 和 <code>seq</code>。
<code>pure</code> 是 <code>Monad</code> 中使用的相同的运算符，因为 <code>Monad</code> 实际上继承自 <code>Applicative</code>。
<code>seq</code> 非常类似于 <code>map</code>：它允许使用一个函数来转换数据类型的内容。
然而，在使用 <code>seq</code> 时，函数本身也被包含在数据类型中：<code>f (α → β) → (Unit → f α) → f β</code>。
将函数置于类型 <code>f</code> 之下会允许 <code>Applicative</code> 的实例去控制函数被应用的方式，而 <code>Functor.map</code> 则无条件地应用函数。
第二个参数的类型以 <code>Unit →</code> 开头，以允许在函数永远不会被应用的情况下，定义 <code>seq</code> 时短路。</p>
<!--
The value of this short-circuiting behavior can be seen in the instance of `Applicative Option`:
-->
<p>这种短路行为的价值可以在 <code>Applicative Option</code> 的实例中看到：</p>
<pre><code class="language-lean">instance : Applicative Option where
  pure x := .some x
  seq f x :=
    match f with
    | none =&gt; none
    | some g =&gt; g &lt;$&gt; x ()
</code></pre>
<!--
In this case, if there is no function for `seq` to apply, then there is no need to compute its argument, so `x` is never called.
The same consideration informs the instance of `Applicative` for `Except`:
-->
<p>在这种情况下，如果没有函数供 <code>seq</code> 应用，那么就不需要计算其参数，因此 <code>x</code> 永远不会被调用。
同样的考虑也适用于 <code>Except</code> 的 <code>Applicative</code> 实例。</p>
<pre><code class="language-lean">instance : Applicative (Except ε) where
  pure x := .ok x
  seq f x :=
    match f with
    | .error e =&gt; .error e
    | .ok g =&gt; g &lt;$&gt; x ()
</code></pre>
<!--
This short-circuiting behavior depends only on the `Option` or `Except` structures that _surround_ the function, rather than on the function itself.
-->
<p>这种短路行为仅依赖于 <strong>包围</strong> 着函数的 <code>Option</code> 或 <code>Except</code> 结构，而不是函数本身。</p>
<!--
Monads can be seen as a way of capturing the notion of sequentially executing statements into a pure functional language.
The result of one statement can affect which further statements run.
This can be seen in the type of `bind`: `m α → (α → m β) → m β`.
The first statement's resulting value is an input into a function that computes the next statement to execute.
Successive uses of `bind` are like a sequence of statements in an imperative programming language, and `bind` is powerful enough to implement control structures like conditionals and loops.
-->
<p><strong>单子 (Monad)</strong> 可以被看作是一种将按顺序执行语句的概念引入纯函数式语言的方法。
一个语句的结果会影响接下来要执行的语句。
这可以从 <code>bind</code> 的类型中看出：<code>m α → (α → m β) → m β</code>。
第一个语句的结果值是作为一个函数的输入，该函数会计算下一个要执行的语句。
连续使用 <code>bind</code> 类似于命令式编程语言中的语句序列，而且 <code>bind</code> 足够强大，可以实现诸如条件语句和循环等控制结构。</p>
<!--
Following this analogy, `Applicative` captures function application in a language that has side effects.
The arguments to a function in languages like Kotlin or C# are evaluated from left to right.
Side effects performed by earlier arguments occur before those performed by later arguments.
A function is not powerful enough to implement custom short-circuiting operators that depend on the specific _value_ of an argument, however.
-->
<p>按照这个类比，<code>Applicative</code> 捕获了在具有副作用的语言中函数的应用。
在像 Kotlin 或 C# 这样的语言中，函数的参数是从左到右进行求值的。
较早的参数所执行的副作用在较晚的参数执行的副作用之前发生。
然而，函数不足以实现依赖于参数特定 <strong>值</strong> 的自定义短路运算符。</p>
<!--
Typically, `seq` is not invoked directly.
Instead, the operator `<*>` is used.
This operator wraps its second argument in `fun () => ...`, simplifying the call site.
In other words, `E1 <*> E2` is syntactic sugar for `Seq.seq E1 (fun () => E2)`.
-->
<p>通常情况下，不会直接调用 <code>seq</code>。
而是使用运算符 <code>&lt;*&gt;</code>。
这个运算符将其第二个参数包装在 <code>fun () =&gt; ...</code> 中，从而简化了调用位置。
换句话说，<code>E1 &lt;*&gt; E2</code> 是 <code>Seq.seq E1 (fun () =&gt; E2)</code> 的语法糖。</p>
<!--
The key feature that allows `seq` to be used with multiple arguments is that a multiple-argument Lean function is really a single-argument function that returns another function that's waiting for the rest of the arguments.
In other words, if the first argument to `seq` is awaiting multiple arguments, then the result of the `seq` will be awaiting the rest.
For example, `some Plus.plus` can have the type `Option (Nat → Nat → Nat)`.
Providing one argument, `some Plus.plus <*> some 4`, results in the type `Option (Nat → Nat)`.
This can itself be used with `seq`, so `some Plus.plus <*> some 4 <*> some 7` has the type `Option Nat`.
-->
<p>允许 <code>seq</code> 与多个参数一起使用的关键特性在于，在 Lean 中的多参数函数实际上是一个单参数函数，该函数会返回另一个正在等待其余参数的函数。
换句话说，如果 <code>seq</code> 的第一个参数正在等待多个参数，那么 <code>seq</code> 的输出结果将等待其余的参数。
例如，<code>some Plus.plus</code> 可以具有类型 <code>Option (Nat → Nat → Nat)</code>。
提供一个参数后，<code>some Plus.plus &lt;*&gt; some 4</code> 的类型将转变为 <code>Option (Nat → Nat)</code>。
这本身也可以与 <code>seq</code> 一起使用，因此 <code>some Plus.plus &lt;*&gt; some 4 &lt;*&gt; some 7</code> 的类型为 <code>Option Nat</code>。</p>
<!--
Not every functor is applicative.
`Pair` is like the built-in product type `Prod`:
```lean
structure Pair (α β : Type) : Type where
  first : α
  second : β
```
Like `Except`, `Pair` has type `Type → Type → Type`.
This means that `Pair α` has type `Type → Type`, and a `Functor` instance is possible:
```lean
instance : Functor (Pair α) where
  map f x := ⟨x.first, f x.second⟩
```
This instance obeys the `Functor` contract.
-->
<p>不是每个函子都是应用函子。
<code>Pair</code> 类似于内置的乘积类型 <code>Prod</code>：</p>
<pre><code class="language-lean">structure Pair (α β : Type) : Type where
  first : α
  second : β
</code></pre>
<p>如同 <code>Except</code>，<code>Pair</code> 的类型是 <code>Type → Type → Type</code>。
这意味着 <code>Pair α</code> 的类型是 <code>Type → Type</code>，因此可以有一个 <code>Functor</code> 实例：</p>
<pre><code class="language-lean">instance : Functor (Pair α) where
  map f x := ⟨x.first, f x.second⟩
</code></pre>
<p>此实例遵循 <code>Functor</code> 契约。</p>
<!--
The two properties to check are that `id <$> Pair.mk x y = Pair.mk x y` and that `f <$> g <$> Pair.mk x y = (f ∘ g) <$> Pair.mk x y`.
The first property can be checked by just stepping through the evaluation of the left side, and noticing that it evaluates to the right side:
```lean
id <$> Pair.mk x y
===>
Pair.mk x (id y)
===>
Pair.mk x y
```
The second can be checked by stepping through both sides, and noting that they yield the same result:
```lean
f <$> g <$> Pair.mk x y
===>
f <$> Pair.mk x (g y)
===>
Pair.mk x (f (g y))

(f ∘ g) <$> Pair.mk x y
===>
Pair.mk x ((f ∘ g) y)
===>
Pair.mk x (f (g y))
```
-->
<p>要检查的两个属性是 <code>id &lt;$&gt; Pair.mk x y = Pair.mk x y</code> 和 <code>f &lt;$&gt; g &lt;$&gt; Pair.mk x y = (f ∘ g) &lt;$&gt; Pair.mk x y</code>。
第一个属性可以通过从左侧的逐步求值直到右侧来检查：</p>
<pre><code class="language-lean">id &lt;$&gt; Pair.mk x y
===&gt;
Pair.mk x (id y)
===&gt;
Pair.mk x y
</code></pre>
<p>第二个属性可以通过逐步检查两侧来验证，并注意它们产生了相同的结果：</p>
<pre><code class="language-lean">f &lt;$&gt; g &lt;$&gt; Pair.mk x y
===&gt;
f &lt;$&gt; Pair.mk x (g y)
===&gt;
Pair.mk x (f (g y))

(f ∘ g) &lt;$&gt; Pair.mk x y
===&gt;
Pair.mk x ((f ∘ g) y)
===&gt;
Pair.mk x (f (g y))
</code></pre>
<!--
Attempting to define an `Applicative` instance, however, does not work so well.
It will require a definition of `pure`:
```lean
def Pair.pure (x : β) : Pair α β := _
```
```output error
don't know how to synthesize placeholder
context:
β α : Type
x : β
⊢ Pair α β
```
There is a value with type `β` in scope (namely `x`), and the error message from the underscore suggests that the next step is to use the constructor `Pair.mk`:
```lean
def Pair.pure (x : β) : Pair α β := Pair.mk _ x
```
```output error
don't know how to synthesize placeholder for argument 'first'
context:
β α : Type
x : β
⊢ α
```
Unfortunately, there is no `α` available.
Because `pure` would need to work for _all possible types_ α to define an instance of `Applicative (Pair α)`, this is impossible.
After all, a caller could choose `α` to be `Empty`, which has no values at all.
-->
<p>但是，尝试定义一个 <code>Applicative</code> 实例的效果并不理想。
它需要 <code>pure</code> 的定义：</p>
<pre><code class="language-lean">def Pair.pure (x : β) : Pair α β := _
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
β α : Type
x : β
⊢ Pair α β
</code></pre>
<p>在当前作用域内有一个类型为 <code>β</code> 的值（即 <code>x</code>），下划线处的错误信息表明了下一步是使用构造子 <code>Pair.mk</code>：</p>
<pre><code class="language-lean">def Pair.pure (x : β) : Pair α β := Pair.mk _ x
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder for argument 'first'
context:
β α : Type
x : β
⊢ α
</code></pre>
<p>不幸的是，没有可用的 <code>α</code>。
因为 <code>pure</code> 需要适用于 <strong>所有可能的类型</strong> <code>α</code> ，才能定义 <code>Applicative (Pair α)</code> 的实例，所以这是不可能的。
毕竟，调用者可以选择 <code>α</code> 为 <code>Empty</code>，而 <code>Empty</code> 根本没有任何值。</p>
<!--
## A Non-Monadic Applicative
-->
<h2 id="一个非单子的应用函子"><a class="header" href="#一个非单子的应用函子">一个非单子的应用函子</a></h2>
<!--
When validating user input to a form, it's generally considered to be best to provide many errors at once, rather than one error at a time.
This allows the user to have an overview of what is needed to please the computer, rather than feeling badgered as they correct the errors field by field.
-->
<p>在验证表单中的用户输入时，通常认为最好一次性提供多个错误，而不是一次提供一个错误。
这样，用户可以大致了解需要做什么才可以满足计算机的要求，而不是逐个对属性地纠正错误时感到烦恼。</p>
<!--
Ideally, validating user input will be visible in the type of the function that's doing the validating.
It should return a datatype that is specific—checking that a text box contains a number should return an actual numeric type, for instance.
A validation routine could throw an exception when the input does not pass validation.
Exceptions have a major drawback, however: they terminate the program at the first error, making it impossible to accumulate a list of errors.
-->
<p>理想情况下，验证用户输入将在执行验证的函数类型中可见。
它应该返回一个特定的数据类型——例如，检验包含数字的文本框是否返回一个实际的数字类型。
验证例程可能会在输入未通过验证时抛出 <strong>异常 (Exception)</strong>。
然而，异常有一个主要缺点：它们在第一个错误出现时终止程序，从而无法累积错误列表。</p>
<!--
On the other hand, the common design pattern of accumulating a list of errors and then failing when it is non-empty is also problematic.
A long nested sequences of `if` statements that validate each sub-section of the input data is hard to maintain, and it's easy to lose track of an error message or two.
Ideally, validation can be performed using an API that enables a new value to be returned yet automatically tracks and accumulates error messages.
-->
<p>另一方面，累积错误列表并在列表非空时失效的常见设计模式也是有问题的。
一个用于验证输入数据的每个子部分的长嵌套 <code>if</code> 语句序列难以维护，而且很容易遗漏一两条错误信息。
理想情况下，可以使用一个 API 来执行验证，该 API 不仅可以返回一个新的值，还能自动跟踪和累积错误信息。</p>
<!--
An applicative functor called `Validate` provides one way to implement this style of API.
Like the `Except` monad, `Validate` allows a new value to be constructed that characterizes the validated data accurately.
Unlike `Except`, it allows multiple errors to be accumulated, without a risk of forgetting to check whether the list is empty.
-->
<p>一个名为 <code>Validate</code> 的应用函子提供了一种实现这种风格的 API 的方法。
像 <code>Except</code> 单子一样，<code>Validate</code> 允许构造一个准确描述验证数据的新的值
与 <code>Except</code> 不同，它允许累积多个错误，而不必担心忘记检查列表是否为空。</p>
<!--
### User Input
-->
<h3 id="用户输入"><a class="header" href="#用户输入">用户输入</a></h3>
<!--
As an example of user input, take the following structure:
```lean
structure RawInput where
  name : String
  birthYear : String
```
The business logic to be implemented is the following:
 1. The name may not be empty
 2. The birth year must be numeric and non-negative
 3. The birth year must be greater than 1900, and less than or equal to the year in which the form is validated
-->
<p>作为用户输入的示例，请考虑以下结构体：</p>
<pre><code class="language-lean">structure RawInput where
  name : String
  birthYear : String
</code></pre>
<p>要实现的业务逻辑如下：</p>
<ol>
<li>姓名不能为空</li>
<li>出生年份必须是数字且非负</li>
<li>The birth year must be greater than 1900, and less than or equal to the year in which the form is validated 出生年份必须大于1900，并且小于或等于表单被验证的年份</li>
</ol>
<!--
Representing these as a datatype will require a new feature, called _subtypes_.
With this tool in hand, a validation framework can be written that uses an applicative functor to track errors, and these rules can be implemented in the framework.
-->
<p>将这些表示为数据类型将会需要一个新功能，称为 <strong>子类型 (Subtype)</strong>。
有了这个工具，可以编写一个使用应用函子来跟踪错误的验证框架，并且可以在框架中实现这些规则。</p>
<!--
### Subtypes
-->
<h3 id="子类型"><a class="header" href="#子类型">子类型</a></h3>
<!--
Representing these conditions is easiest with one additional Lean type, called `Subtype`:
```lean
structure Subtype {α : Type} (p : α → Prop) where
  val : α
  property : p val
```
This structure has two type parameters: an implicit parameter that is the type of data `α`, and an explicit parameter `p` that is a predicate over `α`.
A _predicate_ is a logical statement with a variable in it that can be replaced with a value to yield an actual statement, like the [parameter to `GetElem`](../type-classes/indexing.md#overloading-indexing) that describes what it means for an index to be in bounds for a lookup.
In the case of `Subtype`, the predicate slices out some subset of the values of `α` for which the predicate holds.
The structure's two fields are, respectively, a value from `α` and evidence that the value satisfies the predicate `p`.
Lean has special syntax for `Subtype`.
If `p` has type `α → Prop`, then the type `Subtype p` can also be written `{x : α // p x}`, or even `{x // p x}` when the type can be inferred automatically.
-->
<p>表示这些条件最简单的方法就是使用 Lean 内一种额外的类型，称为 <code>Subtype</code>：</p>
<pre><code class="language-lean">structure Subtype {α : Type} (p : α → Prop) where
  val : α
  property : p val
</code></pre>
<p>该结构体有两个类型参数：一个隐式参数是数据 <code>α</code> 的类型，另一个显式参数 <code>p</code> 是 <code>α</code> 上的谓词。
<strong>谓词 (Predicate)</strong> 是一个逻辑语句，其中包含一个变量，可以用值替换改变量以生成一个实际的语句，就像 <a href="../type-classes/indexing.html#overloading-indexing"><code>GetElem</code> 的参数</a> 那样，它描述了索引在查找范围内的意义。
在 <code>Subtype</code> 的情况下，谓词划分出 <code>α</code> 的一些值的子集，且这些值满足谓词的条件。
该结构体的两个属性分别是一个来自 <code>α</code> 的值，以及该值满足谓词 <code>p</code> 的证据。
Lean 对 <code>Subtype</code> 有特殊的语法。
如果 <code>p</code> 的类型是 <code>α → Prop</code>，那么类型 <code>Subtype p</code> 也可以写作 <code>{x : α // p x}</code>，或者在类型可以被自动推断时，甚至可以写作 <code>{x // p x}</code>。</p>
<!--
[Representing positive numbers as inductive types](../type-classes/pos.md) is clear and easy to program with.
However, it has a key disadvantage.
While `Nat` and `Int` have the structure of ordinary inductive types from the perspective of Lean programs, the compiler treats them specially and uses fast arbitrary-precision number libraries to implement them.
This is not the case for additional user-defined types.
However, a subtype of `Nat` that restricts it to non-zero numbers allows the new type to use the efficient representation while still ruling out zero at compile time:
```lean
def FastPos : Type := {x : Nat // x > 0}
```
-->
<p><a href="../type-classes/pos.html">将正数表示为归纳类型</a> 是清晰且易于编程的。
但是，它有一个主要的缺点。
虽然从 Lean 程序的角度来看，<code>Nat</code> 和 <code>Int</code> 具有普通归纳类型的结构，但编译器会特殊对待它们，并使用快速的任意精度数字库来实现它们。
对于其他用户定义的类型则不是这样的情况。
然而，一个将 <code>Nat</code> 限制为非零数的子类型允许新类型使用高效的表示方式，同时在编译时仍然排除零：</p>
<pre><code class="language-lean">def FastPos : Type := {x : Nat // x &gt; 0}
</code></pre>
<!--
The smallest fast positive number is still one.
Now, instead of being a constructor of an inductive type, it's an instance of a structure that's constructed with angle brackets.
The first argument is the underlying `Nat`, and the second argument is the evidence that said `Nat` is greater than zero:
```leantac
def one : FastPos := ⟨1, by simp⟩
```
The `OfNat` instance is very much like that for `Pos`, except it uses a short tactic proof to provide evidence that `n + 1 > 0`:
```leantac
instance : OfNat FastPos (n + 1) where
  ofNat := ⟨n + 1, by simp_arith⟩
```
The `simp_arith` tactic is a version of `simp` that takes additional arithmetic identities into account.
-->
<p>最小的快速正数仍然是 1。
现在，它不再是归纳类型的构造子，而是由尖括号构造的结构实例。
第一个参数是底层的 <code>Nat</code>，第二个参数是描述着 <code>Nat</code> 大于零的证据：</p>
<pre><code class="language-leantac">def one : FastPos := ⟨1, by simp⟩
</code></pre>
<p><code>OfNat</code> 实例十分类似于 <code>Pos</code> 实例，只不过它使用了一个简短的策略证明来提供 <code>n + 1 &gt; 0</code> 的证据：</p>
<pre><code class="language-leantac">instance : OfNat FastPos (n + 1) where
  ofNat := ⟨n + 1, by simp_arith⟩
</code></pre>
<p><code>simp_arith</code> 策略是 <code>simp</code> 的一个版本，它考虑了额外的算术恒等式。</p>
<!--
Subtypes are a two-edged sword.
They allow efficient representation of validation rules, but they transfer the burden of maintaining these rules to the users of the library, who have to _prove_ that they are not violating important invariants.
Generally, it's a good idea to use them internally to a library, providing an API to users that automatically ensures that all invariants are satisfied, with any necessary proofs being internal to the library.
-->
<p>子类型是一把双刃剑。
它们允许高效地表示验证规则，但它们将维护这些规则的负担转移到了库的使用者身上，使用者必须 <strong>证明</strong> 他们没有违反重要的不变量。
通常，最好在库的内部使用子类型，这为使用者提供了一个自动确保满足所有不变量的API，并且将任何必要的证明放在库的内部去进行处理。</p>
<!--
Checking whether a value of type `α` is in the subtype `{x : α // p x}` usually requires that the proposition `p x` be decidable.
The [section on equality and ordering classes](../type-classes/standard-classes.md#equality-and-ordering) describes how decidable propositions can be used with `if`.
When `if` is used with a decidable proposition, a name can be provided.
In the `then` branch, the name is bound to evidence that the proposition is true, and in the `else` branch, it is bound to evidence that the proposition is false.
This comes in handy when checking whether a given `Nat` is positive:
```lean
def Nat.asFastPos? (n : Nat) : Option FastPos :=
  if h : n > 0 then
    some ⟨n, h⟩
  else none
```
In the `then` branch, `h` is bound to evidence that `n > 0`, and this evidence can be used as the second argument to `Subtype`'s constructor.
-->
<p>检查类型为 <code>α</code> 的值是否属于子类型 <code>{x : α // p x}</code>，通常需要命题 <code>p x</code> 是 <strong>可判定的 (Decidable)</strong>。
<a href="../type-classes/standard-classes.html#equality-and-ordering">关于相等性和排序类的小节</a> 描述了如何将可判定命题与 <code>if</code> 一起使用。
当 <code>if</code> 与一个可判定命题一起使用时，可以提供一个名称。
在 <code>then</code> 分支中，该名称会与命题为真的证据绑定，在 <code>else</code> 分支中，该名称会与命题为假的证据绑定。
这在检查给定的 <code>Nat</code> 是否为正数时非常有用：</p>
<pre><code class="language-lean">def Nat.asFastPos? (n : Nat) : Option FastPos :=
  if h : n &gt; 0 then
    some ⟨n, h⟩
  else none
</code></pre>
<p>在 <code>then</code> 分支中，<code>h</code> 会与 <code>n &gt; 0</code> 的证据绑定，且这个证据可以用作 <code>Subtype</code> 构造子的第二个参数。</p>
<!--
### Validated Input
-->
<h3 id="经验证输入"><a class="header" href="#经验证输入">经验证输入</a></h3>
<!--
The validated user input is a structure that expresses the business logic using multiple techniques:
 * The structure type itself encodes the year in which it was checked for validity, so that `CheckedInput 2019` is not the same type as `CheckedInput 2020`
 * The birth year is represented as a `Nat` rather than a `String`
 * Subtypes are used to constrain the allowed values in the name and birth year fields
```lean
structure CheckedInput (thisYear : Nat) : Type where
  name : {n : String // n ≠ ""}
  birthYear : {y : Nat // y > 1900 ∧ y ≤ thisYear}
```
-->
<p>经过验证后的用户输入是一种使用多种技术表达业务逻辑的结构：</p>
<ul>
<li>结构类型本身编码了被检验了有效性的年份，因此 <code>CheckedInput 2019</code> 与 <code>CheckedInput 2020</code> 不是相同的类型</li>
<li>出生年份表示为 <code>Nat</code> 而不是 <code>String</code></li>
<li>子类型被用来约束名称属性和出生年份属性中的允许值</li>
</ul>
<pre><code class="language-lean">structure CheckedInput (thisYear : Nat) : Type where
  name : {n : String // n ≠ &quot;&quot;}
  birthYear : {y : Nat // y &gt; 1900 ∧ y ≤ thisYear}
</code></pre>
<!--
An input validator should take the current year and a `RawInput` as arguments, returning either a checked input or at least one validation failure.
This is represented by the `Validate` type:
```lean
inductive Validate (ε α : Type) : Type where
  | ok : α → Validate ε α
  | errors : NonEmptyList ε → Validate ε α
```
It looks very much like `Except`.
The only difference is that the `error` constructor may contain more than one failure.
-->
<p>一个输入验证器应接受当前年份和一个 <code>RawInput</code> 作为参数，然后返回一个经检验的输入或者至少一个验证失败。
这由 <code>Validate</code> 类型来表示：</p>
<pre><code class="language-lean">inductive Validate (ε α : Type) : Type where
  | ok : α → Validate ε α
  | errors : NonEmptyList ε → Validate ε α
</code></pre>
<p>它看起来很像 <code>Except</code>。
唯一的区别是 <code>error</code> 构造子可能包含多个失败。</p>
<!--
Validate is a functor.
Mapping a function over it transforms any successful value that might be present, just as in the `Functor` instance for `Except`:
```lean
instance : Functor (Validate ε) where
  map f
   | .ok x => .ok (f x)
   | .errors errs => .errors errs
```
-->
<p>Validate 是一个函子。
将一个函数映射到其上会转换任何可能存在的成功值，就像在 <code>Except</code> 的 <code>Functor</code> 实例中一样：</p>
<pre><code class="language-lean">instance : Functor (Validate ε) where
  map f
   | .ok x =&gt; .ok (f x)
   | .errors errs =&gt; .errors errs
</code></pre>
<!--
The `Applicative` instance for `Validate` has an important difference from the instance for `Except`: while the instance for `Except` terminates at the first error encountered, the instance for `Validate` is careful to accumulate all errors from _both_ the function and the argument branches:
```lean
instance : Applicative (Validate ε) where
  pure := .ok
  seq f x :=
    match f with
    | .ok g => g <$> (x ())
    | .errors errs =>
      match x () with
      | .ok _ => .errors errs
      | .errors errs' => .errors (errs ++ errs')
```
-->
<p><code>Validate</code> 的 <code>Applicative</code> 实例与 <code>Except</code> 的实例有一个重要的区别：<code>Except</code> 的实例会在遇到第一个错误时终止，而 <code>Validate</code> 的实例则会小心地累积 <strong>同时</strong> 来自函数和参数分支中的所有错误：</p>
<pre><code class="language-lean">instance : Applicative (Validate ε) where
  pure := .ok
  seq f x :=
    match f with
    | .ok g =&gt; g &lt;$&gt; (x ())
    | .errors errs =&gt;
      match x () with
      | .ok _ =&gt; .errors errs
      | .errors errs' =&gt; .errors (errs ++ errs')
</code></pre>
<!--
Using `.errors` together with the constructor for `NonEmptyList` is a bit verbose.
Helpers like `reportError` make code more readable.
In this application, error reports will consist of field names paired with messages:
```lean
def Field := String

def reportError (f : Field) (msg : String) : Validate (Field × String) α :=
  .errors { head := (f, msg), tail := [] }
```
-->
<p>将 <code>.errors</code> 与 <code>NonEmptyList</code> 的构造子一起使用会有点繁琐。
像 <code>reportError</code> 这样的辅助函数可以使代码更易读。
在这个应用中，错误报告将由属性名称和消息一起组成：</p>
<pre><code class="language-lean">def Field := String

def reportError (f : Field) (msg : String) : Validate (Field × String) α :=
  .errors { head := (f, msg), tail := [] }
</code></pre>
<!--
The `Applicative` instance for `Validate` allows the checking procedures for each field to be written independently and then composed.
Checking a name consists of ensuring that a string is non-empty, then returning evidence of this fact in the form of a `Subtype`.
This uses the evidence-binding version of `if`:
```lean
def checkName (name : String) : Validate (Field × String) {n : String // n ≠ ""} :=
  if h : name = "" then
    reportError "name" "Required"
  else pure ⟨name, h⟩
```
In the `then` branch, `h` is bound to evidence that `name = ""`, while it is bound to evidence that `¬name = ""` in the `else` branch.
-->
<p><code>Validate</code> 的 <code>Applicative</code> 实例允许每个属性的检查过程被独立编写，然后进行组合。
检查一个名称包括着确保字符串非空，然后以 <code>Subtype</code> 的形式返回这一事实证据。
这使用了 <code>if</code> 的证据绑定的版本：</p>
<pre><code class="language-lean">def checkName (name : String) : Validate (Field × String) {n : String // n ≠ &quot;&quot;} :=
  if h : name = &quot;&quot; then
    reportError &quot;name&quot; &quot;Required&quot;
  else pure ⟨name, h⟩
</code></pre>
<p>在 <code>then</code> 分支中，<code>h</code> 绑定着 <code>name = &quot;&quot;</code> 的证据，而在 <code>else</code> 分支中，它绑定着 <code>¬name = &quot;&quot;</code> 的证据。</p>
<!--
It's certainly the case that some validation errors make other checks impossible.
For example, it makes no sense to check whether the birth year field is greater than 1900 if a confused user wrote the word `"syzygy"` instead of a number.
Checking the allowed range of the number is only meaningful after ensuring that the field in fact contains a number.
This can be expressed using the function `andThen`:
```lean
def Validate.andThen (val : Validate ε α) (next : α → Validate ε β) : Validate ε β :=
  match val with
  | .errors errs => .errors errs
  | .ok x => next x
```
While this function's type signature makes it suitable to be used as `bind` in a `Monad` instance, there are good reasons not to do so.
They are described [in the section that describes the `Applicative` contract](applicative-contract.md#additional-stipulations).
-->
<p>某些验证错误确实会导致其他检查无法进行。
例如，若一个困惑的用户在出生年份的属性处输入了 <code>&quot;syzygy&quot;</code> 这个词而不是一个数字，那么检查该属性是否大于 1900 就没有意义。
只有在确保该属性实际上包含一个数字之后，检查数字的允许范围才有意义。
这可以使用函数 <code>andThen</code> 来表示：</p>
<pre><code class="language-lean">def Validate.andThen (val : Validate ε α) (next : α → Validate ε β) : Validate ε β :=
  match val with
  | .errors errs =&gt; .errors errs
  | .ok x =&gt; next x
</code></pre>
<p>虽然这此数的类型签名使其适合作为一个 <code>Monad</code> 实例中的 <code>bind</code> 去使用，但也有充分的理由不这样做。
这些理由在<a href="applicative-contract.html#additional-stipulations">描述 <code>Applicative</code> 契约的小节</a>中进行了说明。</p>
<!--
To check that the birth year is a number, a built-in function called `String.toNat? : String → Option Nat` is useful.
It's most user-friendly to eliminate leading and trailing whitespace first using `String.trim`:
```lean
def checkYearIsNat (year : String) : Validate (Field × String) Nat :=
  match year.trim.toNat? with
  | none => reportError "birth year" "Must be digits"
  | some n => pure n
```
To check that the provided year is in the expected range, nested uses of the evidence-providing form of `if` are in order:
```leantac
def checkBirthYear (thisYear year : Nat) : Validate (Field × String) {y : Nat // y > 1900 ∧ y ≤ thisYear} :=
  if h : year > 1900 then
    if h' : year ≤ thisYear then
      pure ⟨year, by simp [*]⟩
    else reportError "birth year" s!"Must be no later than {thisYear}"
  else reportError "birth year" "Must be after 1900"
```
-->
<p>要检查出生年份是否为数字，一个名为 <code>String.toNat? : String → Option Nat</code> 的内置函数非常有用。
最方便用户的做法是先使用 <code>String.trim</code> 消除前导和尾随的空格：</p>
<pre><code class="language-lean">def checkYearIsNat (year : String) : Validate (Field × String) Nat :=
  match year.trim.toNat? with
  | none =&gt; reportError &quot;birth year&quot; &quot;Must be digits&quot;
  | some n =&gt; pure n
</code></pre>
<p>为了检验提供的年份是否在预期范围内，需要嵌套使用提供证据形式的 <code>if</code> 语句：</p>
<pre><code class="language-leantac">def checkBirthYear (thisYear year : Nat) : Validate (Field × String) {y : Nat // y &gt; 1900 ∧ y ≤ thisYear} :=
  if h : year &gt; 1900 then
    if h' : year ≤ thisYear then
      pure ⟨year, by simp [*]⟩
    else reportError &quot;birth year&quot; s!&quot;Must be no later than {thisYear}&quot;
  else reportError &quot;birth year&quot; &quot;Must be after 1900&quot;
</code></pre>
<!--
Finally, these three components can be combined using `seq`:
```lean
def checkInput (year : Nat) (input : RawInput) : Validate (Field × String) (CheckedInput year) :=
  pure CheckedInput.mk <*>
    checkName input.name <*>
    (checkYearIsNat input.birthYear).andThen fun birthYearAsNat =>
      checkBirthYear year birthYearAsNat
```
-->
<p>最后，这三个组件可以使用 <code>seq</code> 进行组合：</p>
<pre><code class="language-lean">def checkInput (year : Nat) (input : RawInput) : Validate (Field × String) (CheckedInput year) :=
  pure CheckedInput.mk &lt;*&gt;
    checkName input.name &lt;*&gt;
    (checkYearIsNat input.birthYear).andThen fun birthYearAsNat =&gt;
      checkBirthYear year birthYearAsNat
</code></pre>
<!--
Testing `checkInput` shows that it can indeed return multiple pieces of feedback:
```lean
#eval checkInput 2023 {name := "David", birthYear := "1984"}
```
```output info
Validate.ok { name := "David", birthYear := 1984 }
```
```lean
#eval checkInput 2023 {name := "", birthYear := "2045"}
```
```output info
Validate.errors { head := ("name", "Required"), tail := [("birth year", "Must be no later than 2023")] }
```
```lean
#eval checkInput 2023 {name := "David", birthYear := "syzygy"}
```
```output info
Validate.errors { head := ("birth year", "Must be digits"), tail := [] }
```
-->
<p>测试 <code>checkInput</code> 体现了它确实可以返回多条反馈信息：</p>
<pre><code class="language-lean">#eval checkInput 2023 {name := &quot;David&quot;, birthYear := &quot;1984&quot;}
</code></pre>
<pre><code class="language-output info">Validate.ok { name := &quot;David&quot;, birthYear := 1984 }
</code></pre>
<pre><code class="language-lean">#eval checkInput 2023 {name := &quot;&quot;, birthYear := &quot;2045&quot;}
</code></pre>
<pre><code class="language-output info">Validate.errors { head := (&quot;name&quot;, &quot;Required&quot;), tail := [(&quot;birth year&quot;, &quot;Must be no later than 2023&quot;)] }
</code></pre>
<pre><code class="language-lean">#eval checkInput 2023 {name := &quot;David&quot;, birthYear := &quot;syzygy&quot;}
</code></pre>
<pre><code class="language-output info">Validate.errors { head := (&quot;birth year&quot;, &quot;Must be digits&quot;), tail := [] }
</code></pre>
<!--
Form validation with `checkInput` illustrates a key advantage of `Applicative` over `Monad`.
Because `>>=` provides enough power to modify the rest of the program's execution based on the value from the first step, it _must_ receive a value from the first step to pass on.
If no value is received (e.g. because an error has occurred), then `>>=` cannot execute the rest of the program.
`Validate` demonstrates why it can be useful to run the rest of the program anyway: in cases where the earlier data isn't needed, running the rest of the program can yield useful information (in this case, more validation errors).
`Applicative`'s `<*>` may run both of its arguments before recombining the results.
Similarly, `>>=` forces sequential execution.
Each step must complete before the next may run.
This is generally useful, but it makes it impossible to have parallel execution of different threads that naturally emerges from the program's actual data dependencies.
A more powerful abstraction like `Monad` increases the flexibility that's available to the API consumer, but it decreases the flexibility that is available to the API implementor.
-->
<p>使用 <code>checkInput</code> 进行表单验证展示了 <code>Applicative</code> 相对于 <code>Monad</code> 的一个关键优势。
由于 <code>&gt;&gt;=</code> 提供了足够的能力来根据第一步的值修改程序其余部分的执行，所以它 <strong>必须</strong> 接收到第一步的值才能继续。
如果没有接收到值（例如由于一个错误发生了），那么 <code>&gt;&gt;=</code> 就无法执行程序的其余部分。
<code>Validate</code> 演示了为什么继续运行程序的其余部分可能是有用的：在不需要前面数据的情况下，运行程序的其余部分可以提供有用的信息（在这种情况下，是更多的验证错误）。
<code>Applicative</code> 的 <code>&lt;*&gt;</code> 可以在重新组合结果之前运行它的两个参数。
类似地，<code>&gt;&gt;=</code> 会强制按照顺序执行。
每一步都必须完成后才能运行下一步。
这通常是有用的，但这导致了不可能并行执行那些自然地从程序实际数据依赖中所产生的不同线程。
像 <code>Monad</code> 这样更强大的抽象增加了 API 使用者可用的灵活性，但减少了 API 实现者可用的灵活性。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../functor-applicative-monad/inheritance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../functor-applicative-monad/applicative-contract.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../functor-applicative-monad/inheritance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../functor-applicative-monad/applicative-contract.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../custom.js"></script>
    </body>
</html>
